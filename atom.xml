<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  <icon>https://future-architect.github.io/feed_icon.png</icon>
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2022-06-02T01:39:27.983Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>H&amp;M Personalized Fashion Recommendations 参加記 (46th/2952)</title>
    <link href="https://future-architect.github.io/articles/20220602b/"/>
    <id>https://future-architect.github.io/articles/20220602b/</id>
    <published>2022-06-01T15:00:01.000Z</published>
    <updated>2022-06-02T01:39:27.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Strategic AI Group所属の金子です。普段は推薦に関連する実装やデータ分析を行っています。</p><p>先日Kaggleで開催された<a href="https://www.kaggle.com/competitions/h-and-m-personalized-fashion-recommendations/overview">H&amp;M Personalized Fashion Recommendations</a>コンペに単独で参加し、2952チーム中46位をとりました。</p><p>今回の参加記では以下の内容を紹介します。</p><ul><li>H&amp;Mコンペ概要</li><li>H&amp;Mコンペの難しいところ</li><li>解法のサマリ</li><li>解放の工夫</li><li>次に取り組みたいこと</li><li>感想</li></ul><h1 id="H-amp-Mコンペ概要"><a href="#H-amp-Mコンペ概要" class="headerlink" title="H&amp;Mコンペ概要"></a>H&amp;Mコンペ概要</h1><p>本コンペはH&amp;Mのオンライン・オフラインの行動履歴をもとに、次にユーザーが購買する商品をレコメンドするコンペティションでした。提供されたデータの期間は2018-09-20～2020-09-22の約二年間で、このデータをもとに2020/9/23～2020/09/29のユーザーの行動を予測しました。予測対象のユーザーは約137万人のユーザーで、これらのユーザーに対し予測対象の商品(=article)は約10万点の中から12点を選び、MAP@12で評価しました。データの種類をユーザー、アイテム、インタラクションの三つに分類すると、それぞれ以下のようなデータがありました。</p><ul><li>ユーザー: 年齢、ハッシュ化された住所、会員登録の状況</li><li>アイテム: 商品のカテゴリ、色・模様、商品の説明文(英語)、商品画像</li><li>インタラクション: 日付、オンラインかオフラインか</li></ul><h1 id="H-amp-Mコンペの難しいところ"><a href="#H-amp-Mコンペの難しいところ" class="headerlink" title="H&amp;Mコンペの難しいところ"></a>H&amp;Mコンペの難しいところ</h1><p>今回のコンペで難しかった点について、レコメンド一般的な課題、このコンペ特有の課題の順に説明していきます。</p><h2 id="レコメンド一般的な問題"><a href="#レコメンド一般的な問題" class="headerlink" title="レコメンド一般的な問題"></a>レコメンド一般的な問題</h2><p>レコメンド一般的な課題として、暗黙的(=implicit)なデータであること、大量のデータを高速にさばく必要があること、コールドスタートに対応する必要があることがあります。</p><h3 id="implicit-なデータ"><a href="#implicit-なデータ" class="headerlink" title="implicit なデータ"></a>implicit なデータ</h3><p>implicitなデータとは、ユーザーから明示的(=explicit)なフィードバックが与えられていないデータです。それぞれ例を挙げるなら、explicitは星の数やいいねなどユーザーの反応がついている状態、implicitはユーザーが見たという情報だけがあるような状態です。explicitなデータではユーザーの好みが数値化されているので、これを直接予測し評価することができますが、implicitなデータではユーザーが何かしらの行動を起こしたということが分かるのみで、実際にユーザーが気に入ったかどうかは分からないという問題があります。また、ユーザーが行動を起こさなかったデータはない場合が多く、閲覧・購入したデータを二値分類の正例にするのであれば、負例は上手く生成する必要があるのも問題です。</p><h3 id="大量の商品xユーザー、履歴データ。"><a href="#大量の商品xユーザー、履歴データ。" class="headerlink" title="大量の商品xユーザー、履歴データ。"></a>大量の商品xユーザー、履歴データ。</h3><p>今回のコンペは137万人のユーザーに対し、10万の商品の候補からレコメンドを行う必要がありました。また、履歴については2年間で約3000万件あり、これをうまく処理することが求められました。レコメンドはリアルタイムに予測を行う場合と、バッチ形式でまとめて予測するものがありますが、今回のコンペでは後者で時間もマシンリソースも無限でした。ただ、それでも全組み合わせを愚直に評価するのは難しく工夫が求められました。</p><h3 id="コールドスタート問題"><a href="#コールドスタート問題" class="headerlink" title="コールドスタート問題"></a>コールドスタート問題</h3><p>コールドスタートは履歴の少ないユーザー・アイテムに対して上手く予測ができない問題です。レコメンドは主にユーザーの行動履歴もとに予測を行う協調フィルタリング形式と、アイテム自身のカテゴリや画像といった情報を活用するコンテンツベースの手法に分類されます。前者の協調フィルタリングのアルゴリズムは大量にデータがあるアイテムやユーザーには上手く作用しますが、まだ履歴の少ないユーザーや新しく登録されたばかり・マイナーなアイテムには上手く予測できないという問題があります。</p><h2 id="コンペ特有の課題"><a href="#コンペ特有の課題" class="headerlink" title="コンペ特有の課題"></a>コンペ特有の課題</h2><p>コンペ特有の課題として、ユーザーの行動が散発的であること、繰り返しの購入パターンが強すぎることがありました。</p><h3 id="散発的な履歴"><a href="#散発的な履歴" class="headerlink" title="散発的な履歴"></a>散発的な履歴</h3><p>ユーザーの履歴を確認したところ、前回の履歴から数か月空いていることが多く、履歴があったのは似たようなズボン数種類だけ、と一部の種類のカテゴリにのみ行動があったケースが多くみられました。これはユーザーの気持ちになって考えると、ある程度買いたい種類の服を決めてからオンラインのサイトを見て欲しいものだけ買うケースが多かったからではないかと考えています。</p><h3 id="繰り返し購入の多さ"><a href="#繰り返し購入の多さ" class="headerlink" title="繰り返し購入の多さ"></a>繰り返し購入の多さ</h3><p>また、今回のコンペでは繰り返し商品を購入するパターンが強い傾向が見られました。例えば書籍などの推薦では一度購入した商品を再度推薦する意味はないのですが、今回のH&amp;Mでは同じ商品やその色違いを購入するケースが多くみられました。この点は自身が普段服をオンラインで買うときはサイズを間違えてもダメージの少ない靴下やシャツ等の消耗品ばかり買っているので予測はできていました。ただ、想像以上にスコアに対する比率が高く、以前購入した商品の再購入をとらえるのがコンペのカギとなっていました。</p><h1 id="解法のサマリ"><a href="#解法のサマリ" class="headerlink" title="解法のサマリ"></a>解法のサマリ</h1><p>今回私はこの問題に対し、候補を高速に絞り込むretrievalステージと精度よく予測を行うrankingステージの二段階で予測を行う<a href="https://research.google/pubs/pub48840/">two-tower model</a>を構築しました。解法については<a href="https://www.kaggle.com/competitions/h-and-m-personalized-fashion-recommendations/discussion/324205">kaggleのdiscussion</a>にも投稿したので、ここではサマリで割愛させていただきます。<br><img src="/images/20220602b/H&M_46th_solution_overview.drawio.png" alt="H&M_46th_solution_overview.drawio" width="811" height="531" loading="lazy"></p><h2 id="Retrieval-Stage"><a href="#Retrieval-Stage" class="headerlink" title="Retrieval Stage"></a>Retrieval Stage</h2><p>Retrieval Stageではarticleの画像や自然言語、カテゴリといった情報を、articleの性質を表すベクトル(=embedding)に変換し、ユーザーの行動履歴で学習を行う協調フィルタリングとコンテンツベースのハイブリッド手法を実装しました。ユーザーの行動履歴はこのembeddingの平均とし、ユーザーと候補のアイテムのembeddingの類似度を内積計算で計算することで、ユーザーの行動履歴に近い商品を高速に絞り込みました。検索対象のアイテムはユーザーが過去に購入したことのあるアイテムと、直近90日で履歴の数が多かったトップ20000のアイテムのうち、過去一週間で1回以上購入されている販売終了になっていないものに絞ることで実行速度と精度を上げました。</p><h2 id="Ranking-Stage"><a href="#Ranking-Stage" class="headerlink" title="Ranking Stage"></a>Ranking Stage</h2><p>Ranking Stageではユーザーの行動履歴とRetrival Stageで絞り込んだ商品の組み合わせについて、それぞれBERT等に用いられるattentionという技術を用いてより正確に相性を判定し精度を高めました。<br>この二つを組み合わせることで130万人のユーザーに対する予測をRTX3090でわずか20分のうちに予測し全体で46位に入ることができました。</p><h1 id="解法の工夫"><a href="#解法の工夫" class="headerlink" title="解法の工夫"></a>解法の工夫</h1><p>今回の課題で有効だった工夫について三点紹介します。</p><h2 id="Gumbel-Max-Trickを用いた効率的Negative-Hard-Sampling"><a href="#Gumbel-Max-Trickを用いた効率的Negative-Hard-Sampling" class="headerlink" title="Gumbel-Max Trickを用いた効率的Negative Hard Sampling"></a>Gumbel-Max Trickを用いた効率的Negative Hard Sampling</h2><p>二値問題のモデルを学習させる際、負例はある程度難しいものを選ぶと良いことが知られています。例えば[gensimのWord2Vec](<a href="https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2Vec)%E3%81%A7%E3%81%AF%E5%8D%98%E8%AA%9E%E3%81%AE%E5%87%BA%E7%8F%BE%E7%A2%BA%E7%8E%87%E3%81%AE%CE%B1(%E9%80%9A%E5%B8%B8%E3%81%AF3/4)%E4%B9%97%E3%81%A7%E8%B2%A0%E4%BE%8B%E3%82%92%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%97%E3%81%BE%E3%81%99%E3%80%82">https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2Vec)では単語の出現確率のα(通常は3/4)乗で負例をサンプリングします。</a><br>今回のデータでは予測日と対象のユーザーの年齢が分かっていました。そこでバッチごとにユーザーの年齢(10歳区切り)と予測日を統一し、予測する日から直近1週間における予測対象の年齢層の購入数top10000の割合からItem2Vec用の負例をサンプリングしました。</p><p>サンプリングの方法はGumbel-Max-Trickという手法を用いました。これはカテゴリカル分布から重複のない組み合わせをサンプリングする手法です。日ごと年齢層ごとにtop10000のarticleのIDと出現確率を入れた配列を用意し、それを用いて計算を行いました。</p><p>今回のItem2Vecの学習では負例の量と質が非常に重要でした。Word2Vecの負例の数は通常5~15付近ですが、今回のモデルでは負例の数を最大4096まで増やしました。負例の数を変えて学習させたところ、負例が4096個の時がLB0.020付近で、1024個の時がLB0.010付近、それより少なく質の低い負例ではあまり効率的に学習ができませんでした。</p><h2 id="ApproxNDCGLossベースによるランク学習"><a href="#ApproxNDCGLossベースによるランク学習" class="headerlink" title="ApproxNDCGLossベースによるランク学習"></a>ApproxNDCGLossベースによるランク学習</h2><p>Ranking StageにおけるTransformerの学習では<a href="https://www.tensorflow.org/ranking/api_docs/python/tfr/keras/losses/ApproxNDCGLoss">ApproxNDCGLoss</a>ベースのランク学習が有効でした。通常の二値分類ではユーザーが購入したかどうかをそれぞれ別々に計算するPointwiseの学習を行いますが、ApproxNDCGLossを用いた学習では一つの予測対象につき複数個のarticleを予測し、その順番を最適化するlistwiseな学習を行います。ApproxNDCGLossの実装は、予測値の差をsigmoid関数にかけることで微分可能な順位を計算し、その順位を用いてnDCGLossを計算します。私はこれをもとにnDCGの重み付けの部分を代わりに正例の順位差で計算するように改造しました。これが効いた原因は今回の予測は難しく、例えば128個サンプリングしても正例は平均して32位付近に予測されるので、nDCGによる重みづけが上手くいかず、代わりに順位差をそのまま使った方がよかったからだと推測しています。</p><h2 id="配列長を意識したattention計算の効率化"><a href="#配列長を意識したattention計算の効率化" class="headerlink" title="配列長を意識したattention計算の効率化"></a>配列長を意識したattention計算の効率化</h2><p>計算時間短縮のための工夫としてattentionの計算を大幅に高速化しました。通常のattentionではクエリの長さとターゲットの長さの積の計算量で行列計算を行います。ただ、行動履歴のようなデータは大抵が一桁二桁の長さで、ヘビーユーザーのみ三桁四桁の長さである場合が多いです。ただ、精度のためにヘビーユーザーに合わせた行列の大きさで計算を行うとかなり無駄な計算を行って非効率的になってしまいます。</p><p>そこで、クエリとターゲットの配列を一定の長さで分割し、計算を行うペアのみ部分的に計算を行うようにtf.tensor_scatter_nd系のメソッドを使ってTransformer Layerを設計することで、時間・空間計算量を大幅に削減しました。また、予測時は行動履歴の少ない順にユーザーを並べ、行動履歴の少ないユーザーの時はバッチサイズを大きくすることでさらに予測時間を短縮しました。</p><h1 id="次に取り組みたいこと"><a href="#次に取り組みたいこと" class="headerlink" title="次に取り組みたいこと"></a>次に取り組みたいこと</h1><p>今回のコンペのテーマでは取り組めませんでしたが、検討すると面白いと思うテーマについて個人的に述べていきたいと思います。</p><h2 id="セレンディピティの検討"><a href="#セレンディピティの検討" class="headerlink" title="セレンディピティの検討"></a>セレンディピティの検討</h2><p>今回のコンペは繰り返しの購入を当てることが有効で、それにうまく取り組めたチームが上位になっていました。一方で実際のレコメンドではユーザーにとって自明なレコメンドより、ユーザーにとって有用でかつ意外なアイテムを推薦することが重要な場合もあります。(セレンディピティといいます)実際には今回のH&amp;Mコンペのような指標のみではなく、本当に改善したい指標(ユーザーの満足度・売上)につながる指標も検討が必要と考えています。　</p><h2 id="ユーザー・アイテムセグメンテーションと分析"><a href="#ユーザー・アイテムセグメンテーションと分析" class="headerlink" title="ユーザー・アイテムセグメンテーションと分析"></a>ユーザー・アイテムセグメンテーションと分析</h2><p>今回はItem2Vecを推薦に用いましたが、ここで得られたベクトル(=embedding)を分析することで似たようなアイテム・ユーザーの傾向を分析することができます。embeddingを用いた分析の例は過去に<a href="https://future-architect.github.io/articles/20210901a/">医薬品副作用データベースから医薬品同士の関係を学習・評価・可視化する</a>や<a href="https://speakerdeck.com/nadare881/embeddingwoyong-itafen-xi-jian-suo-tui-jian-falseji-shu">embeddingを用いた分析・検索・推薦の技術</a>で紹介しましたが、これらの手法を用いることでレコメンドモデルから新たな示唆を得られる可能性があります。</p><h2 id="テーマ別推薦・検索との融合"><a href="#テーマ別推薦・検索との融合" class="headerlink" title="テーマ別推薦・検索との融合"></a>テーマ別推薦・検索との融合</h2><p>今回のコンペではユーザーに対して全アイテムの中からレコメンドを行っていました。実際にレコメンドを適用するとしたらサイトのトップページ、もしくはメルマガやアプリのプッシュ通知のような例が考えられます。しかしこのようなレコメンドから購入するというケースは少なく、ユーザーはキーワードで検索・もしくはカテゴリのページで探しながら商品を購入すると考えられます。</p><p>私は趣味でいろいろなECサイトのUIを眺めるのですが、カテゴリ・検索後の部分までパーソナライズできているサイトは少ないです。(ウィンドウを見て評価するショッピングをしています。)レコメンドは一方的に出して終わりではなく、ユーザーに気づきを与え、そこから興味を深堀りできるようインタラクティブに設計していくのがキモだと思っています。全商品からだけでなく、カテゴリ別のページや検索結果にもパーソナライズされたレコメンドを適用できるモデルの検討は実用上重要なテーマであると考えています。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>今回のコンペは画像・自然言語・カテゴリの詰まったログデータによるレコメンドコンペということで非常にワクワクしながら挑戦しました。ただ、今回のコンペはユーザーの購入間隔がばらばらかつ同じ商品の繰り返しの購入傾向が強いという性質からか画像や自然言語を用いたNNがあまり効かないタスクでした。私はEnd2EndのNNで勝つことにこだわったため、NNを用いた解法の中では非常に高いスコアを出せたものの、順位としては46位ともっと上を目指せたのになという後悔が残りました。このコンペからは良いレコメンドには人のロジックとMLのアルゴリズムを上手く融合させることのできる設計が必要と学びました。それを実現するための仕組みを引き続き研究していきたいと思います。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、Strategic AI</summary>
        
      
    
    
    
    <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
    <category term="参戦記" scheme="https://future-architect.github.io/tags/%E5%8F%82%E6%88%A6%E8%A8%98/"/>
    
    <category term="Kaggle" scheme="https://future-architect.github.io/tags/Kaggle/"/>
    
    <category term="TensorFlow" scheme="https://future-architect.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>int32 のサロゲートキーが数年でオーバーフローしそうになった件</title>
    <link href="https://future-architect.github.io/articles/20220602a/"/>
    <id>https://future-architect.github.io/articles/20220602a/</id>
    <published>2022-06-01T15:00:00.000Z</published>
    <updated>2022-06-02T00:58:35.359Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220602a/key-gd9783fabe_1280.jpg" alt="" width="1280" height="799"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして、2021/11 にキャリア入社したTIGの穴井です。<br>Go の ORM（Object-relational mapping）である <code>gorm</code> 利用時の構造体にて、サロゲートキーの型が <code>int32</code>であることに起因して、当該フィールドが数年でオーバーフローしそうだった件について、なぜ実装時に気づけなかったのか、記載いたします。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>既存システムに機能追加することで、これまでとは比べ物にならないデータ量を扱うシステムとなることがあると思います。私が参画しているプロジェクトでも扱うデータ量が大幅に急増し、結果として Go の構造体の <code>int32</code> のサロゲートキーが数年でオーバーフローすることが見込まれる状況となりました。</p><h1 id="なぜ実装時に気づけなかったのか"><a href="#なぜ実装時に気づけなかったのか" class="headerlink" title="なぜ実装時に気づけなかったのか"></a>なぜ実装時に気づけなかったのか</h1><p>システム開発を行う際に、開発者が共通で利用する部品を作り込むと思いますが、<br>その部品の利用に問題がありました。</p><p>私が参画しているプロジェクトは、全てのテーブルでサロゲートキーとシステムカラムを定義するという開発規約があるため、これらを表現する構造体を一つ定義しておき、構造体の埋め込みを利用して ORM を利用していました。また、サロゲートキーは ID という名称にするテーブル定義規約があり、ID はデータが insert されるたびに increment されるテーブル定義 (PostgreSQL の serial 型) となっています。</p><p>上記をコードで表すと以下の通りとなります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseColumns 共通カラムの構造体</span></span><br><span class="line"><span class="keyword">type</span> BaseColumns <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="type">int32</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line"></span><br><span class="line">CreatePgmCd  <span class="type">string</span></span><br><span class="line">CreateUserID <span class="type">string</span></span><br><span class="line">CreatedAt    time.Time <span class="string">`gorm:&quot;column:create_dt&quot;`</span></span><br><span class="line"></span><br><span class="line">UpdatePgmCd  <span class="type">string</span></span><br><span class="line">UpdateUserID <span class="type">string</span></span><br><span class="line">UpdatedAt    time.Time <span class="string">`gorm:&quot;column:update_dt&quot;`</span></span><br><span class="line"></span><br><span class="line">PatchCd     *<span class="type">string</span></span><br><span class="line">PatchUserID *<span class="type">string</span></span><br><span class="line">PatchedAt   *time.Time <span class="string">`gorm:&quot;column:patch_dt&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateSampleModel SampleModel を DB に書き込む関数（利用例）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateSampleModel</span><span class="params">(ctx context.Context, userID <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">s := &amp;SampleModel&#123;</span><br><span class="line">UserID:        userID,</span><br><span class="line">SystemColumns: BaseColumns&#123;CreateUserID: userID, UpdateUserID: userID&#125;,</span><br><span class="line">&#125;</span><br><span class="line">tx := GetTx(ctx)</span><br><span class="line">err := tx.WithContext(ctx).Create(&amp;s).Error</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このような規約がある中で実装を愚直に進めた結果、データ量に関する考慮漏れが発生し、<br>int32 のサロゲートキーを利用してしまい、数年でオーバーフローが見込まれる状況となってしまいました。</p><p>今回はサロゲートキーのオーバフロー問題ということで下記に int32, int64 の最大値を示します。</p><div class="scroll"><table><thead><tr><th>int32</th><th>int64</th></tr></thead><tbody><tr><td>2,147,483,647</td><td>9,223,372,036,854,775,807</td></tr></tbody></table></div><p>本事象では、DB で自動採番された ID が 2,147,483,647 を超えた際に Go の構造体にパースできずオーバーフローすることが見込まれました。</p><p>機能追加により約21億のデータを扱うシステムとなることは、稀なケースですが、このようなオーバーフロー問題はすべての人が遭遇する可能性がある事象だと思います。本事象に遭遇したことで、改めて、データ量と型設定について見直すいい機会となりました。</p><p>※本事象発覚後、int64のサロゲートキーを利用するようソースを修正しました。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>同じ苦しみを味わう人が出ないよう、本記事にて供養いたします。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220602a/key-gd9783fabe_1280.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; height=&quot;799&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="GORM" scheme="https://future-architect.github.io/tags/GORM/"/>
    
    <category term="失敗談" scheme="https://future-architect.github.io/tags/%E5%A4%B1%E6%95%97%E8%AB%87/"/>
    
    <category term="オーバーフロー" scheme="https://future-architect.github.io/tags/%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%95%E3%83%AD%E3%83%BC/"/>
    
  </entry>
  
  <entry>
    <title>GoとDynamoDBを用いた開発で反省していること</title>
    <link href="https://future-architect.github.io/articles/20220601b/"/>
    <id>https://future-architect.github.io/articles/20220601b/</id>
    <published>2022-05-31T15:00:00.000Z</published>
    <updated>2022-06-02T00:59:37.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG真野です。<a href="/articles/20220601a/">失敗談をテーマにした連載</a>で、ちょうどプロダクト開発的に良い区切りのタイミングでもあるため、振り返りがてら、DynamoDB,Go,AWS Lambdaの技術要素について自分自身の理解・見込みの甘さについて反省します。</p><h2 id="DynamoDBのシステム項目created-atとかupdated-atのタイムゾーンはJSTにすれば良かった"><a href="#DynamoDBのシステム項目created-atとかupdated-atのタイムゾーンはJSTにすれば良かった" class="headerlink" title="DynamoDBのシステム項目created_atとかupdated_atのタイムゾーンはJSTにすれば良かった"></a>DynamoDBのシステム項目created_atとかupdated_atのタイムゾーンはJSTにすれば良かった</h2><p>DynamoDBは日付型を直接サポートしておらず、文字列型で保存することになります。</p><ul><li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes.String">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes.String</a></li></ul><p>データサイズや諸々の理由で<a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/#UnixTime">UnixTime</a> 勢力もあるかもしれませんが、アプリケーションから直接参照されず、トレースその他を運用時の利用を目的にしたシステム項目は、可読性が大事なのでRFC3339ナノ秒で保管していました。RFC3339ナノ秒は <code>2022-06-01T03:31:14.6300415Z</code> と言った形式です。</p><p>ここまでは良かったのですがタイムゾーンはUTCに統一する方針を取っていたので、JSTではないです。変換するときは常に+9時間することになり激しく反省をしています。少なくてもクライアントのタイムゾーンがJSTであれば、JSTで保存したほうが良かったと考えています。JSTですと次のような形式を想定しています。</p><ul><li><code>2022-06-01T12:31:14.6300415+09:00</code></li></ul><p>ちなみに、AWS SDK for Goを用いると、time.Time型はデフォルトではRFC3339で保存されます。</p><blockquote><p><code>time.Time</code> is marshaled as RFC3339 format.<br><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/#:~:text=%60time.Time%60%20is%20marshaled%20as%20RFC3339%20format">https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/#:~:text=%60time.Time%60%20is%20marshaled%20as%20RFC3339%20format</a>.</p></blockquote><p>ちなみに、システム項目に限っていますが、時系列データのソートキーなどもJSTタイムゾーンで保存するほうが日本ユーザーが大半のケースにおいてはベターだと思います。</p><h2 id="時系列DBをDynamoDBに貯めるのは良かったけど、分析用のデータストアを最初から分けるべきだった"><a href="#時系列DBをDynamoDBに貯めるのは良かったけど、分析用のデータストアを最初から分けるべきだった" class="headerlink" title="時系列DBをDynamoDBに貯めるのは良かったけど、分析用のデータストアを最初から分けるべきだった"></a>時系列DBをDynamoDBに貯めるのは良かったけど、分析用のデータストアを最初から分けるべきだった</h2><p>今回のユースケースとしては、温湿度や移動情報（緯度経度）をそれなりの量と頻度（つまり時系列）で受信するようなタイプです。基本的には全データを利用するというよりは、ときより発生する異常値をトリガーに通知をしたり、ある断面のセンサー値を別システムに連携します。発生するデータ量の将来換算が読みきれずDynamoDBをメインのデータストアに採用したのは良かったのですが、データが蓄積するとちょっとした調査・集計をかなり頻繁に行いたくなりました。</p><p>最初はちょっとした集計ですし、簡易なスクリプトを開発していましたが、気づけばチーム全員がちょっとしたスクリプトを開発するのがうまくなっていました。これはこれで悪くないスキルセットかもしれませんが、すこし方向性が異なります。</p><p><a href="/articles/20210403/">S3 Export + Athenaで集計しよう</a>という方法も部分的に行いましたが、やはり特定の業務キー＋年月日でパーティショングしたいということもあり、これについては早期にデータ基盤を整えるべきであったと反省しています。</p><p>例えば次のように、DynamoDB Streamsトリガーでデータレイク側に参照したい形式で転送するといったことを早期に行っていれば..という反省があります。</p><img src="/images/20220601b/失敗談技術ブログ.drawio.png" alt="分析用データストアにDDB Streamsで転送" width="1200" height="698" loading="lazy"><h2 id="参照Viewを構築するためのDynamoDB-Streamsの処理はWeb-API側の同期処理に寄せて良かったのでは"><a href="#参照Viewを構築するためのDynamoDB-Streamsの処理はWeb-API側の同期処理に寄せて良かったのでは" class="headerlink" title="参照Viewを構築するためのDynamoDB Streamsの処理はWeb API側の同期処理に寄せて良かったのでは"></a>参照Viewを構築するためのDynamoDB Streamsの処理はWeb API側の同期処理に寄せて良かったのでは</h2><p>逆に、DynamoDB Streamsを使わないほうが良かったという話です。どうしてもアプリケーション管理画面からの参照要件が耐えられず、メインのテーブルの更新トリガーでLambdaを着火させ、参照のビューテーブルを作成する処理を追加しました。管理画面を作る処理は後々の追加要件であったため、すでに稼働済みのシステムに手をいれることを避け、疎結合に追加したという動きです。</p><p>アプリ上は疎結合となりましたが、アプリケーションの構成要素を増やすと後々面倒だなという思いが募ってきました。インフラの監視、運用、リリース。日機能的な性能、障害テストなども手間です。もちろん許容範囲内なので、この件に関してはメインテーブルに書き込みを担当するWeb APIのロジックに追加して良かったのかなと考えています。</p><h3 id="元の構成"><a href="#元の構成" class="headerlink" title="元の構成"></a>元の構成</h3><img src="/images/20220601b/失敗談技術ブログ-ページ2.drawio.png" alt="失敗談技術ブログ-ページ2.drawio.png" width="1200" height="771" loading="lazy"><h3 id="こうすればよかった"><a href="#こうすればよかった" class="headerlink" title="こうすればよかった"></a>こうすればよかった</h3><p>元も思想的には悪くない（DynamoDB Streams部分だけの改修で済むケースもあり影響範囲が限定的だった）ですが、終わってみればやや重厚だった気がします（ローカルの環境で再現するのが面倒で、単体テスト品質が上がりにくいにもあり）。</p><img src="/images/20220601b/失敗談技術ブログ-ページ3.drawio.png" alt="失敗談技術ブログ-ページ3.drawio.png" width="1200" height="771" loading="lazy"><h2 id="DynamoDBアクセスにAWS-SDK-for-Goを生で使う必要はなかったのでは"><a href="#DynamoDBアクセスにAWS-SDK-for-Goを生で使う必要はなかったのでは" class="headerlink" title="DynamoDBアクセスにAWS SDK for Goを生で使う必要はなかったのでは"></a>DynamoDBアクセスにAWS SDK for Goを生で使う必要はなかったのでは</h2><p>GoからDynamoDBアクセスをするためのパッケージは大体3つあるかなと思います。<a href="/tags/DynamoDB%C3%97Go/">DynamoDB×Go連載</a>を行ったことすらありました。</p><ol><li><a href="https://aws.amazon.com/jp/sdk-for-go/">AWS SDK for Go</a><ul><li>v1, v2がある</li></ul></li><li><a href="https://github.com/guregu/dynamo">guregu/dynamo</a></li><li><a href="https://gocloud.dev/">Go CDK</a></li></ol><p>AWS SDK for Goですが、記載がやや冗長になりがちでした。条件式も<a href="/articles/20211025a/">ヘルパーパッケージがあるよという記事</a>を書きましたが、やっぱり冗長です。公式提供だけに使えない機能は存在しない安心感はありましたが、guregu/dynamo が優秀すぎるので逆に生でわざわざ使う理由はないかなという印象です。</p><p>ちなみに、Go CDKは<a href="/articles/20200228/">DynamoDBアクセスもけっこういけるんじゃないか？</a>で1本記事を書きましたが、結局導入に至っていないです。別の機会があればこれはこれでチャレンジしたいと考えています。</p><h2 id="AWS-Lambdaのバッチ処理はStep-Functionsで必ずラップするルールにすれば良かった"><a href="#AWS-Lambdaのバッチ処理はStep-Functionsで必ずラップするルールにすれば良かった" class="headerlink" title="AWS Lambdaのバッチ処理はStep Functionsで必ずラップするルールにすれば良かった"></a>AWS Lambdaのバッチ処理はStep Functionsで必ずラップするルールにすれば良かった</h2><p>データ量が少ないため、ちょっとしたシステムI/Fでの受信/送信処理は生のLambdaで軽く書いていました。ご存知の通り最大実行時間は2022.6.1時点で15分です。今回の要件では問題なかったのですが、隣のチームに構成を移植された場合にはデータ量が多くなるケースがありタイムアウトが発生。いっそすべてStep Functionsでラップして統一するルールにしても良かったのかなと今では少し思っています。もちろん、ここだけECSやApp Runnerにする形式も面白いと思います。</p><h3 id="少し反省している構成"><a href="#少し反省している構成" class="headerlink" title="少し反省している構成"></a>少し反省している構成</h3><p>初期移行、リラン、連携先の不具合などで予期せぬデータ量に達した場合は、タイムアウトになりがち。</p><img src="/images/20220601b/失敗談技術ブログ-ページ4.drawio.png" alt="失敗談技術ブログ-ページ4.drawio.png" width="962" height="470" loading="lazy"><h3 id="横展開するのであれば最初から固く作っておいても良かったと思っている構成"><a href="#横展開するのであれば最初から固く作っておいても良かったと思っている構成" class="headerlink" title="横展開するのであれば最初から固く作っておいても良かったと思っている構成"></a>横展開するのであれば最初から固く作っておいても良かったと思っている構成</h3><p>連携先の品質その他の制御が取りにくい場合は、自衛的に固く作り込んでおくことが吉。</p><img src="/images/20220601b/失敗談技術ブログ-ページ5.drawio.png" alt="失敗談技術ブログ-ページ5.drawio.png" width="962" height="682" loading="lazy"><h2 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h2><ul><li><a href="https://github.com/go-swagger/go-swagger">go-swagger</a>も好きですが、 <a href="https://github.com/deepmap/oapi-codegen">deepmap/oapi-codegen</a> にしておけば良かった<ul><li>別にOpenAPI Specification v2（Swagger）で困ることもなく、v3を使いたいことはなかったのですが…</li></ul></li><li>go-swaggerで –strict-additional-properties をつけていることを忘れて、項目追加が許容できないため互換性を失い、リリースのときに困った<ul><li>開発時にtypoで誤った項目をcurlなどで呼ばれるよりはつけておいた方が間違いないだろうと考えたが、いつしかクライアントが増え、サーバ・クライアントのリリースサイクルがずれたときに困りました</li></ul></li><li>スキーマ駆動で自動生成したStructを、アプリ本体で用いるモデルのStructに埋め込めば良かった<ul><li>必ずしもWeb API時の項目とDBカラムが1:1ではないので、埋め込む方向に舵を切るとそれはそれで何か不満が出そうですが、項目詰め替え作業も<a href="https://github.com/jinzhu/copier">copier</a> を導入するのも何だかなと思っていた</li></ul></li><li>DynamoDBのGSIを用いて重複チェックをアプリ側で実装していましたが、反映まで時間がかかるため同時実行数の制御が必要などモヤるポイントがあった</li></ul><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>列挙すると事前に回避ないしは途中で方向転換できそうな内容が多く、アーキテクチャ的な意思決定を微修正したり、マネジメントレベルの調整ができてなかったんだなと感じました。</p><p>また、こういった振り返りの記事がもっと増えると良いなと思います。</p><p>失敗談連載の次は穴井さんの<a href="/articles/20220602a/">int32 型のサロゲートキーが数年でオーバーフローしそうになった件</a>です。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;TIG真野です。&lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="DynamoDB" scheme="https://future-architect.github.io/tags/DynamoDB/"/>
    
    <category term="振り返り" scheme="https://future-architect.github.io/tags/%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8A/"/>
    
    <category term="失敗談" scheme="https://future-architect.github.io/tags/%E5%A4%B1%E6%95%97%E8%AB%87/"/>
    
  </entry>
  
  <entry>
    <title>失敗談連載2022を始めます</title>
    <link href="https://future-architect.github.io/articles/20220601a/"/>
    <id>https://future-architect.github.io/articles/20220601a/</id>
    <published>2022-05-31T15:00:00.000Z</published>
    <updated>2022-06-02T00:58:24.664Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220601a/the-eleventh-hour-g4dea65fba_1280.jpg" alt="" width="800" height="531"><p>こんにちは。技術ブログ運営の伊藤です。<br>今回は、タイトルの通り、普段仕事している中での失敗談を集めた連載開始のインデックス記事となります。</p><h2 id="いろんな失敗"><a href="#いろんな失敗" class="headerlink" title="いろんな失敗"></a>いろんな失敗</h2><p>普段、仕事で開発などを進めているとき、そのときのレビューが通過したり、気づきにくい小さなミスなどがあるかと思います。そういった内容がちょっとずつ積もっていき、どこかで障害になったり、性能の劣化を引き起こします。</p><p>はたまた、日頃の作業をしている中で、一つ忘れてしまったがために、クラウドプロバイダーから高額な請求が来てしまうこともあります。<br>そういった、人が作業、開発する上ではどこかに失敗はつきものであるので、本連載を読んで、失敗しそうな落とし穴を事前に把握したり、日々の業務をちょっと気をつけるなどしていただければ幸いです。</p><h2 id="連載スケジュール"><a href="#連載スケジュール" class="headerlink" title="連載スケジュール"></a>連載スケジュール</h2><p>本連載は以下のスケジュールで記事を公開します。<br>扱う内容が変わったり、公開日程がずれることがございますが、ご了承ください。</p><div class="scroll"><table><thead><tr><th>日付</th><th>執筆者</th><th>タイトル</th></tr></thead><tbody><tr><td>6/1</td><td>真野隼記</td><td><a href="/articles/20220601b/">GoとDynamoDBを用いた開発で反省していること</a></td></tr><tr><td>6/2</td><td>穴井智史</td><td><a href="/articles/20220602a/">int32 型のサロゲートキーが数年でオーバーフローしそうになった件</a></td></tr><tr><td>6/3</td><td>原忠辰</td><td>Go言語において、map型の間違った使用による性能劣化と解決まで至った経緯</td></tr><tr><td>6/6</td><td>藤井亮佑</td><td>RDSの自動再起動によるインフラコストの悲劇</td></tr><tr><td>6/7</td><td>久保勇暉</td><td>Dynamoでユーザー要望で検索条件増えてく</td></tr><tr><td>6/8</td><td>辻大志郎</td><td>Lambdaのグローバル変数</td></tr><tr><td>6/9</td><td>岸下優介</td><td>Google Workspace Admin SDK の Directory APIのリクエスト間隔は気を付けましょう</td></tr></tbody></table></div><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>失敗談連載は今年が初の試みになりますが、ジャストアイデアで募ったところ、6名の方が参加してくださいました。</p><p>失敗を経て、現在は修正されているネタなので、失敗からどう回復したか、なども是非読んでいただければと思います。</p><p>その他の連載は以下の連載スケジュールに記載されていたり、Twitterにて告知するので、ぜひ併せてご確認お願いします！</p><ul><li><a href="/articles/20220117a">2022年のブログ連載予定を発表します</a></li><li><a href="https://twitter.com/future_techblog">公式Twitter</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220601a/the-eleventh-hour-g4dea65fba_1280.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="失敗談" scheme="https://future-architect.github.io/tags/%E5%A4%B1%E6%95%97%E8%AB%87/"/>
    
  </entry>
  
  <entry>
    <title>golang.tokyo #32 で go-twowaysql について紹介しました</title>
    <link href="https://future-architect.github.io/articles/20220531a/"/>
    <id>https://future-architect.github.io/articles/20220531a/</id>
    <published>2022-05-30T15:00:00.000Z</published>
    <updated>2022-05-31T05:34:11.999Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220531a/top.jpg" alt="" width="1000" height="560"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG 多賀です。 2022/5/19 に開催された <a href="https://golangtokyo.connpass.com/event/246982/">golang.tokyo #32</a> に登壇しましたので報告させていただきます。<br>「自作ライブラリ、ソフトウェアGo自慢大会」ということで、OSS 活動の一環で作成した <a href="https://github.com/future-architect/go-twowaysql">future-architect/go-twowaysql</a> について紹介してきました。</p><h2 id="発表資料"><a href="#発表資料" class="headerlink" title="発表資料"></a>発表資料</h2><p>5分と短めな発表のため、<a href="https://github.com/future-architect/go-twowaysql">go-twowaysql</a> の概要について整理された資料になっていると思いますので、気になる方は以下見てみてください。</p><iframe src="https://docs.google.com/presentation/d/1mkqEEb7eNtkXnW-t_lw3OPmTrD7JoR04SDSvy6WhjPg/embed?start=false&loop=false&delayms=3000" frameborder="0" width="100%" height="550" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>昔からよくイベントに観る側として参加していた<a href="https://golangtokyo.connpass.com/event/246982/">golang.tokyo</a> でしたが、良い機会をいただき登壇することができ、嬉しく思います。</p><p><a href="https://github.com/future-architect/go-twowaysql">future-architect/go-twowaysql</a> についても、日々改善を行っていてより使いやすくしていきたいと考えています。イベントの中で上がった、 <code>go:embed</code> 対応はぜひサポートできるようにしたいですね。</p><p>他の方々が発表された OSS ライブラリ、発表資料ともに、<a href="https://golangtokyo.connpass.com/event/246982/">golang.tokyo #32</a> イベントページ内にリンクが載ってます。面白い OSS ライブラリがいくつもありましたので、ぜひ見てみてください。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://future-architect.github.io/articles/20210803a/">Go言語で2WaySQL</a></li><li><a href="https://future-architect.github.io/uroborosql-doc/">uroboroSQL</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220531a/top.jpg&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;560&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
    <category term="2WaySQL" scheme="https://future-architect.github.io/tags/2WaySQL/"/>
    
  </entry>
  
  <entry>
    <title>【エネルギー業界】LPガス基礎知識編part2 供給設備</title>
    <link href="https://future-architect.github.io/articles/20220530a/"/>
    <id>https://future-architect.github.io/articles/20220530a/</id>
    <published>2022-05-29T15:00:00.000Z</published>
    <updated>2022-05-31T05:37:34.257Z</updated>
    
    <content type="html"><![CDATA[<p>TIG DXユニット真野です。業界ドメインに詳しくなろうというテーマで、LPガス業界入門編のpart2です。前回の基礎知識編はなるべく幅広く説明しましたが、本記事では供給設備にフォーカスします。</p><ul><li><a href="https://future-architect.github.io/articles/20220519a/">【エネルギー業界】LPガス基礎知識編  part1</a></li></ul><h2 id="LPガス設備とは"><a href="#LPガス設備とは" class="headerlink" title="LPガス設備とは"></a>LPガス設備とは</h2><p>part1で説明したとおりですが、供給設備と消費設備の2つに分類することができます。</p><img src="/images/20220530a/LPガス設備.png" alt="LPガス設備" width="981" height="511" loading="lazy"><p>供給設備はLPガス会社側の持ち物（つまり資産）で、消費設備が利用者側の資産です。</p><p>少し例外的ですが細かい話をします。消費設備側について業界慣習があり、戸建てでは貸し付け配管、アパートでは無償貸与と言う、LPガス会社側が住宅内のガス管を無償で設置し、代わりに毎月のガス料金に利用料を上乗せして払うようなケースがあります。つまりLPガスの販売業者の所有のまま貸与していることもあります。この辺りは経産省のワーキンググループ<a href="https://www.chugoku.meti.go.jp/policy/seisaku/sekiyu/pdf/p408sub_1_1.pdf">改正液石法省令等・取引適正化ガイドライン説明会資料 p7</a> にも課題感と周知について動きがあります。<a href="https://www.asahi.com/articles/ASPDY722TPCSULFA038.html">LPガス料金、月数千円を上乗せ　違約金20万円請求の業界慣行も：朝日新聞デジタル</a> にもわかりやすくまとまっています。LPガス会社の中の方が執筆した書籍を複数読みましたが、LP会社としても好ましいとは思っておらず、ただ商流上、要請されると断るのが難しいという構造があるようです。</p><p>続いて、供給設備を構成する主な設備について細かく紹介します。図にあるLPと書かれた容器（ボンベ）、圧力調整器、ガスメータについて触れていきます。図には書いていないですが、ボンベ・ガスメーター間には放出防止器や高圧ホースなどがありますが省略します。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>ボンベと（私は）よく言いますが、液石法や高圧ガス保安法では”容器”と呼びます。バルク（比較的大容量のＬＰガスを蓄えることが可能なタンク）と対比しての、シリンダー容器を略したシリンダーと呼ぶこともあります。50kg”瓶” と言った、瓶をつけて呼ぶこともあります。業界人と話す時は、大体は”容器”と表現すれば問題ないと思います。</p><p>この容器ですが、part1 でも話した通り、20kg, 50kgなどのサイズの違いがあります。LPガス業者としてはなるべく大きいサイズを設置したほうが配送コストを抑えることができますが、50kg容器にLPガスが充てんされると90kg近くになり、持ち運びとしては限界サイズになるためか、一般家庭用に使われる上限が50kgとなります。工業用ですと<a href="http://www.zenkenkyo.jp/test/propane.php">450~500kgもある</a>ようです。</p><p>50kg容器の持ち運びは担ぐ方法もありますが、<a href="https://www.youtube.com/watch?v=woWn6VcJsdw">転がす</a>方法も一般的です。また、二輪台車（キャリーや、ネコ車と呼ぶことも）で運ぶこともできます。</p><img src="/images/20220530a/二輪台車.jpeg" alt="二輪台車" width="1200" height="655" loading="lazy"><p>二輪台車、現場では <strong>ネコ</strong> と呼ぶことも多いらしく、一輪車じゃなくてもこう呼ぶのが少し新鮮でした。</p><p>ちなみに、家庭用に用いられる容器の素材は、炭素鋼を使用した溶接容器が用いられています。炭素鋼以外だとアルミウム合金製もあるようですが少量です。溶接容器以外だと、継目なし容器や複合容器が存在するようです。海外では、容器が軽い・美観がよい等の理由で、この複合容器（FRP容器（繊維強化プラスチック複合型容器））が選ばれることが増えているそうです。</p><img src="/images/20220530a/image.png" alt="複合容器" width="994" height="746" loading="lazy"><p>※画像は <a href="https://www.kanagawalpg.or.jp/images/201503_p3.pdf">https://www.kanagawalpg.or.jp/images/201503_p3.pdf</a> より。右側が複合容器です</p><p>美観…はわかりませんが、軽いのは良いですね。左は8kg容器で9.6kg、右は7.5kg容器で4.4kgだそうです。どちらも当然、容器だけの重さです。</p><p>日本でも中国工業株式会社さんが2020年8月に、<a href="http://www.ckk-chugoku.co.jp/topics/20200828%2020kgPLACOMPO.pdf">プラコンポ 20kg (FRP 製 20 ㎏型 LP ガス容器)発売のお知らせ</a>を発表していますので、もしかしたら広がっているのかもしれません（まだ私は見たことがないです）。</p><h3 id="容器検査"><a href="#容器検査" class="headerlink" title="容器検査"></a>容器検査</h3><p>容器ですが、充てん期限が存在します。充てん期限を超過した場合、再検査をしないと再度ガスを充填できません。20kg, 50kg容器ですと製造から20年未満5年に1度。20年以上経過すると2年に1度検査する必要があります<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>充てん期限はガチャガチャ写真ですが、こんな感じで記載されています。平成38年、つまり令和8年、西暦2026年の4月までということがわかります。</p><img src="/images/20220530a/充てん期限.jpeg" alt="充てん期限" width="1000" height="628" loading="lazy"><p>通常、LPガス業者では無い我々が気にすることはほとんど無いと思いますが、期限が切れた場合は耐圧検査に回されるか、破棄されることで、安全が保たれています。</p><p>検査が終わると、容器に合格年月が <strong>刻印</strong> されます。月→年の順で打刻されるため、下画像の場合は、5-02で2002年5月に検査を受けたことがわかります。</p><img src="/images/20220530a/容器の刻印.jpeg" alt="容器の刻印" width="1200" height="971" loading="lazy"><p>※画像は <a href="https://www.hyogolpg.or.jp/info20131001.html">https://www.hyogolpg.or.jp/info20131001.html</a> より</p><h3 id="容器の固定"><a href="#容器の固定" class="headerlink" title="容器の固定"></a>容器の固定</h3><p>容器は転倒・転落の防止のため、チェーンで固定されています。</p><img src="/images/20220530a/チェーン.png" alt="チェーン" width="577" height="345" loading="lazy"><p>※ 画像は <a href="http://www.lpg.or.jp/sp/about_lpg/about_lpg04.html">http://www.lpg.or.jp/sp/about_lpg/about_lpg04.html</a> より</p><p>1重、2重のルールですが、経済産業省の<a href="https://www.meti.go.jp/policy/safety_security/industrial_safety/oshirase/2021/06/20210618-01.html">液石法施行規則及び同規則の機能性基準の運用（例示基準）の一部改正について（自然災害対策：充てん容器の流出防止措置）</a>を見ると、洪水浸水想定区域などにおいて1m以上の浸水が予想される場合は2重にすると言った基準があるそうです。</p><p>こういった安全策は何重にも検討・実施されており、安心してガスを使えるありがたみを感じることができます。</p><h2 id="圧力調整器"><a href="#圧力調整器" class="headerlink" title="圧力調整器"></a>圧力調整器</h2><img src="/images/20220530a/調整器.jpeg" alt="調整器" width="1072" height="1072" loading="lazy"><p>※画像は <a href="https://www.katsuraseiki.co.jp/?page_id=287">https://www.katsuraseiki.co.jp/?page_id=287</a> にある 桂精機製作所さんのCA8A-BH065Zより</p><p>圧力調整器（調整器）は容器の中の高い圧力のガスを、コンロなどの消費設備で利用に適した、低い圧力に下げるための設備です。容器内のLPガスの圧力は0.4～1.2MPa程度で、調整器により2.3～3.3kPaまで下げてくれます。容器と調整器の間は、高圧ホースという特殊な管でつながっています。他にも流量調整機能（整圧、閉塞圧力）などの機能も持っていて、途中でガスが使えなかったり流れ過ぎを防止しています。まさに調整の役目です。</p><p>自動切替式（”じきり”と呼ぶことも）の調整器も存在します。これは下図を見るとわかりやすいです。容器が複数系統接続されている場合に、片方が無くなるともう片方に切り替えてくれます。</p><img src="/images/20220530a/圧力調整器による切り替え.png" alt="圧力調整器による切り替え" width="1200" height="683" loading="lazy"><p>※画像は <a href="https://www.lia.or.jp/Portals/0/images/news/kurashi2020_4.pdf">https://www.lia.or.jp/Portals/0/images/news/kurashi2020_4.pdf</a> より</p><p>自動切替式調整器を設置することのメリットですが、例えば片方のボンベを使い切ったタイミングから、予備側を使い切る間に、容器交換に向かえば必ず1本（方系）の容器が空っぽなので、持ち帰り時に楽（ガソリン代も浮く）があります。必ず両系統（図だと2本）交換するような配送の仕組みでは、持ち帰り残量としてのメリットは無いですが、通常の戸建てでは一般的に使われていると思います。1970年ほどから容器の複数構成＋自動切替調整器の組み合わせが多くなったようで、それまではガス切れが日常茶飯事<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>だったようです。</p><p>調整器切り替えの注意としては、必ずしも使用側が完全に0Paになるタイミングで、予備側に切り替わるということではないということです。ゼロ近くまでは利用しますが、圧力が低くなると完全に無くなる前に切り替えられちゃいます。</p><p>切り替わりですが、図のように真ん中の表示が「赤色（シグなりあり）」になっていると、予備側の容器から供給されています。「表示無し」は使用側の容器から供給されていることを示しています。矢印の向いている側が使用側です。</p><p>他にも、二段式調整器という種類の機器があります。マンションなど高層階にガスを届けるには、中圧に落として各戸の前で低圧に落とすという二段階の減圧の仕組みです。</p><ul><li>参考: <a href="https://gas-2syuhan.com/security-management/lp_tool_household/#i-8">https://gas-2syuhan.com/security-management/lp_tool_household/#i-8</a></li></ul><h2 id="中圧"><a href="#中圧" class="headerlink" title="中圧"></a>中圧</h2><p>圧力について、LPガス（プロパンガス）において高圧・中圧・低圧が存在します。高圧はボンベから高圧ガスを通って、調整器で減圧されるまでです。低圧は一般の消費設備が利用する圧力です。中圧は先程述べた通り、マンションなどの配管が長い場合や、工業用（溶接など）などに利用します。</p><div class="scroll"><table><thead><tr><th>種類</th><th>圧力<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></th></tr></thead><tbody><tr><td>高圧</td><td>0.7MPa ～ 1.3MPa</td></tr><tr><td>中圧</td><td>60kPa ～ 80kPa</td></tr><tr><td>低圧</td><td>2.3kPa ～ 3.3kPa</td></tr></tbody></table></div><p>この中圧のまま減圧せずガスを利用するパターンにおいては、中圧対応のガスメーターを利用して計測する場合があります。また、この供給圧力によって、係数を変えて利用量を算出するようです。</p><img src="/images/20220530a/流量換算.png" alt="流量換算" width="1129" height="438" loading="lazy"><p>※画像は愛知時計電機株式会社さんの <a href="https://www.aichitokei.co.jp/wp/wp-content/uploads/gk-ah-020z-1606.pdf">https://www.aichitokei.co.jp/wp/wp-content/uploads/gk-ah-020z-1606.pdf</a> より</p><p>上図の例では、1㎥とガスメータ上は表示されていても、例えば60kPaの圧力で供給された場合、1.5922㎥利用したとカウントするということです。</p><img src="/images/20220530a/中圧設備.png" alt="中圧設備" width="1111" height="271" loading="lazy"><h2 id="ガスメーター"><a href="#ガスメーター" class="headerlink" title="ガスメーター"></a>ガスメーター</h2><p>ガスの使用量を計測するガスメーターについて説明します。</p><h3 id="種類"><a href="#種類" class="headerlink" title="種類"></a>種類</h3><img src="/images/20220530a/マイコンガスメーター.png" alt="マイコンガスメーター" width="1200" height="534" loading="lazy"><p>※画像は <a href="http://www.lpg.or.jp/download/pdf/micom_meter_s.pdf">http://www.lpg.or.jp/download/pdf/micom_meter_s.pdf</a> より</p><p>一般家庭につけられているガスメーターですが、part1でも説明した通り、内部にマイコンが入っており非常に賢い作りになっています。大きくS型、E型の2種類ありますが。それぞれについて説明しますが、機能的には同等です。</p><ol><li>S型（マイコンメーターS）<ul><li>ガスの流量を膜式で計測する（下図の左を参考）</li><li>消費社宅のガス消費パターンを学習する機能があり、自動的に遮断値を設定してくれる</li></ul></li><li>E型（マイコンメーターE）<ul><li>ガスの流量を超音波で計測する。膜式と異なり計量室が不要なので約半分の大きさとなり小型である<ul><li>超音波で、一定距離の往復時間の相違から、流速を求め流量を計測します</li></ul></li><li>微量流量でも数秒で計測できるため、漏洩検知など安全性も向上している</li><li>機能上はS型と同様</li></ul></li></ol><p>それぞれの継続方法の簡単なイメージは次のとおりです。膜式は直接体積を計測しているイメージです。</p><img src="/images/20220530a/計測方法.png" alt="計測方法" width="1200" height="403" loading="lazy"><p>※画像は <a href="http://toma-lpg.com/2017micon_1.pdf">http://toma-lpg.com/2017micon_1.pdf</a> より</p><p>S型ガスメーターは、KHKS 0733(高圧ガス協会規格)で規格化されています<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。KHKは高圧ガス保安協会の略で、KHKSの最後のSはStandardの意味です。<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p><p>マイコンメーターにはS型・E型があるというお話をしましたが、さらにS4、SB、E4、EBなどに分かれます。ざっと違いをまとめます。</p><div class="scroll"><table><thead><tr><th>分類</th><th>型</th><th>計測方法</th><th>最大流量</th><th>規格(すべてKHKS 0751に統合される予定)</th></tr></thead><tbody><tr><td>家庭用</td><td>S型</td><td>腹膜式</td><td>2.5㎥</td><td><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200733(2016).pdf">KHKS 0733</a></td></tr><tr><td>家庭用</td><td>S4型</td><td>腹膜式</td><td>4㎥</td><td><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200742(2016).pdf">KHKS 0742</a></td></tr><tr><td>家庭用</td><td>E型</td><td>超音波式</td><td>2.5㎥</td><td><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200741(2016).pdf">KHKS 0741</a></td></tr><tr><td>家庭用</td><td>E4型</td><td>超音波式</td><td>4㎥</td><td><a href="KHKS_0743">KHKS 0743</a></td></tr><tr><td>業務用</td><td>SB型</td><td>腹膜式</td><td>6～16 ㎥/h</td><td><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200737(2016).pdf">KHKS 0737</a></td></tr><tr><td>業務用</td><td>EB型</td><td>超音波式</td><td>6～16 ㎥/h</td><td><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200741(2016).pdf">KHKS 0741</a></td></tr></tbody></table></div><p>マイコンメーターで調べると、メーカーごとにこういった型番が出てきて混乱するかと思います。家庭用、業務用などの区別ができると混乱も減るかなと思います。</p><h3 id="マイコンメーターの名称の系譜"><a href="#マイコンメーターの名称の系譜" class="headerlink" title="マイコンメーターの名称の系譜"></a>マイコンメーターの名称の系譜</h3><p>最初に登場するのはマイコンⅠです。1981年ごろに東京ガスさんと松下電器産業さんの共同開発で生まれました。先行で部分的に導入され安全性が高く評価されたため、1987年に全戸普及を図るべく次のような機能を持ったマイコンⅡが発売されました。マイコンⅡは総称のようなもので規格です。6社10型式が申請を出して合格したのを皮切りに広がっていきます。</p><ol><li>異常なガス流量を検知したら遮断する（合計・増加流量遮断）</li><li>異常な長時間使用を検知したら遮断する（継続使用時間遮断）</li><li>微小流量を含むガス流量を、30日継続して検知したら警告表示する（微小漏洩表示）</li></ol><p>1989年には、マイコンⅡが一般家庭用に異常検知ロジックを組んだため、業務用に用いられるように改良したバージョンが登場。マイコンB（業務用）、C（大消費者及び、緩加熱型貯湯式湯沸器仕様世帯用）、L（大口消費者用）です。これで大多数のガスメーターをマイコンメーターに置き換えられるようになったとのことです。設置が進むに連れて、機能強化・改善や寸法の統一など、様々な要望が寄せられました。</p><p>そこで1994年頃から出てきたのがマイコンSです。Ⅱに比べて追加された機能が主に4つあります。Sはスマートメーターの略だと思います。</p><ol><li>最大流用および最大器具流量を学習結果に基づき設定</li><li>メータ上流側の漏れ及び恒久圧力の状態も認知できるように圧力センサーを追加<ul><li>これは配管低圧部側の漏洩検査を省略できるようになり、事業者側のメリットが大きかったとのこと<ul><li>従来は2年に1回、法定点検で手動で検査していたとのこと</li></ul></li></ul></li><li>感震器を内蔵し、震度5相当の地震で遮断</li><li>通信機能<ul><li>Ⅱでは通信機能があるもの、無いものが混在していたため、通信仕様を標準化</li><li><a href="https://www.khk.or.jp/Portals/0/khk/lpg/kikaku/2022/public%20comment/KHKS%200733(2016).pdf">KHKS 0733</a> を見る限り、外部端末に接続できる端子などの決まりがあるようです</li></ul></li></ol><p>その後は超音波型の、E型（おそらく電子式のElectronicから）が登場したといった流れです。</p><ul><li>参考<ul><li><a href="https://www.tokyo-gas.co.jp/letter/2020/07/20200715sp.html">https://www.tokyo-gas.co.jp/letter/2020/07/20200715sp.html</a></li><li><a href="http://www.shmj.or.jp/dev_story/pdf/develop17.pdf">http://www.shmj.or.jp/dev_story/pdf/develop17.pdf</a></li><li><a href="https://www.lia.or.jp/Portals/0/resources/ayumi/05anteiki.pdf">https://www.lia.or.jp/Portals/0/resources/ayumi/05anteiki.pdf</a></li></ul></li></ul><h3 id="交換期限"><a href="#交換期限" class="headerlink" title="交換期限"></a>交換期限</h3><p>マイコンメーターですが交換期限が法律で決まっており、10年（6号より大きいと7年<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>）の期限があります。これは液石法ではなく、計量法で定められています。ガスメーターは供給設備でありLPガス業者側の業務となります。交換のタイミングですがLPガス配送の繁忙期が冬期（寒くなるとガスを使うので当たり前ですね）であるため、閑散期にあたる夏期にメーター交換を行うことが多いようです。</p><p>さらりと6号というワードを出しましたが、これは1時間あたりに何㎥を流すことができるかの単位で、号数と呼びます。例えば、2.5号だと2.5㎥/h、4号だと4㎥/hです。この号数は各メーターの型番にもよく利用されます。</p><p>ちなみに、都市ガスについては16号より大きいと交換期限が7年となります。こちらも計量法と、都市ガスの1㎥あたりの発熱量から分かります。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>ざっとLPガスの供給設備について説明しました。設備周りは用語が揺れている気がしたり（ボンベ/容器/シリンダーや、S型/マイコンS/マイコンメーターSなど）、名前の由来が謎（Sってどういう意味なんだろうなど）が多く、調べるのに骨が折れました。</p><p>この記事が初学者の取っ掛かりになれば良いなと思います。最後まで読んでいただき、ありがとうございました。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><a href="http://www.zenkenkyo.jp/test/post.php">http://www.zenkenkyo.jp/test/post.php</a> にあるように、製造日や容器サイズで充てん期限が異なります。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">数値は <a href="https://fatmag.jp/lpg-pressure-operator/">https://fatmag.jp/lpg-pressure-operator/</a> を参考</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">計量法では、①ガスの総発熱量が90MJ/㎥未満・使用最大流量16㎥以下を10年。②ガスの総発熱量が90MJ/㎥以上・使用最大流量6㎥以下を10年。③1,2以外を7年と記載がある。プロパンの発熱量は99MJ/㎥のため2の条件と考えると、6号未満は10年。6号より大きいと7年となる</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="vertical-align: top; padding-right: 10px;">4.</span><span style="vertical-align: top;">2022年にKHKS 0751に統合予定だそうです</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="vertical-align: top; padding-right: 10px;">5.</span><span style="vertical-align: top;"><a href="https://www.lia.or.jp/Portals/0/resources/ayumi/03sogyoki.pdf">https://www.lia.or.jp/Portals/0/resources/ayumi/03sogyoki.pdf</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="vertical-align: top; padding-right: 10px;">6.</span><span style="vertical-align: top;"><a href="https://www.khk.or.jp/public_information/public_introduction/publications/standards.html">https://www.khk.or.jp/public_information/public_introduction/publications/standards.html</a> のURLが &quot;s&quot;tandards.html から推測</span><a href="#fnref:6" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;TIG DXユニット真野です。業界ドメインに詳しくなろうというテーマで、LPガス業界入門編のpart2です。前回の基礎知識編はなるべく幅広く説明しましたが、本記事では供給設備にフォーカスします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Business" scheme="https://future-architect.github.io/categories/Business/"/>
    
    
    <category term="業界ドメイン" scheme="https://future-architect.github.io/tags/%E6%A5%AD%E7%95%8C%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3/"/>
    
    <category term="LPガス業界" scheme="https://future-architect.github.io/tags/LP%E3%82%AC%E3%82%B9%E6%A5%AD%E7%95%8C/"/>
    
    <category term="エネルギー業界" scheme="https://future-architect.github.io/tags/%E3%82%A8%E3%83%8D%E3%83%AB%E3%82%AE%E3%83%BC%E6%A5%AD%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #22 Flutter勉強会より：Flutterアプリのperformance測定と基本的な実装ポイント</title>
    <link href="https://future-architect.github.io/articles/20220525a/"/>
    <id>https://future-architect.github.io/articles/20220525a/</id>
    <published>2022-05-24T15:00:00.000Z</published>
    <updated>2022-05-25T03:08:36.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。TIGの藤田です。<a href="https://future.connpass.com/event/242858/">Future Tech Night #22 Flutter勉強会</a>にてお話した「Flutterアプリのperformance測定と基本的な実装ポイント」についてご紹介します。</p><h2 id="コンテンツ"><a href="#コンテンツ" class="headerlink" title="コンテンツ"></a>コンテンツ</h2><ol><li>Performanceについて</li><li>DevToolsについて</li><li>レンダリングのプロファイリングデモ</li><li>メモリのプロファイリングデモ</li></ol><h2 id="Performanceについて"><a href="#Performanceについて" class="headerlink" title="Performanceについて"></a>Performanceについて</h2><p>複数の観点があります。Flutter GitHub リポジトリではPerformance issue を４カテゴリに分けて管理しています： <a href="https://github.com/flutter/flutter/issues?q=is:open+label:%22perf:+speed%22+sort:updated-asc+">perf: speed</a>, <a href="https://github.com/flutter/flutter/issues?q=is:open+label:%22perf:+memory%22+sort:updated-asc+">perf: memory</a>, <a href="https://github.com/flutter/flutter/issues?q=is:open+label:%22perf:+app+size%22+sort:updated-asc+">perf: app size</a>, <a href="https://github.com/flutter/flutter/issues?q=is:open+label:%22perf:+energy%22+sort:updated-asc+">perf: energy</a>.<br>“Speed”には、レンダリング速度、ファイルIOなども影響します。</p><h2 id="DevToolsについて"><a href="#DevToolsについて" class="headerlink" title="DevToolsについて"></a>DevToolsについて</h2><p><a href="https://docs.flutter.dev/development/tools/devtools/overview">公式ページ</a>でも紹介されるように、Widget inspector, CPU profiler, Memory view, Performance view, Network view, Logging view, Debug機能を持っています。勉強会では、Performance viewと、Memory viewを紹介しました。<br><img src="/images/20220525a/image.png" alt="DevToolsについて" width="1200" height="674" loading="lazy"></p><p>以前に技術ブログで紹介した<a href="https://future-architect.github.io/articles/20220317a/">Performance viewの使い方</a>の振り返りにもなりましたが、勉強会では、さらに実装上の注意点をデモを交えてお話しました。<br><img src="/images/20220525a/image_2.png" alt="DevToolsによる性能測定(Performance View)" width="1200" height="676" loading="lazy"></p><img src="/images/20220525a/image_3.png" alt="Frameと処理時間" width="1200" height="675" loading="lazy"><p>レンダリングPerformanceについての実装上の注意の基本的な3点を紹介しました。3番目については、デモとコードを用いてお話しています。<br><img src="/images/20220525a/image_4.png" alt="レンダリングPerformance tips" width="1200" height="676" loading="lazy"></p><p>Memory viewの紹介もしています。機能は大きく分けると以下の2つで、１）Memory 使用量とイベントの時系列グラフ表示、２）Memory上のインスタンス分析（SnapShot時の分析と、trace分析の2種類）になります。<br><img src="/images/20220525a/image_5.png" alt="DevToolsによる性能測定 Memory View" width="1200" height="676" loading="lazy"></p><h2 id="レンダリングのプロファイリングデモ"><a href="#レンダリングのプロファイリングデモ" class="headerlink" title="レンダリングのプロファイリングデモ"></a>レンダリングのプロファイリングデモ</h2><p>レンダリングPerformance Tips「３）大きなGridやListは画面表示部のみをBuildする」の例をDevToolsの使い方と合わせて紹介しました。Animationを含む100個のWidgetをスクロール表示するために、1つめはColumnとSingleChildScrollViewを使用、2つめはListView.builderを使用しています。</p><p>１）ColumnとSingleChildScrollViewを使用（アンチパターン）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span> <span class="keyword">as</span> math;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SCScrollViewPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> SCScrollViewPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _SCScrollViewPageState createState() =&gt; _SCScrollViewPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SCScrollViewPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SCScrollViewPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _itemCount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> screenSize = MediaQuery.of(context).size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">&#x27;SingleChildScrollView List&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          width: screenSize.width * <span class="number">0.6</span>,</span><br><span class="line">          height: screenSize.width * <span class="number">0.8</span>,</span><br><span class="line">          child: SingleChildScrollView(</span><br><span class="line">            child: Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _itemCount; i++) <span class="keyword">const</span> Item(),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Item(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;Item&gt; createState() =&gt; _ItemState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ItemState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Item</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> _controller = AnimationController(</span><br><span class="line">    vsync: <span class="keyword">this</span>,</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">10</span>),</span><br><span class="line">  )..repeat();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _controller.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> SizedBox(</span><br><span class="line">      height: <span class="number">200</span>,</span><br><span class="line">      child: AnimatedBuilder(</span><br><span class="line">        animation: _controller,</span><br><span class="line">        child: Image.asset(<span class="string">&#x27;assets/images/dash.png&#x27;</span>, fit: BoxFit.fitHeight),</span><br><span class="line">        builder: (_, Widget? child) &#123;</span><br><span class="line">          <span class="keyword">return</span> Transform.rotate(</span><br><span class="line">            angle: _controller.value * <span class="number">2.0</span> * math.pi,</span><br><span class="line">            child: child,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DevToolsのPerformance viewで確認すると、Frame毎に、画面に表示されないWidgetもすべてBuildされてしまっています。<br><img src="/images/20220525a/build_100loop.gif" alt="DevToolsのPerformance viewで確認" width="1200" height="442" loading="lazy"></p><p>２）ListView.builderを使用<br>上の１）と同じItem Widgetを、ListView.builderを使用して表示すると、Frame毎に、画面に表示される数個のWidgetのみがBuildされることが分かります。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span> <span class="keyword">as</span> math;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LVBuilderPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LVBuilderPage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LVBuilderPageState createState() =&gt; _LVBuilderPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LVBuilderPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LVBuilderPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _itemCount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> screenSize = MediaQuery.of(context).size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">&#x27;ListViewBuilder List&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          width: screenSize.width * <span class="number">0.6</span>,</span><br><span class="line">          height: screenSize.width * <span class="number">0.8</span>,</span><br><span class="line">          child: ListView.builder(</span><br><span class="line">            itemCount: _itemCount,</span><br><span class="line">            itemBuilder: (context, index) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">const</span> Item();</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/20220525a/build_listviewbuilder.gif" alt="DevToolsのPerformance viewで確認" width="1200" height="442" loading="lazy"><h2 id="メモリのプロファイリングデモ"><a href="#メモリのプロファイリングデモ" class="headerlink" title="メモリのプロファイリングデモ"></a>メモリのプロファイリングデモ</h2><p><a href="https://docs.flutter.dev/development/tools/devtools/memory">Flutter DevTools公式サイトのMemory view解説ページ</a>で紹介される<a href="https://github.com/flutter/devtools/tree/master/case_study/memory_leaks/images_1_null_safe">Case Study</a>を利用して、Memory viewの簡単な説明をしました。Network経由でサイズの大きな画像を多数連続して読み込んで表示するデモアプリのMemory使用を可視化しています。</p><ul><li>メモリ使用状況を時系列にグラフで確認できます。ユーザイベント、Heapメモリ、Nativeメモリ、Garbage collection (GC)などが表示されています。</li><li>メモリ使用のスパイク(40%以上)を検知してDevToolsが自動でSnapShotを取得（手動でも可能）して、その時のメモリ使用状況を分析できるようになっています。</li><li>以下ではImageCache PackageのObject数が急増していることを確認しています。</li></ul><img src="/images/20220525a/memory_demo.gif" alt="メモリのプロファイリングデモ" width="1200" height="661" loading="lazy"><p>補足：正確なPerformance測定は実機を用いた「Profile mode」での測定を前提としていますが、勉強会デモでは画面表示のためシミュレータのdebug modeでの確認としています。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>Android studioでも同じようにPerformance測定できますか？<br>→ Android studioに、Flutter pluginをインストールすることでDevToolsも使用可能になります。参考：<a href="https://docs.flutter.dev/development/tools/devtools/android-studio">https://docs.flutter.dev/development/tools/devtools/android-studio</a></li><li>実業務での使用事例はありますか？<br>→ 現在のところは、開発プロセスに組み込んでの使用はしていませんが、課題発生時の原因究明に役立つと見込んでいます。</li></ul><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>Performanceについても<a href="https://docs.flutter.dev/development/tools/sdk/release-notes">Flutter stable release</a>で毎回向上していて更新が多く注目度の高い開発ポイントだと分かります。DevToolsをFlutterアプリのPerformance課題解決と品質向上に役立てたいところです。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li>Flutter DevTools公式サイトのMemory view解説ページ<ul><li><a href="https://docs.flutter.dev/development/tools/devtools/memory">https://docs.flutter.dev/development/tools/devtools/memory</a></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは。TIGの藤田です。&lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="性能検証" scheme="https://future-architect.github.io/tags/%E6%80%A7%E8%83%BD%E6%A4%9C%E8%A8%BC/"/>
    
    <category term="Flutter" scheme="https://future-architect.github.io/tags/Flutter/"/>
    
    <category term="DevTools" scheme="https://future-architect.github.io/tags/DevTools/"/>
    
  </entry>
  
  <entry>
    <title>golang.tokyo #32を主催しました</title>
    <link href="https://future-architect.github.io/articles/20220524a/"/>
    <id>https://future-architect.github.io/articles/20220524a/</id>
    <published>2022-05-23T15:00:00.000Z</published>
    <updated>2022-05-24T03:18:57.212Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220524a/image.png" alt="" width="256" height="256" loading="lazy"><p>The Gopher character is based on the Go mascot designed by Renée French.<br>この図柄はtenntennさん作成です</p><p><a href="https://golangtokyo.connpass.com/event/246982/">golang.tokyo #32</a>を主催しました。Futureが社外向けに行なっている<a href="https://future.connpass.com/">Future Tech Night</a>という、だいたい月次で行なっている勉強会があり、今月はGoですかね、という話をしていたのですが、どうせなら外部の人にも登壇してもらう場にして盛り上げて、集客もたくさんしよう、という感じでgolang.tokyoとしての開催にすることにしました。僕はオープニングと司会進行をやりました。</p><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vS_puMX7qVj6pFxR8b1dfU0C9QIpVhY5MGFhP7itvjyugapignGenhuJmdJSc0A7mtPoI23_-kB0bXH/embed?start=false&loop=false&delayms=3000" frameborder="0" width="960" height="569" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><p>IT業界ではよく英語を学べとか一次情報（たいてい英語）に触れろとか言われますが、日本語での発表とかもコミュニティが育っていけば価値があると思っています。Rubyとか海外の人が来てくれたりしますしね。そういう風に日本のGoコミュニティが育っていけばいいな、と思うのですが、そのためには「日本発」を増やしていく必要があると思っています。</p><p>golang.tokyoの趣旨である、Goの業務利用を推進するというのはうまくいっていて、設立当初よりもGoを活用している企業がだいぶ増えてきていると感じます。一方で、日本発を増やしていくには、「自分で作ったぞ！」とかをもっとアピールできる場を作りたいと思っていました。日本で大きなGoのイベントというとGo Conferenceですが、これは募集期間が長めということもあり、作ったものを気軽に発表する場としては敷居が高くなってしまっているし、CfPの競争率も高いです。どうしても「1.Xバージョンで追加された新機能！」みたいなキャッチーなものとかが選ばれがちで、「うちの社内で困っていたこういう問題を解決したい！」みたいな、超現場ニーズみたいなものは選ばれにくいように思います。</p><p>そういうこともあって、Go自慢大会を今回開催させていただきました。</p><h1 id="力強い発表の数々"><a href="#力強い発表の数々" class="headerlink" title="力強い発表の数々"></a>力強い発表の数々</h1><p>今回は1週間程度募集期間を設けて公募しました。多すぎたら抽選にしようと思いましたが、11人なので全員当選となりました。</p><p>実際に使っているというものも多く、リアルな職場のニーズを捉えて作られていたり、なんか魂がこもっているな、という発表が多くて楽しかったです。</p><div class="scroll"><table><thead><tr><th>発表</th><th>URL</th><th>実装の動機</th></tr></thead><tbody><tr><td>濱田洋太</td><td><a href="https://github.com/yohamta/dagu">github.com/yohamta/dagu</a></td><td>データ処理（ETL）バッチ群の依存関係の可視化、運用効率化</td></tr><tr><td>satoken</td><td><a href="https://github.com/sat0ken/go-tcpip">github.com/sat0ken/go-tcpip</a></td><td>プロトコルを学ぶためで業務用ではありません</td></tr><tr><td>convto / 奥村 優哉 (株式会社Kyash)</td><td><a href="https://github.com/convto/bit">github.com/convto/bit</a></td><td>バイナリをbit表現に変換するためのエンコーディングライブラリで、バイナリを解釈するようなプログラムのlogやデバッグのために作りました。 具体的な動機は <a href="https://convto.hatenablog.com/entry/2022/05/08/160157">https://convto.hatenablog.com/entry/2022/05/08/160157</a> に詳しいです</td></tr><tr><td>issei (Univ.Ryukyu)</td><td><a href="https://github.com/Issei0804-ie/who-is-in-a-lab">github.com/Issei0804-ie/who-is-in-a-lab</a></td><td>研究室の先輩からお願いがありソフトウェアを作成しました</td></tr><tr><td>澤田晋之介 (株式会社サイバーエージェント)</td><td><a href="https://github.com/Warashi/wrapmsg">github.com/Warashi/wrapmsg</a></td><td>fmt.Errorf でエラーをwrapするときのメッセージを統一するべく定めたコード規約をlinterとして実装しました</td></tr><tr><td>aereal</td><td><a href="https://github.com/aereal/pkgboundaries">github.com/aereal/pkgboundaries</a></td><td>clean architectureなどプロジェクトごとに依存関係の方向を規定したいことがあります。このツールはJSONで定めたルールを与えてgo vetツールとして実行すると不正な依存（import）を発見してくれます。</td></tr><tr><td>多賀聡一朗 (フューチャー株式会社)</td><td><a href="https://github.com/future-architect/go-twowaysql">github.com/future-architect/go-twowaysql</a></td><td>2-Way SQL 形式の DB アクセスライブラリのニーズがあり作成しました</td></tr><tr><td>小山健一郎 (GMOペパボ株式会社)</td><td><a href="https://github.com/k1LoW/runn">github.com/k1LoW/runn</a></td><td>OpenAPI Documentを使ったGoのAPIサーバを開発している時、複数のAPIをまたいでかつ、データベースのデータを参照しながらのテストをOpenAPI Documentライクに簡単に書けるようにしたいというニーズ</td></tr><tr><td>辻大志郎 (フューチャー株式会社)</td><td><a href="https://github.com/future-architect/awsmfa">github.com/future-architect/awsmfa</a></td><td>以下のニーズによるものです・AWS CLIにおけるMFA認証を効率的に実施したい・簡単にローカルPCにインストールして使えるようにしたい</td></tr><tr><td>原 慧士 (GMOペパボ株式会社)</td><td><a href="https://github.com/harakeishi/whris">github.com/harakeishi/whris</a></td><td>証明書の発行などで該当のドメインのAレコードがどこの管理サーバーに向いているかを１コマンドで調べれるように作成しました</td></tr><tr><td>富樫 知基</td><td><a href="https://github.com/toga4/go-retryabletransport">github.com/toga4/go-retryabletransport</a></td><td>httputil.ReverseProxyを使った実装でHTTPリクエストのリトライをRoundTripperでやりたかった</td></tr></tbody></table></div><p>発表は<a href="https://go.dev/play/p/KKfF9zIJPO4">Goのコード</a>で順番を決めました。あ、Playgroundは常に同じ結果になるのでローカルで実行していますよ。</p><p>当社からも、多賀さんと辻さんの2人が発表してくれました。</p><h1 id="今後"><a href="#今後" class="headerlink" title="今後"></a>今後</h1><p>この場はきっと、定期的に開催して行った方が良いのだろうな、と思っています。目標があればそれに向けて頑張ろうという人も出てくるでしょう。また、OSSを開発に利用する人は多いと思いますが、業務のコードのOSS化の促進の啓発にも繋がると思います。今回、多少手伝ってもらったところはありますが、多くの部分を1人で運営できたので、省力運営は実現できましたので、定期的な運営もできそうです。</p><p>3ヶ月ごとぐらいの開催とかだと良いでしょうかね？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220524a/image.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;256&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;The Gopher character is based on the Go mascot</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="勉強会" scheme="https://future-architect.github.io/tags/%E5%8B%89%E5%BC%B7%E4%BC%9A/"/>
    
    <category term="golang.tokyo" scheme="https://future-architect.github.io/tags/golang-tokyo/"/>
    
  </entry>
  
  <entry>
    <title>【エネルギー業界】LPガス基礎知識編</title>
    <link href="https://future-architect.github.io/articles/20220519a/"/>
    <id>https://future-architect.github.io/articles/20220519a/</id>
    <published>2022-05-18T15:00:00.000Z</published>
    <updated>2022-05-30T01:32:14.569Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220519a/LPボンベ.jpeg" alt="" width="1200" height="589" loading="lazy"><p>※画像は<a href="https://twitter.com/TOYSCABIN/status/1452575185282875399?s=20&t=J0rViIgbnCf7-Uxfj06ooA">トイズキャビンさんの1/24スケール</a>プロパンガスのガチャガチャです。</p><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG真野です。業界ドメインに詳しくなろうというテーマで、LPガス業界について触れていきます。</p><p>この記事はLPG業界知識の超入門編です。新規参画のメンバーのオンボーディングで何度か受け入れの紹介をしましたが、高頻度で繰り返し説明したことをこの記事でまとめます。かなり基礎的な内容も含みますが、個別の詳細な内容は別記事にて紹介します。この記事では各領域を説明する記事から基礎的な部分はこちらで、といったリンクを貼られて使われることも想定しています。</p><h2 id="LPガスとは"><a href="#LPガスとは" class="headerlink" title="LPガスとは"></a>LPガスとは</h2><p>LPガスとはLiquefied Petroleum Gasの略で、プロパンとブタンを液化した液化石油ガスです。LPGと略すことも多いです。8割ほどがプロパンであるためプロパンガスが一般名称にもなっています。トップ画像にあるように、ガスボンベに詰められ、都市ガスが通っていない地域のご家庭などで燃料として使われています。当然、ガスボンベを定期的に交換しないとガスが利用できないため直感的にはかなり手間がかかるインフラだと感じますが、その分ガスボンベは各家庭など供給先単位で独立しているため、災害に強いとされています<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>対して、都市ガスは道路の下のガス管を経由して供給されます。日本ガス業界さんのページからわかりやすい比較図をお借りすると、以下のような物流の違いがあります。都市部でよく見るガスホルダーは都市ガスだけにあるということが分かると思います。</p><img src="/images/20220519a/供給の違い.png" alt="供給の違い" width="1200" height="743" loading="lazy"><p>※画像は <a href="https://www.gas.or.jp/chigai/">https://www.gas.or.jp/chigai/</a> より</p><p>上図のLPガスで補足すると、充填所（じゅうてんじょ）は、ガスボンベにLPガスを詰めることを指します。配送者はトラックで各需要家（エネルギー業界では供給先のお客様を指す）に充填されたボンベと、使用済みで空っぽになったボンベを交換します。後で説明しますが、家庭用でよく見るLPガスが50kg入るボンベだとフル充填で86kgほどになるのでかなり重く運搬が大変です。充填所のスタッフの方や、配送員さんには感謝しかないですね。</p><p>また、よく混乱しやすい点としては、都市ガスはLNG（メタンを主成分に持つ液化天然ガス）で、ガスの種類自体が異なります。理由はLPガスの方が凝固点が高い<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>（マイナス42度。都市ガスはマイナス162度）である点や、LPガスの方が同じ体積で倍以上の熱を出すことができるなど、運搬用途として適しているから使い分けているのだと思います。この燃焼効率が良いという特性から、街の中華料理屋さんなど火力が必要な一部の飲食店では、都市ガスエリアでありながらLPガスを契約する場合もあるそうです<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p><p>その他の利用用途としては、工業向けや、LPG車（タクシーなどに多いですよね）があります。現在、私の自宅は都市ガスですが、鍋を食べる時は<a href="https://www.amazon.co.jp/dp/B008R7OOJ6/">イワタニ カセットフー 達人スリム</a>さんにいつもお世話になりますが、これもLPガスが詰まっています（主成分はブタンになるそうですが）。</p><h2 id="LPガス市場について"><a href="#LPガス市場について" class="headerlink" title="LPガス市場について"></a>LPガス市場について</h2><p>そんなLPガス業界の需要動向ですが、1996年度1970万トンがピークで、2021年以降は1400万トン程度と減少傾向にあります<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。</p><p>「ガス事業の現状<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>」を見ると需要家数は2013年度ベースで、都市ガス2,900万件、簡易ガス（後述します）140万件、LP ガスが約2,400万件なので、だいたい46%ほどがLPガスを利用しています。特筆すべきはその事業者数で、都市ガスは209社ですが、LPガス販売事業は21,052社です。都市ガスはどうしても導管等に必要な設備投資が大きく規模の経済性が働くのですが、LPガスはボンベ配送が地域密着になるため事業者数が多くなるのでしょう。</p><h2 id="LPガス事業について"><a href="#LPガス事業について" class="headerlink" title="LPガス事業について"></a>LPガス事業について</h2><p>ガス事業ですが、大きく3つに分割できます。</p><ol><li><strong>一般ガス事業</strong><ol><li>いわゆる導管でガスを供給する、都市ガスです</li></ol></li><li><strong>簡易ガス事業</strong><ol><li>70戸以上の団地に対して、LPガスを導管で一括で供給する方式</li><li>業界ではコミュニティガス事業とも呼ばれているようです</li></ol></li><li><strong>LPガス販売事業</strong><ol><li>充填したボンベを需要家に対して輸送・供給する方式</li><li>導管を使っていても、70戸未満の場合はこちらになる</li></ol></li></ol><p>簡易ガス事業がLPガス販売事業と分けられているのは、根拠となる法令が異なるからです。一般ガス事業と簡易ガス事業はガス事業法、LPガス販売事業は液石法（液化石油ガスの保安の確保及び取引の適正化に関する法律）の法令が管理されています。本記事では法律の詳細には触れませんが、根拠となる法令が異なるということは知っておくと良いでしょう。</p><h2 id="LPガスの需要家への料金請求"><a href="#LPガスの需要家への料金請求" class="headerlink" title="LPガスの需要家への料金請求"></a>LPガスの需要家への料金請求</h2><p>一般家庭の請求ですが、大体月に1回の検針（ガスメーターの数値を読み取ること）で、ガスの使用量をもとに料金が決定します。物理的に現地に訪問して検針する方法もあれば、何かしらのスマートデバイス経由で読み取るケースもあります。例えば、5/1に101㎥(立方メートルですが、<strong>りゅうべい</strong> と呼ぶことが多い)、6/1に106㎥だった場合、5月分は5㎥分の従量料金を請求するという形です（正確には基本料金も上乗せになるでしょう）。</p><p>この5㎥はどれくらいの使用量でお値段がいくつなんだという話ですが、200リットルの浴槽だと、約0.3㎥のLPガスを使用すれば15℃の水から40℃のお湯にすることができるそうです<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。 16回ほどお風呂にはいれるくらいでしょうか。料金は都道府県ごとに相場が異なりそうですが、<a href="https://selectra.jp/lpgas/guides/ryokin/tekisei">Selectra</a>さんで見てみると、東京都で3,190円ほどでした。2022年5月の国際情勢を見ると、今後はさらに値上がっていくでしょう…。価格決定のメカニズムについて興味がある方は、CP(contract price)について調べると良いと思います。</p><h2 id="産気率"><a href="#産気率" class="headerlink" title="産気率"></a>産気率</h2><p>さきほどガスの使用量が5㎥と例を上げましたが、これは50kgボンベのどれくらい消費したでしょうか。㎥→kgの変換は産気率を用います。産気率ですが、気温によっても変わりますが、日本LPガス協会が出した数値だと、0.458㎥/kg だそうです。</p><ul><li><a href="https://www.j-lpgas.gr.jp/news/files/CO2_guidline.pdf">プロパン、ブタン、ＬＰガスのＣＯ２排出原単位に係るガイドライン - PDF</a></li></ul><p>これをもとにすると、 5[㎥]/ 0.458[㎥/kg] ≒ 10.9[kg] です。50kgボンベですと×5回弱分の消費量ですので、仮に30日5㎥だと、150日ほどで1本消費。1本ごと交換するのであれば、年に2回ほどボンベ交換を行うイメージでしょうか。</p><h2 id="LPガス設備について"><a href="#LPガス設備について" class="headerlink" title="LPガス設備について"></a>LPガス設備について</h2><p>大きく、<strong>供給設備</strong>、<strong>消費設備</strong>の2種類に分かれることが特徴です。</p><img src="/images/20220519a/1-2.gif" alt="供給設備・消費設備" width="472" height="304" loading="lazy"><p>※画像は<a href="https://www.kumalpg.or.jp/anshin.html">熊本県LPガス協会</a>さんのページより</p><p>供給設備ですが、図にあるようにLPボンベからガスメータの出口までが供給設備です。消費設備は、コンロや給湯器などの設備を指します。供給設備はLPガス会社側の持ち物であるため、当然ですがガスメーターを消費者側で自由に取り替えたりできません（そもそも、国家資格が必要です）。</p><p>さて、供給設備の重要な要素の1つであるガスメーターですが、中にはマイコンが入っていて非常に賢い作りになっています。24時間ガスの使用状態を見守っており、ガス漏れ、ガス機器の消し忘れの疑い、や震度5以上の地震発生などの非常時には、ガスを自動的にストップします。電気のブレーカーのようで安全な仕組みです。安全性については<a href="https://www.amazon.co.jp//dp/4778204638">都市ガスはどのようにして安全になったのか?</a> という書籍に詳しく述べられています。東京ガスさんの<a href="https://www.tokyo-gas.co.jp/letter/2020/07/20200715sp.html">◆今日は「何の日」？ ◆ 知られざる「ガスメーター」の歴史</a>にもダイジェストで書かれているので、興味がある方は読むと学びになります。</p><p>ガスボンベですが、大体の一般家庭では2本設置されます（場所が取れず、1本の場合もありえますし、使用量次第では3本以上設置されることもあります）。理由ですが、急な使用量の急増でガスが切れる恐れを極力なくすことや、配送の効率化（持ち帰り時に空っぽになっていることが作業負荷としても良い）がよく説明されます。</p><h2 id="集中プロパン方式（集団供給方式）"><a href="#集中プロパン方式（集団供給方式）" class="headerlink" title="集中プロパン方式（集団供給方式）"></a>集中プロパン方式（集団供給方式）</h2><img src="/images/20220519a/lpg-stand-alone-house2.png" alt="集中プロパン方式" width="402" height="223" loading="lazy"><p>※画像は <a href="https://fatmag.jp/lpg-stand-alone-house/">https://fatmag.jp/lpg-stand-alone-house/</a> より</p><p>供給方法ですが、供給設備:需要家=1:1（個別供給システムとも呼びます）ではなく、1:Nになることがあります。これを集中プロパン方式と言います。この場合は、需要家ごとに料金を請求したいのでガスメーターも複数存在することになります。集中プロパン方式が70戸以上ですと、簡易ガス事業になります。</p><p>簡易ガスとみなすときの注意ですが、供給設備が1つに紐づく需要家が70戸以上とは限らず、同じ団地など区画であることが重要だそうです。また、LPガス会社の事業統合などで、自社あるエリアが70を超えると、簡易ガス扱いになるとのこと。<a href="http://www.kan-eki.jp/pdf/kensyukai/20130520-4.pdf">関東液化石油ガス協議会 保安管理者研修会 研修資料 簡易ガス事業について - 関東経済産業局 ガス事業課</a> のp33に詳しいです。</p><p>LPガス容器庫ですが、次のようなイメージです。集中プロパンですと、大体のケースで供給設備に接続されたボンベも2本より大きくなるでしょう。</p><img src="/images/20220519a/info_work03.jpg" alt="LPガス容器庫" width="300" height="200" loading="lazy"><p>※画像は <a href="http://godo-gas.co.jp/godo-gas/">http://godo-gas.co.jp/godo-gas/</a> より</p><p>集中プロパン方式では、ボンベの代わりにバルク貯槽を用いる方式があります。バルクローリで直接LPガスを充填できるので、配送の合理化、保安の高度化、美観の向上など多くの利点があります。</p><img src="/images/20220519a/image.png" alt="バルク貯槽" width="1087" height="577" loading="lazy"><p>※画像は <a href="http://www.nichidankyo.gr.jp/toku/chapter07/pdf/ch07_07.pdf">http://www.nichidankyo.gr.jp/toku/chapter07/pdf/ch07_07.pdf</a> より</p><p>バルクの場合は、いちいちボンベに詰め替える必要も無いため、かなり配送の合理化ができそうなことが直感的に分かります。</p><p>集団供給方式と並べて、戸建てに対する個別の供給は、戸別供給方式とも呼びます。</p><h2 id="ボンベについて"><a href="#ボンベについて" class="headerlink" title="ボンベについて"></a>ボンベについて</h2><p>ガスボンベですが、複数の大きさが存在します。サイズはどれくらいのLPガスを充填できるかで分けられており50kg、20kgがよく用いられています。おそらくLPガス事業者にとってはなるべく大きなサイズのボンベを設置したほうが有利でしょうが、持ち運びや設置場所などの問題で20kgなど小さな容量のボンベが用いられます。各容量別のサイズについては<a href="https://fatmag.jp/lpg-cylinder_size/">プロパンガス ボンベのサイズ（寸法）について ２Kg ～ ５０Kg | ファトマグ</a> にまとめがありました。</p><p>その他、ベーパーライザーと呼ばれる強制気化装置の存在があります。多量のガスを使用する場では、ボンベからの自然気化によるガス量だけでは供給が追いつかないため、LPG液をベーパーライザーに渡して、温水や電熱で液体を気化させます。これに対応したボンベが、ベーパーライザー用のボンベです。ベーパー瓶と呼ぶこともあります。</p><img src="/images/20220519a/50kg_pr.jpg" alt="ベーパー対応ボンベ" width="100" height="250" loading="lazy"><p>違いですが、緑（真ん中）と赤（左）のバルブが2種類ついていることが特徴です。緑のバルブからは気化したガスが、赤いバルブからは液体のままでてきます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>ざっと新規参画者に概況をインプットするときにお伝えする内容をまとめました。エネルギー業界は昨今の世界情勢もあり非常に注目されていて面白い領域です。業界の将来像（注目されている技術）や最新動向（自由化など）といった内容や、各領域についても、もっとディープダイブした内容を紹介していこうと思います。</p><p>2022.05.30 パート2も公開しました。</p><ul><li><a href="/articles/20220530a/">【エネルギー業界】LPガス基礎知識編part2 供給設備 </a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">東日本大震災でも活躍したというニュースがありました。分散型で軒下在庫があり、劣化しないといった特性があります。 <a href="https://www.enecho.meti.go.jp/about/special/johoteikyo/lpgas.html#:~:text=%E6%9D%B1%E6%97%A5%E6%9C%AC%E5%A4%A7%E9%9C%87%E7%81%BD%E3%81%A7%E3%82%82%E5%AE%9F%E8%A8%BC%E3%81%95%E3%82%8C,%E3%81%97%E3%81%A6%E7%A8%BC%E5%83%8D%E3%81%97%E3%81%BE%E3%81%99%E3%80%82">https://www.enecho.meti.go.jp/about/special/johoteikyo/lpgas.html#:~:text=東日本大震災でも実証され,して稼働します。</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://www.gas.or.jp/chigai/">https://www.gas.or.jp/chigai/</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">もちろん、中華料理屋さん以外の飲食店や、工場などでも必要なケースはあると思います。 <a href="https://gentosha-go.com/articles/-/30464">https://gentosha-go.com/articles/-/30464</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="vertical-align: top; padding-right: 10px;">4.</span><span style="vertical-align: top;">ＬＰガス業界の現況について: <a href="https://www.meti.go.jp/shingikai/mono_info_service/carbon_neutral_car/pdf/002_06_00.pdf">https://www.meti.go.jp/shingikai/mono_info_service/carbon_neutral_car/pdf/002_06_00.pdf</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="vertical-align: top; padding-right: 10px;">5.</span><span style="vertical-align: top;"><a href="https://www.meti.go.jp/shingikai/enecho/kihon_seisaku/gas_system/pdf/01_05_00.pdf">https://www.meti.go.jp/shingikai/enecho/kihon_seisaku/gas_system/pdf/01_05_00.pdf</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="vertical-align: top; padding-right: 10px;">6.</span><span style="vertical-align: top;"><a href="https://gline-fukui.com/faq/gasEquipment/waterHeater/entry-54.html">https://gline-fukui.com/faq/gasEquipment/waterHeater/entry-54.html</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220519a/LPボンベ.jpeg&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;589&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;※画像は&lt;a</summary>
        
      
    
    
    
    <category term="Business" scheme="https://future-architect.github.io/categories/Business/"/>
    
    
    <category term="業界ドメイン" scheme="https://future-architect.github.io/tags/%E6%A5%AD%E7%95%8C%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3/"/>
    
    <category term="LPガス業界" scheme="https://future-architect.github.io/tags/LP%E3%82%AC%E3%82%B9%E6%A5%AD%E7%95%8C/"/>
    
    <category term="エネルギー業界" scheme="https://future-architect.github.io/tags/%E3%82%A8%E3%83%8D%E3%83%AB%E3%82%AE%E3%83%BC%E6%A5%AD%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>OpenSLOについて</title>
    <link href="https://future-architect.github.io/articles/20220518a/"/>
    <id>https://future-architect.github.io/articles/20220518a/</id>
    <published>2022-05-17T15:00:00.000Z</published>
    <updated>2022-05-18T01:41:51.107Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220518a/openslo.png" alt="" width="800" height="150"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして、原木と申します。</p><p>皆さまは<a href="https://sre-next.dev/2022/">SRE NEXT</a>をご覧になりましたでしょうか？</p><p>SRE NEXTは　先日実施された『信頼性に関するプラクティスに深い関心を持つエンジニアのためのカンファレンス』です。国内外のエンジニアが日々SRE(サイト信頼性エンジニアリング/Site Reliability Engineering)の実践手法を共有することで、Webサービスが今後運用、成長していくための次世代の信頼性を担おうとしています。</p><p>もしもWebサービスの運用を安定的に行う手法やそのためのチームビルディングに興味がある場合、SRE NEXTの動画セッションやスライドが公開されると思うのでご覧ください<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>さて本ブログではそんなSREとも関係の深い、OpenSLOに関して取り上げたいと思います。</p><h1 id="OpenSLOとは"><a href="#OpenSLOとは" class="headerlink" title="OpenSLOとは"></a>OpenSLOとは</h1><p>最近、SLOモニタリングという言葉が注目を集めつつあります。例えば、GoogleCloudのCloud Monitoringではサービスモニタリングというサービス名を<a href="https://cloud.google.com/monitoring/slo-monitoring?hl=ja">SLOモニタリング</a>と改め、SLOを使った運用監視を強く推しています。</p><p>従来の運用監視とSLOでは何が違うのでしょうか？その手掛かりの一つにOpenSLOがあります。</p><p>OpenSLOとは、SLOを定義するためのオープンな仕様です。SLOのSaaSサービスを展開しているNobl9が中心となって策定し、先日バージョン1.0を迎えました。</p><p><a href="https://github.com/OpenSLO/OpenSLO/releases/tag/v1.0.0">https://github.com/OpenSLO/OpenSLO/releases/tag/v1.0.0</a></p><p>実際にOpenSLOの例を見てみましょう。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">openslo/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SLO</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">slo-example</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&quot;ウェブサイトの可用性に関するSLO&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">website-backend-service</span></span><br><span class="line">  <span class="comment"># エラーバジェットの消費方法</span></span><br><span class="line">  <span class="attr">budgetingMethod:</span> <span class="string">Occurrences</span></span><br><span class="line">  <span class="comment"># タイムウィンドウ</span></span><br><span class="line">  <span class="attr">timeWindow:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">duration:</span> <span class="string">4w</span></span><br><span class="line">      <span class="attr">isRolling:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># SLI</span></span><br><span class="line">  <span class="attr">indicator:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">error-count</span></span><br><span class="line">      <span class="attr">displayName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">ratioMetric:</span></span><br><span class="line">        <span class="attr">counter:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">good:</span></span><br><span class="line">          <span class="attr">metricSource:</span></span><br><span class="line">            <span class="attr">metricSourceRef:</span> <span class="string">prometheus-datasource</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Prometheus</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">query:</span> <span class="string">sum</span> <span class="string">by(handler)(rate(http_requests_total&#123;code=&quot;200&quot;&#125;[1m]))</span></span><br><span class="line">        <span class="attr">total:</span></span><br><span class="line">          <span class="attr">metricSource:</span></span><br><span class="line">            <span class="attr">metricSourceRef:</span> <span class="string">prometheus-datasource</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Prometheus</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">query:</span> <span class="string">sum</span> <span class="string">by(handler)(rate(http_requests_total[1m]))</span></span><br><span class="line">  <span class="comment"># SLO</span></span><br><span class="line">  <span class="attr">objectives:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">displayName:</span> <span class="string">Total</span> <span class="string">Errors</span></span><br><span class="line">      <span class="attr">target:</span> <span class="number">0.98</span></span><br></pre></td></tr></table></figure><p>OpenSLOを読み解くには、SREの知識が頭の片隅にあるとわかりやすいでしょう。そこでSREの概念をそれぞれ説明しながら、従来の運用監視とSLOの目指す姿の違いについてOpenSLOを通して理解を深めたいと思います。</p><h1 id="SLOとは？"><a href="#SLOとは？" class="headerlink" title="SLOとは？"></a>SLOとは？</h1><p>サービスレベル目標(SLO)とは、<strong>サービスの信頼性の目標レベル</strong>を指定します。</p><p>サービスの信頼性ってわかるようでわからないですね。</p><p>“実際、信頼性(reliability )は可用性(availability )だけではなく、品質(quality)、信頼性(dependability)、応答性(responsiveness)など幅広い含意を持つ言葉です。”</p><p>メーカーの工具から自分の友人に至るまでどれくらい信頼できるのかって聞かれても、なかなか即答って難しいかなと存じます。</p><p>それでも、あえて挙げるとするなら自分は<a href="https://www.alex-hidalgo.com/the-slo-book">Implementing Service Level Objectives</a>という書籍の定義が気に入っています。</p><blockquote><p>The question “Is my service reliable?” is pretty much analogous to the question “Is my service doing what its users need it to do?”<br>「私のサービスは信頼できるか?」という問いは、「私のサービスはユーザーが必要とすることを行っているか?」という問いによく似ています。<br><a href="https://learning.oreilly.com/library/view/implementing-service-level/9781492076803/ch01.html#service_truths">https://learning.oreilly.com/library/view/implementing-service-level/9781492076803/ch01.html#service_truths</a></p></blockquote><p>「私のサービスはユーザーが必要とすることを行っているか?」</p><p>この問いに答えるための材料として重要視されるのが、システムの可用性があります。</p><p>Googleでは、システムの可用性をSLOとして正確な数値目標に落とすことしました。</p><blockquote><p>SRE は、可用性が成功の前提条件であるという考えが発端になっています。<br>可用性のないシステムはその機能を実行できず、デフォルトで失敗します。<br>SRE 用語における可用性の定義は、システムがある時点で目的の機能を実行できるかどうかです。<br>可用性測定の履歴は、レポートツールとしてだけでなく、システムが将来的に予想どおりのパフォーマンスを発揮する確率を示す指標としても使用できます。</p><p>GoogleはSREの用語を定義するにあたり、システムの可用性を正確な数値目標として設定したいと考えました。<br>この目標をシステムの可用性サービスレベル目標（SLO）と呼びます。<br><a href="https://cloud.google.com/blog/ja/products/devops-sre/sre-fundamentals-sli-vs-slo-vs-sla">https://cloud.google.com/blog/ja/products/devops-sre/sre-fundamentals-sli-vs-slo-vs-sla</a></p></blockquote><p>この数値目標がSLOの実態です。このSLOをOpenSLOでどのように定義しているのかは後述で解説するとして、試しにSLOを設定するために、極端なケース…例えばSLOを100%とします!!といった場合に何が起きるか考えてみましょう。</p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span><h2>数値目標</h2>  <p>なぜSLOではシステムの信頼性、可用性を測定するために正確な数値化が必要なのでしょうか。<p>SRE発祥の地でもあるGoogleの社内文化を色々な書籍を通じてみていると<br>この数値化に対してのモチベーションの根本に、多様性を肯定する社風が見えてきます。</p><p>メンバが多種多様な価値観や考え方を持つ中で、意思疎通を誤りなく行うには<br>客観的な指標と、なぜその数字を採用したのかという導出を誰でもわかる形で残すことは欠かせません。</p><p>そのような文化のなか、運用にも変化が生じました。</p><p>「私のサービスはユーザーが必要とすることを行っているか?」</p><p>この問いの中で、旧来の運用監視では損失だと思われていた指標を、機会投資の指標だと見なせないかと考えるようになりました。<br>ポジティブなフィードバックこそが明日のWebサービスを担う推進力であり、コンセンサスの源泉となるからです。</p></p></div><h1 id="100-のSLO-絶対に壊れないシステム？"><a href="#100-のSLO-絶対に壊れないシステム？" class="headerlink" title="100%のSLO=絶対に壊れないシステム？"></a>100%のSLO=絶対に壊れないシステム？</h1><p>100%のSLOとは、先の定義によればユーザーが必要とするときにサービスが目的の機能を提供できる状態が完全無欠に保たれていることです。<br>ならばすべての目標値を100%にすれば、サービス運用は安泰ではないか、そういった軽重な考えに、<br><a href="https://cloud.google.com/blog/ja/products/devops-sre/sre-fundamentals-sli-vs-slo-vs-sla">SRE の基本（2021 年版）: SLI、SLA、SLO の比較</a>では警告を鳴らしています。</p><blockquote><p>サービスの信頼性が高いほど、運用コストが高くなることに注意してください。</p><p>各サービスのユーザーが許容できる最低レベルの信頼性を定義し、それを SLO として規定します。すべてのサービスには可用性 SLO が必要です。これがなければ、チームや関係者はサービスの信頼性を高める（コストを増やして開発を遅らせる）必要があるのか、あるいは信頼性を下げる（開発速度を上げる）必要があるのかを、原則に基づいて判断できません。過剰な可用性が期待されるようになり、それが問題になることがあります。</p><p>ユーザー エクスペリエンスにとって必要でなければ、システムの信頼性を過度に高くしないでください。常にそのレベルに到達することを確約するつもりがない場合はなおさらです。</p></blockquote><p>SREのポジションにあるエンジニアは、次の1,2の間を調整することに大抵は苦労します。</p><ol><li>サービスを継続的に新規開発する速度</li><li>その結果低下していくサービスの信頼性</li></ol><p>どんな注意を払っても開発がある限り、サービスの信頼性に影響を及ぼすことは避けられません。</p><p>しかし、システムを塩漬けにして永遠に変わらない変化をもたらしたとしても「ユーザーが必要としていること」が満たされたままとは限りません。</p><p>どちらが正解なのか…</p><p>もしもそこにユーザーエクスペリエンスに繋がる指標が、蓄積された状態であったとしたらどうでしょう。ウェブサービスのSLOがほんの少し下がってもユーザーの顧客マインドに影響が及ぼさず、満足度を保ったままでいられることがわかりました。あえて余裕のある数値をSLOとして設けることで、それを満たしている間は、サービスを継続的に開発してもいいのではないか？という考えが生まれました。</p><p>エラーバジェットの誕生です。</p><p>可用性の担保について、ある程度のリスクを”予算”と見なすことで予算を超過しそうなら開発速度を抑えて、予算内であれば開発を促進するといったように、サービスを開発する速度をコントロールできるようにしたわけです。</p><p>OpenSLOにも <code>budgetingMethod: Occurrences</code> という項目があります。これは出現率法は、イベント全体に対してgoodイベントのカウントの比率をエラーバジェットの計算方法として使用するという意味です。</p><p>全体のイベントのうち、”良い”イベントの割合を指標として採用する考えはSLOとしてよく採用されています。</p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span><h2>SREをダイエットで例えたら...</h2>  <p>ダイエットにおいて食事制限は最も基本的なやり方です。食事を制限するために我慢を強いられる方も多いと思います。<p>例えば、ダイエットをするときの努力目標として1日1600kcalしか取らないと決めたとします。<br>一日で1600kcalしか取れないんだと思うよりも、1600kcalも食事をしていいんだって思った方がポジティブになれないでしょうか。</p><p>同じことがエラーバジェットにも言えます。</p></p></div><h1 id="SLOとSLI"><a href="#SLOとSLI" class="headerlink" title="SLOとSLI"></a>SLOとSLI</h1><p>エラーバジェットを作るためには数値目標とそれを図るための測定手段が必要です。<br><a href="https://www.oreilly.co.jp/books/9784873119137/">サイトリライアビリティワークブック</a>というSREの参考書では具体的な方法が記載されています。</p><p>例えば、Webサイトにおいて、ユーザーからの評価を良好に保つために読み込み時間を測定、SLOとして定めたとします。<br>これは「サイトリライアビリティワークブック」によれば、<code>SLI specification</code> (SLIの仕様)と <code>SLI implementation</code> (SLIの実装)として分解することができます。</p><ul><li><code>SLI specification</code> (SLIの仕様)<ul><li>100ms以内でホームページが読み込まれた割合。</li><li>ユーザーにとって重要だと思われるサービス評価の結果</li></ul></li><li><code>SLI implementation</code> (SLIの実装)<ul><li>SLIの仕様を計測するための手段。例えば…<ol><li>サーバーログから計測したサーバー内の処理時間</li><li>VM環境のブラウザで動くJavaScript製のプロバーによる測定時間</li><li>ユーザーのホームページのリクエストのうち、読み込み時間が100ミリ秒未満のものの割合。</li></ol></li></ul></li></ul><p>通常、SLIを測定するための手段である <code>SLI implementation</code> (SLIの実装)は複数あり、それぞれのトレードオフを踏まえた上で、今どの指標がユーザーの信頼を測定するために必要な指標か考える必要があります。</p><h1 id="OpenSLOにおけるSLI仕様-SLI実装"><a href="#OpenSLOにおけるSLI仕様-SLI実装" class="headerlink" title="OpenSLOにおけるSLI仕様/SLI実装"></a>OpenSLOにおけるSLI仕様/SLI実装</h1><p>OpenSLOでは、SLI仕様/SLI実装に該当するのがobjectives(目標)とindicator(指標)という項目です。objectives(目標)では数値目標を記載し、indicator(指標)ではSLIの実装にあたるメトリクスの取得方法を記載しています。</p><p>OpenSLOの例を振り返ってみましょう。objectivesと indicatorの項目があることがわかります。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">openslo/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SLO</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">slo-example</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&quot;ウェブサイトの可用性に関するSLO&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">//略</span></span><br><span class="line">  <span class="attr">indicator:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">error-count</span></span><br><span class="line">      <span class="attr">displayName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">ratioMetric:</span></span><br><span class="line">        <span class="attr">counter:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">good:</span></span><br><span class="line">          <span class="attr">metricSource:</span></span><br><span class="line">            <span class="attr">metricSourceRef:</span> <span class="string">prometheus-datasource</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Prometheus</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">query:</span> <span class="string">sum</span> <span class="string">by(handler)(rate(http_requests_total&#123;code=&quot;200&quot;&#125;[1m]))</span></span><br><span class="line">        <span class="attr">total:</span></span><br><span class="line">          <span class="attr">metricSource:</span></span><br><span class="line">            <span class="attr">metricSourceRef:</span> <span class="string">prometheus-datasource</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Prometheus</span></span><br><span class="line">            <span class="attr">spec:</span></span><br><span class="line">              <span class="attr">query:</span> <span class="string">sum</span> <span class="string">by(handler)(rate(http_requests_total[1m]))</span></span><br><span class="line">  <span class="attr">objectives:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">displayName:</span> <span class="string">Total</span> <span class="string">Errors</span></span><br><span class="line">      <span class="attr">target:</span> <span class="number">0.98</span></span><br></pre></td></tr></table></figure><p>GoogleSRE Workbookなどによると、objectives(目標)について二つの数値の比率から導出できることがお勧めされています。</p><p>例えば、</p><blockquote><ul><li>成功したHTTPリクエストの数/合計HTTPリクエスト（成功率）</li><li>100ミリ秒未満で正常に完了したgRPC呼び出しの数/合計gRPCリクエスト</li></ul></blockquote><p>SLIは <code>spec.indicator.spec</code>という項目から読み取ることができます。Pometheusから連携したメトリクスのうち、1分以内に受信したリクエストとそのうちステータスコードが200だったステータスをそれぞれSLIとしてカウントし、ratioMetricとしてその割合を計算していることがわかります。</p><p>そしてSLOにあたるのが<code>spec.objectives</code> になります。<br>エラーとなったステータスリクエストが全体の割合で2%を下回ることを求められています。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">openslo/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SLO</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">slo-example</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&quot;ウェブサイトの可用性に関するSLO&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">//略</span></span><br><span class="line">  <span class="attr">objectives:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">displayName:</span> <span class="string">Total</span> <span class="string">Errors</span></span><br><span class="line">      <span class="attr">target:</span> <span class="number">0.98</span></span><br></pre></td></tr></table></figure><p>SLO/SLIをどのような周期で観測するか(そしてその期間を過ぎたらリセットするか)というタイムウィンドウに関する設定もあります。<br>下記の例では4週間を一定期間としてその特定の日数分だけSLOを評価していることがわかります。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">openslo/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">SLO</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">slo-example</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&quot;ウェブサイトの可用性に関するSLO&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">budgetingMethod:</span> <span class="string">Occurrences</span></span><br><span class="line">　<span class="attr">timeWindow:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">duration:</span> <span class="string">4w</span></span><br><span class="line">      <span class="attr">isRolling:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="OpenSLOの現状"><a href="#OpenSLOの現状" class="headerlink" title="OpenSLOの現状"></a>OpenSLOの現状</h1><p>OpenSLO自体は単なる仕様であり、ドキュメントなので</p><ul><li>運用監視からの情報取得方法</li><li>そのSLO情報に変化があった場合に画面可視化を行うサービスへの連携</li></ul><p>…など、いまだ周辺のエコシステムは拡張に向けた途上にあります。</p><p>現状あるツールを紹介します。</p><ul><li><a href="https://github.com/OpenSLO/oslo">OpenSLO/oslo</a><ul><li>SLOで書かれたYamlファイルのバリエーションチェックなどを行うCLIツール</li></ul></li><li><a href="https://github.com/OpenSLO/slogen">OpenSLO/slogen</a><ul><li>SUMO LogicというSaaSに提供するためのダッシュボード、運用監視対象の自動生成ツール</li></ul></li><li><a href="https://github.com/slok/sloth">sloth/sloth</a><ul><li>PrometheusのSLO設定を容易にするためのジェネレーターツール。チャットツールである<a href="https://mattermost.com/blog/sloth-for-slo-monitoring-and-alerting-with-prometheus/">Mattermost</a>などで活用されている。OpenSLOを限定的にサポートしている。</li></ul></li></ul><p>OpenSLOは、最終的にSLO-as-codeとしてサービスレベルが達成されているかどうかを確認するメトリックを簡単に収集できるようにすることを目的とし、開発が現在も積極的に行われています。</p><p>ITサービスのメトリクス自体はITシステムができた当初から、安定的な運用目的のために取得されてきた情報ですが、SREというフレームワークの大転換により、メトリクス情報がサービスが停止するという機会損失の指標から、新機能開発による機会創出の指標としてつなげられるようになったのはここ最近の変化です。その中心にSLOがあります。</p><p>OpenSLOのエコシステム拡充が進めば、これから先、運用監視ツールとして欠かせないものになっていくのではないでしょうか。</p><h1 id="私的感想"><a href="#私的感想" class="headerlink" title="私的感想"></a>私的感想</h1><p>まだ道半ばですが、generatorについてエコシステムが整うことで運用監視体制がそのままGitOpsとして管理できるような体制になると面白そうですね。その片鱗はすでに各所で起きています。</p><p>例えば、Preferred Networks Researchでは、Alertmanagerでシステムの異常検知を行った後、それをGitHubのissueとして自動的に起票できるようにするOSSを開発しています。<br><a href="https://github.com/pfnet-research/alertmanager-to-github">https://github.com/pfnet-research/alertmanager-to-github</a></p><p>例えば、GrafanaのThemaではCUELANGをベースに、ダッシュボードのコード化を進めようとしています。(既存でもJsonnetという仕組みがあるのですが扱いづらいということから生まれました)<br><a href="https://github.com/grafana/thema">https://github.com/grafana/thema</a></p><p>同様にOpenSLOの仕様書もGit上で管理されて、OpenAPIやIaCでは既に実践されていることではありますが、運用監視システムにCI/CDで動かしたgeneratorを通して組み込まれることで、SLOの棚卸しを気軽に行えるような体制が組めるといいなと思いました。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">SRE NEXT様と筆者(そして多分弊社も...)の間には2022年現在何の関係もありませんが、好きなイベントなのでこの場をお借りして宣伝させていただきました。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220518a/openslo.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;150&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="DevOps" scheme="https://future-architect.github.io/categories/DevOps/"/>
    
    
    <category term="SRE" scheme="https://future-architect.github.io/tags/SRE/"/>
    
    <category term="SLO" scheme="https://future-architect.github.io/tags/SLO/"/>
    
    <category term="OpenSLO" scheme="https://future-architect.github.io/tags/OpenSLO/"/>
    
  </entry>
  
  <entry>
    <title>connpass×Zoomで開く勉強会運営ナレッジ</title>
    <link href="https://future-architect.github.io/articles/20220517a/"/>
    <id>https://future-architect.github.io/articles/20220517a/</id>
    <published>2022-05-16T15:00:00.000Z</published>
    <updated>2022-05-17T01:51:09.476Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220517a/image.png" alt="" width="1200" height="686" loading="lazy"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DXユニット真野です。いつの間にかFuture Tech NightというIT勉強会をメインで運営をすることになりました。イベント企画＆実行も楽しいですね。何度か回を重ねることでナレッジが溜まってきたので共有します。</p><p>利用するツールは以下です。</p><ul><li><a href="https://future.connpass.com/">connpass</a><ul><li>メンバー登録お願いします！</li></ul></li><li>Zoom</li><li>Google Workspace(Google Form, Google Chat)</li><li>SpeakerDeck, Google Slide</li></ul><h2 id="ナレッジについて"><a href="#ナレッジについて" class="headerlink" title="ナレッジについて"></a>ナレッジについて</h2><h3 id="スケジューリングについて"><a href="#スケジューリングについて" class="headerlink" title="スケジューリングについて"></a>スケジューリングについて</h3><p>月1程度の頻度で開催を目指す場合を前提にします。本業（フューチャーだとITコンサルティング事業）と兼務で勉強会の企画をする場合、どのテーマからやろうかと毎月考えるとパワー不足になりがちです。そのため年1で大まかな計画を立てることがおすすめです。それ自体をブログ記事にしておくと検索性も高まるのでおすすめです。</p><p><a href="/articles/20210314/">2021年</a>、<a href="/articles/20220118a/">2022年</a>も運用を回す前に有志で集まって、このテーマでこの月は勉強会しようと決めて運営しました。このとき登壇者はby-nameでは決めておらず、だいたいこの人が出てくれると良いな、というレベルです。</p><h3 id="勉強会テーマについて"><a href="#勉強会テーマについて" class="headerlink" title="勉強会テーマについて"></a>勉強会テーマについて</h3><p>できる限りテーマは小さく絞った方が良いです。例えば、「AWS勉強会」よりは「AWSデータレイク勉強会」の方が明らかに聞き手から見て何を話すかイメージがつきやすいため、集客にプラスです。フューチャーだと、「Terraform勉強会」ではなく「Terraform State縛りの勉強会」にすることで、参加者の聞きたいことと実際に話す内容のギャップを減らすことができたと思います。すでにコモディティ化しているような（？）テーマの場合は、なるべく絞った方が選択されやすいでしょう。ユニークで、尖った勉強会になるように引き続き工夫していこうと思っています。</p><p>逆に、IoT勉強会といった広いカットだと、その分野でブランドが確立していない場合は、具体的な技術要素がどういったものが出てくるか聞き手に見えずマイナスだなと感じます。（ラズパイでの作ってみたなのか、PLCといった産業機器の話なのか、NodeRedみたいなソフト寄りの話なのか本当に絞れないため）</p><h3 id="採用色について"><a href="#採用色について" class="headerlink" title="採用色について"></a>採用色について</h3><p>connpassのサービス自体が「エンジニアをつなぐIT勉強会支援プラットフォーム」ですし、ガチ採用イベントはあまり好まれない傾向があるかなと思います。一方で、○○エンジニア座談会みたいな形式だとあまり違和感がないと思います（私も聞いてみたいケースがある気がします）。</p><p>通常の勉強会であれば、最初 or 最後に採用への誘導を5分ほど行うと良いかなと思います。 Future Tech Nightでは最初の5分で会社紹介。最後の5分でアンケートやこのポジションとかどうでしょうか？とか軽く話しています。最初の5分の会社紹介ですが、勉強会の開始が19時でZoomへの参加が少し遅れる人がいつもいるため、メインコンテンツはちゃんと聞けるような配慮でもあります。</p><h3 id="テーマ選定は型にハメすぎない"><a href="#テーマ選定は型にハメすぎない" class="headerlink" title="テーマ選定は型にハメすぎない"></a>テーマ選定は型にハメすぎない</h3><p><a href="/articles/20220125a/">がんばらない手ぶらオンライン勉強会</a>　というふうに社内勉強会を拡張して社外向けに行っちゃうみたいなの運営も手かと思います。偏りすぎず色々混ぜていくと良いかなと思っています。要はバランスですよね。フューチャーはグループ会社がたくさんあるので、コードキャンプさんと<a href="https://codecampnext.connpass.com/event/241881/">「いいコード」について語り尽くす Night！ #1</a> を共同で開催したり、色々面白うそうだったら気軽にやってみようという姿勢でいます。このあたりは会社の文化次第かもしれませんが、トライ＆エラーできる環境であることを少しでも伝わると良いかなと思います。</p><h3 id="開催日時"><a href="#開催日時" class="headerlink" title="開催日時"></a>開催日時</h3><p>なんとなく、Future Tech Ngithでは木曜日19時開催が良いという経験則を得ました。</p><p>理由は以下です。</p><ul><li>なんとなく集客が良い気がする（感覚値ですいません）</li><li>金曜日開催だと、資料公開のラグがでてしまう<ul><li>完全に運営要件ですが、直前まで資料をブラッシュアップする人が多く、登壇後に最終チェックのためレビューを考えると、翌日が営業日であったほうが良い</li><li>つまり大事なのは、土日/祝日の前日でないこと</li></ul></li><li>19時は家族持ちの方だとディナーで出れない人もいらっしゃいますが、20時開始だと業務時間にすることに抵抗がある</li><li>それより早い18時開始だと、まだ働いている人がいるのか、18時半などといったかなり遅れての途中参加の人が多かった<ul><li>これは客層にもよりそうですが</li></ul></li></ul><h3 id="登壇者数と発表時間"><a href="#登壇者数と発表時間" class="headerlink" title="登壇者数と発表時間"></a>登壇者数と発表時間</h3><p>1時間枠だとすると、登壇者は2名が良いです。3人だと10~15分の登壇時間になるためバタバタしがちです。タイムキープも思ったより難しいのか、だいたい押しちゃいます。</p><p>登壇者は2名の場合は、20分～22分のレンジが目標です。20分より短いとちょっと早く終わりすぎになるため、質問時間で来てくれた人になるべく多く得てもらえるように司会も頑張る必要があります。とは言え、20分は慣れていない人からすると長く感じられるかもしれないですが、いざ登壇してちゃんと話そうとすると時間がちょっと足りないという方も多いのか、ほとんど早く終わったことがないです。</p><h3 id="登壇者が決まったら"><a href="#登壇者が決まったら" class="headerlink" title="登壇者が決まったら"></a>登壇者が決まったら</h3><p>登壇者、運営者、資料レビュアーなど複数のロールが入るため、それ専用のチャットルームを作って使い捨てる運用にしています。</p><h3 id="アンケート"><a href="#アンケート" class="headerlink" title="アンケート"></a>アンケート</h3><p>アンケートは絶対とったほうが良いです。何より登壇者の励みになるためです。わざわさアンケートに答えてくれた人、いつもありがとうって思います。</p><p>Future Tech NightだとGoogleフォームで行っています。この時、アンケート回答結果は登壇者に権限付与して自分で見れるようにすると楽だと気が付きました。わざわざ登壇してくれるくらい良い人であるので、管理者権限、あたえちゃいましょう。結果を後でじっくり見たいときもあると思いますので。</p><h3 id="登壇後の質問タイム"><a href="#登壇後の質問タイム" class="headerlink" title="登壇後の質問タイム"></a>登壇後の質問タイム</h3><p>ZoomにおいてはFAQ、チャットなどで質問があれば投稿してもらうようにしています。Twitterでも指定のハッシュタグ（ <code>#future_tech_night</code> ）でツイートしてくれれば拾うようにしています。</p><p>ただ、セッションの発表中に質問を書くことは通常難しいため（聞き手も集中しているので）、発表後に質問タイムをとってポツポツ出てくるかなという感じでしょう。最初の質問が出てくるまでのラグがもったいないので、このときは司会が「素人質問ですが～」で投げるときもあります。これは司会者特権かもしれません。<br>あと、どうしても質問が出なかったときは別の登壇者に振ったりしても良いかもと思っています。大枠は同じテーマで来てくれているはずなので、質問でなくても感想でも新しい視点が出たりで楽しいです。質問に関してはテーマによって出にくいなと思ったら、知り合いにサクラを頼んでも良いかもしれませんが、Future Tech Nightではあまりがんばれていません。サクラ募集です。</p><h3 id="宣伝について"><a href="#宣伝について" class="headerlink" title="宣伝について"></a>宣伝について</h3><p>特に自社の社員への宣伝は大事です。社員の場合はconnpass登録しなくてもZoom接続情報を渡すようにしています。長期的にはスキル底上げにも繋がりますし、know whoにもなりますし良いこと尽くめでしょう。もちろんconnpass登録したい人を止める理由はないので自由です。開催がオンラインのため会場キャパシティの限界は無いためどんどん呼び込むと良いでしょう。</p><h3 id="Zoomについて"><a href="#Zoomについて" class="headerlink" title="Zoomについて"></a>Zoomについて</h3><p>さきほど会場キャパシティの限界は無いと言いましたが、ちょっと嘘です。こと開催がZoomであればアカウントによって500人枠くらいの上限があります。ただ殆どのイベント規模では十分でしょう。</p><p>Zoomに関しては以下を気をつけています。</p><ul><li>終わった後にアンケート回答設定があるので利用する</li><li>画面共有時に音楽設定がありBGMを流すことが可能だが、あまり使わない<ul><li>普通に自分のPCで音楽を流したい派なので自分は利用しない</li></ul></li><li>今の御時世、事前リハはほぼ不要<ul><li>当日5分前くらいに確認で良いのでは（しなくても良いくらい）</li><li>楽をしたい</li><li>業務がリモートワークほぼ100%（多分）なので、機材トラブルになった試しがない</li></ul></li><li>登壇者の入れ替わりについて<ul><li>音声/動画が見えていますか？って一応確認する登壇者の人も多いので、すぐ返すようにする（場合によってはフルスクリーンになったら、ちゃんとフルスクリーンになっていますよって返す）</li></ul></li></ul><h3 id="イベント募集サービスについて"><a href="#イベント募集サービスについて" class="headerlink" title="イベント募集サービスについて:"></a>イベント募集サービスについて:</h3><p>connpass以外の勉強会募集サービスは使って無いです。 純粋にIT技術の勉強会であれば十分すぎると思っています。ビジネス層を狙う場合は少し違うのでどの層を狙うかは大事でしょう。フューチャーだと <a href="https://www.future.co.jp/futureinsightseminar/">Future Insight Seminar</a> というビジネス観点でのセミナーを開催していますが、そちらはconnpassを利用していません。</p><h3 id="connpassイベント開催の設定"><a href="#connpassイベント開催の設定" class="headerlink" title="connpassイベント開催の設定"></a>connpassイベント開催の設定</h3><p>いくつかナレッジがあります。</p><h4 id="画像について"><a href="#画像について" class="headerlink" title="画像について"></a>画像について</h4><p>まず<a href="https://help.connpass.com/organizers/event-detail.html#:~:text=PC%E7%89%88connpass%E3%81%A7%E3%81%AF%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88,%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%A7%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82">画像サイズ</a>は気にしましょう。画像は横660pixel × 縦270pixelである必要があります。スマホ/PCで崩れないようにテキストの位置決めにはちょっとコツがあります（未だあまり慣れない）。</p><h4 id="Zoom接続先の共有方法"><a href="#Zoom接続先の共有方法" class="headerlink" title="Zoom接続先の共有方法"></a>Zoom接続先の共有方法</h4><p>従来はZoom接続先を参加者メールで送っていましたが、何名の片からメールが届かないと連絡がありました。対応が大変ですし自分がその状態だったらキレる自信があるため、connpass上に参加者のみ表示できる枠があるので、そこに接続URL＋パスワードを入力することが良でしょう。</p><h4 id="重複参加"><a href="#重複参加" class="headerlink" title="重複参加"></a>重複参加</h4><p>connpass上でスケジュールが被っている参加を拒否する設定があります。オンサイト開催ですと物理上ありえないため有効な設定ですが、オンライン開催だと、この発表だけイベントA、それが終わったらイベントBにハシゴするといったユーザー行動も十分ありえますし、Welcomeですらあると思います。そのため重複参加をOKにしています。</p><h4 id="登壇者を管理者に入れる"><a href="#登壇者を管理者に入れる" class="headerlink" title="登壇者を管理者に入れる"></a>登壇者を管理者に入れる</h4><p>connpassのイベントページには、登壇者の他に、「管理者」欄があり、そこにconnpass IDを登録するとイベントページ自体を編集できます。さすがに性善説で登壇者を管理者に入れています。ちょっとしたタイトルの修正などは本人に対応してもらうと楽です。</p><p>当然ですが、ちゃんと登壇者のconnpass IDを入れるようにしましょう。connpass上のアカウントで登壇実績になるのでモチベーションにつながると思います。<br>あと、地味ですがアイコン・自己紹介は未設定の人には登録してもらっています。やっぱりあった方がどういう人が発表するかわかって良いかなと思うからです。</p><h4 id="イベントの公開タイミング"><a href="#イベントの公開タイミング" class="headerlink" title="イベントの公開タイミング"></a>イベントの公開タイミング</h4><p>公開は2週間前を目安にしています。金曜日に公開するとなんとなく拡散が弱い気がするので、月曜日に公開することが多いです。3週間前でも4週間前でも良いかと思います。月次開催だと、本当は前回勉強会時の宣伝時に、次回勉強会の宣伝を流せたほうが良いかと思いますので、4週間以上前に公開するのも手かもしれませんが、イベント間の運営期間が被るため、マネジメントコストは上がるかなと思います。</p><h3 id="会社説明について"><a href="#会社説明について" class="headerlink" title="会社説明について"></a>会社説明について</h3><p>実は、Future Tech Nigthでは会社説明が一番レビューで時間がかかるところです。なぜかというと、クライアント情報や案件など、話してよいか非常に厳密にチェックするため（事業部長レベルにも見てもらいます）。このあたりは個々人で話すと負荷が高いので、運営が統合したほうが無難です。そのため司会の人が話すと良いかなと思います。<br>このあたりの運用は、どういう権限を運営者に移譲するかで変わるとは思います。</p><h3 id="資料の公開"><a href="#資料の公開" class="headerlink" title="資料の公開"></a>資料の公開</h3><p>Google Formのアンケートで、資料公開/動画公開するのか？ってけっこう来るため、勉強会の開催前後で公開有無について触れてあげると優しいかなと思います。なるべく1営業日以内の即時で公開を目指すといいでしょう。鉄はアツイうちに打て的な。</p><p>Future Tech NightではHR（人事）と事業部長レベルのレビューが必須です。このときのワークフローですが、登壇者に依頼ではなく、運営側が巻き取ってます。理由は以下です。</p><ul><li>ワークフローを回すのは慣れた人がやると早いし楽</li><li>逆に、こういった調整が苦手な登壇者の人も多い。逆に慣れると一瞬なので運営側がやるコスパが高い</li><li>いちいち登壇者に承認フローを回してねと依頼するほうが手間。またちゃんと依頼しているか確認することの方が苦痛</li></ul><p>最終的な資料公開は登壇者のアカウントで行ってもらうのでお願いしていますが、発信周りは運営側の仕事です。</p><ul><li>承認が降りたら登壇者に公開依頼→connpass上に資料紐付け/ツイッター発信 までしています</li><li>このとき同時に社内側のSlackなどにも共有することで、アウトプットしている感を出して、社内の雰囲気を気持ち盛り上げたりもしています</li></ul><h3 id="future-tech-night-のハッシュタグ盛り上げ"><a href="#future-tech-night-のハッシュタグ盛り上げ" class="headerlink" title="#future_tech_night のハッシュタグ盛り上げ"></a><code>#future_tech_night</code> のハッシュタグ盛り上げ</h3><p>会によっては、こちらで感想をくれる人もいます。Zoom上のチャット機能なのか、ツイッターで盛り上がるかどっちなのかは自分も感覚がつかめていないですが、どちらもウォッチしておくことが無難でしょう。Zoomのチャットは大体が過疎るので、このあたりは自社イベントであれば最初の投稿は身内に頼むと良いかもしれません。</p><h3 id="登壇レポート（技術ブログ）"><a href="#登壇レポート（技術ブログ）" class="headerlink" title="登壇レポート（技術ブログ）"></a>登壇レポート（技術ブログ）</h3><p>最近は登壇者1名ごとに、開催しましたブログを書いてもらってます。感想や当日もらった質問について、登壇終わった後の振り返りなど簡単に書いてもらえるとコンテンツを使い倒している感じが出て良いと思います。運営の改善アイデアも出ることもありおすすめです。</p><p>従来は代表して1名の方に書いてもらいましたが、他の登壇者の感想コメントを求めたり依存が出てくるため辞めました。シンプルな構造が運営も楽です。</p><h3 id="動画もアップロードする"><a href="#動画もアップロードする" class="headerlink" title="動画もアップロードする"></a>動画もアップロードする</h3><p>編集はがんばらず（前後トリムする程度）でYouTubeに勉強会動画を上げています。</p><ul><li><a href="https://www.youtube.com/channel/UCJUSwYYd0CkGgmEKAW7QVpw/featured">https://www.youtube.com/channel/UCJUSwYYd0CkGgmEKAW7QVpw/featured</a></li></ul><p>運営的には動画あるとメリットがあります。例えば、新規の登壇者を調整するときに、過去の勉強会の様子を知りたいという要求を受けたときに、URLを共有するだけで済みます。また、YouTubeだと倍速でも聞けますし、時間がない人にも便利。またご家族とのご都合などで19時開始に参加することが難しいといった方にも、後で動画を公開するのでお待ち下さい、と素直に言えるようになったのは本当に気が楽になりました。再生数などはいったん追わず、運営都合でアップロードすると良いでしょう。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>connpass, Zoomで運営していて気をつけている内容についてまとめました。</p><p>色々書きましたが、基本的には登壇者を信じて、connpass, Zoom, Google Formなど運営と同じ権限を付与し、気になったら自分でやれるようにするということかなと思います。情報およびアカウント権限の非対称性を作らないといつも思っています。</p><p>これは自分も別に人事とかに所属しているわけじゃなくて、普通に現場で働くITコンサルタントなのでそうしている面もあるかもしれません。合理的に楽していきましょうという意識は忘れないようにしています。</p><p>最後まで読んでいただきありがとうございました。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220517a/image.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;686&quot; loading=&quot;lazy&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Culture" scheme="https://future-architect.github.io/categories/Culture/"/>
    
    
    <category term="運営" scheme="https://future-architect.github.io/tags/%E9%81%8B%E5%96%B6/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="connpass" scheme="https://future-architect.github.io/tags/connpass/"/>
    
    <category term="Zoom" scheme="https://future-architect.github.io/tags/Zoom/"/>
    
  </entry>
  
  <entry>
    <title>Lambda×Go並列処理で100万回APIを呼び出す</title>
    <link href="https://future-architect.github.io/articles/20220516a/"/>
    <id>https://future-architect.github.io/articles/20220516a/</id>
    <published>2022-05-15T15:00:00.000Z</published>
    <updated>2022-05-16T03:08:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG DXチームの後藤です。2021年7月に新卒でフューチャーに入社しました。</p><p>業務でAPIを通して数万～100万のデータのバッチ処理を行うLambdaの開発を行ったので、学びを共有したいと思います。　　</p><h1 id="システム構成"><a href="#システム構成" class="headerlink" title="システム構成"></a>システム構成</h1><p>参画しているプロジェクトでCSVデータをデータベースに登録する必要がありLambdaの開発を行いました。ちなみに所属しているチームではGo言語を採用しているので、Go言語で開発を行いました。データを登録するためのAPI(API Gateway + proxy統合Lambda)を活用してバッチ処理を行います。データの件数は数百件から数十万件と幅が広く、「数十万件ものリクエストをLambdaの実行時間制限である15分以内に処理しきれるのか？」というところから開発を始めました。</p><img src="/images/20220516a/Image_from_iOS.jpg" alt="構成図" width="852" height="362" loading="lazy"><p>ちなみに、1Web API呼び出し大体30ms~80msほどかかります。</p><h1 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h1><p>AWS Lambdaはマネージドサービスでありサーバーの運用管理が必要なく、プログラムが実行された時間に対してのみ課金がされるので、開発コスト、運用コスト、金銭面を考えると非常に使い勝手がいいサービスです。実際に私の所属しているチームではLambdaを積極的に活用しています。そんな便利なLambdaですが、実行時間に制約があり最大で15分までの処理しか行うことができず、15分以上の時間がかかる処理を行う場合にはEC2などの別の環境を用意する必要があります。</p><h1 id="試してみた結果"><a href="#試してみた結果" class="headerlink" title="試してみた結果"></a>試してみた結果</h1><p> まずは非同期処理を使わず同期処理でデータの登録を実行してみました。<br> CSVファイルから読み込んだデータを登録するプログラムを書きLambdaのメモリサイズを512MBに設定ました。サンプルデータとして2万行のCSVファイルの処理を実行してみました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> lines &#123;</span><br><span class="line">    <span class="keyword">if</span> err := postRequest(ctx, line); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;post request error: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>結果としては、約1万4千件のデータを登録し終えたところで15分の実行時間制限を超えてしまいました。通常の方法では数十万件のデータの処理は難しい事がわかりました。</p><p>　　</p><h1 id="並行処理"><a href="#並行処理" class="headerlink" title="並行処理"></a>並行処理</h1><p>実際にプログラムを動かして、数十万件のデータを登録することが難しいとわかったので、他の方法を考えることにしました。1つ目の方法はStep Functionsを使いCSVデータを分割し処理する方法、2つ目はgoroutineで並行処理を行う方法です。Step Functionsを使う場合には追加でインフラの設定が必要になりますが、ソースコードは並行処理を行う場合よりもわかりやすくなるというメリットがあります。goroutineで並行処理を行う場合には、ソースコードは少し複雑になりますが、インフラのリソースを追加する必要がなく1つのLambdaでバッチ処理が完結します。今回はインフラ管理などの保守の容易さからgoroutineを実装することにしました。1つのLambdaで処理が完結している場合の方がログの確認も容易かと思います。再度メモリサイズを512MBに設定しサンプルデータ2万行のCSVファイルの処理を実行しました。　　</p><p>※エラーハンドリングを行う場合には<code>sync.ErrGroup</code>を使用する方がよさそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> lines &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, line CsvLine)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := postRequest(ctx, line); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;post request error: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, line)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>結果は、20秒かからずに終了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duration: 19927.45 ms   Billed Duration: 19928 ms   Memory Size: 512 MB Max Memory Used: 206</span><br></pre></td></tr></table></figure><p>と喜んでいましたが、ログをよく見ると</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dial tcp xxx.xxx.xxx.xxx:443: socket: too many open files</span><br></pre></td></tr></table></figure><p>というエラーが大量に出力されていました。</p><p>これはgoroutineで大量のコネクションを同時に作成してしまっているために起こるエラーです。</p><p>ということで、goroutineの同時実行数を500に制限することにしました。東京リージョンでのLambdaの同時実行数の上限は1000件であるためその半分である500に設定しました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">semaphore := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">500</span>)</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> lines &#123;</span><br><span class="line">    semaphore &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, line CsvLine)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := postRequest(ctx, line); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;post request error: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(&amp;wg, line)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>実行してみると無事にエラーなく処理が終了しました。2万件の処理が約20秒で終了することがわかりました。並行処理を使うとかなり高速に処理が行えました。</p><h1 id="同時実行数と実行時間"><a href="#同時実行数と実行時間" class="headerlink" title="同時実行数と実行時間"></a>同時実行数と実行時間</h1><p>無事に処理が実行できたところで次に気になるのが、同時実行数と実行時間の関係性です。行数を20万、メモリを1024MBに固定し同時実行数を100,300,500と変えて関係性を調査してみました。</p><div class="scroll"><table><thead><tr><th>同時実行数</th><th>APIの最大同時実行数</th><th>メモリ(MB)</th><th>実行時間(秒)</th></tr></thead><tbody><tr><td>100</td><td>98</td><td>1024</td><td>246</td></tr><tr><td>300</td><td>304</td><td>1024</td><td>218</td></tr><tr><td>500</td><td>469</td><td>1024</td><td>227</td></tr></tbody></table></div><p>それぞれ一度ずつしか実行していませんが、API（Lambda）の最大同時実行数は概ね設定した上限値に近い値になっています。Lambdaの最大同時実行が304になっている理由はよくわかりませんが、他のリーソースからAPIが呼ばれたか、実行後のLambdaが完全に停止する前に新しくgoroutineが実行されたのだと思います。実行するたびに結果は違うとは思いますが、表の結果から同時実行数を300あたりに制限するのが良さそうです。</p><h1 id="メモリサイズと実行時間"><a href="#メモリサイズと実行時間" class="headerlink" title="メモリサイズと実行時間"></a>メモリサイズと実行時間</h1><p>同時実行数と実行時間の関係性がわかり、その次に気になるのが、メモリサイズと実行時間の関係性です。同時実行数を500、行数を10万に固定してメモリサイズを変え実行時間との関係性を調査しました。</p><div class="scroll"><table><thead><tr><th>同時実行数</th><th>APIの最大同時実行数</th><th>メモリ(MB)</th><th>実行時間(秒)</th></tr></thead><tbody><tr><td>500</td><td>488</td><td>1024</td><td>199</td></tr><tr><td>500</td><td>320</td><td>2048</td><td>110</td></tr><tr><td>500</td><td>460</td><td>4096</td><td>46</td></tr><tr><td>500</td><td>502</td><td>6144</td><td>39</td></tr><tr><td>500</td><td>475</td><td>8192</td><td>27</td></tr></tbody></table></div><p>メモリサイズが大きいほど、実行時間が短くなっています。それぞれの最大メモリ使用量は200MB～280MBに収まっていたので、CPUの性能の違いで処理が高速化した可能性が高いです。</p><h1 id="APIを100万回呼び出す"><a href="#APIを100万回呼び出す" class="headerlink" title="APIを100万回呼び出す"></a>APIを100万回呼び出す</h1><p>最後に8GBのメモリで100万行の処理を実行してみました。</p><p>処理時間はなんと<strong>258秒</strong>でした！</p><p>多少上振れするとしても、Lambda関数の実行時間の限界である900秒以内に200万件は余裕で登録出来そうです！</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://qiita.com/jerfareza/items/314401bb3fa55a82f8c0">Writing Large Data to CSV File in Go</a><br><a href="https://selfnote.work/20210311/programming/must-consider-use-goroutine-in-loop/">[Golang]ループ処理内でgoroutineを使う時に考慮しておくべきこと</a><br><a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html#concurrent-execution-safety-limit">Lambda function scaling</a><br><a href="https://pkg.go.dev/golang.org/x/sync/errgroup">pkg.go.dev/golang.org/x/sync/errgroup</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="性能検証" scheme="https://future-architect.github.io/tags/%E6%80%A7%E8%83%BD%E6%A4%9C%E8%A8%BC/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="並列処理" scheme="https://future-architect.github.io/tags/%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #21 Google Cloud Vertex AIによるフルマネージドなMLOps導入</title>
    <link href="https://future-architect.github.io/articles/20220513a/"/>
    <id>https://future-architect.github.io/articles/20220513a/</id>
    <published>2022-05-12T15:00:00.000Z</published>
    <updated>2022-06-02T01:43:43.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、SAIG所属の真鍋です。</p><p>この度は「Future Tech Night #21 Google Cloud: データエンジニア＋MLOps」に登壇させていただきましたので、その内容について触れていきたいと思います。</p><p>本イベントはTIGの村田さんの「JSON関数と共に歩む、BigQueryを使った超汎化型データ活用基盤」パートと、私の「Vertex AIによるフルマネージドなMLOps導入」の2本立てで行われました。前者については、別記事が既に投稿されておりますので、そちらもご覧いただければ幸いです。</p><h1 id="発表資料"><a href="#発表資料" class="headerlink" title="発表資料"></a>発表資料</h1><ul><li><a href="https://speakerdeck.com/komodoran/vertex-ainiyoruhurumanezidonamlopsdao-ru">Vertex AIによるフルマネージドなMLOps導入</a></li><li><a href="https://www.youtube.com/watch?v=o0oZnX1Ai-k">Future Tech Night #21 Google Cloud: データエンジニア＋MLOps</a></li></ul><h2 id="MLOpsとは"><a href="#MLOpsとは" class="headerlink" title="MLOpsとは"></a>MLOpsとは</h2><p>機械学習プロジェクトが広く一般に普及してきた昨今、多くのカンファレンスや企業活動の中でMLOpsが注目を集めています。<br>MLOpsとは、下記のライフサイクルを潤滑に回すための概念であり、Machine Learning + DevOps + Operateを合わせたものです。</p><img src="/images/20220513a/image.png" alt="MLOps" width="800" height="450" loading="lazy"><p>本発表では、コーディングと学習のフェーズに焦点を当てています。<br>如何にデータサイエンティストのためのコーディング環境や、ハイスペックな学習環境を用意するかといった環境面の問題や、実装されたアルゴリズムをどのようにサービスとして素早くデプロイするのか等が課題となってきます。</p><h2 id="Vertex-AIとは"><a href="#Vertex-AIとは" class="headerlink" title="Vertex AIとは"></a>Vertex AIとは</h2><p>Vertex AIとはGoogle Cloud Platformにおける必要なMLツールがすべて揃った一元的なAIプラットフォームであり、GAされたのが2021年5月と比較的新しいサービスです。</p><img src="/images/20220513a/image_2.png" alt="Vertex AI" width="800" height="450" loading="lazy"><ul><li>Vertex AI WorkBench<br>フルマネージド型のコンピューティング環境で、JupyterLabの環境を数クリックで構築することができます。<br>本サービスの大きな利点としては、複数のデータサイエンティストが利用する環境をパッケージやマシンスペックについて統一できることと、必要な性能に合わせてマシンスペックを変更できる点です。</li></ul><p>また、Pythonだけでなくパッケージが導入済みのイメージや、自身で作成したイメージを用いて構築することも可能です。</p><img src="/images/20220513a/image_3.png" alt="Vertex AI WorkBench" width="800" height="450" loading="lazy"><ul><li>Vertex AI Pipeline<br>WorkBenchで構築した学習アルゴリズムや推論のコードは、サービス化・システム導入の際に利用する環境に合わせて準備する必要があります。<br>その際注意しているのことは、下記の3点があります。<br>　1. 処理に合わせた性能の環境を用意すること<br>　2. 実行する環境に依存してしまうことでエラーが起こらないようにすること<br>　3. 利用したデータやパラメータ、コードのバージョンを後から見直せるようにすること<br>これらの管理をVertex AI Pipelineを用いることで容易に行うことができます。</li></ul><img src="/images/20220513a/image_4.png" alt="Vertex AI Pipeline概要" width="800" height="450" loading="lazy"><p>Pipelineは複数のコンポーネントから構成されており、デフォルトで用意されたAutoMLといった処理や、各自で作成するDockerイメージによる独自の処理を登録することができます。</p><img src="/images/20220513a/image_5.png" alt="Pipeline" width="800" height="450" loading="lazy"><p>実行されたPipelineは、自動的に利用したデータや設定値、開始日時や実行時間といった各種パラメータを記録することができ、後から結果を遡ることを容易にします。</p><img src="/images/20220513a/image_6.png" alt="メタデータ管理" width="800" height="450" loading="lazy"><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>VertexAIは、TerraformのようなlaCで構築は可能でしょうか？<br>→ 2022/5現在、Terraformで全てのサービスを用意することは難しいのが現状です。WorkBenchはAI Platformのコードを流用することができますが、パイプライン等は別途用意することが必要です。</li><li>データサイエンティストが共通で使う社内ライブラリがあったときにWorkbenchの環境で社内ライブラリが使えるように環境構築できますか？<br>→ 各自が作成したDockerイメージをArtifact RegistryにPushしておくことで、WorkBench構築時に選択することが可能です。</li><li>vertex AIを利用する際、ローカルマシンの環境をうまく組み合わせてコストを抑えられたり出来ますか？<br>→ Vertex AI Pipelineに関してですが、ローカルモード等といったシステムは現時点では存在しない認識です。</li><li>実験管理に関して、mlflow等で自分で作るよりVertex AI Pipelineに任せたほうが楽なんでしょうか。<br>→ 私の個人的な印象ですが、mlflowの実験管理機能の方が柔軟性に富んでおり、必要な情報をトラッキングが容易です。今後、Vertex AIとmlflowの連携についても探っていきたいと考えています。</li></ul><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>フルマネージドなサービスを用いることで、オンプレでは難しい柔軟かつ迅速な環境構築が可能であると考えています。</p><p>特に必要なマシンスペックに大きな差が生じる機械学習プロジェクトでは、フルマネージドサービスの需要が高まっていくことでしょう。</p><p>Vertex AIは現在も発展を続けているサービスであり、引き続きウォッチしていきたいと思います。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、SAIG所属の真鍋です。&lt;/p&gt;
&lt;p&gt;この度は「Future Tech Night #21 Google</summary>
        
      
    
    
    
    <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="MLOps" scheme="https://future-architect.github.io/tags/MLOps/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="VertexAI" scheme="https://future-architect.github.io/tags/VertexAI/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Functions+ GoでビッグデータETLするときのコツ</title>
    <link href="https://future-architect.github.io/articles/20220512a/"/>
    <id>https://future-architect.github.io/articles/20220512a/</id>
    <published>2022-05-11T15:00:00.000Z</published>
    <updated>2022-05-12T01:01:09.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>Google Cloud上の大規模なシステムのとあるログがCloud Storageに溜まっており、それらをBigQueryにロードし、分析したい、ということがありました。このログは未加工のままBigQueryに読み込めるフォーマットではなく、いわゆるETL処理が必要でした。恒常的にいつでもデータ分析したいというわけではなく、必要な時に必要な分だけBigQueryにロードして分析したい、というユースケースなのでバッチETL処理です。</p><p>Google CloudでETL処理する場合Dataflowを採用することが一般的かと思いますが、開発言語でGoを使っていること（DataflowのプレビューではApache Beam SDK for Goが使えるようです）や、運用面を考慮すると利用サービスを増やしたくない、ということで使い慣れたCloud Functionsを使うことにしました。ログファイルが大規模なためCloud Functionsの限られたリソースで処理しきるためにちょっと考えることがあったので、ブログにします。</p><p>フューチャー技術ブログ内の類似記事としては次のようなものがあります。是非合わせてお読みください。</p><ul><li><a href="/articles/20210601a/">15分の壁を超えて。Lambda分散実行術</a></li><li><a href="/articles/20200515/">Serverless連載6: AWSのStep FunctionsとLambdaでServelessなBatch処理を実現する</a></li></ul><h1 id="問題設定"><a href="#問題設定" class="headerlink" title="問題設定"></a>問題設定</h1><p>Cloud Storageに大量かつ、大きいログファイルが存在していました。それを整形し、BigQueryにバッチ読み込みします。</p><p>ログのサイズ感は、</p><ul><li>ファイルサイズは数MiB ~ 数GiB程度で、上限がある。</li><li>ファイル数は約 ~1000件/日</li><li>データサイズは ~500GB/日</li></ul><p>ログファイルは、改行区切りテキストデータです。</p><p>大量データをCloud Functionsで処理する場合、<a href="https://cloud.google.com/functions/quotas?hl=ja">メモリ上限やタイムアウト上限</a>が制約になります。加えて<a href="https://cloud.google.com/bigquery/quotas?hl=ja">BigQueryの一日あたりのロードジョブ数や、一回当たりの読み込みデータサイズの上限などの割り当て</a>も気にしなければなりません。</p><h1 id="Cloud-FunctionsをファンアウトさせてETL処理"><a href="#Cloud-FunctionsをファンアウトさせてETL処理" class="headerlink" title="Cloud FunctionsをファンアウトさせてETL処理"></a>Cloud FunctionsをファンアウトさせてETL処理</h1><p>今回のETL処理の構成を説明していきます。</p><p>Cloud Storageからログファイルを取ってきて、テキスト加工する処理は、Cloud FunctionsとPub/Subを使ったファンアウト構成にしました。</p><img src="/images/20220512a/CloudFunction_ETL.drawio_(1).png" alt="CloudFunction_ETL" width="616" height="301" loading="lazy"><ul><li>左のCloud Functionsが、Cloud Storageに存在するログファイルのリストを1件ずつPub/Subにpublishします。</li><li>真ん中のCloud FunctionsはPub/Subをトリガーにして並行に起動させ、ログファイルをダウンロードして加工し、別のCloud Storageにアップロードします。Cloud Functionsの最大同時実行数までスケールさせることができ、同時に多くのログファイルを処理できます。</li></ul><p>今回はログファイルのサイズに上限がある前提なので、ファイル分割処理はしなくて済んでます。</p><p>最近では、<a href="https://cloud.google.com/functions/docs/2nd-gen/overview">Cloud Functions 第2世代</a>が発表され、より多くのメモリ（最大16GiB）、タイムアウト（イベントトリガーの場合10分）を設定できるようになりました。できることも広がりますね。</p><p>BigQueryへの読み込みはCloud Storageからのバッチ読み込みにしました。Cloud Functionsで並行でBigQueryに書き込むと、処理するファイル数=BigQueryロードジョブ数が多すぎて諸々のBigQueryの割り当てに引っかかる恐れがあったからです。</p><h2 id="実用上の細かい作り込み"><a href="#実用上の細かい作り込み" class="headerlink" title="実用上の細かい作り込み"></a>実用上の細かい作り込み</h2><p>Pub/Subはデフォルトでは<a href="https://cloud.google.com/pubsub/docs/subscriber?hl=eg#at-least-once-delivery">at-least-once配信</a>、つまりpublishされたデータが複数回配信される可能性があるのですが、今回のジョブは単純なファイル加工処理で冪等なのでOKです。</p><p>Cloud FunctionのETL処理の完了を、なんらかの方法で検知しなければならないという課題があります。<a href="https://cloud.google.com/blog/ja/topics/developers-practitioners/celebrating-pi-day-cloud-functions">こちらのブログ</a>のように、並行実行されているジョブの完了や失敗を管理するテーブルを用意したり、<a href="https://cloud.google.com/blog/ja/products/data-analytics/ingesting-data-into-bigquery-using-serverless-spark">こちらのブログ</a>のように失敗したジョブを別のPub/Subに公開する、などの方法があるかなと思います。</p><h1 id="Cloud-Functinonsの中身のGo実装"><a href="#Cloud-Functinonsの中身のGo実装" class="headerlink" title="Cloud Functinonsの中身のGo実装"></a>Cloud Functinonsの中身のGo実装</h1><p>Cloud FunctionsにはGoのソースをデプロイしました。並行で起動するCloud Functionsが、メモリを効率よく使いつつタイムアウト内に処理を終えるために考えたことを説明していきます。</p><h2 id="ログファイルは1行ずつ読み込む"><a href="#ログファイルは1行ずつ読み込む" class="headerlink" title="ログファイルは1行ずつ読み込む"></a>ログファイルは1行ずつ読み込む</h2><p>ログファイルは改行区切りのテキストファイルなので、Cloud Storageから1行ずつ読み込んで加工し、1行ずつ書き込みます。これによってメモリにログファイル全量を展開せずに済みます。<br>Cloud Storageからの読み込み、書き込みに使う<a href="https://pkg.go.dev/cloud.google.com/go/storage">storage.Reader, storage.Writer</a>はio.Reader, io.Writerを満たすので、ファイルへの読み書きと同じように扱えます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;cloud.google.com/go/storage&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PubSubMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">Data []<span class="type">byte</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PubSubEntryPoint</span><span class="params">(ctx context.Context, m PubSubMessage)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">logFilePath := <span class="type">string</span>(m.Data) <span class="comment">// Pub/Subからログファイルのパスがpushされてくる</span></span><br><span class="line"></span><br><span class="line">client, err := storage.NewClient(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">storageReader, err := client.Bucket(LogBucket).Object(logFilePath).NewReader(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">storageWriter := client.Bucket(TmpBucket).Object(translatedLog).NewWriter(ctx)</span><br><span class="line"></span><br><span class="line">s := bufio.NewScanner(storageReader)</span><br><span class="line"><span class="keyword">for</span> s.Scan() &#123;</span><br><span class="line">line := s.Text() <span class="comment">// 1行ずつ読み込む</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// なんらかの加工処理を行う</span></span><br><span class="line"></span><br><span class="line">fmt.Fprintln(storageWriter, line) <span class="comment">// 1行ずつ書き込む</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := storageWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文字列の加工は並行処理"><a href="#文字列の加工は並行処理" class="headerlink" title="文字列の加工は並行処理"></a>文字列の加工は並行処理</h2><p>読み込んだ行を処理するところは並行で書けます。<a href="https://pkg.go.dev/golang.org/x/sync/errgroup">sync.errgroup</a>を使うと、groutineのエラーハンドリングがしやすいです。<br>goroutineの数だけメモリを使うのでgoroutineの同時実行数の上限を設定してあげます。これは実際のログの1行分のサイズと、Cloud Functionのメモリ消費量を計測してよしなに決めます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">s := bufio.NewScanner(storageReader)</span><br><span class="line">eg := errgroup.Group&#123;&#125;</span><br><span class="line">limit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">5000</span>) <span class="comment">// 同時実行数に制限をかける</span></span><br><span class="line"><span class="keyword">for</span> s.Scan() &#123;</span><br><span class="line">line := s.Text() <span class="comment">// 1行ずつ読み込む</span></span><br><span class="line">limit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-limit</span><br><span class="line">&#125;()</span><br><span class="line">translatedLine, err := translate(line) <span class="comment">// なんらかの加工処理を行う</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintln(storageWriter, translatedLine) <span class="comment">// 1行ずつ書き込む</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := eg.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>今回はCloud FunctionsでETL処理を実装しましたが、Dataflowや他のETL処理パターンも今後試していきたいです。<br>かなり大規模なシステムになると、データの規模も大きくなります。当たり前かもしれませんが、<strong>クラウドでも無尽蔵にリソースを使えるわけではなく、諸々の制約、割り当てを気にしなければならないな</strong>、、、ということを意識させられました。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;Google Cloud上の大規模なシステムのとあるログがCloud</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="CloudFunctions" scheme="https://future-architect.github.io/tags/CloudFunctions/"/>
    
    <category term="ETL" scheme="https://future-architect.github.io/tags/ETL/"/>
    
    <category term="サーバーレス" scheme="https://future-architect.github.io/tags/%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>IPAの過去問で学ぶDNSキャッシュポイズニングの攻撃手法と対応策</title>
    <link href="https://future-architect.github.io/articles/20220511a/"/>
    <id>https://future-architect.github.io/articles/20220511a/</id>
    <published>2022-05-10T15:00:00.000Z</published>
    <updated>2022-05-11T02:57:51.129Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220511a/title.png" alt="title.png" width="840" height="542" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG 村瀬です。</p><p>情報処理推進機構(IPA)のネットワークスペシャリスト試験の過去問を解いていて興味深い問題がありました。</p><p>対象の試験は ネットワークスペシャリスト試験 令和元年度 午後Ⅱ 問2<br>過去問は<a href="https://www.jitec.ipa.go.jp/1_04hanni_sukiru/mondai_kaitou_2019h31.html#01aki">こちら</a>からダウンロード可能です。<br>　　<br>この問題の中でSYNフラッド攻撃、DNSキャッシュポイズニング、C&amp;C(Command &amp; Control)サーバの攻撃手法と対応策が記載されています。</p><p>ネットワークの試験ではあるものの内容としてはセキュリティに関するものです。DNSキャッシュポイズニングという攻撃があるのは知っていたのですが、攻撃手法と対応策を知らなかったので自分の知識を整理するためにブログにしてみました。</p><p>当たり前ですが、このブログでは犯罪行為を推奨するものではなく、セキュリティ意識、対策の向上を目的として記載しております。</p><h1 id="DNSとは"><a href="#DNSとは" class="headerlink" title="DNSとは"></a>DNSとは</h1><p>DNSキャッシュポイズニングの説明をする前にDNSについておさらいします。</p><p>DNS(ディーエヌエス: Domain Name System)とはインターネットなどのIPネットワーク上でドメイン名(ホスト名)とIPアドレスの対応を管理するシステムです。</p><p>DNSがあるおかげで利用者はブラウザにURLを入力するだけで目的のWEBページを見ることができます。目的のWEBページが表示されるまでの過程で利用者が意識することなくDNSの名前解決によってドメイン名(ホスト名)からIPアドレスを取得しています。</p><p>インターネットを支える縁の下の力持ちですね。</p><h1 id="DNSキャッシュポイズニングとは"><a href="#DNSキャッシュポイズニングとは" class="headerlink" title="DNSキャッシュポイズニングとは"></a>DNSキャッシュポイズニングとは</h1><p>DNSキャッシュポイズニングとはDNSのキャッシュを書き換えることでDNSの名前解決で本来あるべきIPアドレスではなく、攻撃者が用意した悪意のあるサーバのIPアドレスを返却すること。これがなされると悪意のあるサーバでフィッシングなどが行われます。不正なURLを利用する一般的なフィッシングとは異なり、正規のURLで悪意のあるWEBページが表示されることになるので注意深いユーザであっても気が付くのは困難になります。</p><h1 id="なぜキャッシュを書き換えられるのか"><a href="#なぜキャッシュを書き換えられるのか" class="headerlink" title="なぜキャッシュを書き換えられるのか"></a>なぜキャッシュを書き換えられるのか</h1><p>試験問題を読むと理解しやすかったので抜粋します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DNSキャッシュポイズニング攻撃は、次の手順で行われる。</span><br><span class="line">(ⅰ)攻撃者は、偽の情報を送り込みたいドメイン名について、標的のフルリゾルバサーバに問い合わせる。</span><br><span class="line">(ⅱ)フルリゾルバサーバは、指定されたドメインのゾーン情報を管理するコンテンツサーバに問い合わせる。</span><br><span class="line">(ⅲ)攻撃者は、コンテンツサーバから正しい応答が返ってくる前に、大量の偽の応答パケットを標的のフルリゾルバサーバ宛てに送信する。</span><br><span class="line">(ⅳ)フルリゾルバサーバは、受信した偽の応答パケットをチェックし、偽の応答パケットが正当なものであると判断してしまった場合、キャッシュの内容を偽の応答パケットを基に書き換える。</span><br></pre></td></tr></table></figure><p>ネットワークスペシャリスト試験 令和元年度 午後Ⅱ 問2 から抜粋(試験問題に関する表記を改変しています。)</p><p>問題文に記載のある通り、フルリゾルバサーバが偽の応答パケットを正当なものと判断してしまうため、誤った情報がキャッシュされてしまいます。</p><p>もう少し詳細に説明すると上記のDNSのやりとりはTCPではなく、UDPで行われます。UDPでは通信相手を確認することなく処理が行われるため、攻撃者は偽のパケットを容易に作成することができます。</p><p>問合せに対する応答は先に届いた情報が利用されるので、正当な応答パケットよりも先に偽の応答パケットがフルリゾルバサーバに受信されると攻撃が成功してしまうのです。</p><p>図で表すと以下のようになります。</p><h2 id="通常時の名前解決"><a href="#通常時の名前解決" class="headerlink" title="通常時の名前解決"></a>通常時の名前解決</h2><p>問合せに対して応答が1つだけなされます。その応答の情報がキャッシュされます。</p><img src="/images/20220511a/p1.png" alt="通常時の名前解決" width="1200" height="380" loading="lazy"><h2 id="DNSキャッシュポイズニングが行われる場合"><a href="#DNSキャッシュポイズニングが行われる場合" class="headerlink" title="DNSキャッシュポイズニングが行われる場合"></a>DNSキャッシュポイズニングが行われる場合</h2><p>正規の応答が行われるタイミングに合わせて正当なものであると判断されうる大量の偽の応答パケットを送信します。<br><img src="/images/20220511a/p2.png" alt="DNSキャッシュポイズニング" width="1200" height="366" loading="lazy"></p><p>攻撃者は宛先ポート番号と識別子が何かわからないのでこれらを変更した応答パケットを大量に送信することになります。全てのパターンを網羅する場合には宛先ポート番号 * 識別子の全ての組み合わせになります。宛先ポート番号が固定の単一のポートであった場合、識別子は16ビットのため65,536パターンになります。</p><p>なお、応答パケットに必要なその他の情報であるフルリゾルバサーバのIPアドレス、コンテンツサーバのIPアドレス、送信元ポート番号は攻撃者が容易に把握できるものになります。</p><h1 id="対応策"><a href="#対応策" class="headerlink" title="対応策"></a>対応策</h1><p>大別して2つの方法があります。</p><h2 id="対応策1-送信元ポート番号のランダム化"><a href="#対応策1-送信元ポート番号のランダム化" class="headerlink" title="対応策1 送信元ポート番号のランダム化"></a>対応策1 送信元ポート番号のランダム化</h2><p>ネットワークスペシャリスト試験 令和元年度 午後Ⅱ 問2 から抜粋します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ⅱ)の問合せパケットの送信元ポート番号には特定の範囲の値が使用されるケースが多いので、攻撃者は、(ⅲ)の偽の応答パケットを正当なパケットに偽装しやすくなるという問題がある。調査の結果、この問題の対応策には、送信元ポート番号のランダム化があることが分かった。</span><br></pre></td></tr></table></figure><p>DNSキャッシュポイズニング攻撃が成立する条件の必要条件として、問合せパケットの送信元ポート番号と応答パケットの宛先ポート番号が一致し、かつ問合せパケットの識別子と応答パケットの識別子が一致することが挙げられます。固定であった送信元ポート番号をランダムにすることで攻撃が成功する確率をぐっと下げることができます。</p><p>100個のポート番号を利用するだけでも成功率を1/100にすることができます。ポート番号を仮に30,000個利用する場合の全ての組み合わせは、30,000 * 65,536 = 1,966,080,000パターンになるので攻撃者からしてみると用意するのが辛い数になります。</p><h2 id="対応策2-フルリゾルバサーバに対する攻撃者からの名前解決要求の禁止"><a href="#対応策2-フルリゾルバサーバに対する攻撃者からの名前解決要求の禁止" class="headerlink" title="対応策2 フルリゾルバサーバに対する攻撃者からの名前解決要求の禁止"></a>対応策2 フルリゾルバサーバに対する攻撃者からの名前解決要求の禁止</h2><p>また、試験問題と解答にもあるとおり、そもそもの話、フルリゾルバサーバに対して攻撃者から名前解決の要求を禁止することが効果的です。<br>試験問題では外部DNSサーバ上でフルリゾルバサーバとコンテンツサーバが稼働しているため、(試験問題の都合上)インターネットからの名前解決要求を許容していました。</p><img src="/images/20220511a/p3.png" alt="フルリゾルバサーバに対する攻撃者からの名前解決要求の禁止" width="794" height="590" loading="lazy"><p>ネットワークスペシャリスト試験 令和元年度 午後Ⅱ 問2から引用</p><p>試験問題と解答を踏まえてフルリゾルバサーバとコンテンツサーバの分離後のあるべき姿を整理すると以下の通りです。</p><ul><li>フルリゾルバによるインターネット上のホストの名前解決はFPサーバとメール中継サーバからの要求に応答できればよい。</li><li>コンテンツサーバは、インターネット上の不特定のホストからの名前解決要求に応答する必要がある。</li></ul><p>フルリゾルバサーバは社内(DMZ)からの名前解決要求だけ許容すれば良いため、インターネットからのフルリゾルバサーバに対する名前解決要求をファイアーウォールで防ぐことが重要です。<br>この対応により攻撃者はインターネットからフルリゾルバサーバに対して名前解決要求をできなくなります。<br>ちなみにコンテンツサーバにはインターネットからの名前解決要求が来ますが、DNSキャッシュを持たないので問題ありません。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>DNSキャッシュポイズニングという言葉自体は知っていたものの、キャッシュを書き換える仕組みや対応策を知らなかったのでネットワークスペシャリスト試験の勉強をすることで知識が身に付きました。</p><p>セキュリティは重要ですが、やみくもに恐れてはセキュリティ対策コストがいくらあっても足りません。どういった仕組みで攻撃が成功するかを適切に理解しておくことで、費用対効果の高いセキュリティ対策やインフラ設計ができるようになるはずです。</p><p>日々新たな脆弱性が見つかる状況であるため、100%安全と言い切れるネットワークを作ることはできません。しかしそのような状況であっても攻撃に合う確率を如何に0%に近づけるかがネットワーク(セキュリティ)エンジニアの腕の見せ所かと思います。</p><p>今回はDNSキャッシュポイズニングに焦点を充てて記載しましたが、SYNフラッド攻撃、C&amp;C(Command &amp; Control)サーバも興味深いのでそのうちまとめてみようと思います。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220511a/title.png&quot; alt=&quot;title.png&quot; width=&quot;840&quot; height=&quot;542&quot; loading=&quot;lazy&quot;&gt;


&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot;</summary>
        
      
    
    
    
    <category term="Security" scheme="https://future-architect.github.io/categories/Security/"/>
    
    
    <category term="Network" scheme="https://future-architect.github.io/tags/Network/"/>
    
    <category term="DNS" scheme="https://future-architect.github.io/tags/DNS/"/>
    
    <category term="攻撃手法" scheme="https://future-architect.github.io/tags/%E6%94%BB%E6%92%83%E6%89%8B%E6%B3%95/"/>
    
    <category term="DNSキャッシュポイズニング" scheme="https://future-architect.github.io/tags/DNS%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9D%E3%82%A4%E3%82%BA%E3%83%8B%E3%83%B3%E3%82%B0/"/>
    
    <category term="IPA" scheme="https://future-architect.github.io/tags/IPA/"/>
    
  </entry>
  
  <entry>
    <title>Lambda Function URLs をGoでお試し。実行時間の上限（タイムアウト）やWeb API構築周りで気になること</title>
    <link href="https://future-architect.github.io/articles/20220510a/"/>
    <id>https://future-architect.github.io/articles/20220510a/</id>
    <published>2022-05-09T15:00:00.000Z</published>
    <updated>2022-05-12T00:59:45.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG DXユニット真野です。2022/04/06にGAになったと発表された、Lambda Function URLsは、AWS Lambdaに直接HTTPSエンドポイントを追加できるというもので、API Gateway（やALB）無しでWeb APIやサイトを構築できると話題になりました。</p><ul><li><a href="https://aws.amazon.com/jp/blogs/aws/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/">Announcing AWS Lambda Function URLs: Built-in HTTPS Endpoints for Single-Function Microservices</a><ul><li><a href="https://aws.amazon.com/jp/blogs/news/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/">（4/14公開の日本語訳）AWS Lambda Function URLs の提供開始: 単一機能のマイクロサービス向けの組み込み HTTPS エンドポイント</a></li></ul></li></ul><p>私も業務でAPI Gateway + Lambdaの組み合わせで稼働している事例があります。非常に安定稼働していますが、この組み合わせだとタイムアウトがAPI GatewayのLambda統合となるため上限が29秒<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>です。Lambda Function URLs だとAPI Gatewayを経由しない分、Lambda側の15分<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>になることが嬉しいなと思いました。Web APIでそんなに長時間動かすことって無いだろうと思いますよね。私もそう思っていましたが、Excelファイルアップロードによるバッチ登録や、Excel帳票ダウンロード機能の登場を予見できず目論見は崩れました。</p><p>さて、ドキュメントにはLambda Function URLsで個別のタイムアウト制約があるという記載がないため、制約は通常のLambdaと同様に15分が上限であることは自明な気がしますが、せっかくなので検証します。また、GoでJSONを返すWeb APIを構築するときにどういった使い方になるかコードベースで試します。</p><h2 id="タイムアウトについて"><a href="#タイムアウトについて" class="headerlink" title="タイムアウトについて"></a>タイムアウトについて</h2><p>Lambdaについては「関数URLを有効化」し、cURLやブラウザなどで簡易的に疎通したかったので認証タイプは「NONE」を選択します。関数名は「my-function-url-lambda」とします。</p><img src="/images/20220510a/lambda_create_resource.png" alt="lambda_create_resource" width="1200" height="987" loading="lazy"><p>Lambda設定は、ランタイムを「Go 1.x」、ハンドラは適当に「lambda」にしています。Lambdaリソースのタイムアウトは「15分0秒」（最長）にします。</p><p>AWS LambdaをGoで動かすためには、ドキュメントにもあるように <code>github.com/aws/aws-lambda-go/lambda</code> パッケージを利用します。本来は不要ですが、動いているか心配になったので、tickerで1分ごとに標準出力しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleRequest</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">term := t.Sub(start)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Term %f[sec]&quot;</span>, term.Seconds())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// チャネル受信待ちにして、無限にウェイトさせています</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;3年も一緒に暮らしたのに、猫がまったく懐かなくて悲しい&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>デプロイは次のようなMakefileを作って行います（どういうやり方でも良いと思います）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">deploy:</span></span><br><span class="line">GOOS=linux GOARCH=amd64 go build -ldflags=<span class="string">&quot;-s -w -buildid=&quot;</span> -trimpath -o bin/lambda_raw/lambda cmd/lambda_raw/main.go</span><br><span class="line">zip -j bin/lambda_raw/lambda.zip bin/lambda_raw/lambda</span><br><span class="line">aws lambda update-function-code --profile my_profile --region ap-northeast-1 --function-name my-function-url-lambda --zip-file fileb://bin/lambda_raw/lambda.zip</span><br></pre></td></tr></table></figure><p>アクセスするURLは、関数URLという部分に表示されるので、ブラウザでクリックしてLambdaを実行します。</p><img src="/images/20220510a/Lambda定義.png" alt="Lambda定義" width="1200" height="381" loading="lazy"><p>15分待つと <code>Internal Server Error</code> がブラウザで表示されます。CloudWatch Logsで確認すると、以下のように約900秒（15分）起動したことが分かります。おお..!!  29秒の呪縛から開放されている!!</p><figure class="highlight plaintext"><figcaption><span>実行結果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2022-05-05T00:34:58.224+09:00START RequestId: 5203b933-276b-4abc-b1cb-8a92ffbfec06 Version: $LATEST</span><br><span class="line">2022-05-05T00:35:59.228+09:00Term 60.000960[sec]</span><br><span class="line">2022-05-05T00:36:59.228+09:00Term 120.001254[sec]</span><br><span class="line">2022-05-05T00:37:59.228+09:00Term 180.001482[sec]</span><br><span class="line">2022-05-05T00:38:59.228+09:00Term 240.000151[sec]</span><br><span class="line">2022-05-05T00:39:59.229+09:00Term 300.000145[sec]</span><br><span class="line">2022-05-05T00:40:59.230+09:00Term 360.000407[sec]</span><br><span class="line">2022-05-05T00:41:59.231+09:00Term 420.000769[sec]</span><br><span class="line">2022-05-05T00:42:59.232+09:00Term 480.001089[sec]</span><br><span class="line">2022-05-05T00:43:59.285+09:00Term 540.054274[sec]</span><br><span class="line">2022-05-05T00:44:59.286+09:00Term 600.054582[sec]</span><br><span class="line">2022-05-05T00:45:59.288+09:00Term 660.054826[sec]</span><br><span class="line">2022-05-05T00:46:59.288+09:00Term 720.055132[sec]</span><br><span class="line">2022-05-05T00:47:59.290+09:00Term 780.055406[sec]</span><br><span class="line">2022-05-05T00:48:59.290+09:00Term 840.055729[sec]</span><br><span class="line">2022-05-05T00:49:58.245+09:00END RequestId: 5203b933-276b-4abc-b1cb-8a92ffbfec06</span><br><span class="line">2022-05-05T00:49:58.245+09:00REPORT RequestId: 5203b933-276b-4abc-b1cb-8a92ffbfec06 Duration: 900011.38 ms Billed Duration: 900000 ms Memory Size: 512 MB Max Memory Used: 28 MB Init Duration: 90.72 ms</span><br><span class="line">2022-05-05T00:49:58.245+09:002022-05-04T15:49:58.244Z 5203b933-276b-4abc-b1cb-8a92ffbfec06 Task timed out after 900.01 seconds</span><br><span class="line">2022-05-05T00:49:58.455+09:00START RequestId: 89b046b7-dc8d-4f68-be08-66a992f2e46e Version: $LATEST</span><br></pre></td></tr></table></figure><p>これで、Lambda Function URLsは実行時間の面でかなり有用だと感じます。</p><h2 id="WAFの制御"><a href="#WAFの制御" class="headerlink" title="WAFの制御"></a>WAFの制御</h2><p>API Gatewayのようなリッチな制御は行えなくても、セキュリティ要件でWAF設置が必須な場合があります。Lambda Function URLsは2022.5.5時点ではAWS WAFの設定は不可のようです。AWS WAFの設定画面をみても、現状はAPI Gateway, ALB, AppSyncの3つに限られています。</p><img src="/images/20220510a/WAF設定画面.png" alt="WAF設定画面" width="840" height="256" loading="lazy"><p>そのためブラウザアクセスを許容したいけど、検証用のエンドポイントは送信元IPを絞りたいとかも現状はできないです。スロットリング、カスタムドメイン名などとともに、これらの要件が必要な場合はAPI Gatewayを利用しましょうということです。（InboundのSecurity Groupが設定できれば最高なんですが..）</p><h2 id="httpハンドラー対応"><a href="#httpハンドラー対応" class="headerlink" title="httpハンドラー対応"></a>httpハンドラー対応</h2><p>AWS Lambdaですが、aws-sdk for Goのお作法にそのまま従うとGoのhttpハンドラーと微妙に使い勝手が異なります。このギャップを吸収するために用いるのが <code>github.com/awslabs/aws-lambda-go-api-proxy</code> で、API Gatewayリクエストをnet/httpのhandlerの形式に変換してくれ、アプリコードとしてはnet/http、Gin、Echoの形式で実装すれば良くなります。</p><p>Lambda Function URLsでも使えるかなと試しました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/awslabs/aws-lambda-go-api-proxy/httpadapter&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(w, <span class="string">&quot;aws labs http adapter response!!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">lambda.Start(httpadapter.New(http.DefaultServeMux).ProxyWithContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>動かしてみます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://ma5pnqdphjf6tvd5xxxxxxxxxxxxxxxx.lambda-url.ap-northeast-1.on.aws/</span><br><span class="line">aws labs http adapter response!!</span><br></pre></td></tr></table></figure><p>そのまま、、、動きましたね。 API Gateway用のアダプターだと思いましたが、Lambda Function URLsでも動きます。</p><p>というのも、ドキュメントを見ると、Lambda Function URLsのリクエスト形式は <strong>API Gatewayペイロードフォーマットv2.0と同じ</strong> だからです。</p><blockquote><p>The request and response event formats follow the same schema as the Amazon API Gateway payload format version 2.0.<br><a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-payloads">https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-payloads</a></p></blockquote><p>そのため、現在API Gateway + Lambda構成で開発しているアプリも、アプリコードとしてはそのまま Lambda Function URLsに移植できますし、同様に <code>awslabs/aws-lambda-go-api-proxy</code> を使っている場合もです。 <code>awslabs/aws-lambda-go-api-proxy</code> を使っていれば、ECSでもAPI Gateway Lambdaでも Lambda Function URLs でもコアなアプリコードは同じにできるので、非常に安心ですね。（ECSはproxyなしで生のHTTPサーバを実行するイメージです）</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li>Lambda Function URLsのタイムアウトは最長15分になり、API Gatewayを経由するときより伸びた</li><li>AWS WAFはつけられないので、ブラウザ経由のアクセス制御は個別に実施する必要がある</li><li>リクエストはAPI Gatewayペイロードフォーマットと同じなので、エコシステムをそのまま流用できる</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">2022.4.30時点でAPI Gatewayの統合のタイムアウトは最大29秒で上限緩和不可。 <a href="https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/limits.html">https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/limits.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">2022.4.30時点でLambda関数タイムアウトは最大15分で上限緩和不可。<a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/gettingstarted-limits.html">https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/gettingstarted-limits.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;TIG DXユニット真野です。2022/04/06にGAになったと発表された、Lambda Function</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="タイムアウト" scheme="https://future-architect.github.io/tags/%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%A6%E3%83%88/"/>
    
    <category term="LambdaFunctionURLs" scheme="https://future-architect.github.io/tags/LambdaFunctionURLs/"/>
    
    <category term="サーバーレス" scheme="https://future-architect.github.io/tags/%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #21 Google Cloud：JSON関数と共に歩む、BigQueryを使った超汎化型データ活用基盤</title>
    <link href="https://future-architect.github.io/articles/20220509a/"/>
    <id>https://future-architect.github.io/articles/20220509a/</id>
    <published>2022-05-08T15:00:00.000Z</published>
    <updated>2022-05-11T02:59:04.835Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、TIGの村田です。<br>本記事では、3月17日に開催された「Future Tech Night #21 Google Cloud: データエンジニア＋MLOps」のセッションサマリと補足事項について触れていきます。</p><p>当日のセッションは2つありましたが、私の記事では「JSON関数と共に歩む、BigQueryを使った超汎化型データ活用基盤」のセッションについて記載します。「Vertex AIによるフルマネージドなMLOps導入」のセッションについては真鍋さんの記事をお待ち下さい。</p><h1 id="スライド-amp-動画"><a href="#スライド-amp-動画" class="headerlink" title="スライド&amp;動画"></a>スライド&amp;動画</h1><p>登壇時の資料および動画がそれぞれ以下にアップロードされています。</p><p><a href="https://speakerdeck.com/mura123yasu/jsonguan-shu-togong-nibu-mu-bigquerywoshi-tutachao-fan-hua-xing-detahuo-yong-ji-pan">JSON関数と共に歩む、BigQueryを使った超汎化型データ活用基盤</a><br><a href="https://www.youtube.com/watch?v=o0oZnX1Ai-k">Future Tech Night #21 Google Cloud: データエンジニア＋MLOps</a></p><h1 id="サマリ"><a href="#サマリ" class="headerlink" title="サマリ"></a>サマリ</h1><p>セッションでは、ビルIoTデータ蓄積基盤の設計開発をユースケースとしてピックアップし、設計における考慮ポイント等についてお話ししました。</p><h2 id="At-least-onceとの付き合い方"><a href="#At-least-onceとの付き合い方" class="headerlink" title="At least onceとの付き合い方"></a>At least onceとの付き合い方</h2><p>Google CloudでのIoTデータ蓄積基盤を構築する際、「データは最終的にBigQueryに格納する」というケースは多く存在すると思います。</p><p>データ格納までの道中でメッセージングサービスを利用することも多く、アーキデザイン時の考慮事項として”QoSとの付き合い方”は欠かせません。</p><img src="/images/20220509a/スクリーンショット_2022-05-06_19.47.04.png" alt="At least onceについて" width="1200" height="669" loading="lazy"><p>今回のアーキテクチャではPub/Subを採用したのですが、Pub/SubはAt least onceのQoSで動作するため、BigQuery到達までの道中で電文が重複してしまう可能性がありました。</p><p>結論としては、BigQueryにてSELECT DISTINCTを利用する方針で、道中の電文重複を許容する形をとりました。</p><p>そのため、Cloud Runで行っていたIoT電文の加工は最小限および冪等に設計し、BigQueryでのSELECT DISTINCTにて”同一レコードである”と確実に判定されるよう考慮しました。</p><h2 id="BigQueryのカラム構造設計とJSON関数"><a href="#BigQueryのカラム構造設計とJSON関数" class="headerlink" title="BigQueryのカラム構造設計とJSON関数"></a>BigQueryのカラム構造設計とJSON関数</h2><p>今回のユースケースでは、データ取得元のデータ構造含めて発展途上かつ今後も頻繁なレイアウト変更が予想されました。そのため、テーブルのカラム構造は極力柔軟な形を目指し設計しました。</p><img src="/images/20220509a/スクリーンショット_2022-05-06_19.55.51.png" alt="BigQueryカラム構造" width="1200" height="668" loading="lazy"><p>添付資料記載の”JSON一括”方式を最終的には採用しました。カラムをキーごとに分割して格納する形はとらず、受け取ったJSONを丸ごと1カラムに格納しました。</p><p>この方式、BigQueryの課金体系を考慮するとベストプラクティスとは言えないのですが、データ量が少ないかつ発展途上である点を考慮して現段階では柔軟な形を採用しました。</p><p>BigQueryの課金はスキャンデータ量に応じた従量課金モデルであり、列単位での課金となるため、”JSON一括”方式にした場合不要なデータのバイト数もスキャンされ、課金の対象となります。もしこの方式を採用する場合にはその点に注意する必要があります。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="Q1-JSON一括方式を採用した際、具体的な性能懸念等はありましたか？"><a href="#Q1-JSON一括方式を採用した際、具体的な性能懸念等はありましたか？" class="headerlink" title="Q1. JSON一括方式を採用した際、具体的な性能懸念等はありましたか？"></a>Q1. JSON一括方式を採用した際、具体的な性能懸念等はありましたか？</h2><p>無かったです。</p><p>というよりも、データ量が少なかったのでそこまで具体的に「遅い！」となるケースは無かったです。理論上はデータ量が増えてくるとチリツモで性能劣化してくるのではないかなと思います。（未検証です）</p><h2 id="Q2-検索キーだけでも固まっていれば、そこを切り出すとコスト削減を見込めるのでは？"><a href="#Q2-検索キーだけでも固まっていれば、そこを切り出すとコスト削減を見込めるのでは？" class="headerlink" title="Q2. 検索キーだけでも固まっていれば、そこを切り出すとコスト削減を見込めるのでは？"></a>Q2. 検索キーだけでも固まっていれば、そこを切り出すとコスト削減を見込めるのでは？</h2><p>おっしゃる通りですね。利活用側の要件が一定見えているのであればそのようなコスト最適化アプローチをとることができたと考えられます。本ケースではデータ蓄積時に利活用側の要件が見えきらず、柔軟な形を採択しました。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>BigQueryの機能に助けられる形で、クイックスタートに適したデータ活用基盤を簡単に構築することができました。JSON関数は非常に便利なのですが、BQのコスト最適化アプローチは念頭に置きつつアーキテクチャデザインおよび処理方式設計を行うことがとても重要だなと感じました。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;こんにちは、TIGの村田です。&lt;br&gt;本記事では、3月17日に開催された「Future Tech Night #21 Google Cloud:</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="BigQuery" scheme="https://future-architect.github.io/tags/BigQuery/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>AWS Glueの開発環境の構築(2022)</title>
    <link href="https://future-architect.github.io/articles/20220428a/"/>
    <id>https://future-architect.github.io/articles/20220428a/</id>
    <published>2022-04-27T15:00:00.000Z</published>
    <updated>2022-04-28T01:19:01.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>昨年の記事<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>でもAWSの公式のDockerイメージを使って環境構築をする内容の記事があるのですが、Glue3.0の公式のDockerイメージがリリースされていたので、そちらを使って再度Glueのローカルでの開発環境構築の記事を書いてみようと思います。</p><p>せっかくなので昨年の記事と少しコードを変えようと思い、AWSの公式ドキュメント<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>に書かれたコードを基に解説します。公式ドキュメントとは、</p><ul><li>docker-compose</li><li>LocalStack</li></ul><p>を使用している点が異なるので、その点でも本記事は参考になると思います。</p><p>本記事で紹介するコードは以下のレポジトリに載せてあります。</p><p><a href="https://github.com/RyujiTamaki/glue-dev-sample">https://github.com/RyujiTamaki/glue-dev-sample</a></p><p>ディレクトリ構成は以下のようになっています。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── spark.conf</span><br><span class="line">├── src</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── sample.py</span><br><span class="line">└── tests</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_sample.py</span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h1><p>本記事ではDockerFileを特に作らず、GlueとLocalStackのDockerイメージをそのまま使用します。</p><p>以下docker-compose.ymlになります。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">glue.dev.s3.local:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">s3.dev</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">localstack/localstack:0.12.8</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVICES=s3</span></span><br><span class="line">      <span class="comment"># dummy configure</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_REGION=ap-northeast-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_OUTPUT=json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_ACCESS_KEY_ID=test</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_SECRET_ACCESS_KEY=test</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">glue.dev.network</span></span><br><span class="line">  <span class="attr">glue.dev.summary:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">glue.dev</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">amazon/aws-glue-libs:glue_libs_3.0.0_image_01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/home/glue_user/workspace/jupyter_workspace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./spark.conf:/home/glue_user/spark/conf/spark-defaults.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DISABLE_SSL=true</span></span><br><span class="line">      <span class="comment"># dummy configure</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_REGION=ap-northeast-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_OUTPUT=json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_ACCESS_KEY_ID=test</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_SECRET_ACCESS_KEY=test</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># jupyterlabのポート</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8888</span><span class="string">:8888</span></span><br><span class="line">      <span class="comment"># spark uiのポート</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4040</span><span class="string">:4040</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">glue.dev.network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/home/glue_user/jupyter/jupyter_start.sh</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">glue.dev.network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">glue.dev.network</span></span><br></pre></td></tr></table></figure><p>以前の記事<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>では <code>jupyter_start.sh</code> をDockerFileでコピーしていましたが、本記事では最初からDockerイメージにある <code>jupyter_start.sh</code> を実行しています。</p><p>また、Glue3.0の公式のDockerイメージにはバグがあり、暗号化を無効にすることで解決することが報告されています<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。そのため <code>spark.conf</code> を用いて <code>/home/glue_user/spark/conf/spark-defaults.conf</code>を上書きしています。</p><p>上書きに使用している <code>spark.conf</code>は以下になります。元からある <code>/home/glue_user/spark/conf/spark-defaults.conf</code> の <code>spark.io.encryption.enabled</code> を <code>false</code>に書き換えています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spark.driver.extraClassPath /home/glue_user/spark/jars/*:/home/glue_user/aws-glue-libs/jars/*</span><br><span class="line">spark.executor.extraClassPath   /home/glue_user/spark/jars/*:/home/glue_user/aws-glue-libs/jars/*</span><br><span class="line">spark.sql.catalogImplementation hive</span><br><span class="line">spark.eventLog.enabled  true</span><br><span class="line">spark.history.fs.logDirectory   file:////tmp/spark-events</span><br><span class="line">spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version    2</span><br><span class="line">spark.hadoop.mapreduce.fileoutputcommitter.marksuccessfuljobs   false</span><br><span class="line">spark.unsafe.sorter.spill.read.ahead.enabled    false</span><br><span class="line">spark.network.crypto.enabled    true</span><br><span class="line">spark.network.crypto.keyLength  256</span><br><span class="line">spark.network.crypto.keyFactoryAlgorithm    PBKDF2WithHmacSHA256</span><br><span class="line">spark.network.crypto.saslFallback   false</span><br><span class="line">spark.authenticate  true</span><br><span class="line">spark.io.encryption.enabled false</span><br><span class="line">spark.io.encryption.keySizeBits 256</span><br><span class="line">spark.io.encryption.keygen.algorithm    HmacSHA256</span><br><span class="line">spark.authenticate.secret       62e100c5-5281-4030-992b-1f60391ed508</span><br></pre></td></tr></table></figure><h1 id="Glueジョブのサンプルコードとテストコード"><a href="#Glueジョブのサンプルコードとテストコード" class="headerlink" title="Glueジョブのサンプルコードとテストコード"></a>Glueジョブのサンプルコードとテストコード</h1><p>AWSの公式ドキュメント<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>に書かれているサンプルコードを用います。</p><p>サンプルコードは以下です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"><span class="keyword">from</span> awsglue.job <span class="keyword">import</span> Job</span><br><span class="line"><span class="keyword">from</span> awsglue.utils <span class="keyword">import</span> getResolvedOptions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GluePythonSampleTest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        params = []</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;--JOB_NAME&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">            params.append(<span class="string">&#x27;JOB_NAME&#x27;</span>)</span><br><span class="line">        args = getResolvedOptions(sys.argv, params)</span><br><span class="line"></span><br><span class="line">        self.context = GlueContext(SparkSession.builder.getOrCreate())</span><br><span class="line">        self.job = Job(self.context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;JOB_NAME&#x27;</span> <span class="keyword">in</span> args:</span><br><span class="line">            jobname = args[<span class="string">&#x27;JOB_NAME&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            jobname = <span class="string">&quot;test&quot;</span></span><br><span class="line">        self.job.init(jobname, args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        dyf = read_json(self.context, <span class="string">&quot;s3://awsglue-datasets/examples/us-legislators/all/persons.json&quot;</span>)</span><br><span class="line">        dyf.printSchema()</span><br><span class="line"></span><br><span class="line">        self.job.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_json</span>(<span class="params">glue_context, path</span>):</span><br><span class="line">    dynamicframe = glue_context.create_dynamic_frame.from_options(</span><br><span class="line">        connection_type=<span class="string">&#x27;s3&#x27;</span>,</span><br><span class="line">        connection_options=&#123;</span><br><span class="line">            <span class="string">&#x27;paths&#x27;</span>: [path],</span><br><span class="line">            <span class="string">&#x27;recurse&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">format</span>=<span class="string">&#x27;json&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> dynamicframe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    GluePythonSampleTest().run()</span><br></pre></td></tr></table></figure><p>S3に置かれたJSONファイルをDynamicFrameに読み込む処理をしています。<br>こちらのサンプルに対するテストコードが以下となります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"><span class="keyword">from</span> awsglue.job <span class="keyword">import</span> Job</span><br><span class="line"><span class="keyword">from</span> awsglue.utils <span class="keyword">import</span> getResolvedOptions</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> src <span class="keyword">import</span> sample</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;module&quot;</span>, autouse=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">glue_context</span>():</span><br><span class="line">    sys.argv.append(<span class="string">&#x27;--JOB_NAME&#x27;</span>)</span><br><span class="line">    sys.argv.append(<span class="string">&#x27;test_count&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = getResolvedOptions(sys.argv, [<span class="string">&#x27;JOB_NAME&#x27;</span>])</span><br><span class="line">    sc = SparkSession.builder.getOrCreate()</span><br><span class="line">    sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.endpoint&quot;</span>, <span class="string">&quot;http://glue.dev.s3.local:4566&quot;</span>)</span><br><span class="line">    sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.path.style.access&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.signing-algorithm&quot;</span>, <span class="string">&quot;S3SignerType&quot;</span>)</span><br><span class="line">    sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.change.detection.mode&quot;</span>, <span class="string">&quot;None&quot;</span>)</span><br><span class="line">    sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.change.detection.version.required&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    context = GlueContext(sc)</span><br><span class="line">    job = Job(context)</span><br><span class="line">    job.init(args[<span class="string">&#x27;JOB_NAME&#x27;</span>], args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span>(context)</span><br><span class="line"></span><br><span class="line">    job.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_counts</span>(<span class="params">glue_context</span>):</span><br><span class="line">    dyf = sample.read_json(glue_context, <span class="string">&quot;s3://awsglue-datasets/examples/us-legislators/all/persons.json&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> dyf.toDF().count() == <span class="number">1961</span></span><br></pre></td></tr></table></figure><p>公式のドキュメントのコードとは以下の設定を加えている箇所が異なります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sc = SparkSession.builder.getOrCreate()</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.endpoint&quot;</span>, <span class="string">&quot;http://glue.dev.s3.local:4566&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.path.style.access&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.signing-algorithm&quot;</span>, <span class="string">&quot;S3SignerType&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.change.detection.mode&quot;</span>, <span class="string">&quot;None&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.change.detection.version.required&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br></pre></td></tr></table></figure><p>以前のAWS Glueの単体テスト環境の構築手順<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>でも紹介されている設定に加えて、change.detectionを無効にする設定もしています。これはサードパーティのS3実装に対してはS3の変更の検知がうまくできないためです<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。ローカルでのテストにはLocalStackを用いるため、change.detectionを無効にしています。</p><h1 id="動作確認"><a href="#動作確認" class="headerlink" title="動作確認"></a>動作確認</h1><p>以下コマンドでDockerを起動します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up --build</span><br></pre></td></tr></table></figure><p>Glue用のコンテナとLocalStack用のコンテナが立ち上がります。<br><code>http://127.0.0.1:8888</code> にブラウザでアクセスすると、JupyterLabが起動していることが確認できます。</p><img src="/images/20220428a/スクリーンショット_2022-04-03_16.24.58.png" alt="JupyterLab" width="1200" height="905" loading="lazy"><p>次にテストを実行してみましょう。<br>Dockerが起動していれば、以下コマンドでglue.devコンテナに入れます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it glue.dev bash</span><br></pre></td></tr></table></figure><p><code>/home/glue_user/workspace/jupyter_workspace</code> にマウントしたファイルがあることが確認できます。<br><img src="/images/20220428a/スクリーンショット_2022-04-03_16.28.33.png" alt="マウント結果" width="1036" height="282" loading="lazy"></p><p>テストに使用するJSONファイル <code>s3://awsglue-datasets/examples/us-legislators/all/persons.json</code> をローカルにコピーします。</p><p>Dockerコンテナ内で以下コマンドを実行し、LocalStackのS3に格納します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ aws s3 mb s3://awsglue-datasets --endpoint-url http://glue.dev.s3.<span class="built_in">local</span>:4566</span><br><span class="line">$ aws s3 <span class="built_in">cp</span> /path/to/persons.json s3://awsglue-datasets/examples/us-legislators/all/ --endpoint-url http://glue.dev.s3.<span class="built_in">local</span>:4566</span><br></pre></td></tr></table></figure><p>jupyter_workspace配下で以下のコマンドを実行することにより、pytestが実行できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pytest tests/</span><br></pre></td></tr></table></figure><p>以下実行結果です。<br><img src="/images/20220428a/スクリーンショット_2022-04-03_16.37.16.png" alt="pytest結果" width="1200" height="275" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeprecationWarning: Deprecated in 3.0.0. Use SparkSession.builder.getOrCreate() instead.</span><br></pre></td></tr></table></figure><p>上記Warningが出ていますが、テストがパスできたことを確認できました。<br>テスト実行中に <code>http://127.0.0.1:4040/</code> にブラウザでアクセスすると、Spark UIを確認できます。</p><img src="/images/20220428a/スクリーンショット_2022-04-03_16.40.41.png" alt="Spark UI" width="1200" height="573" loading="lazy"><p>Jobの調査に便利です。ただ、自分が使ってみたところ少し不安定なところもありました。今後の改善に期待です。</p><p>以上で開発環境構築の紹介を終わります。以降はsrc/以下にGlueジョブのスクリプトを作成、tests/以下にGlueジョブのテストを追加、としていくといいと思います。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>dockerを再起動すると以下のようなエラーが出ます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glue.dev             | PermissionError: [Errno 13] Permission denied: &#x27;/home/glue_user/.jupyter/migrated&#x27;</span><br></pre></td></tr></table></figure><p>根本解決になっていなくて恐縮ですが、一度 <code>docker compose rm</code> で停止済みのコンテナを削除すると次の <code>docker compose up</code>では上記のエラーが出ずにJupyter Labが立ち上がるようになります。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>本記事では最新のGlue3.0のDockerイメージを使って、ローカルでの環境構築を紹介しました。<br>Sparkの設定を変える箇所がハマりどころだと思うので、参考になれば幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><a href="https://future-architect.github.io/articles/20210521a/">https://future-architect.github.io/articles/20210521a/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-libraries.html">https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-libraries.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;"><a href="https://github.com/awslabs/aws-glue-libs/issues/128">https://github.com/awslabs/aws-glue-libs/issues/128</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="vertical-align: top; padding-right: 10px;">4.</span><span style="vertical-align: top;"><a href="https://future-architect.github.io/articles/20191206/">https://future-architect.github.io/articles/20191206/</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="vertical-align: top; padding-right: 10px;">5.</span><span style="vertical-align: top;"><a href="https://hadoop.apache.org/docs/r3.3.1/hadoop-aws/tools/hadoop-aws/index.html#Handling_Read-During-Overwrite">https://hadoop.apache.org/docs/r3.3.1/hadoop-aws/tools/hadoop-aws/index.html#Handling_Read-During-Overwrite</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;昨年の記事&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot;</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Glue" scheme="https://future-architect.github.io/tags/Glue/"/>
    
    <category term="環境構築" scheme="https://future-architect.github.io/tags/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/"/>
    
    <category term="LocalStack" scheme="https://future-architect.github.io/tags/LocalStack/"/>
    
    <category term="DockerCompose" scheme="https://future-architect.github.io/tags/DockerCompose/"/>
    
    <category term="JupyterNotebook" scheme="https://future-architect.github.io/tags/JupyterNotebook/"/>
    
  </entry>
  
  <entry>
    <title>インフラからアプリ領域にチャレンジした話</title>
    <link href="https://future-architect.github.io/articles/20220427a/"/>
    <id>https://future-architect.github.io/articles/20220427a/</id>
    <published>2022-04-26T15:00:00.000Z</published>
    <updated>2022-05-11T02:59:51.062Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20220427a/change-g898fb62db_640.jpg" alt="" width="640" height="426"><p>こんにちは。TIGの伊藤です。この記事は<a href="/articles/20220418a">春の入門連載2022</a>の8日目の記事です。<br>この連載は「新年度新しいことに取り組んでみる」ということも目的やテーマとして取り上げていますが、そんな私は新年明けてから3月末までアプリ領域に取り組んでみた、という内容を取り上げてみようと思います。<br>未知の領域に入門するとき、どうしても点になりがちな知識たちをつなげるためにどうしたか？みたいなところを読んでいただけると幸いです。</p><h2 id="これまでの私の遍歴"><a href="#これまでの私の遍歴" class="headerlink" title="これまでの私の遍歴"></a>これまでの私の遍歴</h2><p>前職に新卒で入社してはじめてエンジニアになりました。その頃は、エンジニアにもインフラとかフロントエンドとかあったことを全く知らずに、日々案件の仕事をこなしていました。前職ではRuby on Railsを取り扱っており、それに関わるフロントからインフラまで触れたのはいい経験でした。そんなこんなで、これまででアプリは全くの未経験というわけではないです。とはいえ、結構前の出来事であったり、その当時はインフラの方がより興味があったため、転職を機にインフラ領域を主軸として仕事をしています。<br>インフラを仕事にしてからは、コードと呼ばれるものはTerraformくらいで、あとはYAMLは書いていました。そんな中、年明けにプロジェクト異動のタイミングが重なり、アプリに挑戦させてもらいました。</p><h2 id="ロールチェンジしたモチベーション"><a href="#ロールチェンジしたモチベーション" class="headerlink" title="ロールチェンジしたモチベーション"></a>ロールチェンジしたモチベーション</h2><p>私がアプリに手を出したいと思ったきっかけ、モチベーションです。<br>当たり前と言えば当たり前なのですが、インフラだけやっていてもサービスが完成することはもちろんなく、作ったインフラの上にアプリを乗せることで初めてどちらも力を発揮するものだと改めて思っています。車の両輪、とまではいかないですが、インフラの上にアプリを乗せる常がある限りは、</p><ul><li>何がアプリとして乗るのか</li><li>どんなシステムを作るのか</li></ul><p>の視野を広げたいという気持ちでアプリを作れる環境を選びました。<br>このきっかけとは別で、以前所属していたプロジェクトでクラウドリフトをやっていた時に、既存のアプリへの理解が深くできなかったために、踏み入れられないエリアがあったためでもあります。</p><h2 id="ロールチェンジしてやっていたこと"><a href="#ロールチェンジしてやっていたこと" class="headerlink" title="ロールチェンジしてやっていたこと"></a>ロールチェンジしてやっていたこと</h2><p>アプリをやり始めたときは、プロジェクトとしてGoを取り入れるタイミングで参画したので、数日Goを勉強する時間をいただいて、アウトプットとして簡単なCLIを作りました。<br>また、チームで開発するための共通認識としてGoDocの書き方をまとめて説明もしたり、エディタの設定の統一など開発の基準を設けることもやりました。幸いにもフューチャーには、先日発売された<a href="https://www.oreilly.co.jp/books/9784873119694/">「実用Go言語」</a>を執筆する方もおり、助言をいただきながらしっかり目に基準を設けることができたかと思います。<br>その他は実際にGoのコードを書いてはレビューをもらい、わずかながらですが案件を出る頃には少しだけ感覚を掴むことが出来ました。</p><h2 id="ロールチェンジして思ったこと"><a href="#ロールチェンジして思ったこと" class="headerlink" title="ロールチェンジして思ったこと"></a>ロールチェンジして思ったこと</h2><p>ロールチェンジして改めて肌で感じたことがいくつかあります。</p><h3 id="別領域の開発経験も役に立つ"><a href="#別領域の開発経験も役に立つ" class="headerlink" title="別領域の開発経験も役に立つ"></a>別領域の開発経験も役に立つ</h3><p>言わずもがなといえばそうなのですが、これまでインフラをやって経験したことが役に立ちました。Terraformの理解度は高く、大体の勘所は分かるようになっている一方、俗に言うプログラミング言語はほぼできないので不安はありました。しかし、一定のルールについてはソースコードを書くときの感覚にも生きており、知識が繋がっていることを感じました。</p><h3 id="インフラを意識してアプリを考えられる"><a href="#インフラを意識してアプリを考えられる" class="headerlink" title="インフラを意識してアプリを考えられる"></a>インフラを意識してアプリを考えられる</h3><p>これはバックグラウンドが生きてきた場面ですが、先のモチベーションのところでも書きましたが、自分の領域外のところを意識してものづくりが出来たと思っています。</p><ul><li>どんなインフラの作りになっているか</li><li>性能が悪くなるとどんな影響が起こるか</li></ul><p>など、インフラを理解してアプリの作りを考えられたことは良かったです。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>この記事は本当に新人の方向けになっていると思います。未知の領域に飛び込んだ時、全てを一回リセットして初めてみることもありだと思いますが、意外と技術はつながっているので、点を結ぶように調べていくと効率もよく、より楽しく学べるのかなと思いました。<br>また、ロールチェンジはタイミングあれど、リフレッシュにもなったので、オススメです！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20220427a/change-g898fb62db_640.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;426&quot;&gt;

&lt;p&gt;こんにちは。TIGの伊藤です。この記事は&lt;a</summary>
        
      
    
    
    
    <category term="Culture" scheme="https://future-architect.github.io/categories/Culture/"/>
    
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
    <category term="ロールチェンジ" scheme="https://future-architect.github.io/tags/%E3%83%AD%E3%83%BC%E3%83%AB%E3%83%81%E3%82%A7%E3%83%B3%E3%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>ソフトウェアのバージョンと開発スタイルの関係について</title>
    <link href="https://future-architect.github.io/articles/20220426a/"/>
    <id>https://future-architect.github.io/articles/20220426a/</id>
    <published>2022-04-25T15:00:00.000Z</published>
    <updated>2022-04-26T01:41:56.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>初めまして、TIGに所属している原木と申します。<br>バージョンという言葉を身近に聞いたり、体感することは多いのではないでしょうか？</p><ul><li>霜踏み弱体化前のバージョンでRTAの記録をたたき出したらしいね。最新版ならどんなビルドがおすすめだと思う？(執筆時は三月でした)</li><li>今日新作ゲームが配信されるぞ、帰ったら遊ぶんだ…ネットワーク機能を使うためには”本体の更新が必要です。更新しますか?”</li></ul><p>ソフトウェア開発においてもバージョンは決して避けて通ることはできません。しかし、プログラムにバージョンをつける側に立ってみると、そもそもバージョンとは何なのでしょうか？ふわっと考え出すとわりときりがないと思います。</p><ul><li>バージョンの付け方ってどんなルールがあるのだろうか？</li><li>バージョンをつけるタイミングは？</li><li>バージョンってだいたいどれくらいの期間で上がるのだろう？</li><li>バージョンって1(or0.1)から始めないといけないのか？</li><li>バージョンが何回更新されるまで同じソフトウェアだと言えるのだろうか？</li></ul><p>本記事ではソフトウェア開発において、避けて通ることのできないソフトウェアのバージョンについてそんな疑問に答えていきたいと思います。</p><h1 id="セマンティックバージョニング"><a href="#セマンティックバージョニング" class="headerlink" title="セマンティックバージョニング"></a>セマンティックバージョニング</h1><p>ソフトウェアのバージョンに関する命名規則は、昔から開発者の心をつかんで離さない、ホットトピックの一つです。</p><p><a href="https://en.wikipedia.org/wiki/Software_versioning">Software versioning</a>というウィキペディアの記事を見ると、古今東西、ソフトウェアのバージョン管理方法として様々な手法が試されてきたことがわかります。その中でも、今日特によく目にするのがセマンティックバージョニングです。</p><blockquote><p>コンテナオーケストレーションを実現するKubernetesの最新版となる「<strong>Kubernetes 1.23</strong>」正式版がリリースされました。<br><a href="https://www.publickey1.jp/blog/21/kubernetes_123ipv4v6podapiv2kubelet_cri_api.html">https://www.publickey1.jp/blog/21/kubernetes_123ipv4v6podapiv2kubelet_cri_api.html</a></p></blockquote><blockquote><p>プログラミング言語「Go」の最新版「<strong>Go 1.18</strong>」が、3月15日にリリースされた。<br><a href="https://forest.watch.impress.co.jp/docs/news/1395812.html">https://forest.watch.impress.co.jp/docs/news/1395812.html</a></p></blockquote><p>ソフトウェアのバージョンにおいて、昨今ではこのように小数点を突き抜けてる書き方をよく目にする機会が多いと思います。<br>この表記方法をセマンティックバージョニングといいます。Githubの共同創業者であるTom Preston Werner氏が2010年に提唱し、GitHub上のオープンソースソフトウェア(OSS)等で広く使われるようになりました。</p><p>セマンティックバージョニングでは、 X.Y.Z (Major.Minor.Patch)というフォーマットで書きます。具体的な説明として、Go言語のモジュールにおけるバージョン番号の付け方に関する説明から引用します。</p><p><a href="https://go.dev/doc/modules/version-numbers">https://go.dev/doc/modules/version-numbers</a></p><blockquote><p>リリースされたモジュールは、下図のようにセマンティックバージョンニング・モデルでバージョン番号を付けて公開されます。<br><img src="/images/20220426a/image.png" alt="セマンティックバージョニング" width="512" height="160" loading="lazy"><br>次の表は、バージョン番号の各パーツが、モジュールの安定性と後方互換性をどのように示すかを説明したものです。</p><div class="scroll"><table><thead><tr><th align="left">バージョンの段階</th><th align="left">例</th><th align="left">開発者へのメッセージ</th></tr></thead><tbody><tr><td align="left">開発中</td><td align="left">自動的な疑似バージョン番号 v<strong>0</strong>.x.x</td><td align="left">このモジュールが<strong>まだ開発中であり、不安定であること</strong>を示します。このリリースは、後方互換性や安定性を保証しません。</td></tr><tr><td align="left">メジャーバージョン</td><td align="left">v<strong>1</strong>.x.x</td><td align="left"><strong>後方互換性のない、公開APIの変更</strong>を示します。このリリースは、以前のメジャーバージョンとの後方互換性を保証しません。</td></tr><tr><td align="left">マイナーバージョン</td><td align="left">vx.<strong>4</strong>.x</td><td align="left"><strong>後方互換性のある、公開APIの変更</strong>を示します。このリリースは後方互換性と安定性を保証します。</td></tr><tr><td align="left">パッチバージョン</td><td align="left">vx.x.<strong>1</strong></td><td align="left"><strong>モジュールの公開APIや依存関係に影響を与えない変更</strong>を示します。このリリースは後方互換性と安定性を保証します。</td></tr><tr><td align="left">プレリリースバージョン</td><td align="left">vx.x.x-<strong>beta.2</strong></td><td align="left"><strong>アルファ版やベータ版のような、リリース前のマイルストーンであること</strong>を示します。このリリースは安定性を保証しません。</td></tr></tbody></table></div></blockquote><p>新しいバージョンのソフトウェアを公開した時は、通常パッチを出さないため(ゲームだと即日同時リリースだったりしますが….)、最後のZを省略してX.Yと書くことが多いです。先ほどの例も厳密にはGo 1.18.0、 Kubernetes 1.23.0ですが、最後のパッチバージョンを省略したため、小数点だけど小数点じゃない、そんな見え方になっていたのでした。</p><p>ソフトウェアのバージョンの付け方はセマンティックバージョニングだけではありません。例えばLinuxはかつて、バージョンの末尾が偶数か奇数かによってソフトウェアが安定版か不安定版か(ベータ版、開発版に相当)を示していました。Microsoft Windows Vistaが登場するより前の話です。</p><p>バージョニングに関する長い歴史の中で、なぜセマンティックバージョニングがこれだけ普及したのでしょうか? その理由について、<strong>リリース間隔</strong>と<strong>ソフトウェアをとりまくエコシステム</strong>という二つの視点から探ってみました。</p><h1 id="バージョンとリリースの関係"><a href="#バージョンとリリースの関係" class="headerlink" title="バージョンとリリースの関係"></a>バージョンとリリースの関係</h1><p>プログラミング言語には、前述したGo以外にも、RustやRuby等セマンティックバージョニングを採用、準拠したものが少なくありません。試しにRustのバージョンが1.0以降どのように刻まれてきたかプロットしてみました。</p><img src="/images/20220426a/image_2.png" alt="Rustリリース" width="641" height="296" loading="lazy"><p>等間隔にぎっしりであることがわかりますね。<br>比較材料としてJavaのバージョンヒストリーを並べてみるとその違いがよくわかると思います。</p><img src="/images/20220426a/image_3.png" alt="Javaリリース" width="641" height="296" loading="lazy"><p>なぜRustはこんなバージョンの刻み方をしているのでしょうか？</p><p>その理由はRustのリリースサイクル(あるソフトウェアが改修されて次のバージョンが出る前の間隔)にあります。Rust言語とそのコンパイラは6週間で新しいバージョンがリリースされます。つまり、6週間でバージョンが変わってしまうんですね。</p><p>バージョンを0.1、 0.2と刻んでいって0.9まで来たけれども、まだリリースできないから1.0にはしたくない、そんな状況を思い浮かべてみてください。セマンティックバージョニングならば、高頻度でバージョンが更新されてもバージョン間の違いや互換性を破綻なく表すことが可能です。そんなセマンティックバージョニングの恩恵を受けるのは、実は人ではなく機械側なのかもしれません。</p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span>  <p>一年間に8回以上バージョンが変わるRustのバージョンヒストリーが人間にとってわかりやすいかというと正直微妙だと思います。"これらを振り返って、「Rust 1.10とRust 1.31を比較すると、すごく変わったねえ！」などとリリースごとに言うのは難しいです。" そこで、**エディション**というさらに視野を広げたパッケージ管理のバージョン単位がRustでは採用されています。</p>  <p><a href="https://doc.rust-jp.rs/book-ja/appendix-05-editions.html">https://doc.rust-jp.rs/book-ja/appendix-05-editions.html</a></p></div><h1 id="エコシステムを支えるセマンティックバージョニング"><a href="#エコシステムを支えるセマンティックバージョニング" class="headerlink" title="エコシステムを支えるセマンティックバージョニング"></a>エコシステムを支えるセマンティックバージョニング</h1><p>昨今のソフトウェアは単一のリポジトリのソースコードからビルドできないこと、実行できないことは珍しくありません。ライブラリを管理しているパッケージマネージャーからダウンロードしたシステムモジュールパッケージ(ライブラリ)であったり、ビルドを行うためのパラメータやテスト環境が組み込まれたビルド用のパイプラインであったり、様々なサービス、別のソフトウェアに支えられてできています。ソフトウェアを取り巻く環境を生態系に例えてエコシステムと呼ぶことがあります。</p><p>このエコシステムにおいて、セマンティックバージョニングは重要な役割を果たしています。</p><p>iOSのネイティブアプリケーション作成などで利用されるプログラミング言語、Swift(金融制裁の方ではなく)のパッケージマネージャーツールであるSwift Package Managerの<a href="https://github.com/apple/swift-package-manager/tree/main/Documentation">README.md</a>を見ると、このバージョン指定を雑に行った結果、”依存性地獄(Dependency Hell)”に陥ってしまったユーザーシナリオが紹介されています。</p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span>  <p>OSS全盛期の昨今、アプリケーションがとあるライブラリを呼び出し、そのライブラリがまた別のライブラリを呼び出し...とマトリョーシカみたいになっていることは珍しくありません。このソフトウェアが動くために別のライブラリが必要な状況を 依存関係(Dependency) と呼びます。ライブラリがお互いに依存関係を持つとどうなってしまうでしょうか？身動きが取れませんよね。立派な依存地獄の完成です。(このケースだけを指して循環参照なんていうこともあります)</p></div><p>その一つにバージョンの固定があります。意外に思われるかもしれませんが、ライブラリのバージョンをガチガチに固定することはあまり望ましくありません。</p><p>例えば、文字を解析するライブラリであるパーサーがあったとしましょう。このパーサーを利用する、ログ出力ライブラリとファイル解析ライブラリを組み込んだアプリケーションを開発します。</p><p>しかし、問題が発覚しました。ログ解析のライブラリを作ったときはパーサーv2.0.1が最新で、ファイル処理のライブラリを作ったときにはパーサーv2.0.2が最新だったので、最新のバージョンを指定したのですが、二つのライブラリを同時に使うことを想定していなかったのです。この場合、パーサーはどちらのバージョンを指定すればいいでしょうか？</p><img src="/images/20220426a/ライブラリ依存ツリー1.svg" alt="ライブラリ依存ツリー1" width="606" height="208" loading="lazy"><p>めんどくさいし、二つのバージョンのパーサーをいれてビルドしてしまえ…アプリケーションでエラーが起きました。v2.0.1とv2.0.2はほとんどのソースコードが一緒なので、メソッド名やクラス名が重複してしまったからです。</p><img src="/images/20220426a/ライブラリ依存ツリー2.svg" alt="ライブラリ依存ツリー2" width="585" height="206" loading="lazy"><p>これに対する解決策の一つとしてセマンティックバージョニングの活用があります。機能やIFといった大まかに変わらない範囲内でバージョンをゆるーく設定することで依存性地獄を回避することができます。</p><p>Swift Package Managerで、v2.0.0~v2.0.1までのバージョンで最新のライブラリを指定する方法を下記に示します。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package <span class="operator">=</span> <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">&quot;Parser&quot;</span>,</span><br><span class="line">    <span class="comment">// いろいろな書き方があります</span></span><br><span class="line">    dependencies:</span><br><span class="line">        <span class="comment">// v2.0.0以上v2.1.0未満の最新バージョンを指定する</span></span><br><span class="line">        .<span class="type">Package</span>(url: <span class="string">&quot;git@github.com:foo/ParserPackage1.git&quot;</span>, versions: <span class="string">&quot;2.0.0&quot;</span><span class="operator">..&lt;</span><span class="string">&quot;2.1.0&quot;</span>)</span><br><span class="line">        <span class="comment">// メジャーバージョン2, マイナーバージョン0に合致する最新バージョンを指定する</span></span><br><span class="line">        .<span class="type">Package</span>(url: <span class="string">&quot;git@github.com:foo/ParserPackage2.git&quot;</span>, majorVersion: <span class="number">2</span>, minor: <span class="number">0</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="開発時とリリース時"><a href="#開発時とリリース時" class="headerlink" title="開発時とリリース時"></a>開発時とリリース時</h1><p>今までセマンティックバージョニングについて説明してきましたが、ソフトウェアがリリースされた後につけるバージョンを前提に話を進めてきました。</p><p>日常的に目にするソフトウェアは、テストがちゃんと行われて動くようになったから一般的に広く使っていいよということが保障されています。これをGA版(General Availability)といいます。</p><p>GAがあるのであれば、当然GAじゃない、開発途中に対する呼び名もあります。</p><blockquote><p>アプリケーションソフトウェアの開発は、さまざまな状態／段階を経て完成します。<br>その段階／状態と、リリース後の状態／段階を示したのが、バージョン表記です。<br>Pre-Alpha（Nightly Build）<br>Alpha<br>Beta<br>RC（Release Candidate）<br>RTM（Release to Manufacturing）または、GM（Golden Master）<br>GA（General Availability）<br><a href="https://atmarkit.itmedia.co.jp/ait/articles/1003/26/news106.html">https://atmarkit.itmedia.co.jp/ait/articles/1003/26/news106.html</a></p></blockquote><p>リリース時とは異なり、リリースするまでの開発時につけるバージョンはセマンティックバージョニングに完全に従うよりも、開発現場の都合を優先することが多いと個人的に思います。</p><p>筆者が以前お世話になっていたところでは、Kubernetes環境で動くコンテナイメージのバージョンについて開発中は、カレンダーの日付とgitのコミットのハッシュ値を組み合わせたものを使用していました。</p><p>コンテナイメージをpushするためのコンテナイメージレジストリを定期的に掃除して、ストレージ容量を抑える必要があったのですが、カレンダーの日付が先頭にあれば古いものを消すときに指定が楽だったからです。</p><p>もちろん、セマンティックバージョニングの枠組みでバージョンを運用することもあります。</p><p>例えば前述したRustでは、<code>stable</code>というバージョン以外に<br><code>nightly</code>ビルドという毎日その日の夜に毎晩ビルドしたバージョンと<br><code>beta</code>ビルドという次のリリース機能がお試しで入ったバージョンがあります。<br>セマンティックバージョニングのプレリリースバージョンに続けて<br>ソースコードのリリース日とgitのハッシュ値が表示されるため、わかりやすいものとなっています。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">soharaki@NOTE:~/work$ rustc --version</span><br><span class="line">rustc 1.59.0 (9d1b2106e 2022-02-23)</span><br><span class="line"></span><br><span class="line">soharaki@NOTE:~/work$ rustc --version</span><br><span class="line">rustc 1.60.0-beta.6 (7bccde197 2022-03-22)</span><br><span class="line"></span><br><span class="line">soharaki@NOTE:~/work$ rustc --version</span><br><span class="line">rustc 1.61.0-nightly (1d9c262ee 2022-03-26)</span><br></pre></td></tr></table></figure><h1 id="開発プロセスとバージョンの関係"><a href="#開発プロセスとバージョンの関係" class="headerlink" title="開発プロセスとバージョンの関係"></a>開発プロセスとバージョンの関係</h1><p>ソフトウェアをどういう過程で開発し、リリースするか？この一連の流れを開発プロセスといいます。アジャイルやウォーターフォールは開発プロセスの具体的なやり方の一つです。</p><p>この開発プロセスとバージョンには大きくかかわりがあります。</p><p>例えば、 ECMAScript（エクマスクリプト）の略称で知られる、JavaScriptの標準規格があります。このECMAScript、途中まではES1, ES2, というバージョン表記でしたが途中で名前がES2015, ES2016という風に名前が変わりました。</p><p>バージョンのタイムラインをここで見てみましょう。</p><img src="/images/20220426a/image_4.png" alt="ECMAScriptリリース" width="641" height="296" loading="lazy"><p>バージョン間隔が飛び飛びですが2015年を境にほぼ等間隔になっていることがわかります。</p><p>現在のECMAScriptはTC39という専門委員会が新しい仕様を一年かけてブラッシュアップして、その上の組織にあたるEcma Internationalが一年に一回、総会(General Assembly)にて採択しています。しかし、かつては様々な混乱があり、採択できないことが多々ありました。一年に一回、ちゃんと仕様書として出せるように策定プロセスが整ったのは2015年のことです。それ以降、ES2016、ES2017..と年がバージョン名として採用されるようになりました。</p><p>最新版のES2021/2022については、柏木さんが詳しく解説しています。<br><a href="https://future-architect.github.io/articles/20210617a/">https://future-architect.github.io/articles/20210617a/</a></p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span>  <p>ES4は意見がまとまらず途中で放棄されたため、仕様書はドラフト版しか存在しません。</p></div><br><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span>  <p>前述のJava(JDK)もある時期を境に開発プロセス、リリースの間隔を変更しています。</p>  <p><a href="https://www.oracle.com/jp/technical-resources/article/java/ja-topics/jdk-release-model.html">https://www.oracle.com/jp/technical-resources/article/java/ja-topics/jdk-release-model.html</a></p></p></div><p>ソフトウェアや開発体制が成熟したことで、バージョンアップが遅くなったソフトウェアもあれば、早くなったソフトウェアもあります。例えば、Rustは実は開発当初、12週間のリリースサイクルを採用していました。ですが、GA版を迎えたことで、変化を迎えます。</p><p>Rustをより早いスピードで機能開発し、同時に安定性を求めるため「リリーストレイン」という開発手法を採用しました。</p><p>…その結果、Rustは6週間!!という間隔でバージョンアップを行うようになります。<br><a href="https://rust-lang.github.io/rfcs/0507-release-channels.html">https://rust-lang.github.io/rfcs/0507-release-channels.html</a></p><p>「リリーストレイン」では数週間から数か月という短い時間の中で、決まった期間にソフトウェアのリリースを行っていきます。「リリーストレイン」自体が安定した定期的なリリースを実現するための手法ではありますが、なぜRustではより短い時間間隔を採用したのでしょうか？</p><h1 id="ソフトウェアの更新頻度と人気の関係"><a href="#ソフトウェアの更新頻度と人気の関係" class="headerlink" title="ソフトウェアの更新頻度と人気の関係"></a>ソフトウェアの更新頻度と人気の関係</h1><p>OSSの人気を集める上で、バージョン更新の頻度自体が欠かせない要素かもしれません。</p><p>ここにGitHub上のJaraライブラリをベースに、バージョン更新がAPIの互換性、そしてライブラリを利用するユーザーにどれくらい影響を与えているかを調べた2017年の調査論文があります。</p><p><a href="https://ieeexplore.ieee.org/document/7884616">Historical and Impact Analysis of API Breaking Changes: A Large-Scale Study</a></p><p>この論文によると、実世界の317のJavaライブラリ、9000のリリース、26万のクライアントアプリケーションを対象とした大規模な分析により、<br>(i) API変更の14.78%は旧バージョンとの互換性を破壊していること<br>(ii) API変更の破壊頻度は時間とともに増加すること<br>(iv) API変更の破壊頻度が高いシステムほど大規模、人気、活発であること<br>などがわかったそうです。</p><p>要はバージョン更新の頻度が大きく修正を要求されるソフトウェアほど、より利用者に人気であり、開発に協力してくれる人も集めていたというものです。変化し続けるマインドを持つOSSがプロジェクトもコミュニティも成長することができると言いきっていいのかもしれません。</p><p>逆に言えば、ソフトウェアを安定的に塩漬けしたい、そういった作業に従事していただける開発者をOSSにおいて求めるのは、文化的にも人材的にも難しいという現実があります。</p><p>例えば、Go言語の父とも呼ばれるRob Pike氏は、Go言語にLTSがほしいというissueに対して次の通り回答しています。</p><blockquote><p>また、ソフトウェアのビルドに必要なライブラリやその他の依存物の一式をサポートする必要があります。今なら、1.16からのコアライブラリが古いコンパイラで引き続きコンパイルされ、正しく動作することを期待するのは、大きな要求ではありますが、妥当なことかもしれません。しかし、それにはサポートを継続することに同意する貢献者文化も必要です。それを実現するのはかなり難しいようです。<br><a href="https://github.com/golang/go/issues/47942#issuecomment-905184706">https://github.com/golang/go/issues/47942#issuecomment-905184706</a></p></blockquote><img src="/images/20220426a/image_5.png" alt="Goリリース" width="641" height="296" loading="lazy"><h1 id="バージョン更新が当たり前の世界で守りたい約束"><a href="#バージョン更新が当たり前の世界で守りたい約束" class="headerlink" title="バージョン更新が当たり前の世界で守りたい約束"></a>バージョン更新が当たり前の世界で守りたい約束</h1><blockquote><p>semver(セマンティックバージョニングのこと)は実際のところ、<br>メジャーバージョンアップ: 「おそらく多くの場所でコードの更新が必要になるだろう」、<br>マイナーバージョンアップ: 「ほとんどの部分で常に問題がないはずだ」<br>ということを意味します。</p><p><a href="https://github.com/microsoft/TypeScript/issues/14116#issuecomment-292581018">https://github.com/microsoft/TypeScript/issues/14116#issuecomment-292581018</a><br>※なぜTypeScriptはセマンティックバージョニングを採用しないのか？という質問に対する中の人の解答</p></blockquote><p>セマンティックバージョニングを単純に採用するだけでは、ソフトウェアの安定性や互換性を担保するものにはなりません。コンベンショナルコミットといったソースコードの修正をわかりやすくするコメントの書き方であったり、ビルドパイプラインでテストをなるべく自動化することで意図しない破壊的な修正=デグレを防ぐような仕組みが別途必要です。</p><p>それらの仕組みを設けてセマンティックバージョニングに準じようとしていても開発の過程でマイナーバージョン更新によって今まで使えていたAPIが使えなくなるといったことはあります<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>…ですが、そういった修正を繰り返すと利用者側(開発者も含む)の信用は当然すり減っていきます。</p><p>「メジャーバージョンが変わらないから、影響はそんなにないと思っていたのに…」</p><p>バージョンをパッと見たときのユーザーの暗黙的な期待値を下げないための工夫の一つとして、メジャーバージョンが同じ間は、最低限この機能は影響が及ばないように品質を保証しますといったことをドキュメント化する手立てがあります。</p><p>例えばクラウドの構築などで利用されるTerraformでは”Terraformv1.0の互換性の約束”として、メジャーバージョンが1の間、互換性を維持する内容について明文化しています。<br><a href="https://www.terraform.io/language/v1-compatibility-promises">https://www.terraform.io/language/v1-compatibility-promises</a></p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>ソフトウェアのバージョンの付け方について、主にセマンティックバージョニングを中心に開発手法を交えて説明しました。</p><ul><li>バージョンの付け方ってルールがあるのだろうか？<ul><li>セマンティックバージョニング等、様々な種類があります。</li><li><a href="https://en.wikipedia.org/wiki/Software_versioning">https://en.wikipedia.org/wiki/Software_versioning</a> の内容が非常に詳しいです</li></ul></li><li>バージョンをつけるタイミングは？<ul><li>開発時～リリースまで目的に応じた様々な段階があります。</li></ul></li><li>バージョンってだいたいどれくらいの期間で上がるのだろう？<ul><li>開発を行うプロジェクトがどういった開発手法を採用しているかによります</li><li>人気のあるOSSは「リリーストレイン」と呼ばれるリリース期間を固定した方法を取っているところが多いようです。だいたい1ヵ月～6か月でマイナーバージョンが上がります。</li></ul></li><li>バージョンって1(or0.1)から始めないといけないのか？<ul><li>セマンティックバージョニングに従えば、0.1.0から開発版をリリースして、マイナーバージョンを上げていけばいいと一般的に言われています</li><li>セマンティックバージョニングに従うのでなければ、開発者の気持ち次第です。</li></ul></li></ul><p>ソフトウェアやサービスの開発現場に配属後、バージョンを意識し、時には互換性といった問題で悩む機会は多々あると思います。本記事はそういったトラブルを具体的に解決するものではありませんが、そういったルールで回ってるんだと頭の片隅にあれば、問題を意識しやすいのではないでしょうか。</p><p>少しでもお力になれば幸いです。</p><h1 id="閑話休題-最初のバージョンは1から？"><a href="#閑話休題-最初のバージョンは1から？" class="headerlink" title="閑話休題: 最初のバージョンは1から？"></a>閑話休題: 最初のバージョンは1から？</h1><p>バージョンが1.0になるとテストがちゃんと行われて動くようになったから一般的に広く使っていいよということが慣例で決まっています。これをGA版(General Availability)といいます。<br>ですが、SuSE Linux(Jurixベース版)の最初のリリースのバージョンは4.2でした。これはSF小説「銀河ヒッチハイク・ガイド」をフィーチャーしたものです。<br><a href="https://en.opensuse.org/S.u.S.E._Linux_4.2">https://en.opensuse.org/S.u.S.E._Linux_4.2</a></p><h1 id="閑話休題-一見セマンティックバージョニングっぽいけど…"><a href="#閑話休題-一見セマンティックバージョニングっぽいけど…" class="headerlink" title="閑話休題: 一見セマンティックバージョニングっぽいけど…"></a>閑話休題: 一見セマンティックバージョニングっぽいけど…</h1><p>TypeScriptは型の構文を備えたJavaScriptであり、Webアプリケーションの開発などで活躍しているプログラミング言語です。<br>TypeScriptのバージョンは一見するとセマンティックバージョニングに見えます</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soharaki@NOTE:~/work/example-20220328$ tsc --version</span><br><span class="line">Version 4.6.3</span><br></pre></td></tr></table></figure><p>ですが、実態は十進数的なdecimal versioningです。</p><p><a href="https://twitter.com/teppeis/status/1296672623498149888">https://twitter.com/teppeis/status/1296672623498149888</a></p><img src="/images/20220426a/image_6.png" alt="TypeScriptリリース" width="641" height="296" loading="lazy"><h1 id="閑話休題-バージョンといえば、リリースノート芸も忘れてはなりません"><a href="#閑話休題-バージョンといえば、リリースノート芸も忘れてはなりません" class="headerlink" title="閑話休題: バージョンといえば、リリースノート芸も忘れてはなりません"></a>閑話休題: バージョンといえば、リリースノート芸も忘れてはなりません</h1><p>ソフトウェアのバージョンを上げたとき(リリースした時)、どんな機能を更新したのか？<br>説明する文書をリリースノートといいます。</p><p>企業によっては知られざる文才が密かにその実力を発揮しているようです…<br>例えば、チャットアプリケーションのSlackの履歴を見てみましょう。</p><blockquote><p>Slack 22.03.10 2022年3月14日 新着情報<br>チャンネル参加前にプレビューする際、チャンネル名とともに説明が表示されるようになり、より詳しい情報を得られるようになりました。これなら「#たぬき」が信楽焼のチャンネルなのか、カップ麺の話なのか、それとも策略家の集いなのか、一目瞭然ですね！</p><p>「明日」や「来週」などにリマインダーを設定した場合、その表示時間を選べるようになりました。始業が朝 9 時でない皆さんや、Slackbot のアラートが朝一に飛び込んでくるのがしっくりこない人にぴったりです。「環境設定」&gt;「通知」で、好きな時間をデフォルト設定してください。<br><a href="https://slack.com/intl/ja-jp/release-notes/ios">https://slack.com/intl/ja-jp/release-notes/ios</a></p></blockquote><p>新しくリリースされた機能がユーザーのどういった利用シーンで活躍するのか非常にわかりやすいですね。</p><p>このリリースノートから、Slackは一か月単位で機能をリリースしているリリーストレインスタイルであること、バージョニング方法はカレンダー方式(これはOracle等で採用されている昔からある方式)であることがわかります。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://semver.org/lang/ja/">https://semver.org/lang/ja/</a><ul><li>セマンティックバージョニングのドキュメント</li></ul></li><li><a href="https://azu.github.io/slide/jser200/javascript-2014.html">https://azu.github.io/slide/jser200/javascript-2014.html</a><ul><li>開発プロセスとバージョニングの関係について参考にさせていただきました</li></ul></li><li><a href="https://rust-lang.github.io/rfcs/0507-release-channels.html">https://rust-lang.github.io/rfcs/0507-release-channels.html</a><ul><li>RustがGAしてからもうじき7年か…</li></ul></li><li><a href="https://atmarkit.itmedia.co.jp/ait/articles/1003/26/news106.html">https://atmarkit.itmedia.co.jp/ait/articles/1003/26/news106.html</a><ul><li>セマンティックバージョニングが周知される前の記事ですが、非常に参考になりました</li></ul></li><li><a href="https://en.wikipedia.org/wiki/Software_versioning">https://en.wikipedia.org/wiki/Software_versioning</a><ul><li>ソフトウェアのバージョンについて学びました</li></ul></li><li><a href="https://qiita.com/righteous/items/e5448cb2e7e11ab7d477">https://qiita.com/righteous/items/e5448cb2e7e11ab7d477</a><ul><li>NPMとpackage.jsonについて詳しく説明されています</li></ul></li><li><a href="https://homepages.dcc.ufmg.br/~mtov/pub/2017-saner-breaking-apis.pdf">https://homepages.dcc.ufmg.br/~mtov/pub/2017-saner-breaking-apis.pdf</a><ul><li>APIの更新頻度とコミュニティの活性度の関係について調べた調査論文</li></ul></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><a href="https://ieeexplore.ieee.org/document/6975655">https://ieeexplore.ieee.org/document/6975655</a>JavaのパッケージマネージャーであるMavenで、後方互換性を意識したセマンティックバージョニングをちゃんと行っているライブラリがどれくらいあるのか調べた調査論文</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="設計" scheme="https://future-architect.github.io/tags/%E8%A8%AD%E8%A8%88/"/>
    
    <category term="バージョン管理" scheme="https://future-architect.github.io/tags/%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
