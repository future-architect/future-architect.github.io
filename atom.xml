<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Future Tech Blog - フューチャーアーキテクト</title>
  
  <subtitle>フューチャー開発者ブログ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2019-12-01T03:18:53.670Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <author>
    <name>Future Architect Consultants</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SORACOM USBドングルの自動接続</title>
    <link href="https://future-architect.github.io/articles/20191201/"/>
    <id>https://future-architect.github.io/articles/20191201/</id>
    <published>2019-12-01T03:02:03.000Z</published>
    <updated>2019-12-01T03:18:53.670Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://qiita.com/advent-calendar/2019/future2" target="_blank" rel="noopener">フューチャー2 Advent Calendar 2019</a> の1日目の記事です。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>自動化できる業務ならば極力自動化したいというのは万国共通だとは思います。例えば対象がWebページであれば Selenium によるUI操作自動化が可能ですが、PCにインストールされたGUIアプリに対しては、Webページの「idタグ」に相当するものがなく、UIの自動化は簡単にはできないと考えている方が多いのではないでしょうか。</p><p>このWindowsにインストールされたGUIアプリを「マウスで手動クリック」から「コードで自動操作」に切り替える仕事が業務でありましたので、その手法について紹介します。</p><h2 id="無人化要求"><a href="#無人化要求" class="headerlink" title="無人化要求"></a>無人化要求</h2><p>技術的な可否に関わらず、ニュース等で最新のテクノロジー知識を仕入れた人ならば、「無人化したい/自動化したい」という要求が当然出てきます。それらの試みは技術的に面白いものが多く、エンジニア的には「解決しがいのある課題」だと感じます。</p><p>ただし、「無人化したい/自動化したい」案件では、「無人化/自動化を行うプログラムのメンテナンスを行うという、新しい業務が生まれてしまう」ことがあります。<br>開発側から見れば「全体から見ると総作業量は効率化されるのだから、この新しい作業にはお客様側で担当者をアサインしてほしい」となりますが、お客様側から見ると「既存の業務プロセスに新しい業務を追加することは難しい。可能な限り自動化してほしい」という回答となります。</p><p>この場合、エンジニアは…</p><ol><li>「申し訳ありません。不可能です。」と頭を下げる。</li><li>なんとか解決策を見つけて「課題は解決しました。本件はクローズします。」と報告する。</li></ol><p>…のどちらかだと思います。<br>幸いにも、私が担当したタスクでは「2」で対応できましたので、その際の試みを紹介します。</p><h2 id="工場とクラウドを接続したい。"><a href="#工場とクラウドを接続したい。" class="headerlink" title="工場とクラウドを接続したい。"></a>工場とクラウドを接続したい。</h2><p>あらゆる現場、例えば工場などではIoT化の波があり、あらゆる機器をクラウドとつなげたいニーズがあります。そのようなケースでは、「どのように工場とクラウドをつなぐのか」が鍵となります。というわけで、今回は工場を例にとって紹介します。</p><h3 id="工場とクラウドを阻む最大の壁"><a href="#工場とクラウドを阻む最大の壁" class="headerlink" title="工場とクラウドを阻む最大の壁"></a>工場とクラウドを阻む最大の壁</h3><p>工場現場の機器とインターネットを直接繋ぐのはセキュリティ上よろしくないので、例えば「工場→踏み台PC→クラウド」という構成が考えられます。また、新たに物理的なケーブルを用意するのも大変なので、踏み台PC→クラウドは SORACOM社の提供する USB wi-fi Network Adapter 「NCXX UX302NC-R」という製品を利用してみました。</p><p>NCXX UX302NC-Rとは？</p><blockquote><p>LTE/3G/GSM 対応 USB スティック型データ通信端末です。<br>デバイスへセットすることで、SORACOM の提供する通信環境を利用した無線通信が可能となります。<br><a href="https://soracom.jp/products/module/ux302nc-r/" target="_blank" rel="noopener">参照サイト</a></p></blockquote><p>工場とクラウドを繋ぐ「接続の窓口」として SORACOM USBドングル（NCXX UX302NC-R）を設置したのですが、そのアプリが接続における壁となってしまいました。</p><p>SORACOM USBドングルは、デバイスにセットした段階ではインターネットに接続されず、専用のGUIアプリを立ち上げて「<strong>マウスで接続ボタンをクリックする</strong>」ことでネットに繋がる仕様でした。</p><p>CLI経由による操作は見当たらず、カスタマーセンターに電話で問い合わせても…<br>「<strong>コマンド等による操作は想定しておりません。</strong>Connection Manager（SORACOM USBドングル専用のGUIアプリ）を立ち上げ、接続ボタンをクリックしていただけると幸いです。」<br>…という丁寧な忠告をいただきました。</p><p>つまり、このままでは停電対応などでPCを再起動させるたびに、マウスを手動でクリックするという業務をお客様にお願いする必要がありました。「絶対にその業務はお客様に忘れられるのではないか？むしろ忘れられる自信がある！」ということで、自動化を試みるモチベーションが生まれました。</p><h2 id="マウスによるクリックを自動化する"><a href="#マウスによるクリックを自動化する" class="headerlink" title="マウスによるクリックを自動化する"></a>マウスによるクリックを自動化する</h2><p>WindowsのGUIアプリの操作自動化と言っても大げさなものではなく、</p><ol><li>アプリを立ち上げる</li><li>任意の文字列を入力する</li><li>任意のボタンをクリックする</li></ol><p>…といった程度です。</p><h3 id="作業環境-利用ツール"><a href="#作業環境-利用ツール" class="headerlink" title="作業環境/利用ツール"></a>作業環境/利用ツール</h3><ul><li>Windows 10</li><li>Ruby 2.5.x</li><li>selenium-webdriver 3.142.6</li><li>appium_lib 10.4.1</li><li>WinAppDriver 1.2</li><li>Inspect.exe</li></ul><h3 id="Ruby側の準備"><a href="#Ruby側の準備" class="headerlink" title="Ruby側の準備"></a>Ruby側の準備</h3><p>Gemによるパッケージのインストールと、Ruby設定ファイルの一部を編集をしてください。</p><p>Gemによるインストールコマンド</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem install selenium-webdriver -v 3.142.6</span><br><span class="line">gem install appium_lib -v 10.4.1</span><br></pre></td></tr></table></figure><p>Ruby設定ファイルの編集:</p><p>eventmachine.rbを開き、以下の1文を追加してください。<br>（筆者の環境では以下のパスにありました。）<br><code>C:¥Ruby25-x64¥lib¥ruby¥gems¥2.5.0gems¥eventmachine-1.2.7-x64-mingw32¥lib¥eventmachine.rb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &apos;em/pure_ruby&apos;</span><br></pre></td></tr></table></figure><h3 id="Windows側の準備"><a href="#Windows側の準備" class="headerlink" title="Windows側の準備"></a>Windows側の準備</h3><p>WinAppDriverというドライバと、Inspect.exe というアプリをインストールしてください。</p><ul><li>WinAppDriver (<a href="https://github.com/microsoft/WinAppDriver" target="_blank" rel="noopener">Microsoftの公式リリース</a>)</li><li>Inspect.exe (<a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk" target="_blank" rel="noopener">Microsoftの公式リリース</a>) ※Windows 10 SDK に Inspect.exe が含まれています</li></ul><p>また、WinAppDriver を起動するために、PCを「開発者モード」に変更してください。</p><p>以上により、Ruby・Windowsの事前準備が完了です。<br>ここまで長かったですが、これからGUI操作を自動化するコーディングを開始します。</p><h3 id="自動操作の環境整備"><a href="#自動操作の環境整備" class="headerlink" title="自動操作の環境整備"></a>自動操作の環境整備</h3><p>まずは、自動化したいアプリへの絶対パスを取得しましょう。<br>今回は「SORACOM USBドングル」を自動操作するので、そのGUIアプリまでの絶対パスを記載します。<br>（自動操作したいアプリに合わせて、適宜パスを書き換えてください）</p><figure class="highlight ruby"><figcaption><span>connect.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_path = <span class="string">'C:/Program Files (x86)/UX302NC Data Connection Manager/Main/USB Modem.exe'</span></span><br></pre></td></tr></table></figure><p>また、自動操作は WinAppDriver が担当するので、その起動スクリプトも書いてしまいましょう。</p><figure class="highlight ruby"><figcaption><span>connect.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_driver_cmd = <span class="string">'start "" "C:\Program Files (x86)\Windows Application Driver\WinAppDriver.exe" 127.0.0.1 4723/wd/hub'</span></span><br><span class="line">system(start_driver_cmd)</span><br></pre></td></tr></table></figure><p>次は「ボタンをクリックする」を自動化するために、GUIアプリの「ボタンの要素」を取得します。Webページならば「デベロッパーツール」を使えば ページ内要素のidタグが取得できますが、Windows GUIアプリでは「Inspect.exe」を使います。</p><p>自動操作したいGUIアプリと Inspect.exe を立ち上げ、カーソルをボタン等の上にホバーすれば、その要素名が取得できます。</p><p>ex) SORACOM USBドングルの「接続」ボタンの場合<br>接続ボタンの名前は「接続」だとわかります。それ以外にも IsEnabled（ボタンが押せるか）が true になっていることもわかります。<br><img src="/images/20191201/photo_20191201_01.png"></p><h3 id="実装コード"><a href="#実装コード" class="headerlink" title="実装コード"></a>実装コード</h3><p>以上の作業により</p><ul><li>ドライバの起動コマンド</li><li>GUIアプリへのパス</li><li>GUIアプリ内要素の名前</li></ul><p>が準備できたので、GUI操作を自動化するコードを書きます。</p><figure class="highlight ruby"><figcaption><span>connect.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'selenium-webdriver'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'appium_lib'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ドライバの起動コマンド</span></span><br><span class="line">start_driver_cmd = <span class="string">'start "" "C:\Program Files (x86)\Windows Application Driver\WinAppDriver.exe" 127.0.0.1 4723/wd/hub'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GUIアプリへの絶対パス</span></span><br><span class="line">app_path = <span class="string">'C:/Program Files (x86)/UX302NC Data Connection Manager/Main/USB Modem.exe'</span></span><br><span class="line"></span><br><span class="line">$ConnectorSession</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line">    opts =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">caps:</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="symbol">platformName:</span> <span class="string">"WINDOWS"</span>,</span><br><span class="line">            <span class="symbol">platform:</span> <span class="string">"WINDOWS"</span>,</span><br><span class="line">            <span class="symbol">deviceName:</span> <span class="string">"WindowsPC"</span>,</span><br><span class="line">            <span class="symbol">app:</span> app_path</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $ConnectorSession = Appium::Driver.new(opts, <span class="literal">false</span>).start_driver     <span class="comment"># GUIアプリを起動する</span></span><br><span class="line">    wait = Selenium::WebDriver::Wait.new <span class="symbol">:timeout</span> =&gt; <span class="number">120</span>                 <span class="comment"># GUIアプリからの応答を120秒まで待つ</span></span><br><span class="line"></span><br><span class="line">    wait.<span class="keyword">until</span>&#123; $ConnectorSession.find_element(<span class="symbol">:name</span>, <span class="string">"接続"</span>).enabled? &#125;  <span class="comment"># "接続"ボタンの IsEnabled が true になるまで待つ</span></span><br><span class="line">    $ConnectorSession.find_element(<span class="symbol">:name</span>, <span class="string">"接続"</span>).click()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ドライバを起動する</span></span><br><span class="line">system(start_driver_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GUIアプリを立ち上げ、自動操作を開始する</span></span><br><span class="line">start()</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>今回の実装コードでは</p><ol><li>アプリを立ち上げる</li><li>ボタンが押せるようになるのを待つ</li><li>ボタンを押す<br>という簡単な操作を自動化しました。</li></ol><p>これまでは「UI操作の自動化はWebアプリでのみ可能」と思っていましたが、WinAppDriverとAppiumを使うことで「GUIアプリ操作の自動化も可能」だとわかりました。これにより私自身の「自動化スキルの裾野が広がったこと」は、今後増えるであろう「無人化したい/自動化したい」案件に向けても良い兆候だと感じています。</p><p>以上、長文にお付き合いいただき、ありがとうございました。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://qiita.com/advent-calendar/2019/future2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;フューチャー2 Advent Calendar 2019&lt;/a&gt; の1日目の記事です。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Ruby" scheme="https://future-architect.github.io/tags/Ruby/"/>
    
      <category term="Selenium" scheme="https://future-architect.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>GDG DevFest in 信州2019に登壇しました</title>
    <link href="https://future-architect.github.io/articles/20191129/"/>
    <id>https://future-architect.github.io/articles/20191129/</id>
    <published>2019-11-29T04:58:44.000Z</published>
    <updated>2019-11-29T05:06:23.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG/DXユニットの伊藤です。普段はGCPの開発支援を行なっているインフラエンジニアです。今回は私の地元である長野で開催された<a href="https://gdg-shinshu.connpass.com/event/151084/" target="_blank" rel="noopener">GDG Devfest 信州</a>に参加しました。今回でこちらの勉強会の参加は2回目になるのですが、登壇する機会をいただいたのでその時のことを書いていきます。</p><img src="/images/20191129/photo_20191129_01.jpeg" class="img-small-size"><h2 id="GDG信州について"><a href="#GDG信州について" class="headerlink" title="GDG信州について"></a>GDG信州について</h2><p>本題に入る前に、この勉強会のコミュニティについて少し説明します。Google Developers Groupを略してGDGと呼び、GDG信州は国内10チャプターあるうちの1つになります。他のチャプターは<a href="https://sites.google.com/site/gdgjapan/" target="_blank" rel="noopener">こちら</a>を見てみてください。</p><p>現在はGDG Cloud信州(旧 GCPUG 信州)とオーガナイザーが同じのため、同時開催されていることが多いようです。首都圏ではGCPUGも細分化されている中、ここでは1回の勉強会で幅広い内容が発表されるため、登壇することはもちろん、参加者側としても楽しみでした。</p><h2 id="登壇を決めたモチベーション"><a href="#登壇を決めたモチベーション" class="headerlink" title="登壇を決めたモチベーション"></a>登壇を決めたモチベーション</h2><p>Terraformを当社に入社して以来3ヶ月弱触ってきて、せっかくならTerraformの触りだけでも紹介したい、また人に教える、話すことを通して知識の再確認や新しいことのインプットをしたいと思って登壇を決めました。また、実家に帰るきっかけにしたり、地元のITも盛り上げたい思いがあり、前回は聴く側でしたが今回は登壇することを決めました。</p><h1 id="当日のセッションについて"><a href="#当日のセッションについて" class="headerlink" title="当日のセッションについて"></a>当日のセッションについて</h1><h2 id="登壇内容"><a href="#登壇内容" class="headerlink" title="登壇内容"></a>登壇内容</h2><p>今回は登壇にあたってのモチベーションにも書きましたが、Terraformについての発表をしました。今回はLTで、かつ幅広い方(ネイティブアプリやハード)が参加されることなんとなく考えていました。そのため、まずはGCPを触るきっかけとして、さらにTerraformを使きっかけになるように資料を作りました。以下がその時の資料になります。</p><script async class="speakerdeck-embed" data-id="fea7b09893e0479cb2f4d5a969c43e70" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script><p>内容を要約すると</p><ul><li>Terraformについての説明</li><li>Terraformを使ってGCEインスタンスを立てる<ul><li>設定を変えても冪等性を保てることを確認してもらう</li></ul></li><li>使ってみて便利だった機能<ul><li><code>terraform fmt</code> を使ったコードの整形</li><li>Workspaceを使ってリソース名を変更</li></ul></li></ul><p>になります。そしてこちらが実際の反応です。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">terraform 便利そう。インフラ担当に教えてあげよう　<a href="https://twitter.com/hashtag/GDG%E4%BF%A1%E5%B7%9E?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GDG信州</a> <a href="https://twitter.com/hashtag/devfest19?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#devfest19</a></p>&mdash; GRTN (@GRTN_NXST) <a href="https://twitter.com/GRTN_NXST/status/1198118758948061185?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">November 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/devfest19?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#devfest19</a> <a href="https://twitter.com/hashtag/GDG%E4%BF%A1%E5%B7%9E?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GDG信州</a><br>LT3番目がトップバッターになったterraformの話をkaedemaluさんから <a href="https://t.co/k4KHBPEdZC" target="_blank" rel="noopener">pic.twitter.com/k4KHBPEdZC</a></p>&mdash; GDG信州 (@GDGShinshu) <a href="https://twitter.com/GDGShinshu/status/1198118731253043200?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">November 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>会社に持って帰って共有する、など参加した方からさらに広めていただけるのはとても嬉しいですね。</p><h2 id="その他の勉強会内容"><a href="#その他の勉強会内容" class="headerlink" title="その他の勉強会内容"></a>その他の勉強会内容</h2><p>私が参加した午後からの内容をざっくり紹介します。</p><h3 id="セッション"><a href="#セッション" class="headerlink" title="セッション"></a>セッション</h3><ul><li><a href="https://speakerdeck.com/koda/devfest-in-shinshu-2019-abount-devops-in-gcp" target="_blank" rel="noopener">DevOps環境のの紹介</a><ul><li>言葉としては浸透してきているDevOpsを改めて考える機会になりました。インフラで実際に使える例も示していただいたのでとてもわかりやすかったです。</li></ul></li><li>デバイス＋グーグル：グーグルの技術とDIYのデバイスの繋ぎ方<ul><li>こちらは午前のハンズオンと内容がリンクしたセッションでした。簡単ではありますが、マイコンを使った機械学習の中身等も解説していただきました。</li></ul></li></ul><h3 id="ガジェット品評会"><a href="#ガジェット品評会" class="headerlink" title="ガジェット品評会"></a>ガジェット品評会</h3><p>参加者が持ち寄ったガジェットの品評会を行いました。人によっては昔のガジェットを出展したり、また自作キーボードの数々を並べている方もいました。私も自作キーボードで有名なErgoDoxを時々使うのですが、こういったガジェットを見ると改めて自作も楽しそうだなと思いました。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">いつものレトロPC vs モダンキーボードの構図<a href="https://twitter.com/hashtag/GDG%E4%BF%A1%E5%B7%9E?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GDG信州</a> <a href="https://twitter.com/hashtag/DebFest19?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#DebFest19</a> <a href="https://t.co/5m2GFPQrCQ" target="_blank" rel="noopener">pic.twitter.com/5m2GFPQrCQ</a></p>&mdash; 魔王 (@swan_match) <a href="https://twitter.com/swan_match/status/1198085871397826560?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">November 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/devfest19?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#devfest19</a> <a href="https://twitter.com/hashtag/GDG%E4%BF%A1%E5%B7%9E?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GDG信州</a><br>信州名物のガジェット品評会始まりました！ <a href="https://t.co/MT0qxwvqDP" target="_blank" rel="noopener">pic.twitter.com/MT0qxwvqDP</a></p>&mdash; GDG信州 (@GDGShinshu) <a href="https://twitter.com/GDGShinshu/status/1198112181981593600?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">November 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><h3 id="パネルトーク-災害とIT"><a href="#パネルトーク-災害とIT" class="headerlink" title="パネルトーク 災害とIT"></a>パネルトーク <del>災害とIT</del></h3><p>こちらのセッションでは、まだ皆さんの記憶にも新しい10月の台風の被害から考える、ITをどう災害に用いていくか、また今回の台風では実際に何が役に立ったのかなどを共有していきました。<br>パネルトーク中で話題になったツールは</p><ul><li><a href="https://www.google.org/crisismap/japan?hl=ja&gl=jp" target="_blank" rel="noopener">Google 災害情報マップ</a></li><li><a href="https://maps.gsi.go.jp/#13/36.680751/138.285317/&base=std&ls=std%7C20191012typhoon19_chikumagawa_1016do_sokuho&blend=0&disp=11&lcd=seamlessphoto&vs=c0j0h0k0l0u0t0z0r0s1m0f0&vs2=f0&sync=1&base2=ort&ls2=ort%7Cexperimental_anno&disp2=11&lcd2=experimental_jhj" target="_blank" rel="noopener">国土地理院</a></li><li><a href="https://www.waze.com/ja" target="_blank" rel="noopener">waze</a></li></ul><p>でした。国土地理院のサイトは、今回の台風による浸水地域を現在の地図にオーバーレイ表示させることができます。また過去の水害情報も見ることが可能なので、「歴史に学ぶ」と言う部分において、現在の居住地域に対しての理解が深まりそうでした。<br>Googlerの<a href="https://twitter.com/proppy" target="_blank" rel="noopener">Proppy</a>がアメリカに住んでいた頃はwazeというアプリを使って、使えなくなってしまった道の共有をしていたと話していました。今回の台風で、地元の人からは実際に通れなくなった橋もいくつかあったという話もありました。参加者からはTwitterが交通情報や被害状況を確認するためによく見ていたという声が多かったです。<br>一方で、災害用ツールは必要か、といった議論はありましたが、</p><ul><li>災害時にのみ使うものは浸透しない</li><li>スタンバイしている時のコストがそこそこ高い</li></ul><p>といった意見が多く、一方で普段から使い慣れているツールを災害時にも使えるようにしたいといった声が多かったです。</p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>私自身、LTでの登壇は2回目になるのですが、改めて発表することを通して自分の知識が整理されたり、人に説明するにあたって正確さが必要であることを改めて認識しました。5分でTerraformの導入や魅力はまだまだ伝えきれていないと思うので、今度はもう少し知識をつけてハンズオンなども行っていきたいです。</p><p>今回参加した勉強会の趣向もありますが、1日でハードからクラウドまで本当に幅広い情報に触れることが出来ました。今まで首都圏の勉強会には積極的に参加してきましたが、自らターゲッティングしており、周辺知識まで同時に入れることはあまりなかったように思います。今回参加して、より自分が興味を持つことができる範囲が広がったと思いました。</p><p>最後になりますが、本記事を読んでくださった方も、足を伸ばして遠くの勉強会へ行ってみてはいかがでしょうか？</p><h2 id="当日のまとめサイト"><a href="#当日のまとめサイト" class="headerlink" title="当日のまとめサイト"></a>当日のまとめサイト</h2><p><a href="https://sites.google.com/site/gdgshinshu/home/archive/devfest19" target="_blank" rel="noopener">DevFest in 信州2019</a></p><hr><p>関連記事：</p><ul><li><a href="/articles/20190820/">初めてのGCPで環境構築してハマったこと</a></li><li><a href="/articles/20190927/">Let’s Try GCP #2 ～Cloud FunctionをVPC connectorと一緒に使ってみる～</a></li><li><a href="/articles/20190909/">Let’s Try GCP #1 ～Cloud Run Buttonを使った楽々コンテナデプロイをやってみた～</a></li><li><a href="/articles/20190827/">GKEのPodから異なるプロジェクトのIPアドレスへ接続できずハマった話</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG/DXユニットの伊藤です。普段はGCPの開発支援を行なっているインフラエンジニアです。今回は私の地元である
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</title>
    <link href="https://future-architect.github.io/articles/20191128/"/>
    <id>https://future-architect.github.io/articles/20191128/</id>
    <published>2019-11-28T04:08:47.000Z</published>
    <updated>2019-11-28T04:15:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>Go Cloudはいろいろなドライバーが整備されているものの当然のことながら、この世のすべてのバックエンドに対応しているわけではありません。AWSやGCPやAzureが提供されているサービス以外にも、自前で運用しているミドルウェアにも対応したくなったりするはずです。Go Cloudの中を覗き見るついでに、自分でドライバーを実装してみました。</p><p>Go CloudにはPubSubを扱うパッケージ群があります。GCPのPubSub、AWSのSNS/SQS、Azure Service Busというクラウドベンダーのサービス以外に、RabbitMQ、NATS、Kafkaといったオンプレでも使えるミドルウェア（KafkaはAWSのサービスもありますが）もあります。</p><p>アプリケーションのログの収集というと、最近はOpenTelemetryとかNew Relic APMのようなパフォーマンスモニタリングや大規模なマイクロサービスのサポートを目的とした分散トレースなどもありますが、ここで対応されているKafka以外にもFluentdをオンプレやクラウドなどで動かしているお客様も多いので、PubSubのバックエンドとして、Fluentdのpublisherを実装してみます。受け側（Subscription）はなく、サーバーへの送信（Publish）だけなので、fluentdpubという名前でApacheライセンスで公開しました。もとからあるKafkaも合わせれば、ログ収集基盤への送信にもGo Cloudが利用できるようになります。</p><ul><li><a href="https://github.com/future-architect/fluentdpub" target="_blank" rel="noopener">github.com/future-architect/fluentdpub</a></li></ul><p>実装は次の3ステップに分けて実装します。</p><ul><li>Fluentd特化の<code>fluentdpub.OpenTopic()</code>を実装する</li><li><code>fluentdpub.URLOpener</code>を実装する</li><li>Resolverに登録し、<code>pubsub.OpenTopic()</code>で使えるようにする</li></ul><h1 id="Fluentd特化のfluentdpub-OpenTopic-を実装してみる"><a href="#Fluentd特化のfluentdpub-OpenTopic-を実装してみる" class="headerlink" title="Fluentd特化のfluentdpub.OpenTopic()を実装してみる"></a>Fluentd特化の<code>fluentdpub.OpenTopic()</code>を実装してみる</h1><p>Fluentdに実際に接続するのは、公式の<code>&quot;github.com/fluent/fluent-logger-golang/fluent&quot;</code>パッケージを利用します。</p><p>まず、Fluentd特化の<code>OpenTopic()</code>を実装しますが、まず、<code>fluent</code>パッケージのコネクション情報のインスタンスをそのまま受け取るようにします。このようにすることで、<code>fluent</code>パッケージの機能をすべて利用する、という使い方をかんたんにユーザーに提供できます。すべての機能をラップするのは大変ですので。</p><p>Go Cloudのお作法として、インタフェースをあまり使わないというものがあります。PubSubに関しては次のようなコードになります。</p><ul><li><code>gocloud.dev/pubsub/driver</code>パッケージの<code>Topic</code>インタフェースを満たす構造体を作る。これが最終的にFluentdへのアクセスを担うことになる。</li><li><code>Topic</code>インタフェースを満たす構造体のポインタを<code>gocloud.dev/pubsub</code>パッケージの<code>NewTopic()</code>に渡しし、ユーザーに<code>*pubsub.Topic</code>のポインタを返す</li></ul><p>利用者は<code>gocloud.dev/pubsub</code>パッケージだけを知っていればいいが、実装者はそれに加えて<code>gocloud.dev/pubsub/driver</code>パッケージを実装するという区分けになっています。</p><p>それでは実装していきます。PubSubのAPIとFluentdを比べると、Fluentdにはタグがあり、PubSubにはBodyがあるという違いがあります。 <code>OpenTopic()</code> にはこの違いを吸収するオプションを追加します。Bodyで設定されたコンテンツは<code>message</code>の値に設定し、逆に <code>tag</code> で設定された値は<code>tagPrefix</code>と組み合わせてタグとなる（<code>tagPrefix.tag</code>が最終的なタグになる）、というルールにします。このあたりのルールの違いを吸収する方法はここで検討が必要になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TopicOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">BodyKey <span class="keyword">string</span></span><br><span class="line">TagKey  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenTopic</span><span class="params">(f *fluent.Fluent, tagPrefix <span class="keyword">string</span>, opt TopicOptions)</span> <span class="params">(*pubsub.Topic, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"fluentdpub: fluent.Fluent is required"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt.BodyKey == <span class="string">""</span> &#123;</span><br><span class="line">opt.BodyKey = <span class="string">"message"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> opt.TagKey == <span class="string">""</span> &#123;</span><br><span class="line">opt.TagKey = <span class="string">"tag"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pubsub.NewTopic(&amp;topic&#123;</span><br><span class="line">f:         f,</span><br><span class="line">tagPrefix: tagPrefix,</span><br><span class="line">bodyKey:   opt.BodyKey,</span><br><span class="line">tagKey:    opt.TagKey,</span><br><span class="line">&#125;, <span class="literal">nil</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全メソッドの実装の紹介はしませんが、一番のコアとなる<code>SendBatch()</code>メソッドだけ紹介します。メッセージの配列が来るので、自分のモジュールが対象としているエクスポート先（ここではFluentd）に情報を流します。</p><p>メタタグの一部をタグとして取り出して、構造体のフィールドのtagPrefixなどと組み合わせて、出力先のタグ名を決定します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t topic)</span> <span class="title">SendBatch</span><span class="params">(ctx context.Context, ms []*driver.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> ms &#123;</span><br><span class="line"><span class="keyword">var</span> fullTag <span class="keyword">string</span></span><br><span class="line">tag, ok := msg.Metadata[t.tagKey]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="built_in">delete</span>(msg.Metadata, t.tagKey)</span><br><span class="line"><span class="keyword">if</span> t.tagPrefix != <span class="string">""</span> &#123;</span><br><span class="line">fullTag = t.tagPrefix + <span class="string">"."</span> + tag</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fullTag = tag</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fullTag = t.tagPrefix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fullTag == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Message %v doesn't have tag"</span>, msg.AckID)</span><br><span class="line">&#125;</span><br><span class="line">msg.Metadata[t.bodyKey] = <span class="keyword">string</span>(msg.Body)</span><br><span class="line">err := t.f.Post(fullTag, msg.Metadata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この<code>OpenTopic</code>も、他のPubSub APIでは公開APIとなっていますし、かんたんですが、これだけでもすでに使えるようになっているはずです。これで、<code>fluentdpub</code>の背骨が出来上がりました。</p><h1 id="fluentdpub-URLOpenerを実装する"><a href="#fluentdpub-URLOpenerを実装する" class="headerlink" title="fluentdpub.URLOpenerを実装する"></a><code>fluentdpub.URLOpener</code>を実装する</h1><p>次に、URLなどの文字列をパースしてFluentdに接続する部分を実装していきます。これはNATS向けのPubSubでも公開構造体・メソッドとして実装されていますが、ドキュメントには書かれていません。</p><p><code>pubsub</code>パッケージの共通初期化関数の場合、対象のサービスを選択する方法はURLしかありません。先ほどの関数は挙動を変えるオプションは<code>TopicOptions</code>構造体を利用していましたが、この追加のオプションも渡せないので、すべてURLの中に情報をもたせる必要があります。</p><p>なお、NATS向けの実装では、オペレーターが気にするNATSサーバーの接続先は<code>NATS_SERVER_URL</code>で指定し、ソースコード中に登場しうるURLにはトピック名などの開発者向けの情報のみという使い分けがされています。これも、Go Cloudの設計思想に従った役割分担と言えます。<code>fluentdpub</code>も、<code>FLUENTD_UPSTREAM_URL</code>という環境変数に接続情報（プロトコル、ホスト、ポート）は任せて、URLはタグ名のみとします。それ以外の情報をここでは扱います。</p><p>TagPrefixというのはFluentd全体でタグを先頭につけたい場合に使うものとします。というのも、PubとSubが対応した他のPubSubのコードの識別子と比べると、Fluentdの方が分析の方は分析に任せるものとして、なるべく詳細な情報をタグに載せようとする分、識別子は長くなります。prodとかdevみたいな文字列をオペレータ視点で入れたくなるかもしれませんので、これを追加できるようにしておきます。</p><p>実装としては以下の通りです。先ほど作った<code>topic</code>構造体に対して<code>、TopicOptions</code>ではなく、URLをキーとして扱えるようにする機能がこれで実現されました。もう少しです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URLOpener <span class="keyword">struct</span> &#123;</span><br><span class="line">Connection *fluent.Fluent</span><br><span class="line">TagPrefix <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *URLOpener)</span> <span class="title">OpenTopicURL</span><span class="params">(ctx context.Context, u *url.URL)</span> <span class="params">(*pubsub.Topic, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> opt TopicOptions</span><br><span class="line">key := u.Query().Get(<span class="string">"bodykey"</span>)</span><br><span class="line"><span class="keyword">if</span> key != <span class="string">""</span> &#123;</span><br><span class="line">opt.BodyKey = key</span><br><span class="line">u.Query().Del(<span class="string">"bodykey"</span>)</span><br><span class="line">&#125;</span><br><span class="line">tagkey := u.Query().Get(<span class="string">"tagkey"</span>)</span><br><span class="line"><span class="keyword">if</span> tagkey != <span class="string">""</span> &#123;</span><br><span class="line">opt.TagKey = tagkey</span><br><span class="line">u.Query().Del(<span class="string">"tagkey"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> param := <span class="keyword">range</span> u.Query() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"open topic %v: invalid query parameter %s"</span>, u, param)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subject <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> o.TagPrefix != <span class="string">""</span> &amp;&amp; u.Hostname() != <span class="string">""</span> &#123;</span><br><span class="line">subject = o.TagPrefix + <span class="string">"."</span> + u.Hostname()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">subject = o.TagPrefix + u.Hostname()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OpenTopic(o.Connection, subject, opt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="リゾルバーに登録"><a href="#リゾルバーに登録" class="headerlink" title="リゾルバーに登録"></a>リゾルバーに登録</h1><p>それでは最終段階に入ります。URLスキーマを登録することで、共通APIの<code>pubsub.OpenTopic()</code>などの関数からも使えるようになり、マルチクラウドに一歩近づきます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scheme = <span class="string">"fluentd"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">o := <span class="built_in">new</span>(defaultDialer)</span><br><span class="line">pubsub.DefaultURLMux().RegisterTopic(Scheme, o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultDialer <span class="keyword">struct</span> &#123;</span><br><span class="line">opener *URLOpener</span><br><span class="line">err    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d defaultDialer)</span> <span class="title">OpenTopicURL</span><span class="params">(ctx context.Context, u *url.URL)</span> <span class="params">(*pubsub.Topic, error)</span></span> &#123;</span><br><span class="line">c, tag, err := parseEnvVar(os.Getenv(<span class="string">"FLUENTD_UPSTREAM_URL"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">conn, err := fluent.New(*c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">o := URLOpener&#123;</span><br><span class="line">Connection: conn,</span><br><span class="line">TagPrefix:  tag,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o.OpenTopicURL(ctx, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最終的にはこの内部の先ほど実装した<code>URLOpener.OpenTopicURL()</code>メソッドを呼んでいます。一点異なるのは、環境変数のパース部分でしょう。URL形式で渡されたものを<a href="https://github.com/future-architect/fluentdpub/blob/master/init.go#L81" target="_blank" rel="noopener">パースしています</a>。</p><h1 id="実装したものの整理"><a href="#実装したものの整理" class="headerlink" title="実装したものの整理"></a>実装したものの整理</h1><p>この記事ではストレートに一発でできたかのように書いていますが、実際作成中は何が何をするものか整理ができておらず、結構混乱して手戻りしつつ実装しました。整理をしてみると、コードが少ない薄い機能を先に実装し、徐々にロジックが多い文字列からの初期化に手を出していっていることがわかります。</p><table><thead><tr><th align="center"></th><th align="center">実装したもの</th><th align="center">接続情報</th><th align="center">タグ設定</th><th align="center">最後に何をする？</th></tr></thead><tbody><tr><td align="center">ステップ1</td><td align="center"><code>OpenTopic()</code></td><td align="center">*fluent.Fluent</td><td align="center"><code>TopicOptions</code></td><td align="center"><code>pubsub.NewTopic()</code>呼び出し</td></tr><tr><td align="center">ステップ2</td><td align="center"><code>URLOpener</code></td><td align="center">*fluent.Fluent</td><td align="center"><code>URL</code>をパース</td><td align="center">ステップ1で作ったものを呼び出し</td></tr><tr><td align="center">ステップ3</td><td align="center"><code>defaultDialer</code></td><td align="center">環境変数をパース</td><td align="center"><code>URL</code>をパース</td><td align="center">ステップ2で作ったものを呼び出し</td></tr></tbody></table><h1 id="使い方とまとめ"><a href="#使い方とまとめ" class="headerlink" title="使い方とまとめ"></a>使い方とまとめ</h1><p>テスト用にDockerを起動します。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run --rm -v $&#123;PWD&#125;/tmp/fluentd:/fluentd/log --name fluentd -p 24224:24224 fluent/fluentd:latest</span><br></pre></td></tr></table></figure><p>よく使うと思われるステップ3は、環境変数を設定し、URLとして接続情報を渡す必要があります。ここでは、すべてのタグのプリフィックスとして、<code>first</code>を設定しています(省略可能)。タグ名にピリオドを差し込むことで2段階、3段階でも深いタグを設定できます。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> export FLUENTD_UPSTREAM_URL=tcp://localhost:24224/first</span><br></pre></td></tr></table></figure><p><code>pubsub.OpenTopic</code>にはURLを設定します。プリフィックスの次に設定されるタグも指定します（省略可能）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topic, err := pubsub.OpenTopic(context.Background(), <span class="string">"fluentd://second"</span>)</span><br></pre></td></tr></table></figure><p>あとは送信だけですね。ここでもタグを設定しています（省略可能）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">topic.Send(context.Background(), &amp;pubsub.Message&#123;</span><br><span class="line">Body: []<span class="keyword">byte</span>(<span class="string">"Hello, World!\n"</span>),</span><br><span class="line">Metadata: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"tag"</span>:        <span class="string">"third"</span>,</span><br><span class="line"><span class="string">"language"</span>:   <span class="string">"en"</span>,</span><br><span class="line"><span class="string">"importance"</span>: <span class="string">"high"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3か所でそれぞれタグを設定していますが、それらは結合されて、<code>first.second.third</code>というタグになるという実装にしています。実行してみると、Dockerで起動したFluentdのフォルダにファイルが生成されてログが出力されていることが確認できるでしょう。</p><p>まだ全部のコードを読んだわけではないですが、だいたいはこのような階層構造になっているようです。テストもしやすいですし、もし、何かを実装したくなった場合もこのような手順で実装していくとスムーズでしょう。</p><h1 id="Go-Cloud集中連載の結びの言葉"><a href="#Go-Cloud集中連載の結びの言葉" class="headerlink" title="Go Cloud集中連載の結びの言葉"></a>Go Cloud集中連載の結びの言葉</h1><p>10月ごろに、社内チャットのGoチャンネルにGo Cloudをみんなで集まって技術ブログに集中連載してみませんか？と軽く声をかけたところ、何人かから声があがり、5人で7本の記事が集まりました（1人はPCトラブルで復旧中）。Go Cloudは幅広いライブラリですし、学ぼうとしても、個人の興味のあるところ以外はどうしても手薄になりがちです。いろいろな興味・仕事のメンバーを集めたことで、それぞれの興味がオーバーラップして、紹介記事としてのカバレッジをあげることができました。</p><p>内容としては主要な機能の説明は網羅できたと思いますし、ウェブで情報を見たことがないローカルでのAWS/GCPのエミュレーションと組み合わせたGo Cloudのテスト環境構築、ドライバーの実装と幅も深さも1人では書けない記事をお届けできたと思います。中には、実現のための苦労が滲み出る記事もありましたが、今後も、仕事を通じてGo Cloudのノウハウが溜まったら、不定期で記事を公開していこうと思っています。</p><hr><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li>Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる（この記事です）</li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go Cloudはいろいろなドライバーが整備されているものの当然のことながら、この世のすべてのバックエンドに対応しているわけではありません。AWSやGCPやAzureが提供されているサービス以外にも、自前で運用しているミドルウェアにも対応したくなったりするはずです。Go C
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>「脱Oracle」の背景にある、Oracle Databaseの価値を改めて考える</title>
    <link href="https://future-architect.github.io/articles/20191121/"/>
    <id>https://future-architect.github.io/articles/20191121/</id>
    <published>2019-11-21T00:20:12.000Z</published>
    <updated>2019-11-21T01:52:57.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>2019年10月15日、<a href="https://jp.techcrunch.com/2019/10/16/2019-10-15-amazon-migrates-more-than-100-consumer-services-from-oracle-to-aws-databases/" target="_blank" rel="noopener">Amazonは自社サービスにおける実質的な”脱Oracle”を発表</a>しました。75PBに及ぶデータを、傘下のAWSが提供するDatabase Service（AuroraやDynamoDB、Redshiftなど）へと移行したとの事。</p><p>この一報は、Amazonというグローバル規模のECの巨人、クラウド・プラットフォーマーのリーダーの一角が、大規模基幹システム領域におけるRDBMSのデファクト・スタンダードと決別したという点で、業界関係者に対して非常に大きなインパクトを残したものかと思います。<br>大人の色々な側面が垣間見えるものの、非常に難易度の移行PJであった事はを想像に難くありません。</p><p>“Oracleもいよいよ賞味期限を迎える”</p><p>果たしてそうなのか。ここで今一度、<strong>“脱Oracle”とは何を脱する事なのか</strong>、を考えてみます。</p><h2 id="“脱Oracle”とは？"><a href="#“脱Oracle”とは？" class="headerlink" title="“脱Oracle”とは？"></a>“脱Oracle”とは？</h2><p>第1は高コスト &amp; ベンダー・ロックインからの脱却です。Oracle Databaseの価格が競合のプロダクトと比較して高額である中で、価格改定や廉価版プロダクトの提供停止、自社クラウド・プラットフォームへの見る人によってはやや露骨に見える誘導といった流れに対してのアレルギー反応から生まれた潮流と見ます。</p><p>第2はHWと代替プロダクト(主にPostgreSQL)の進化です。HWに関しては、DBの性能面でボトルネックとなりやすい物理I/Oの領域におけるフラッシュストレージの普及が大きいと考えます。</p><p>PostgreSQLは近年、メジャーバージョンのリリース毎に目覚ましい機能追加を続けています。特に注目すべきはパーティショニング機能で、Oracleの専売特許と言って過言でなかった機能レベルに近づきつつあります。</p><p>また、PostgreSQLはBSDライセンスの体系を採用している事から、後述のAurora(RDS)、RedshiftといったAWSのマネージド・サービス、EnetrpriseDB、Vertica、Greenplumなどの商用プロダクトのベースとして採用され、名を変え機能拡張された形で世出しています。</p><p>具体的な採用領域としては、Oracle EEの代替・SEの移行先としてAurora(RDS)やEnterpriseDB、Exadataの代替(DHW系ワークロードの場合)としてRedshiftやVertica、Greenplumといったマッピングになるかと思います。</p><p><strong>「デザインしたアーキテクチャに対して、必要な機能とコストを鑑みてプロダクト選定した結果、それはOracle Databaseでなかった」</strong></p><p>私はこれを”脱Oracle”と定義します。</p><h2 id="Oracleの進化"><a href="#Oracleの進化" class="headerlink" title="Oracleの進化"></a>Oracleの進化</h2><p>Oracle Databseは時代のニーズに応え続ける事により、DBMSのリーディング・プロダクトという地位を築きました。</p><p>以降では、改めてOracle Databaseの歴史を辿ってみたいと思います。</p><h3 id="Oracle-V2"><a href="#Oracle-V2" class="headerlink" title="Oracle V2"></a>Oracle V2</h3><ul><li>Oracle Databaseはイメージ戦略(枯れているプロダクトと印象付けたい)からV2銘と打たれ、<strong>世界初の商用RDBMS</strong>としてリリースされました。</li></ul><h3 id="Oracle-8"><a href="#Oracle-8" class="headerlink" title="Oracle 8"></a>Oracle 8</h3><ul><li><strong>パーティショニング機能</strong>が実装され、テーブルをパーティション・キーに応じて物理分割する事が可能となりました。これにより、ストレージ(HDD)ネックの時代において、I/O極小化の観点での新たなチューニング・アプローチをもたらしました。</li><li><strong>ORDBMSの機能(関数や型の独自定義)</strong>が実装され、より柔軟なデータ管理が可能となりました。<br>※ORDBMSの実装自体はOracleが他プロダクトに先行しているものではありません</li></ul><h3 id="Oracle-9i"><a href="#Oracle-9i" class="headerlink" title="Oracle 9i"></a>Oracle 9i</h3><ul><li>9iで実装された<strong><a href="https://docs.oracle.com/cd/E15817_01/rac.111/e05738/admcon.htm" target="_blank" rel="noopener">Real Application Clusters</a>(RAC)</strong>は業界屈指の革新的な発明だと私は解釈しています。クラスタ構成ノードのメモリ間でデータを転送・共有させる事で、トランザクションを担保しながらDBのスケールアウトを可能としました。このアーキテクチャのボトルネックは物理ストレージの性能に依存しますが、ストレージが性能限界でない限りはHWリソースの追加により処理性能がスケールすします(機能特性に応じたのチューニングは必要です)。</li><li>9iの登場は、ベンダー・ロックイン状態の企業における<strong>“脱メインフレーム”</strong>にあたっての強力な武器となりました。</li></ul><h3 id="Oracle-10g"><a href="#Oracle-10g" class="headerlink" title="Oracle 10g"></a>Oracle 10g</h3><ul><li>10gにおいて実装された<strong>Grid Infrastructure</strong>、とりわけ<strong><a href="http://otndnld.oracle.co.jp/document/products/oracle11g/111/doc_dvd/server.111/E05783-04/asmcon.htm" target="_blank" rel="noopener">Automatic Storage Management</a>(ASM)</strong>の機能は、ストレージの仮想化を実現しました。Oracle Databaseから見えるデバイスをASM DiskGroupという形で抽象化させる事で、I/Oを複数の物理デバイスに分散可能となります。これにより、Oracleは可用性の向上とともに、前述のRACの性能面での懸念を補完しました。</li><li>当該バージョン以降からは、DB運用の自動化(機械化)を目指した機能が追加されています。</li></ul><h3 id="Oracle-Exadata-Database-Machine"><a href="#Oracle-Exadata-Database-Machine" class="headerlink" title="Oracle Exadata Database Machine"></a>Oracle Exadata Database Machine</h3><ul><li>現在のオンプレミス・シーンにおいて、最高峰のRDBMS環境です。Oracle社のSun Microsystems買収により、SunのHW技術を土台としてOracle Databaseの稼働に特化したHW/MW一体のプロダクトが登場しました。</li><li>Oracle社は、<strong><a href="http://otndnld.oracle.co.jp/ondemand/technight/20180117%20TechNigiht%20Exadata_1.pdf" target="_blank" rel="noopener">“Exadataに移行するだけで性能が向上する”</a></strong>という謳い文句とともに売り込みを行い、2010年代に多くの導入事例が生まれました。このコンセプトは、<strong>自PJメンバーのスキル不足や、アーキテクチャの多少の考慮不足をプロダクトがカバーしてくれる</strong>という点で、システムの導入側にとっては非常に魅力的です。それゆえに、アーキテクチャ・デザインで勝負したい人達(私たちもそうですが)にとっては、最終手段的位置付けなのではないでしょうか。</li></ul><h3 id="Oracle-19c-12cR2"><a href="#Oracle-19c-12cR2" class="headerlink" title="Oracle 19c(12cR2)"></a>Oracle 19c(12cR2)</h3><ul><li>11g以降も、Oracleは機能アップグレードを継続的に行ってきました。現時点での最新バージョンは19cで、これは旧バージョン体系(Oracle社が2018年リリースよりポリシー変更)では12cR2に相当します。</li><li>近年ではクラウド・プラットフォームでの稼働を意識した機能追加がされていますが、プロダクトのライセンス体系(廉価版エディションの廃止、稼働筐体の物理CPUコア数に対する課金など)がOracle Cloudを前提としているため、前述のアレルギー反応を生む結果となっています。</li></ul><h2 id="Amazonの事例から見る-推察する-”脱Oracle”"><a href="#Amazonの事例から見る-推察する-”脱Oracle”" class="headerlink" title="Amazonの事例から見る(推察する)”脱Oracle”"></a>Amazonの事例から見る(推察する)”脱Oracle”</h2><p>先に取り上げたAmazonにおけるDBのAWS移行に関して、どういった機能マッピングで”脱Oracle”したのか、私なりにAWSのマネージド・サービスとのマッピングして読み解いてみたいと思います。</p><p>※あくまでも私個人の推察であり、関係者へのヒアリング等に基づいたものではありません</p><h3 id="Aurora-RDS"><a href="#Aurora-RDS" class="headerlink" title="Aurora(RDS)"></a>Aurora(RDS)</h3><p><a href="https://aws.amazon.com/jp/rds/aurora/" target="_blank" rel="noopener">https://aws.amazon.com/jp/rds/aurora/</a></p><p>ハイトランザクションのOLTP系のDBがここに移行されたと推察します。ECのコア領域の大半の移行先がここなのではないでしょうか。<br>ワークロード特性によって、PostgreSQLのMySQLで使い分けをしているかもしれません。</p><h3 id="Redshift"><a href="#Redshift" class="headerlink" title="Redshift"></a>Redshift</h3><p><a href="https://aws.amazon.com/jp/redshift/" target="_blank" rel="noopener">https://aws.amazon.com/jp/redshift/</a></p><p>RedshiftのようなMPPアーキテクチャの分散RDBMSが活きるのは、構造化された大量データを扱うバッチ処理や、BIのようなアドホックなクエリが発行される(いわゆる事由分析)といった領域です。<br>ECのイメージでは、多角的なメトリクスでの売上等の集計であったり、顧客の行動分析など、主に(やはり)BI領域で適用されているのではと推察します。</p><h3 id="DyanmoDB"><a href="#DyanmoDB" class="headerlink" title="DyanmoDB"></a>DyanmoDB</h3><p><a href="https://aws.amazon.com/jp/dynamodb/" target="_blank" rel="noopener">https://aws.amazon.com/jp/dynamodb/</a></p><p>RDBMSよりもNoSQL(KVS)で管理する方が適しているデータを管理するようなアプリケーションで利用していると推察します。<br>昨年にトランザクション機能がリリースされるなど、採用可能領域を拡げてる印象です。トランザクション機能はユーザーの需要に応えたというのは当然あるでしょうが、もしかしたらAmazonのDB移行PJを見据えた側面もあるかもしれません。</p><h3 id="Neptune"><a href="#Neptune" class="headerlink" title="Neptune"></a>Neptune</h3><p><a href="https://aws.amazon.com/jp/neptune/" target="_blank" rel="noopener">https://aws.amazon.com/jp/neptune/</a></p><p>リコメンド機能など、消費者と商品の関連性の分析といった領域で利用していると推察します。<br>機能実装の初期段階からグラフDBを利用している事も考えられ、当該領域に関しては”脱Oracle”のスコープ外かもしれません。</p><h3 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h3><p><a href="https://aws.amazon.com/jp/elasticache/" target="_blank" rel="noopener">ElasticCache</a>、<a href="https://aws.amazon.com/jp/documentdb/" target="_blank" rel="noopener">DocumentDB(MongoDB)</a>、<a href="https://aws.amazon.com/jp/timestream/" target="_blank" rel="noopener">Timestream</a>、<a href="https://aws.amazon.com/jp/qldb/" target="_blank" rel="noopener">QLDB</a> 等のマネージド・サービスも適宜利用しているでしょうし、非/未公開のDBも利用しているかもしれません。</p><h2 id="Oracleの現在地"><a href="#Oracleの現在地" class="headerlink" title="Oracleの現在地"></a>Oracleの現在地</h2><p>ここまで述べてきたように、Oracle Databaseは現在においても最も洗練されたRDBMSの一つでしょう。しかしながら、市場におけるシェアは減っていくものと考えます。DBMSはOracle一択といっても過言ではなかった時代から、数多の選択肢が存在する群雄割拠の時代に突入しています。</p><p>ここ数年、私自身が顧客や業界関係者と会話する中でも、”脱Oracleがよしとされる風潮”を感じる場面に多く遭遇します。Oracle Databaseの旗色は悪く、今後ドラスティックな方向転換(価格など含めたライセンス体系の見直し)がない限りは劇的に良くなる事もないでしょう。</p><p>“脱Oracle”は大いに結構な事だと思います。</p><p>しかしながら、そこには敬意があるべきと考えます。Oracle DatabaseはRDBMSの歴史を作り、未だDBMSのリーディング・プロダクトです。その存在あったからこそ、追随せんとするプロダクト/サービスが生まれているのもまた事実です。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>RDBMSは世の中を変えました。</p><p>Edger F. Coddが提唱したリレーショナル・モデル、IBMのSystem R、Michael Stonebreakerが実装に落としたIngress(→ Postgres → PostgreSQL → MPPアーキテクチャの分散RDBMS)、Larry Ellisonが商用化を成功させたOracle Database、この系譜は、然るべき人が然るべく時代の流れを読み、”世界を変える”仕事をしたものだと思います。</p><p>彼らの功績により、私たちはコンピューター・リソースを用いてデータを構造的に管理する事が可能になりました。企業は業務の自動化を行い、生産性を飛躍的に向上させました。</p><p>定量的な多角的分析によって、新たなサービスが創出され、企業のみならず私たち個人も日常の発見・改善の恩恵を受けてきました。</p><p>全体を通して、Oracle Databaseの良い面にフォーカスを当てた内容となっていますが、決して肩入れするといった意図はありません。昨今の潮流・批判(やや的を外したもの)を少し不憫に感じ、この記事を執筆するに至りました。</p><p>私も自分の仕事として、自らの定義に従い、”脱Oracle”をします。</p><p><strong>「デザインしたアーキテクチャに対して、必要な機能とコストを鑑みてプロダクト選定した結果、それはOracle Databaseでなかった」</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;2019年10月15日、&lt;a href=&quot;https://jp.techcrunch.com/2019/10/16/2019
      
    
    </summary>
    
      <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
      <category term="Oracle" scheme="https://future-architect.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Go Conference 2019 Autumn に登壇しました</title>
    <link href="https://future-architect.github.io/articles/20191120/"/>
    <id>https://future-architect.github.io/articles/20191120/</id>
    <published>2019-11-20T00:05:17.000Z</published>
    <updated>2019-11-20T00:13:01.560Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIG DXチーム<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>の辻です。<br>先日開催された Go Conference 2019 Autumn に参加/登壇したので、その内容をレポートします。</p><img src="/images/20191120/gopher-kun.jpg" class="img-small-size"><h2 id="きっかけ"><a href="#きっかけ" class="headerlink" title="きっかけ"></a>きっかけ</h2><p>マネージャーとの面談で、勉強会やカンファレンスで登壇して貢献していきたいと話していたところ <a href="https://www.papercall.io/gocon-tokyo-2019-autumn" target="_blank" rel="noopener">Go Conference 2019 Autumn</a> の CfP を募集を見かけたので応募しました。</p><h3 id="アイデアの種"><a href="#アイデアの種" class="headerlink" title="アイデアの種"></a>アイデアの種</h3><p>Go の goroutine や channel を用いることで並行処理をシンプルに書くことができます。基本的な計算をマルチスレッドで高速化する試みは、私が Qiita に書いた <a href="https://qiita.com/tutuz/items/057452fbbe9a5ae26d37" target="_blank" rel="noopener">Golangを用いた様々な計算の高速化</a> の記事が詳しいです。<br>もちろん同じアルゴリズムを用いて Go 以外の言語でも実装できるのですが、Go でシンプルに実装でき、効率的に実行されることが確認できました。Qiita で 100 いいね程度の反響があり Go の並行処理をベースにしたネタで Go Conference に登壇したら面白いのではないか、と考えました。</p><p>私が競技プログラミング部にも所属していたのもあり <a href="https://atcoder.jp/contests/future-contest-2020-qual" target="_blank" rel="noopener">HTTF</a> といったマラソン形式のコンテストでよくもちいられる「焼きなまし法」を並行化したら面白いのではないかと考え、どのような並行化手法が存在するかサーベイしました。</p><p>サーベイする中で興味深かった論文が『<a href="https://ipsj.ixsq.nii.ac.jp/ej/?action=repository_uri&item_id=13940&file_id=1&file_no=1" target="_blank" rel="noopener">温度並列シミュレーテッド・アニーリング法とその評価</a>』<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>です。従来のシミュレーテッドアニーリングは 1 プロセスで温度を少しずつ冷却して、良い結果を探索するアプローチです。本論文では、一定の温度を持つ複数のプロセスが並行してシミュレーテッドアニーリングをします。隣接する温度のプロセス間で、解を一定の条件で交換して最適な解を探索するアプローチです。基本的なアイデアはシンプルながら、最適化能力は劣化せず、並行化することができ、処理時間の短縮に寄与します。</p><p>Go は並行処理が書きやすく、上記の研究のような並行化アプローチをシンプルに実装することができます。Qiita に書いたような基本的な計算処理だけでなく、論文で示されているアルゴリズムを Go で実装して、なんなら Go のパッケージを用いて計算過程を可視化したら面白いと考えました。</p><h2 id="準備"><a href="#準備" class="headerlink" title="準備"></a>準備</h2><h3 id="アイデアのブラッシュアップ"><a href="#アイデアのブラッシュアップ" class="headerlink" title="アイデアのブラッシュアップ"></a>アイデアのブラッシュアップ</h3><p>当社では TIG Friday というイベントが隔週で実施されています。当社の澁川のアイデアから生まれたイベントです。以下のようなコンセプトで運営されています。</p><blockquote><p>外部の発表が怖い人の練習台とかになれるように。完璧な資料じゃなくて、発表のタネから目が出たぐらいの状態で書き出した箇条書きの資料とかベースで10分x2+質疑ぐらいでわいわいやりたい。準備を頑張らないのがコンセプト。</p></blockquote><p>TIG Friday でどうですか？と声をかけていただき、社内で練習する機会をいただきました。準備を頑張らない、というコンセプトのイベントでしたが Go Conference の CfP に出すアイデアだったのでがっつり準備しました😋<br>アイデアを共有し、有識者からフィードバックをいただき、改善することができるので、非常によい機会だと感謝しています。</p><h3 id="CfP"><a href="#CfP" class="headerlink" title="CfP"></a>CfP</h3><p>登壇のネタは決まったものの、 CfP は出したことがなかったので Go Conference への道は CfP の書き方を知ることからでした。</p><p>以下のサイトが特に参考になりました。</p><ul><li><a href="https://www.papercall.io/gocon-tokyo-2019-autumn" target="_blank" rel="noopener">Go Conference Tokyo 2019 Autumn</a></li><li><a href="https://blog.monochromegane.com/blog/2019/08/11/toward_the_oversea_conference/" target="_blank" rel="noopener">初めて海外カンファレンス登壇するためにやったこと</a></li><li><a href="https://ymotongpoo.hatenablog.com/entry/2019/04/25/001319" target="_blank" rel="noopener">Go Conference 2019 SpringのPaperCallを初めて使ってみた感想＋α</a></li><li><a href="https://www.clear-code.com/blog/2017/6/6.html" target="_blank" rel="noopener">RubyKaigiのCFPへの応募例 #rubykaigi</a></li></ul><h3 id="発表準備"><a href="#発表準備" class="headerlink" title="発表準備"></a>発表準備</h3><p>しばらくして CfP が採択されたことをメールで確認しました。Go Conference 2019 Autumn への登壇が決まりました。初めての登壇でしたので、持てる力を十分に発揮できるよう、登壇の素振りは数回は実施しました。伝える内容がクリアになっているかどうかや、発表時間に気をつけていました。</p><h2 id="発表"><a href="#発表" class="headerlink" title="発表"></a>発表</h2><p>当日の発表は <a href="https://github.com/future-architect/vuls" target="_blank" rel="noopener">Vuls</a> にコントリビュートしている有名な方の裏番組だったので、人が集まるか心配していましたが、杞憂でした。来ていただいた方、ありがとうございます。</p><img src="/images/20191120/photo_20191120_01.jpeg"><p>資料は Speaker Deck に公開されています。</p><script async class="speakerdeck-embed" data-id="01855be763dc46f18bfba1cf8d60f147" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><p>発表後の質問タイムでは、「実際に業務でシミュレーテッドアニーリングが使われる機会があるのか？」といった質問がありました。私は業務で実装したことはないですが、先進的 AI プロジェクトをリードしている当社の Strategic AI Group というチームでは実際の業務で使われています。</p><p>その他にも参加者や登壇者の方から面白かったなどのコメントをいただき、貢献できてよかったです。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">めちゃくちゃ面白いのでZehi! <a href="https://t.co/7urPamheSZ" target="_blank" rel="noopener">https://t.co/7urPamheSZ</a></p>&mdash; Shogo Tomioka (@tomiokasyogo) <a href="https://twitter.com/tomiokasyogo/status/1188716537110093824?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">October 28, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">シミュレーテッドアニーリングで経路探索、ニューラルネットワークの実装など、GoでアルゴリズムやMLの話の多さがいいね。<br>サーバー言語というイメージから脱却、データサイエンスにも適した言語のイメージが強まる<br> <a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#gocon</a></p>&mdash; zreactor/yuriemon (@z_reactor) <a href="https://twitter.com/z_reactor/status/1188703466656387072?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">October 28, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">rand.Randがglobal lock取るのはたしかにそりゃそうだなぁ <a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#gocon</a> <a href="https://twitter.com/hashtag/gocon_b?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#gocon_b</a></p>&mdash; かるぱねるら (@karupanerura) <a href="https://twitter.com/karupanerura/status/1188702910529462272?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">October 28, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">goの並列処理簡単にできる特徴は色んなところに応用できるんだな <a href="https://twitter.com/hashtag/GoCon?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GoCon</a></p>&mdash; tomoko.h (@_tomoko523) <a href="https://twitter.com/_tomoko523/status/1188700567821905920?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">October 28, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote><p>Golangで並行シミュレーテッドアニーリング</p><p>中で何をやっているかは何やらなのですが、自分が全くわかっていない領域の話を聞けるのは楽しいですね。巡回セールスマン問題が実際に画面に表示されながら解かれて行くのは面白かったです！完全に解を出せなくても、最適解に近づけていくというアプローチがあるのですね。<br><a href="http://gsagawa.hatenablog.com/entry/2019/10/29/092018" target="_blank" rel="noopener">http://gsagawa.hatenablog.com/entry/2019/10/29/092018</a></p></blockquote><h2 id="緊急登壇"><a href="#緊急登壇" class="headerlink" title="緊急登壇"></a>緊急登壇</h2><p>ところで、当社から急遽、澁川も登壇しています。急遽というのは、登壇者が現れなかったというハプニングがあり、その代打登壇です。もともとのセッションは <a href="https://gocon.jp/sessions/multi-cloud_portability_for_go_applications/" target="_blank" rel="noopener">Multi-cloud portability for Go applications</a> というテーマでした。澁川は <a href="https://gocloud.dev/" target="_blank" rel="noopener">Go Cloud</a> について解説されていました。後日澁川から聞いた話では</p><blockquote><p>セッションの PaperCall では Go Cloud を紹介します、となっていたので、当日発表されるであったであろう内容をエスパーしてエミュレーションしました</p></blockquote><p>ということでした😁</p><img src="/images/20191120/photo_20191120_02.jpeg"><p>Go Cloud はクラウドポーダブルなアプリケーションを開発する上で非常に興味深いプロダクトです。Go Cloud は本ブログで連載中です。こちらも是非見ていただければと思います。</p><ul><li><a href="https://future-architect.github.io/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="https://future-architect.github.io/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="https://future-architect.github.io/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="https://future-architect.github.io/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="https://future-architect.github.io/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="https://future-architect.github.io/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li>To be continued …</li></ul><h2 id="参加してみて"><a href="#参加してみて" class="headerlink" title="参加してみて"></a>参加してみて</h2><p>はじめてのカンファレンス登壇でしたが、社内メンバの手厚いサポートもあり、充実した機会になりました。</p><p>運営のみなさまには、このような貴重なカンファレンスを主催していただいたことに感謝しております。当社も <a href="https://gocon.jp/partners/nameplate/future/" target="_blank" rel="noopener">Tofu on Fire</a>（名札）枠としてサポートさせていただきました📛</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">フューチャー株式会社でTofu on Fire（名札）スポンサーしてます。 <a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#gocon</a> <a href="https://t.co/vv5XoBEBQP" target="_blank" rel="noopener">pic.twitter.com/vv5XoBEBQP</a></p>&mdash; 渋川よしき (@shibu_jp) <a href="https://twitter.com/shibu_jp/status/1188601238826303488?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">October 27, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>Gopher のみなさんからの応募もお待ちしております！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">小西健三、瀧和男、木村宏一：温度並列シミュレーテッド・アニーリング法とその評価、情報処理学会論文誌、Vol.36 No.4 (1995)</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Group の略で、フューチャーの中でも特に IT 技術に特化した部隊です。その中でも DX チームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。TIG DXチーム&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;の辻です。&lt;br&gt;先日開催された Go Conference 2019 Autumn に参加/登壇したので、その内容をレポー
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#6 GCPのローカルエミュレータを活用する</title>
    <link href="https://future-architect.github.io/articles/20191119/"/>
    <id>https://future-architect.github.io/articles/20191119/</id>
    <published>2019-11-19T05:39:21.000Z</published>
    <updated>2019-11-28T04:13:12.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG DXチームの真野です。Go Cloud記事の第6弾です。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li>Go Cloud#6 GCPのローカルエミュレータを活用する（この記事です）</li></ul><hr><p>本記事では、Go CloudでGCPのエミュレータに接続してみます。同様の企画である<a href="/articles/20191115/">AWS LocalStack版は第5弾</a>でまとめていますので、詳細はそちらを確認ください</p><h1 id="GCPのローカルエミュレータとは"><a href="#GCPのローカルエミュレータとは" class="headerlink" title="GCPのローカルエミュレータとは"></a>GCPのローカルエミュレータとは</h1><p>GCPのリソースを管理するためのコマンドラインインターフェースとして <a href="https://cloud.google.com/sdk/gcloud/" target="_blank" rel="noopener">gcloud</a> があり、このgcloudコマンド経由で各種エミュレータを実行することができます。</p><p>gcloudはAWSでいうAWS CLIに相当しますが、AWS CLIにはもちろんそのような仕組みは備わっていません。代わりにLocalStackというツールを利用することが多いです。それとは異なりGCPは標準コマンドに組み込まれているということで、思想の違いのようなものを感じられ興味深いですね。</p><h1 id="エミューレータ種類について"><a href="#エミューレータ種類について" class="headerlink" title="エミューレータ種類について"></a>エミューレータ種類について</h1><p><code>gcloud alpha emulators --help</code> で確認すると、2019年11月時点でエミュレートできるサービスは4つです。</p><ol><li>bigtable</li><li>pubsub</li><li>datastore</li><li>firestore</li></ol><p>現時点ではGo CloudのBlobに相当するCloud Storageのエミュレータは存在しないようです<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>存在しない理由は注釈1のStackOverflowの回答にもありますが、各Cloud StorageのSDKに、ローカルストレージに書き込むオプションが存在するため、エミュレータレベルでは存在しないのでは？と推測します。純製ではないですが <a href="https://github.com/fsouza/fake-gcs-server" target="_blank" rel="noopener">fsouza/fake-gcs-server</a>というツールもあるので、こちらを利用することも検討に値するかもしれません。</p><p>本記事では、gcloud emulator で実行できる、 pubsubとfirestoreに対してGo Cloudでアクセスしていきます。</p><h1 id="Cloud-Pub-Sub"><a href="#Cloud-Pub-Sub" class="headerlink" title="Cloud Pub/Sub"></a>Cloud Pub/Sub</h1><p>Cloud Pub/Sub は送信者と受信者を切り離す多対多の非同期メッセージングを提供することによって、別々に開発されたアプリケーションの間で安全かつ高可用な通信を実現するGCPのプロダクトです。送信側がPublisher、受信側がSubscriberと呼ばれ、1:Nのメッセージのやり取りを行えます。<br><a href="https://cloud.google.com/pubsub/docs/overview" target="_blank" rel="noopener">https://cloud.google.com/pubsub/docs/overview</a></p><p><a href="https://cloud.google.com/pubsub/docs/emulator" target="_blank" rel="noopener">ドキュメント</a>に従いgcloud pubsubエミュレータをインストールします。</p><figure class="highlight sh"><figcaption><span>Install</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud components install pubsub-emulator</span><br></pre></td></tr></table></figure><p>インストールが終わったら、以下のコマンドでエミュレータを起動します。</p><figure class="highlight sh"><figcaption><span>pubsubエミュレータの起動</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud beta emulators pubsub start --project=dummy</span><br></pre></td></tr></table></figure><p><code>--project</code> で指定するPJは実際に存在しないダミー値でOKです。ポートはデフォルト <code>8085</code> で起動します。 <code>--port</code> オプションで変更も可能です。</p><p>アプリケーションにエミュレータを認識させるためには、<code>PUBSUB_EMULATOR_HOST</code> と <code>PUBSUB_PROJECT_ID</code> という2つの環境変数を設定する必要があるので設定します。</p><figure class="highlight sh"><figcaption><span>環境変数の設定</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUBSUB_EMULATOR_HOST=localhost:8085</span><br><span class="line"><span class="built_in">export</span> PUBSUB_PROJECT_ID=dummy</span><br></pre></td></tr></table></figure><p>このまま、gcloudコマンドで起動したpub/subのエミュレータに対してトピックを作成します。…と言いたいところですが、 <strong>実はgcloudはエミュレータに非対応です。</strong></p><blockquote><p>The emulator does not support GCP Console or gcloud pubsub commands.<br>（エミュレータはGCPコンソールやgcloud pubsubコマンドに対応していません）<br><a href="https://cloud.google.com/pubsub/docs/emulator#using_the_emulator" target="_blank" rel="noopener">https://cloud.google.com/pubsub/docs/emulator#using_the_emulator</a></p></blockquote><p>え、どうやってトピック作るの？って疑問に思いましたが、GCPのSDK経由であれば操作できるようです（そうでないと意味無いので当然ですが）。ドキュメントにPython製のツールがいくつかおいてあるので、そちらをgcloudコマンドの代わりに利用してトピックを作成します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ツールの取得</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/GoogleCloudPlatform/python-docs-samples.git</span><br><span class="line">$ <span class="built_in">cd</span> python-docs-samples/pubsub/cloud-client</span><br><span class="line"></span><br><span class="line"><span class="comment"># インストール</span></span><br><span class="line">$ pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># トピックの作成</span></span><br><span class="line">$ python publisher.py dummy create future-example</span><br></pre></td></tr></table></figure><p><code>Topic created: name: &quot;projects/dummy/topics/future-example&quot;</code> といったメッセージが出力されれば成功です。</p><p>ではGo Cloudでさきほど作成した <code>future-example</code> というトピックに対してPublishしてみます。</p><figure class="highlight go"><figcaption><span>サンプルPublish(実はNGケース)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line">_ <span class="string">"gocloud.dev/pubsub/gcppubsub"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">topic, err := pubsub.OpenTopic(ctx, <span class="string">"gcppubsub://projects/myproject/topics/mytopic"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line">err = topic.Send(ctx, &amp;pubsub.Message&#123;Body: []<span class="keyword">byte</span>(<span class="string">"Hello, World!"</span>)&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実は上記のコードは2019/11時点のGo CDK 0.1.0では上手く動かないようです。理由は、<code>PUBSUB_EMULATOR_HOST</code> の<a href="https://github.com/google/go-cloud/blob/master/pubsub/gcppubsub/gcppubsub.go#L134" target="_blank" rel="noopener">環境変数は読んでくれているようです</a> が、gRPCのトランスポートがCredentialsがついたたままで、 <a href="https://github.com/google/go-cloud/blob/master/pubsub/gcppubsub/gcppubsub.go#L233" target="_blank" rel="noopener">Insecureオプションへの切り替えが無い</a>からだと思います。PullRequstチャンスだと思いますが、現時点のコードベースだと、gcppubsubパッケージでガンバってInsecureオプションを付ける処理を入れる必要がある気がします。</p><p>ということで、例えば以下のようなコードでWithInsecureで切り替えが必要すれば一応動かすことができます。ちょっと長いですがGCPのCredentailsを環境変数ではなく <a href="https://gocloud.dev/howto/pubsub/publish/#gcp-ctor" target="_blank" rel="noopener">自前で設定する場合のコード</a> に、エミュレータの切り替えを追加しただけです。</p><figure class="highlight go"><figcaption><span>無理やり通すパターン</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> endPoint = <span class="string">"pubsub.googleapis.com:443"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">conn, err := dial(ctx) <span class="comment">// ★エミュレータ対応</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"dial error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">pubClient, err := gcppubsub.PublisherClient(ctx, conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"publisher client error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> pubClient.Close()</span><br><span class="line"></span><br><span class="line">topic, err := gcppubsub.OpenTopicByPath(pubClient, <span class="string">"projects/dummy/topics/future-example"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"open topic error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = topic.Send(ctx, &amp;pubsub.Message&#123;Body: []<span class="keyword">byte</span>(<span class="string">"Hello, World!"</span>)&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"publish error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ★エミュレータ対応して関数切り出し</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dial</span><span class="params">(ctx context.Context)</span> <span class="params">(*grpc.ClientConn, error)</span></span> &#123;</span><br><span class="line">emulatorEndPoint := os.Getenv(<span class="string">"PUBSUB_EMULATOR_HOST"</span>)</span><br><span class="line"><span class="keyword">if</span> emulatorEndPoint != <span class="string">""</span> &#123;</span><br><span class="line">endPoint = emulatorEndPoint</span><br><span class="line"><span class="keyword">return</span> grpc.DialContext(ctx, endPoint,</span><br><span class="line">grpc.WithInsecure(), <span class="comment">// ★追加</span></span><br><span class="line">grpc.WithUserAgent(fmt.Sprintf(<span class="string">"%s/%s/%s"</span>, <span class="string">"pubsub"</span>, <span class="string">"go-cdk"</span>, <span class="string">"0.1.0"</span>)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">creds, err := gcp.DefaultCredentials(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> grpc.DialContext(ctx, endPoint,</span><br><span class="line">grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(<span class="literal">nil</span>, <span class="string">""</span>)),</span><br><span class="line">grpc.WithPerRPCCredentials(oauth.TokenSource&#123;TokenSource: creds.TokenSource&#125;),</span><br><span class="line">grpc.WithUserAgent(fmt.Sprintf(<span class="string">"%s/%s/%s"</span>, <span class="string">"pubsub"</span>, <span class="string">"go-cloud"</span>, <span class="string">"0.1.0"</span>)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>続いて、Subscribeです。先程のPython製ツールでSubscriptionのエンドポイントを作成します。ProjectID, トピック名を指定し、<code>gocdk-example1</code> としたエンドポイントを指定しました。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python subscriber.py dummy create future-example gocdk-example1</span><br></pre></td></tr></table></figure><p>この <code>gocdk-example1</code> に対してGo Cloudでアクセスします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">conn, err := dial(ctx) <span class="comment">// ★先程のエミュレータ対応した関数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"dial error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">subClient, err := gcppubsub.SubscriberClient(ctx, conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"subscriber client error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> subClient.Close()</span><br><span class="line"></span><br><span class="line">sub, err := gcppubsub.OpenSubscriptionByPath(subClient, <span class="string">"projects/dummy/subscriptions/gocdk-example1"</span>, <span class="literal">nil</span>) <span class="comment">// ★さきほど取得したエンドポイントを指定する</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"subscription error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> sub.Shutdown(ctx)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := sub.Receive(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Receiving message: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Got message: %q\n"</span>, msg.Body)</span><br><span class="line">msg.Ack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subscribeのテストをしたい場合は、先程のPythonライブラリにサンプルでPublishするツールも付いているのでそちらで検証すると良いと思います。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python publisher.py dummy publish future-example</span><br></pre></td></tr></table></figure><p>上記は、1から10までpublishする簡単なツールですが、検証用途ととしてはお手軽なのでオススメです。実行すると、Subscription側に標準出力されることが確認できると思います。</p><h1 id="Cloud-Firestore"><a href="#Cloud-Firestore" class="headerlink" title="Cloud Firestore"></a>Cloud Firestore</h1><p>Cloud Firestore は、高速でサーバーレスなフルマネージドのクラウド ネイティブ NoSQL ドキュメント データベースです。<br><a href="https://cloud.google.com/firestore/" target="_blank" rel="noopener">https://cloud.google.com/firestore/</a></p><p>エミュレータのインストールは<a href="https://firebase.google.com/docs/firestore/security/test-rules-emulator" target="_blank" rel="noopener">こちら</a> を参考にできますが、今回はgcloudコマンドを直接叩いて起動させます。</p><figure class="highlight sh"><figcaption><span>Install</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud components install cloud-firestore-emulator</span><br></pre></td></tr></table></figure><p>インストールが終わったら、以下のコマンドでエミュレータを起動します。オプションは<a href="https://cloud.google.com/sdk/gcloud/reference/beta/emulators/firestore/" target="_blank" rel="noopener">こちら</a> を参考ください。</p><figure class="highlight sh"><figcaption><span>pubsubエミュレータの起動</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud beta emulators firestore start --project dummy --host-port=localhost:8080</span><br></pre></td></tr></table></figure><p><code>--host-port</code> オプションでポートを固定できます(指定しないと起動のたびに違うポートが用いられました)。<code>localhost:8080</code> でアクセスすると <code>Ok</code> が返ってくれば起動成功です。</p><p>これをGo Cloudでアクセスします。その前にCloud Pub/Subの場合と同様に、エミュレータの環境変数を設定します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FIRESTORE_EMULATOR_HOST=localhost:8080</span><br><span class="line"><span class="built_in">export</span> FIRESTORE_PROJECT_ID=dummy</span><br></pre></td></tr></table></figure><p>続いてコードはこちらです。FirestoreもPub/Subと同様に、エミュレータ対応する関数を用意してスイッチさせています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="keyword">string</span> <span class="string">`docstore:"id"`</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`docstore:"name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> endPoint = <span class="string">"firesotore.googleapis.com:443"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">client, err := dial(ctx) <span class="comment">// ★エミュレータ対応のため関数切り出し</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"dial error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resourceID := gcpfirestore.CollectionResourceID(<span class="string">"dummy"</span>, <span class="string">"example-collection"</span>)</span><br><span class="line">coll, err := gcpfirestore.OpenCollection(client, resourceID, <span class="string">"id"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"open collection error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> coll.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 書き込み</span></span><br><span class="line">row := Record&#123;</span><br><span class="line">ID:   <span class="string">"1"</span>,</span><br><span class="line">Name: <span class="string">"hoge"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := coll.Create(ctx, &amp;row); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"create error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 読み込み</span></span><br><span class="line">rowToRead := Record&#123;</span><br><span class="line">ID: <span class="string">"1"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := coll.Get(ctx, &amp;rowToRead); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"get error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"get: %+v\n"</span>, rowToRead)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.1.0時点でエミュレータで動かすため自前で切り替え</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dial</span><span class="params">(ctx context.Context)</span> <span class="params">(*vkit.Client, error)</span></span> &#123;</span><br><span class="line">emulatorEndPoint := os.Getenv(<span class="string">"FIRESTORE_EMULATOR_HOST"</span>)</span><br><span class="line"><span class="keyword">if</span> emulatorEndPoint != <span class="string">""</span> &#123;</span><br><span class="line">endPoint = emulatorEndPoint</span><br><span class="line"></span><br><span class="line">conn, err := grpc.DialContext(ctx, endPoint, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vkit.NewClient(ctx,</span><br><span class="line">option.WithEndpoint(endPoint),</span><br><span class="line">option.WithGRPCConn(conn),</span><br><span class="line">option.WithUserAgent(fmt.Sprintf(<span class="string">"%s/%s/%s"</span>, <span class="string">"firestore"</span>, <span class="string">"go-cloud"</span>, <span class="string">"0.1.0"</span>)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">creds, err := gcp.DefaultCredentials(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client, _, err := gcpfirestore.Dial(ctx, creds.TokenSource)</span><br><span class="line"><span class="keyword">return</span> client, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コードの中でCreate（登録）とGet（取得）ができました。後はエミュレータを意識すること無く操作することができます。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>GCPのローカルエミュレータのFirestore, PubSubに対して多少前処理が必要ですがGo Cloudから十分アクセスができます。同時にまだ実装が枯れきっていないので色々PullRequestチャンスだと思います。</p><p>エミュレータを使っていてよかったなと思うポイントは、gcloudこそ利用できませんでしたが、PubSubで登場したPythonツールのように、既存のエコシステムを活用出来る点で、コードの動作確認ではとてもお世話になると思います。</p><p>Go Cloud自体の <code>file</code> や <code>mem</code> のような機能と合わせてエミュレータも上手く使い分けて、より生産性と品質を高められるようにしていきたいですね。</p><hr><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li>Go Cloud#6 GCPのローカルエミュレータを活用する（この記事です）</li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://stackoverflow.com/questions/37542530/is-there-google-cloud-storage-emulator/46692017#46692017</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG DXチームの真野です。Go Cloud記事の第6弾です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</title>
    <link href="https://future-architect.github.io/articles/20191115/"/>
    <id>https://future-architect.github.io/articles/20191115/</id>
    <published>2019-11-15T03:10:54.000Z</published>
    <updated>2019-11-28T04:13:41.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG DXチームの真野です。Go Cloud記事の第5弾です。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li>Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する（この記事です）</li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><hr><p>本記事ではGo Cloud経由でAWSのローカルモック環境である<a href="https://github.com/localstack/localstack" target="_blank" rel="noopener">LocalStack</a>に接続してみたいと思います。</p><p>LocalStackはモックとして活用することが多いと思いますが、Go Cloudそのものにも Blob、Docstore、Pub/Subなどを利用する際に <code>mem</code>や <code>file</code> スキーマベースを指定することで動作検証が可能です。そのためGo Cloudを利用する場合のローカル開発や、CIでの自動テスト時はこちらを活用する場面も多いかなと思います。</p><p>一方で、プロセスのライフサイクルとは別に、データを永続化をさせておいて、次回起動時にも再利用したいといった場合に不便な場面もあると思います。あるいは、既存のGUIツールを用いて実行結果を確認したいといったこともあり得ると思います。こういった要求に備え、Localstackへの接続手法も抑えていきます。</p><h1 id="LocalStackとは"><a href="#LocalStackとは" class="headerlink" title="LocalStackとは"></a>LocalStackとは</h1><blockquote><p>💻 A fully functional local AWS cloud stack. Develop and test your cloud &amp; Serverless apps offline! <a href="https://localstack.cloud" target="_blank" rel="noopener">https://localstack.cloud</a></p></blockquote><p>オフラインでAWSの開発やテストができるスタックです。</p><h1 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h1><p>LocalStackを起動しておきます。Dockerで起動する場合は以下のようにportを開けておきます。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 4567-4584:4567-4584 -p 8080:8080 localstack/localstack:0.10.5</span><br></pre></td></tr></table></figure><p><a href="https://github.com/localstack/localstack#using-docker-compose" target="_blank" rel="noopener">公式のドキュメント</a>にも記載されていますが、4567-4584ポートがエミュレートするAWS相当のリソースが利用し(AWSサービス増加に従いだんだん増えていきますので詳細は公式ドキュメントを確認ください)、8080ポートはWeb UIが利用します。</p><p>Versionは2019/11/15時点で最新の <code>0.10.5</code> を利用していますが <code>latest</code> でも良いかと思います。</p><h1 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h1><p>まず<a href="https://aws.amazon.com/jp/cli/" target="_blank" rel="noopener">AWS CLI</a>を用いてLocalStackにS3バケットを作成します。 <code>--endpoint-url</code> オプションで向き先をLocalStackに切り替えるのが特徴です。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws --endpoint-url=http://localhost:4572 s3api create-bucket --bucket future-example</span><br></pre></td></tr></table></figure><p>作成した <code>future-example</code> バケットにオブジェクトを書き込んでみます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws/session"</span></span><br><span class="line"><span class="string">"gocloud.dev/blob"</span></span><br><span class="line"><span class="string">"gocloud.dev/blob/s3blob"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">w, err := writer(<span class="string">"future-example"</span>, <span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> w.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := w.Write([]<span class="keyword">byte</span>(<span class="string">"1234567890"</span>)); err != <span class="literal">nil</span> &#123; <span class="comment">// 適当な値</span></span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">(bucketURL, key <span class="keyword">string</span>)</span> <span class="params">(io.WriteCloser, error)</span></span> &#123;</span><br><span class="line">sess := session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint:         aws.String(<span class="string">"http://localhost:4572"</span>), <span class="comment">// ★必要</span></span><br><span class="line">S3ForcePathStyle: aws.Bool(<span class="literal">true</span>), <span class="comment">// ★必要</span></span><br><span class="line">&#125;))</span><br><span class="line">bucket, err := s3blob.OpenBucket(context.Background(), sess, bucketURL, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket.NewWriter(context.Background(), key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalStackへのアクセスの場合は、driver のAWS実装側にEndpointなどを指定する必要があります。</p><figure class="highlight go"><figcaption><span>LocalStack固有の設定</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sess := session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint:         aws.String(<span class="string">"http://localhost:4572"</span>),</span><br><span class="line">S3ForcePathStyle: aws.Bool(<span class="literal">true</span>),</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>さらに、BucketのURLも <code>S3ForcePathStyle</code> を指定してしまう関係で、 <code>s3://future-example</code> ではなく <code>future-example</code> とする必要があります。このあたりはまだ実装がこなれていないだけで今後改善される可能性があるので、Go Cloud側のアップデートの都度確認したほうが良いと思います。</p><p>さて、呼び出し側でURLスキーマ <code>s3://</code> の有無を意識することはあまりしたくないと思います。<br>そのため、より業務に近いコードにするには、以下のようにEndpointが環境変数で指定されている場合には、s3スキーマを外す処理を入れると良くなると思います。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openBucket</span><span class="params">(bucketURL <span class="keyword">string</span>)</span> <span class="params">(*blob.Bucket, error)</span></span> &#123;</span><br><span class="line">endpoint := os.Getenv(<span class="string">"ENDPOINT_URL"</span>) <span class="comment">// ★環境変数化する</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(endpoint) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> blob.OpenBucket(context.Background(), bucketURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalStackアクセス用の処理</span></span><br><span class="line">u, err := url.Parse(bucketURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sess := session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint:         aws.String(endpoint),</span><br><span class="line">S3ForcePathStyle: aws.Bool(<span class="literal">true</span>),</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">return</span> s3blob.OpenBucket(context.Background(), sess, u.Host, <span class="literal">nil</span>) <span class="comment">// ★u.Hostで、s3://を切り捨てる処理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例としてはput-objectの実装を上げましたが、get-objectやdelete-objectに関しても、同様に session を指定することで、後はLocalStackを意識せず扱えることができます。</p><h1 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h1><p>事前に、AWS CLI経由でqueueを作成します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aws --endpoint-url=http://localhost:4576 sqs create-queue --queue-name <span class="built_in">test</span>-queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"QueueUrl"</span>: <span class="string">"http://localhost:4576/queue/test-queue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このQueueUrlを用いてGo Cloud経由でSQSにアクセスします。LocalStackのSQSのポートは <code>4576</code> なので設定間違いには注意していきます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws/session"</span></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line"><span class="string">"gocloud.dev/pubsub/awssnssqs"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">sess, err := session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint: aws.String(<span class="string">"http://localhost:4576"</span>), <span class="comment">// ★</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topic := awssnssqs.OpenSQSTopic(ctx, sess, <span class="string">"http://localhost:4576/queue/test-queue"</span>, <span class="literal">nil</span>) <span class="comment">// ★</span></span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line">err = topic.Send(ctx, &amp;pubsub.Message&#123;</span><br><span class="line">Body:     []<span class="keyword">byte</span>(<span class="string">"Hello, World!\n"</span>),</span><br><span class="line">Metadata: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"Env"</span>: <span class="string">"test"</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Blobとは微妙に driver の設定が異なり、今度は <code>Endpoint</code> だけで接続ができました。<br>その代わりに、QueueのURLを <code>OpenSQSTopic</code> 時に指定する必要があります。</p><p>EndpointとQueueURLに重複した設定がなされておりどちらかを省略できそうですが、現時点では両方とも設定する必要がありました。</p><p>Subscribe側も同様のdriverの設定で、後はLocalStackを意識すること無くアクセスが可能です。</p><h1 id="DocStore"><a href="#DocStore" class="headerlink" title="DocStore"></a>DocStore</h1><p>最後にDocStoreでLocalStackのDynamoDB(エミュレータ)にアクセスしてみます。</p><p>最初にAWS CLI経由でテーブルを作成します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws --endpoint-url=http://localhost:4569 dynamodb create-table \</span><br><span class="line">  --table-name <span class="built_in">test</span> \</span><br><span class="line">  --attribute-definitions AttributeName=ID,AttributeType=S \</span><br><span class="line">  --key-schema AttributeName=ID,KeyType=HASH \</span><br><span class="line">  --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1</span><br></pre></td></tr></table></figure><p>このテーブルに対してGo Cloudを利用してアクセスします。</p><p>DocStoreの場合はdriver側に <code>Endpoint</code> を指定するだけでアクセスできます。<br>LocalStackのDyanmoDBのポートは <code>4569</code> なので設定間違いには注意していきます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gocloud.dev/docstore/awsdynamodb"</span></span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entity <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="keyword">string</span> <span class="string">`docstore:"ID"`</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`docstore:"NAME"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sess := session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint:         aws.String(<span class="string">"http://localhost:4569"</span>), <span class="comment">// ★</span></span><br><span class="line">&#125;))</span><br><span class="line">coll, err := awsdynamodb.OpenCollection(dynamodb.New(sess), <span class="string">"test"</span>, <span class="string">"ID"</span>, <span class="string">""</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> coll.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 書き込み</span></span><br><span class="line">row := Entity&#123;</span><br><span class="line">ID:   <span class="string">"1"</span>,</span><br><span class="line">Name: <span class="string">"hoge"</span>,</span><br><span class="line">&#125;</span><br><span class="line">coll.Create(context.Background(), &amp;row)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 読み込み</span></span><br><span class="line">rowToRead := Entity&#123;</span><br><span class="line">ID: <span class="string">"1"</span>,</span><br><span class="line">&#125;</span><br><span class="line">coll.Get(context.Background(), &amp;rowToRead)</span><br><span class="line">fmt.Printf(<span class="string">"get: %+v\n"</span>, rowToRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>こちらも、いったんOpenCollectionをした後は、LocalStackであることを意識せずに操作できました。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Go Cloudはまだまだ発展途上とはいえ、現時点でも十分にLocalStackを用いてアクセスができます。<br>処理レイテンシや消費するリソースは <code>mem</code> や <code>file</code> に比べLocalStackのプロセス群を立ち上げるだけオーバーヘッドがありますが、作成したリソースをGUIツールなどで確認可能なため、利用したい場面もあり得ると思います。</p><p>LocalStackのアクセスのためには、基本的には AWS CLIでは <code>--endpoint-url</code> でローカルのURLを指定しますが、Go Cloudの場合は現時点ではリソースによっては追加のオプションを指定したり、前処理をして上げる必要があります。このあたりはGo CloudのAWS driver側に自らコミットしていくか、ライブラリを被せるか判断してうまく付き合っていきたいですね。</p><hr><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li>Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する（この記事です）</li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG DXチームの真野です。Go Cloud記事の第5弾です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#4 URLを編集するパッケージ</title>
    <link href="https://future-architect.github.io/articles/20191114/"/>
    <id>https://future-architect.github.io/articles/20191114/</id>
    <published>2019-11-14T02:19:44.000Z</published>
    <updated>2019-11-28T04:13:59.114Z</updated>
    
    <content type="html"><![CDATA[<p>昨日に引き続きTIG DX Unitの渋川です。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li>Go Cloud#4 URLを編集するパッケージ（この記事です）</li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><hr><p>これまで、基本的な機能を一通り紹介してきました。</p><p>Go Cloudでは何かとURL扱います。特にポータブルなAPIを使うと、<code>mem://my-pub-sub</code> やら <code>s3://my-bucket</code>やらで、URLでリソースの種類とその実態を指定しますし、場合によっては <code>?filename=collection.db</code>のようなクエリーで属性を設定したりします。</p><p>一方で、設定ファイルやらで正確なURLをすべてきちんと入れるのは大変です。</p><p>DocStoreでテーブルを10個使うアプリケーションがあり、データベース名までは同じだけど、コレクション名（≒RDBのテーブル）だけ置き換えたいみたいなケースでは、データベース名のところまでの1つだけを設定値として持ち、各テーブルのURLはプログラマブルに作りたいですよね？しかし、どこを書き換えればコレクション名が変わるかなど、細かいルールがバックエンドのドライバーごとに解釈が違うという難点があります。</p><p>ということでGo Cloud用のURL正規化パッケージを作りました。</p><ul><li><a href="https://github.com/future-architect/gocloudurls" target="_blank" rel="noopener">github.com/future-architect/gocloudurls</a></li></ul><p>このパッケージには、ちょっと省略形で書いたURLをGo Cloudで解釈できるURLに補完したり、一部書き換えたりといった関数が含まれています。なお、どの関数も、正規表現やテンプレートのパッケージと同じく、<code>Must</code>が接頭辞についた関数も提供しております。</p><h1 id="BlobのURLの正規化"><a href="#BlobのURLの正規化" class="headerlink" title="BlobのURLの正規化"></a>BlobのURLの正規化</h1><p><code>NormalizeBlobURL(srcUrl string) (string, error)</code>がBlobのURLの正規化の関数です。コマンドラインツールでユーザーが入力するフォルダ名を<code>file://folder</code>形式にするといったちょっとした修正をします。Go Cloud、Cloudだけで使うのはもったいなので、CLIでも使おうと思って追加しました。リージョン名は<code>AWS_REGION</code>という環境変数があればそこから補完します。</p><ul><li><code>mem</code> → <code>mem://</code></li><li><code>folder</code> → <code>file://folder</code></li><li><code>s3://my-bucket</code> → <code>s3://my-bucket?region=us-west-1</code></li></ul><h1 id="DocStoreの正規化"><a href="#DocStoreの正規化" class="headerlink" title="DocStoreの正規化"></a>DocStoreの正規化</h1><p><code>NormalizeDocStoreURL(srcUrl string, opt Option) (string, error)</code>という関数を提供しています。</p><p>DocStoreの場合、パスの階層構造やら主キーの設定の方法がバックエンドによって異なったりします。コレクション名は書き換えたいが、主キーはこのカラム名にしたい、みたいなのはこの関数を使えば一元化されます。</p><p>オプションは次の形式になっています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="keyword">struct</span> &#123;</span><br><span class="line">KeyName      <span class="keyword">string</span> <span class="comment">// 主キー名(デフォルトは_id)</span></span><br><span class="line">PartitionKey <span class="keyword">string</span> <span class="comment">// DynamoDBのパーティションキー（後述）</span></span><br><span class="line">Collection   <span class="keyword">string</span> <span class="comment">// コレクション名を上書きしたい場合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例えば、memdocstoreバックエンドの場合は次のようなURLが生成されます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goclodurls.NormalizeDocStoreURL(<span class="string">"mem://"</span>, goclodurls.Option&#123;</span><br><span class="line">    Collection: <span class="string">"addresses"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "mem://addresses/_id"</span></span><br></pre></td></tr></table></figure><p>FireStoreの場合は、プロジェクト名/コレクションといった短い名前や、プロジェクト名/ドキュメント名/コレクション名といった短い名前を渡しても、Go Cloudが期待する名前（projectsやdatabasesやdocumentsというパスを挿入、データベース名のデフォルトは<code>(default)</code>を利用する）に書き換えます。最初からvalidな本来のURLを入れることも可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goclodurls.NormalizeDocStoreURL(<span class="string">"firestore://my-project"</span>, goclodurls.Option&#123;</span><br><span class="line">    Collection: <span class="string">"addresses"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "firestore://projects/my-project/databases/(default)/documents/addresses?name_field=_id"</span></span><br><span class="line">goclodurls.NormalizeDocStoreURL(<span class="string">"firestore://my-project/my-documents/addresses"</span>, goclodurls.Option&#123;&#125;)</span><br><span class="line"><span class="comment">// "firestore://projects/my-project/databases/my-documents/documents/addresses?name_field=_id"</span></span><br></pre></td></tr></table></figure><p>DynamoDBはパーティションキーだけの場合はパーティションキーが主キーになり、パーティションキーとソートキーがあると複合主キーのようになるという特性があります。本ライブラリでは、PartitionKeyが空文字列なら前者のモード(KeyName=パーティションキー)に、PartitionKeyが入っていれば後者のモード(KeyName=ソートキー、PartitionKey=パーティションキー)になるようにしています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goclodurls.NormalizeDocStoreURL(<span class="string">"dynamodb://"</span>, goclodurls.Option&#123;</span><br><span class="line">    Collection: <span class="string">"tasks"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "dynamodb://tasks?partition_key=_id"</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goclodurls.NormalizeDocStoreURL(<span class="string">"dynamodb://"</span>, goclodurls.Option&#123;</span><br><span class="line">    Collection:   <span class="string">"tasks"</span>,</span><br><span class="line">    PartitionKey: <span class="string">"job_id"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "dynamodb://tasks?partition_key=job_id&amp;sort_key=_id"</span></span><br></pre></td></tr></table></figure><h1 id="PubSubの正規化"><a href="#PubSubの正規化" class="headerlink" title="PubSubの正規化"></a>PubSubの正規化</h1><p><code>NormalizePubSubURL(srcUrl string) (string, error)</code>という関数を提供しています。これも今までのものとほぼ同じです。SNSはARNで書いても補完するし、SQSもhttpsのURLを書いても補完します。GCP PubSubはFirestoreと同様に固定のprojects/topicsを省略しても補完します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gocloudurls.NormalizePubSubURL(<span class="string">"arn:aws:sns:us-east-2:123456789012:mytopic"</span>)</span><br><span class="line"><span class="comment">// "awssns:///arn:aws:sns:us-east-2:123456789012:mytopic?region=us-east-2"</span></span><br><span class="line"></span><br><span class="line">gocloudurls.NormalizePubSubURL(<span class="string">"https://sqs.us-east-2.amazonaws.com/123456789012/myqueue"</span>)</span><br><span class="line"><span class="comment">// "awssqs://https://sqs.us-east-2.amazonaws.com/123456789012/myqueue?region=us-east-2"</span></span><br><span class="line"></span><br><span class="line">gocloudurls.NormalizePubSubURL(<span class="string">"gcppubsub://myproject/mytopic"</span>)</span><br><span class="line"><span class="comment">// "gcppubsub://projects/myproject/topics/mytopic"</span></span><br></pre></td></tr></table></figure><h1 id="おまけ"><a href="#おまけ" class="headerlink" title="おまけ"></a>おまけ</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`docstore:"name"`</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このようなdocstoreをマッピングする構造体があったとすると次の関数で、テーブル定義のコマンドライン引数を生成します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ds, err := gocloudurls.NewDynamoDBSchema(&amp;Person&#123;&#125;, </span><br><span class="line">    gocloudurls.MustMustNormalizeDocStoreURL(<span class="string">"dynamodb://persons"</span>))</span><br><span class="line"></span><br><span class="line">ds.CreateTableCommand()</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aws dynamodb create-table --table-name persons \</span><br><span class="line">  --attribute-definitions AttributeName=name,AttributeType=S \</span><br><span class="line">  --key-schema AttributeName=name,KeyType=HASH \</span><br><span class="line">  --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5</span><br></pre></td></tr></table></figure><p>そのうち、Terraformのコードも生成したり、awscliを実行をしたり、というのも追加したいな、と思っています。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>最初のエントリーで紹介したように、クレデンシャルの問題以外を除けばマルチクラウドの利点を生かしたい場合はポータブル版のURLで扱うのがお手軽なことが多いです。しかし、特にDocStoreにおいて、URLのルールがバックエンドごとに違いすぎて、ポータブル版のAPIを扱うのが難しいというのを感じましたので、URLの操作もマルチクラウドにするためのユーティリティを実装しました。これでよりマルチクラウドが行いやすくなったと思います。</p><hr><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li>Go Cloud#4 URLを編集するパッケージ（この記事です）</li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨日に引き続きTIG DX Unitの渋川です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/articles/20191111/&quot;&gt;Go Cloud#1 概要とBlobへの活用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/articles/20191112/&quot;&gt;G
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#3 Go CloudのDocStoreを使う</title>
    <link href="https://future-architect.github.io/articles/20191113/"/>
    <id>https://future-architect.github.io/articles/20191113/</id>
    <published>2019-11-13T01:04:49.000Z</published>
    <updated>2019-11-28T04:14:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>TIG DX Unitの渋川です。今回はGo Cloudの紹介の連載の第3弾です。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li>Go Cloud#3 Go CloudのDocStoreを使う（この記事です）</li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><hr><p>Go Cloudにはいろいろ便利な機能がありますが、ほとんどの機能は既存のAPIへの薄いラッパーだったりします。そんな中、よくぞ実装したな、と思われるのがDocStoreです。</p><p>DocStoreはFireStoreやDynamoDB、MongoDBへの透過的なアクセスを提供するパッケージ群です。NoSQLをどのように使うのか、RDBの代わりになるのかどうかみたいなのは定期的に炎上するネタですが、これらが対象としているドキュメントストア(NoSQLの一部の分野)の場合、ちょっと高度なクエリー言語やら少し高度なアトミックな操作をサポートしていたりすることがあります。DocStoreもこのようなクエリーやアトミックに行える操作などをいくつか提供しています。</p><ul><li>アップデート: 数値をインクリメントするなどが一発で実行できる</li><li>アクションリスト: 取得、追加、更新、削除などの複数の操作をまとめて実行。RedisでいいうところのMULTI。読み込んだ値を元に加工して更新、まではできないが、追加と削除を同時に行うぐらいはできる。トランザクションのようでトランザクションではない、ちょびっとトランザクションな機能。</li><li>クエリー: SQLのように、Where/Limit/Offsetなどの条件式を使ってカラムを取得してくる</li></ul><p>オンメモリ版のmemdocstoreでもこのような高度な機能が利用できますし、バックエンドでサポートしていない機能はGo Cloud上でエミュレーションしていたりするらしいです。</p><h1 id="基本的な使い方"><a href="#基本的な使い方" class="headerlink" title="基本的な使い方"></a>基本的な使い方</h1><p>DocStoreは、ORマッパー内臓のストレージAPIのように使えます。Goの構造体に直接マッピングして読み書きできますので、ORマッパーを別途用意する必要はありません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="comment">// 使いたいバックエンドをこのようにimportしておく</span></span><br><span class="line">_ <span class="string">"gocloud.dev/docstore/memdocstore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CounterEntity <span class="keyword">struct</span> &#123;</span><br><span class="line">ID    <span class="keyword">string</span> <span class="string">`docstore:"id"`</span></span><br><span class="line">Count <span class="keyword">int</span>    <span class="string">`docstore:"count"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">coll, err := docstore.OpenCollection(context.Background(), <span class="string">"mem://counter/id"</span>)</span><br><span class="line"><span class="comment">// これでレコードの作成</span></span><br><span class="line">row := CounterEntity&#123;</span><br><span class="line">ID:    <span class="string">"1"</span>,</span><br><span class="line">Count: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">coll.Create(context.Background(), &amp;row)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 読み込みたい時もエンティティの読み書きのオブジェクトを作り、主キーだけ設定しておく</span></span><br><span class="line">rowToRead := CounterEntity&#123;</span><br><span class="line">ID:    <span class="string">"1"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主キー以外の要素（ここではCount）に値が設定される</span></span><br><span class="line">coll.Get(context.Background(), &amp;rowToRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>簡単ですね。ここではオンメモリで動作するmemdocstoreを使いましたが、awsdynamodb、gcpfirestore、mongodbdocstoreがあります。テーブルを作成する機能はないので、memdocstore以外はawscliやgcloudコマンドなどを利用するなどして事前にテーブルは作っておく必要はあります。</p><p>メソッドとしては次の6つがあります。基本的なCRUD + UPSERT + 更新用の特別なメソッドになります。使い方で迷うことはあまりないでしょう。</p><ul><li>Create: 新しいレコードを追加する（すでに存在するとエラー）</li><li>Replace: 既存のレコードを置換する(存在していなければエラー)</li><li>Put: 既存のレコードがあれば置換し、なければ新規で作成</li><li>Get: レコードの取得(なければエラー)</li><li>Delete: レコードの削除</li><li>Update: 特定のカラムだけ更新（後述）</li></ul><h1 id="上級な使い方"><a href="#上級な使い方" class="headerlink" title="上級な使い方"></a>上級な使い方</h1><p>単なる読み書き以外にさまざまな機能が提供されています。</p><h2 id="アップデート"><a href="#アップデート" class="headerlink" title="アップデート"></a>アップデート</h2><p>RDBの強力なトランザクションがない代わりに、トランザクションが実現していたユースケースの<strong>ごく一部</strong>（レコードを取ってきて、変更してセーブ）をカバーするのがこのアップデート機能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.Update(ctx, &amp;record, docstore.Mods&#123;<span class="string">"count"</span>: docstore.Increment(<span class="number">1</span>)&#125;)</span><br></pre></td></tr></table></figure><p>Modsはmapのエイリアスになっており、特定のフィールドにのみ変更を加えることができます。Modsの値によって結果が変わりますが、現状サポートされている操作は次の3つです。</p><ul><li>nil: フィールドを削除する</li><li>docstore.Increment: 値をインクリメントする</li><li>その他の値: フィールドの値を変更する</li></ul><h2 id="クエリー"><a href="#クエリー" class="headerlink" title="クエリー"></a>クエリー</h2><p>docstoreの中で個人的に一番便利で、クラウドに乗らないサービスでもmemdocstoreを使ってしまおうと思う動機づけになっているのがこのクエリー機能です。公式ドキュメントのサンプルが一通りイテレータの使い方・エラー処理も含めて触れているため、これが一番参考になるかと思います。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/docstore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ask for all players with scores at least 20.</span></span><br><span class="line">iter := coll.Query().Where(<span class="string">"Score"</span>, <span class="string">"&gt;="</span>, <span class="number">20</span>).OrderBy(<span class="string">"Score"</span>, docstore.Descending).Get(ctx)</span><br><span class="line"><span class="keyword">defer</span> iter.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query.Get returns an iterator. Call Next on it until io.EOF.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Player</span><br><span class="line">err := iter.Next(ctx, &amp;p)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s: %d\n"</span>, p.Name, p.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Query()の返り値に対して、fluentインタフェースで情報を付与し、最後にGet()を呼び出します。次のメソッドがあります。どれもSQLでおなじみですね。</p><ul><li>Where()</li><li>OrderBy()</li><li>Limit()</li></ul><p>Whereの演算子としては”=”, “&gt;”, “&lt;”, “&gt;=”, “&lt;=”の5種類が使えます。notはありません。</p><p>Goの場合はスライス（と配列）、mapのシンプルなデータ構造でプログラムを構成していく必要があります。当然、インデックスやキーでのアクセス以外に範囲アクセスなどをしようとすると、自分でいろいろ作り込む必要があります。オンメモリのデータでもこのクエリー機能を使うと、少しリッチな検索機能が得られます（もちろん、処理コストが極めて重要な場合には使えませんが）。</p><p>もちろん、この機能を使うためにはバックエンドのテーブル作成時にインデックスを設定しておくなどをしないとバックエンドによってはフルスキャンになって嬉しくはないでしょう。</p><h2 id="アクションリスト"><a href="#アクションリスト" class="headerlink" title="アクションリスト"></a>アクションリスト</h2><p>複数のオペレーションをまとめて実行するのがアクションリストです。ほとんどのストレージAPIはバルクでまとめて処理を渡すことで効率よく処理することが可能だったりしますが、このアクションリストはそれを活用するためのAPIになっています。</p><p>Actions()で帰ってきた<code>docstore.ActionList</code>に対してfluentインタフェースでメソッドを複数呼び、最後にDoを呼び出すことでまとめて実行されます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := coll.Actions().</span><br><span class="line">    Update(&amp;row, docstore.Mods&#123;<span class="string">"count"</span>: docstore.Increment(<span class="number">1</span>)&#125;).</span><br><span class="line">    Delete(&amp;rowToDelete).</span><br><span class="line">    Do(ctx)</span><br></pre></td></tr></table></figure><p>ここで返されるerrorの実体は<a href="https://github.com/google/go-cloud/blob/master/docstore/docstore.go#L281" target="_blank" rel="noopener">docstore.ActionListError</a>です。これは、エラー情報の配列になっており、ActionListErrorにタイプアサーションでダウンキャストすることで、各アクションのエラー情報が個別に取れるようになっています。</p><h2 id="楽観ロック"><a href="#楽観ロック" class="headerlink" title="楽観ロック"></a>楽観ロック</h2><p>docstoreのドキュメントにはリビジョンフィールドが設定できます。デフォルトの名前はDocstoreRevisionですが、コレクションを開くときのオプションで設定できます。Replaceなどの更新メソッド呼び出し時にこのフィールドを設定しておくと、自分よりも先に誰かが書き込んだ時に楽観ロックによりエラーを検知できます。リビジョンフィールドが存在しない or リビジョン情報を渡さなければこの機構は動作しません。</p><h2 id="ローカルファイルに保存-memdocstore"><a href="#ローカルファイルに保存-memdocstore" class="headerlink" title="ローカルファイルに保存(memdocstore)"></a>ローカルファイルに保存(memdocstore)</h2><p>memdocstoreには、ローカルファイルとの読み書きの機能があります。これを使うとオープン時にファイルがあればそれを読み込んで復元しますし、クローズ時に保存します。ユニットテストでちょっとしたマスターデータをロードするには便利でしょう。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memdocstoreのドライバ側のAPIを使ってオープン時にオプションでファイル指定</span></span><br><span class="line">coll, err := memdocstore.OpenCollection(<span class="string">"id"</span>, &amp;memdocstore.Filename&#123;</span><br><span class="line">    Filename: <span class="string">"collection.db"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ポータブル版のAPIでURLのクエリーでファイル名指定</span></span><br><span class="line">coll, err := docstore.OpenCollection(context.Background(), <span class="string">"mem://counters?filename=counter.db"</span>)</span><br></pre></td></tr></table></figure><h1 id="DocStoreの注意点"><a href="#DocStoreの注意点" class="headerlink" title="DocStoreの注意点"></a>DocStoreの注意点</h1><p>便利なDocStoreですが、いくつか注意点があります。</p><h2 id="gobのエラー-memdocstore"><a href="#gobのエラー-memdocstore" class="headerlink" title="gobのエラー(memdocstore)"></a>gobのエラー(memdocstore)</h2><p>memdocstoreではファイルの保存ができることを紹介しましたが、保存時にエラーが発生することがあります。そして、エラーが発生すると、次回オープンするときに<code>EOFエラー</code>が出てきます。</p><p>保存というのは<code>Close()</code> 時に行われるので、<code>Close()</code>を忘れると保存されませんし、次のように雑に書いているとエラーに気づけません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ダメなコード</span></span><br><span class="line"><span class="keyword">defer</span> coll.Close()</span><br></pre></td></tr></table></figure><p><code>Close()</code>を明示的にロジックの一部で書いても良いですが、<code>defer</code>を使いたいところでもあります。<code>defer</code>を使う場合は<code>Close()</code>のエラーをきちんとハンドリングする必要があります。返り値に名前をつけておけば、<code>defer</code>の中のエラーを正しく呼び出し元に返すことができます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 名前付きの返り値を使って、Close()のエラーを忘れずに上流に流す。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyFunc</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">coll, err := docstore.OpenCollection(context.Background(), <span class="string">"mem://counters?filename=counter.db"</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// すでにエラーがあったときは上書きしないように</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = coll.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 読み書き</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>クローズ時のエラーの原因は、おそらく、保存時に使っている<code>encoding/gob</code>周りだと思います。errさえきちんと把握できればそのあとの対応は難しくはないでしょう。必要な型の保存ができるようにコレクションの読み込み前には<code>gob.Register</code>で型の登録を済ませておきましょう。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gob.Register(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="スレッドセーフではない-memdocstore"><a href="#スレッドセーフではない-memdocstore" class="headerlink" title="スレッドセーフではない(memdocstore)"></a>スレッドセーフではない(memdocstore)</h2><p>memdocstoreは<a href="https://github.com/google/go-cloud/blob/master/docstore/memdocstore/mem.go#L78" target="_blank" rel="noopener">ソースコード中のコメント</a>にこっそり、「スレッドセーフに修正する」と書かれています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(jba): make this package thread-safe.</span></span><br></pre></td></tr></table></figure><p>コレクションそのものは内部にsync.Mutexを持っており、コレクションに対する操作は複数のgoroutineで実行しても問題はないと思います。また、ドライバAPI側の<code>OpenCollection()</code>も、新規のコレクションを作成して返すので問題はありません。</p><p>問題はポータブル版のAPIのコレクション作成です。GoのユニットテストはデフォルトでGOMAXPROCSの数だけ平行に実行されます。同じホストを持つURLを渡すと、同じコレクションのインスタンスを返すため、ユニットテストがお互いに影響を与え合うことになります。</p><p>解決法としてはドライバ版のAPIを使うか、コレクション名にユニークな識別子を付与して衝突しないようにする、といった対策が必要です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/rs/xid"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line"><span class="string">"gocloud.dev/docstore"</span></span><br><span class="line">_ <span class="string">"gocloud.dev/docstore/memdocstore"</span></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIncrement</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">coll, err := docstore.OpenCollection(context.Background(), <span class="string">"mem://counter"</span>+xid.New().String()+<span class="string">"/id"</span>)</span><br><span class="line"><span class="comment">// 以下テストコード</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2つのコンテキスト"><a href="#2つのコンテキスト" class="headerlink" title="2つのコンテキスト"></a>2つのコンテキスト</h2><p>DocStoreはコレクションを開くときにコンテキストを要求します。また、個別の操作のときにもコンテキストが必要です。</p><p>memdocstoreの場合、最初のオープン時のコンテキストがキャンセルされると、データが全てリセットされます。ここは議論を呼んだところですが、この実装から推測できるのは、リクエストのたびにコレクションを開いて操作してクローズするというのではなく、コレクションはプロセスの寿命と同じだけ起動しっぱなしにすることを想定して設計されているということです。</p><p>つまり2種類は独立したコンテキストとなります。1つめはコレクションとの接続（≒アプリケーションのプロセスの生存期間）のためのもので、2つめは1つの読み書きのアクションに対応するコンテキストです。例えばサーバーアプリケーションであれば、サーバーが起動したときに作成され、サーバーの寿命と同じコンテキストと、フロントエンドからのリクエストを受けてそれを返すまでの寿命しかないコンテキストです。</p><h2 id="パーティションキー、ソートキー、Read-Writeキャパシティ-awsdynamodb"><a href="#パーティションキー、ソートキー、Read-Writeキャパシティ-awsdynamodb" class="headerlink" title="パーティションキー、ソートキー、Read/Writeキャパシティ(awsdynamodb)"></a>パーティションキー、ソートキー、Read/Writeキャパシティ(awsdynamodb)</h2><p>DynamoDBのデータベースがどのようにデータを保持しており、どのようにアクセスすると効率よくデータの取得ができるかについては<a href="https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html" target="_blank" rel="noopener">ドキュメントに詳しく書かれています</a>。</p><p>DynamoDBでは他のデータベースなどのストレージとくらべて維持費が安くなっています。一方で、送受信に備えて、テーブルごとにキャパシティユニットを設定しておく必要があり、これの維持費がかかるという設計になっています。そのため、主キーで呼び分けが確実にできるのであればテーブルをまとめておくことでキャパシティを効率よくわけことも可能かもしれません。</p><p>このように、バックエンドのDBの特性がなくなるわけではなく、それをわかった上で利用する必要があります。docstoreがエミュレーションしてくれるおかげで、なんとなく動作してしまうことも多いと思いますが、実行/コスト効率をあげるには、裏の仕組みの理解は欠かせません。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>これまで紹介してきたBlob、PubSubと、このDocStore、そしてGCP/AWS/Azure向けに提供されているMySQL/PostgreSQL用のアダプタが、現状Go Cloudでアプリケーションを組み立てるための部品として提供されています（あとは設定ファイル用アダプタと、もろもろ設定済みのウェブサーバー）。もっとも、SQLの方は使い方は普段のものと変わらないので、大きな機能は今回の本連載の中で一通り説明できたと思います。</p><p>明日はDocStoreなどを少し便利にするユーティリティについて説明します。</p><hr><ul><li><a href="https://future-architect.github.io/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li><a href="https://future-architect.github.io/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li>Go Cloud#3 Go CloudのDocStoreを使う（この記事です）</li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TIG DX Unitの渋川です。今回はGo Cloudの紹介の連載の第3弾です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/articles/20191111/&quot;&gt;Go Cloud#1 概要とBlobへの活用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/arti
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#2 Pub/Subの概要紹介</title>
    <link href="https://future-architect.github.io/articles/20191112/"/>
    <id>https://future-architect.github.io/articles/20191112/</id>
    <published>2019-11-12T01:46:59.000Z</published>
    <updated>2019-11-28T04:14:11.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の辻です。今回は Go Cloudシリーズの第二弾として、Go Cloud の <a href="https://gocloud.dev/howto/pubsub/" target="_blank" rel="noopener">Pub/Sub</a> を紹介します。</p><p>ビジネスニーズとして、今までは AWS のみでアプリケーションを構成していたけど、GCP のサービスも取り入れてマルチクラウド構成にしていきたいという声も聞きます。</p><p>また Google Trends で過去 5 年間の検索傾向を見ると、ゆるやかな上昇傾向にあるように見えます。</p><img src="/images/20191112/photo_20191112_01.png" style="border:solid 1px #000000"><p>マルチクラウドなアプリケーションの実装としては、各サービスのインターフェースに依存することが多く、独自に各サービスのインターフェースをラップして実装するのもなかなか大変なのではないでしょうか。</p><p>Go Cloud はアプリケーションのポータビリティに役に立つと考えています。</p><p>Go Cloud記事はこちらもご参考ください。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li>Go Cloud#2 Pub/Subの概要紹介（この記事です）</li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><h2 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h2><p>Producer-Consumer モデルを用いたメッセージングは、サーバーレスアーキテクチャやマイクロサービスアーキテクチャでよく利用されるような、非同期サービス間通信のモデルです。</p><p>キューイングサービスとしてよく用いられるサービスとして、AWS だと Amazon Simple Queue Service 、GCP だと Google Cloud Pub/Sub、ミドルウェアだと Kafka などが挙げられます。</p><p>現時点(2019/11/08)では以下のサービスをサポートしています。</p><ul><li>Google Cloud Pub/Sub</li><li>Amazon Simple Notification Service</li><li>Amazon Simple Queue Service</li><li>Azure Service Bus</li><li>RabbitMQ</li><li>NATS</li><li>Kafka</li><li>In-Memory</li></ul><p>本記事では Google Cloud Pub/Sub と Amazon Simple Queue Service と In-Memory について Go Cloud で Publish / Subscribe した例を紹介します。</p><h2 id="GCP"><a href="#GCP" class="headerlink" title="GCP"></a>GCP</h2><p>Go Cloud を用いて Google Cloud Pub/Sub に対して Publish と Subscribe をしてみます。</p><p>先に topic は手動で作成しておきます。クレデンシャルはデフォルトのクレデンシャルを用います。サービスアカウントキーを払い出しておきましょう。<br>今回は環境変数 <code>GOOGLE_APPLICATION_CREDENTIALS</code> にサービスアカウントキーの json へのパスが設定されているものとします。</p><img src="/images/20191112/photo_20191112_02.png" style="border:solid 1px #000000"><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><p>以下のようにして topic に Publish できます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line">_ <span class="string">"gocloud.dev/pubsub/gcppubsub"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">topic, err := pubsub.OpenTopic(ctx, <span class="string">"gcppubsub://projects/develop-123456/topics/test-topic"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line">err = topic.Send(ctx, &amp;pubsub.Message&#123;</span><br><span class="line">Body: []<span class="keyword">byte</span>(<span class="string">"Hello, World!\n"</span>),</span><br><span class="line">Metadata: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Env"</span>: <span class="string">"test"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理コンソールから確認すると topic にメッセージが Publish されていることが分かります。</p><img src="/images/20191112/photo_20191112_03.png" style="border:solid 1px #000000"><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>続いて topic から Subscribe してみます。</p><p>以下の実装で topic を監視します。この状態でコンソールからメッセージを publish します。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line">_ <span class="string">"gocloud.dev/pubsub/gcppubsub"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">subscription, err := pubsub.OpenSubscription(ctx, <span class="string">"gcppubsub://projects/develop-123456/subscriptions/test-sub"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"could not open topic subscription: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> subscription.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := subscription.Receive(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Receiving message: %v"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Got message: %q\n"</span>, msg.Body)</span><br><span class="line">msg.Ack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/20191112/photo_20191112_04.png" style="border:solid 1px #000000" class="img-middle-size"><p>メッセージを公開すると、標準出力に</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got message: &quot;test-msg&quot;</span><br></pre></td></tr></table></figure><p>と出力されることが確認できました。管理コンソールからもメッセージが削除され、取得できていることが確認できました。</p><h2 id="SQS"><a href="#SQS" class="headerlink" title="SQS"></a>SQS</h2><p>GCP の Pub/Sub と同様に AWS の SQS でも Go Cloud を試してみます。</p><p>キューは予め作成しておきました。標準キューです。<br><img src="/images/20191112/photo_20191112_05.png" style="border:solid 1px #000000"></p><h3 id="Publish-1"><a href="#Publish-1" class="headerlink" title="Publish"></a>Publish</h3><p>キューにメッセージを送信してみます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/pubsub/awssnssqs"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws/session"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">sess, err := session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Region: aws.String(<span class="string">"ap-northeast-1"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queueURL = <span class="string">"https://sqs.ap-northeast-1.amazonaws.com/123456789012/test-queue"</span></span><br><span class="line">topic := awssnssqs.OpenSQSTopic(ctx, sess, queueURL, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line">err = topic.Send(ctx, &amp;pubsub.Message&#123;</span><br><span class="line">Body: []<span class="keyword">byte</span>(<span class="string">"Hello, World!\n"</span>),</span><br><span class="line">Metadata: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Env"</span>: <span class="string">"test"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>送信できていることがコンソールから確認できました。</p><img src="/images/20191112/photo_20191112_06.png" style="border:solid 1px #000000"><h3 id="Subscribe-1"><a href="#Subscribe-1" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>続いてキューからメッセージを Subscribe します。以下のようなメッセージをコンソールから送信します。</p><img src="/images/20191112/photo_20191112_07.png" style="border:solid 1px #000000" class="img-middle-size"><p>それでは受信してみます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/pubsub/awssnssqs"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws"</span></span><br><span class="line"><span class="string">"github.com/aws/aws-sdk-go/aws/session"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">sess, err := session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Region: aws.String(<span class="string">"ap-northeast-1"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queueURL = <span class="string">"https://sqs.ap-northeast-1.amazonaws.com/123456789012/test-queue"</span></span><br><span class="line">subscription := awssnssqs.OpenSubscription(ctx, sess, queueURL, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> subscription.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := subscription.Receive(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Receiving message: %v"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Got message: %q\n"</span>, msg.Body)</span><br><span class="line">msg.Ack()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コンソールから送信すると、以下のように標準出力されることを確認できました。キューからもメッセージが削除されていました。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got message: &quot;test-msg&quot;</span><br></pre></td></tr></table></figure><h2 id="In-Memory"><a href="#In-Memory" class="headerlink" title="In-Memory"></a>In-Memory</h2><p>最後に In-Memory を扱ってみます。<a href="https://godoc.org/gocloud.dev/pubsub/mempubsub" target="_blank" rel="noopener">GoDoc</a> にもあるように本番では使ってはダメです。ローカルでの開発とテストを目的としています。</p><blockquote><p>mempubsub should not be used for production: it is intended for local development and testing.</p></blockquote><h3 id="Publish-and-Subscribe"><a href="#Publish-and-Subscribe" class="headerlink" title="Publish and Subscribe"></a>Publish and Subscribe</h3><p>In-Memory で Publish と Subscriber の動作は以下のようにして確認できました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gocloud.dev/pubsub"</span></span><br><span class="line">_ <span class="string">"gocloud.dev/pubsub/mempubsub"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">topic, err := pubsub.OpenTopic(ctx, <span class="string">"mem://myTopic"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> topic.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line">subscription, err := pubsub.OpenSubscription(ctx, <span class="string">"mem://myTopic"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> subscription.Shutdown(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := topic.Send(ctx, &amp;pubsub.Message&#123;Body: []<span class="keyword">byte</span>(<span class="string">"test-msg"</span>)&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg, err := subscription.Receive(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Receiving message: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Got message: %q\n"</span>, msg.Body)</span><br><span class="line">msg.Ack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got message: &quot;test-msg&quot;</span><br></pre></td></tr></table></figure><p>ちなみに Google Cloud Pub/Sub や Amazon Simple Queue Service のときは必要ありませんでしたが、In-Memeory の場合は明示的に OpenTopic する必要があります。OpenTopic しないと、以下のようにエラーになります。エラーになる理由は <a href="https://github.com/google/go-cloud/blob/master/pubsub/mempubsub/mem.go" target="_blank" rel="noopener">mem.go</a> を見れば分かります。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/11/11 20:27:50 open subscription mem://myTopic: no topic &quot;myTopic&quot; has been created</span><br></pre></td></tr></table></figure><h2 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h2><p>Go Cloud の API から Google Cloud Pub/Sub と Amazon Simple Queue Service 、ローカルの In-Memeory での Publish/Subscribe を操作できることが確認できました。GoDoc からもわかりますが API として指定できるパラメータは少ないです。キューイングサービスをエンタープライズで利用する上で、ポーリング間隔や可視性タイムアウト(確認応答期限)などは気になるポイントだと思います。</p><p>細かい実装はドキュメントには記載されておらず、<a href="https://github.com/google/go-cloud/blob/master/pubsub/pubsub.go" target="_blank" rel="noopener">pubsub.go</a> を見ると、各ドライバーの SendAcks や ReceiveBatch メソッドなどの実装に依存することがわかります。OSS はコードを確認すれば挙動が把握できるので便利ですね。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>今回は Go Cloud を用いた Pub/Sub の簡単な例を紹介しました。API としてベンダー中立な汎用 API を提供し、マルチクラウドの展開をサポートする試みは非常に興味深いです。</p><p>以下にあるように Go Cloud プロジェクトはアルファ版で枯れておらず、今後より発展していくと考えられます。プロジェクトで検証/導入するチャンスを見つけてフィードバックしていきたいですね。</p><blockquote><p>The APIs are still in alpha, but we think they are production-ready and are actively looking for feedback from early adopters. If you have comments or questions, you can post to the Go Cloud mailing list or email us at <a href="mailto:go-cdk-feedback@google.com" target="_blank" rel="noopener">go-cdk-feedback@google.com</a>.</p></blockquote><hr><p>Go Cloud記事はこちらもご参考ください。</p><ul><li><a href="/articles/20191111/">Go Cloud#1 概要とBlobへの活用方法</a></li><li>Go Cloud#2 Pub/Subの概要紹介（この記事です）</li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でも DX チームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは。TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Cloud#1 概要とBlobへの活用方法</title>
    <link href="https://future-architect.github.io/articles/20191111/"/>
    <id>https://future-architect.github.io/articles/20191111/</id>
    <published>2019-11-11T02:15:01.000Z</published>
    <updated>2019-11-28T04:13:33.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>TIG DX Unit所属の多賀です。今回は、Go Cloudシリーズとしていくつか Go Cloudに関する記事をリレー形式で書いていきたいと思います。</p><p>第一弾としては、Go Cloud についての概要と、案件でも活用した Blob を利用したサンプルについて解説します。また、認証系の情報の扱いについても記載します。</p><p>Go Cloud記事はこちらもご参考ください。</p><ul><li>Go Cloud#1 概要とBlobへの活用方法（この記事です）</li><li><a href="https://future-architect.github.io/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><h1 id="Go-Cloud-とは"><a href="#Go-Cloud-とは" class="headerlink" title="Go Cloud とは"></a>Go Cloud とは</h1><p>2018/07 に Google の Go チームが立ち上げたプロジェクトで、Go アプリケーションを各クラウド間でポータブルにすることを目指して、実装されています。</p><p>昨今の開発では、マルチクラウドやハイブリッドクラウドの導入により、アプリケーションを複数のクラウドに対応させる要件がでてきています。現状では、各クラウドサービスの SDK を利用して、クラウドごとにアプリケーションコードを実装する必要がありますが、正直大変な部分もあるかと思います。</p><p>ですが、各クラウドのサービスをまとめて抽象化して、統一的なコードでアクセスできれば、ソースコードの重複を排除できて便利になりそうです。(実際、各クラウドごとに似たようなサービスは出ているので抽象化はさほど困難ではないですよね。)<br>この <strong>「各クラウドサービスに統一的なコードでアクセスする」</strong> ことを実現して、Goのアプリケーションをクラウド間でポータブルにするためのツールとして Go Cloud は開発されています。</p><p>イメージとしては、データベースアクセスがあげられるかと思います。データベースも様々な種類(MySQL,PostgreSQL,Oracle,SQLite, etc..)が存在しますが、アプリケーションとして実装する際は統一的なコードを通して、アクセスすることが多いかと思います。実際は、言語により driver interface が提供されて、各データベースごとに driver が実装されているため、この機能は実現できています。同様なことをクラウドの SDK に対して実現していきたい思惑があるのだと考えています。</p><p>実際に API の仕様設計で、データベースと似たような設計思想で作られていることが言及されていて面白かったです。(<a href="https://github.com/google/go-cloud/blob/master/internal/docs/design.md#portable-types-and-drivers" target="_blank" rel="noopener">link</a>)(個人的には、<a href="https://github.com/google/go-cloud/blob/master/internal/docs/design.md#developers-and-operators" target="_blank" rel="noopener">Developers and Operators</a>の章も面白かったのでおすすめです。)</p><p>実装は OSS で公開されております。<br><a href="https://github.com/google/go-cloud" target="_blank" rel="noopener">https://github.com/google/go-cloud</a></p><p>ドキュメントのベージは別でこちらです。<br><a href="https://gocloud.dev/" target="_blank" rel="noopener">https://gocloud.dev/</a></p><p>ここで少々余談ですが、Go Cloud は公式的な呼称は「Go CDK (Cloud Development Kit)」となっています(<a href="https://blog.golang.org/gcdk-whats-new-in-march-2019" target="_blank" rel="noopener">Blog</a>)。当シリーズ記事では、他サービスとの命名がかぶることでググラビリティが下がることを懸念して、「Go Cloud」と統一しております。</p><h2 id="プロジェクトの状況"><a href="#プロジェクトの状況" class="headerlink" title="プロジェクトの状況"></a>プロジェクトの状況</h2><p>2019/11 現在 Alpha ステータスですが、Production Ready である旨は言及されています。(breaking change があるとの文言は 2019/02 に削除されています) (<a href="https://github.com/google/go-cloud#project-status" target="_blank" rel="noopener">link</a>)</p><h2 id="対応クラウド"><a href="#対応クラウド" class="headerlink" title="対応クラウド"></a>対応クラウド</h2><p>下記クラウドの一部サービスに対応しています。</p><ul><li>AWS</li><li>GCP</li><li>Azure</li><li>HashiCorp</li></ul><p><a href="https://blog.golang.org/go-cloud" target="_blank" rel="noopener">vendor-neutral なAPIを実装していくと言及</a>されているので、<br>対象クラウドを絞っているわけではなく、順次拡大する方針のようです。</p><h2 id="導入の検討対象"><a href="#導入の検討対象" class="headerlink" title="導入の検討対象"></a>導入の検討対象</h2><p>どういったケースで、利用を検討できるか <a href="https://blog.golang.org/gcdk-whats-new-in-march-2019" target="_blank" rel="noopener">The Go Blog</a> にて言及されている内容を引用いたします。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. You develop cloud applications locally.</span><br><span class="line">  -&gt; クラウドアプリケーションをローカルで開発</span><br><span class="line"></span><br><span class="line">2. You have on-premise applications that you want to run in the cloud (permanently, or as part of a migration).</span><br><span class="line">  -&gt; オンプレのアプリケーションをクラウド上で動かしたい</span><br><span class="line"></span><br><span class="line">3. You want portability across multiple clouds.</span><br><span class="line">  -&gt; 複数クラウド間で動作するアプリケーションを開発したい</span><br><span class="line"></span><br><span class="line">4. You are creating a new Go application that will use cloud services.</span><br><span class="line">  -&gt; クラウドが提供するサービスを利用したアプリケーションを作りたい</span><br></pre></td></tr></table></figure><p>少々、補足コメントとして私の考えを記載していきます。</p><h3 id="1-クラウドアプリケーションをローカルで開発"><a href="#1-クラウドアプリケーションをローカルで開発" class="headerlink" title="1.クラウドアプリケーションをローカルで開発"></a>1.クラウドアプリケーションをローカルで開発</h3><p>クラウドアプリケーションをローカルで開発する際に、利用するクラウドサービスへの接続に困るケースが出てくるかと思います(権限/通信 etc..)。<br>現状の解決策としては、AWS だと <a href="https://github.com/localstack/localstack" target="_blank" rel="noopener">LocalStack</a>や<a href="https://github.com/awslabs/serverless-application-model" target="_blank" rel="noopener">AWS SAM</a>, GCP だと Emulator の利用があるかと思います。これはローカル環境に実際のクラウドサービスのモックを立ち上げて、処理を実行させる解決策で、とても便利です(私もよく利用しています)。</p><p>Go Cloud ではこの課題を、「各環境に合わせて実装を差し替える」ことで解決しています。例えば、S3 からファイルを読み出すコードを実装したい場合は、ローカル環境では実際に S3 にアクセスする代わりに、ローカルのファイルシステムにアクセスさせます。ローカルのファイルシステム上にファイルを用意しておくことで、クラウド上と同一の挙動を実現できます。開発時はファイルシステム、デプロイ後は S3 アクセスとすることを、Go Cloud を間に挟むことで簡単に実現できます。(ファイルパスを <code>s3://</code> → <code>file://</code> と変える)<br>また、単体テストを実装するのにも便利そうです</p><h3 id="2-オンプレのアプリケーションをクラウド上で動かしたい"><a href="#2-オンプレのアプリケーションをクラウド上で動かしたい" class="headerlink" title="2.オンプレのアプリケーションをクラウド上で動かしたい"></a>2.オンプレのアプリケーションをクラウド上で動かしたい</h3><p>オンプレでのアプリケーションの実装を Go Cloud での実装に差し替えることで、オンプレでも動作させつつ、クラウド上でも同一のコードで動作させることができます。</p><h3 id="3-複数クラウド間で動作するアプリケーションを開発したい"><a href="#3-複数クラウド間で動作するアプリケーションを開発したい" class="headerlink" title="3.複数クラウド間で動作するアプリケーションを開発したい"></a>3.複数クラウド間で動作するアプリケーションを開発したい</h3><p>マルチクラウドで実装する際に、各クラウドごとのサービスは利用しない or 各サービスの抽象化レイアーを自作して実装等が考えられるかと思います。後者の抽象化レイアーを自作部分を Go Cloud が担ってくれることで、AWS 上では DynamoDB, GCP 上では Firestore, オンプレでは MongoDB といった使い分けも実現することができます。</p><h3 id="4-クラウドが提供するサービスを利用したアプリケーションを作りたい"><a href="#4-クラウドが提供するサービスを利用したアプリケーションを作りたい" class="headerlink" title="4.クラウドが提供するサービスを利用したアプリケーションを作りたい"></a>4.クラウドが提供するサービスを利用したアプリケーションを作りたい</h3><p>3 と少し異なり、動作させる環境は AWS 上ですが、アプリケーションの挙動内で各クラウドへ接続するケースでも利用できます。例としてはアプリケーション内で、S3/GCS/Azure Storage へアクセスしてファイルを取得する必要がある場合があげられます。<br>私の案件での導入はこの例のケースで、各 Blob システムに対してのアクセスをシンプルに実装したいと考えて利用しています。</p><h2 id="用語"><a href="#用語" class="headerlink" title="用語"></a>用語</h2><p>下記の実装の説明で、用語が出てくるため補足しておきます。</p><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p>driver interface としてGo Cloud上で定義されています(例: <a href="https://github.com/google/go-cloud/blob/master/blob/driver/driver.go#L224" target="_blank" rel="noopener">blob driver</a>)。各クラウド SDK ごとに driver の実装をします。(データベースと同様ですね)<br>driverの実装も、現状は合わせて Go Cloud上で行われています。 (<a href="https://github.com/google/go-cloud/blob/master/blob/s3blob/s3blob.go" target="_blank" rel="noopener">s3 driver実装</a>)</p><h3 id="portable-type"><a href="#portable-type" class="headerlink" title="portable type"></a>portable type</h3><p>ユーザーが実際に利用する API で、concrete type(interface ではない)が返却されます。</p><p>driver interface を利用して、共通の API が実装されています。driver interface を直接ユーザーに公開せず、共通的な実装を driver-user 間にいれたいため、このような形になっています。</p><p>また concrete type 利用の理由は、共通実装が interface の場合は重複してしまう(各 driver ごとに複製の実装が必要)ため、スケールしないためと記載されています。<br>(<a href="https://github.com/google/go-cloud/blob/master/internal/docs/design.md#portable-types-and-drivers" target="_blank" rel="noopener">Desing Doc 参照</a>)</p><h1 id="Blob-での活用"><a href="#Blob-での活用" class="headerlink" title="Blob での活用"></a>Blob での活用</h1><p>Blob Storage での活用方法について、記載していきます。</p><h2 id="サポート済みサービス"><a href="#サポート済みサービス" class="headerlink" title="サポート済みサービス"></a>サポート済みサービス</h2><ul><li>Amazon Simple Storage Service(S3)</li><li>Google Cloud Storage(GCS)</li><li>Azure Blob Storage</li><li>ローカルファイルシステム</li><li>オンメモリ</li></ul><h2 id="サンプル実装"><a href="#サンプル実装" class="headerlink" title="サンプル実装"></a>サンプル実装</h2><p>Blob(S3)から指定した key のファイルを取得するサンプルです。</p><p><code>blob.OpenBucket()</code> を呼び出して、 <code>Bucket</code> オブジェクトを取得して、オブジェクトのメソッドを通して、各種処理を実行します。 <code>Bucket</code> オブジェクトから <code>NewReader()</code>/<code>NewWriter()</code> を呼び出すことで、 <code>io.Reader</code>/<code>io.Writer</code> インターフェイスを得ることもできます。 (<a href="https://godoc.org/gocloud.dev/blob#Bucket" target="_blank" rel="noopener">blob - GoDoc</a>)</p><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gocloud.dev/blob"</span></span><br><span class="line"><span class="comment">// 対象の driver を blank import する</span></span><br><span class="line">_ <span class="string">"gocloud.dev/blob/s3blob"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkBlobFileContent</span><span class="params">(bucketURL, key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"> bucket, err := blob.OpenBucket(context.Background(), bucketURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> bucket.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// blob から 指定した key の content を取得</span></span><br><span class="line">b, err := bucket.ReadAll(context.Background(), key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := checkBlobFileContent(<span class="string">"s3://future-example"</span>, <span class="string">"hoge.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>サンプルを見ていただいたとおり、 <code>OpenBucket()</code> 呼び出し時には特に S3 固有の処理を実行していません。</p><p>Go Cloud 側でクラウドサービスごとに実装を切り替えているのですが、実際の切り替えソースとしては URL Schema が利用されています。</p><p>少し脱線しますが、実装の切替方法としては下記の通りになっています。</p><ol><li>対象の driver (s3blob) を blank import</li><li>driver 内の init 関数で Schema が defaultURLMux に登録 (<a href="https://github.com/google/go-cloud/blob/master/blob/s3blob/s3blob.go#L85" target="_blank" rel="noopener">src</a>)</li><li>s3 の Schema は default で <code>s3</code> が定義されている (<a href="https://github.com/google/go-cloud/blob/master/blob/s3blob/s3blob.go#L121" target="_blank" rel="noopener">src</a>)</li><li>OpenBucket 内で defaultURLMux を利用して、Bucket オブジェクト生成 (<a href="https://github.com/google/go-cloud/blob/master/blob/blob.go#L1085" target="_blank" rel="noopener">src</a>)</li></ol><p>そのため blank import がないと、切り替え対象がないエラーになってしまうので注意です。</p><h3 id="テストコード"><a href="#テストコード" class="headerlink" title="テストコード"></a>テストコード</h3><p>動作確認したかったため、テストコードを実装しました。</p><p>テストでは S3 に接続したくなかったため、ローカルファイルシステムを利用しています。</p><p>先程とは違い、<code>fileblob</code> を blank import しています。</p><p>hoge.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUCCESS!!!</span><br></pre></td></tr></table></figure><p>main_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"gocloud.dev/blob/fileblob"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_checkBlobFileContent</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">pwd, err := os.Getwd()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">bucketURL <span class="keyword">string</span></span><br><span class="line">key       <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">args    args</span><br><span class="line">want    <span class="keyword">string</span></span><br><span class="line">wantErr <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">"local storage test"</span>,</span><br><span class="line">args: args&#123;</span><br><span class="line">bucketURL: fmt.Sprintf(<span class="string">"file:///%v"</span>, pwd),</span><br><span class="line">key:       <span class="string">"hoge.txt"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">want:    <span class="string">"SUCCESS!!!"</span>,</span><br><span class="line">wantErr: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got, err := checkBlobFileContent(tt.args.bucketURL, tt.args.key)</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>) != tt.wantErr &#123;</span><br><span class="line">t.Errorf(<span class="string">"checkBlobFileContent() error = %v, wantErr %v"</span>, err, tt.wantErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">t.Errorf(<span class="string">"checkBlobFileContent() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>テスト結果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v .</span><br><span class="line">=== RUN   Test_checkBlobFileContent</span><br><span class="line">=== RUN   Test_checkBlobFileContent/local_storage_test</span><br><span class="line">--- PASS: Test_checkBlobFileContent (0.00s)</span><br><span class="line">    --- PASS: Test_checkBlobFileContent/local_storage_test (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example.com/xxxx/gocdk-blog    0.019s</span><br></pre></td></tr></table></figure><p>無事テストがパスして、ローカルファイル上のファイルが読み込めております。</p><h3 id="認証情報について"><a href="#認証情報について" class="headerlink" title="認証情報について"></a>認証情報について</h3><p><code>OpenBucket()</code> を利用することで、S3/ローカルファイルシステムを切り替えられることは説明いたしました。</p><p>ですが実運用となると、認証情報付きで扱いたいケースが多くなってきます。</p><p>その場合は、driver の実装側に認証情報付きで <code>Bucket</code> オブジェクトを生成する関数が用意されているためそちらを利用します。</p><p><a href="https://github.com/google/go-cloud/blob/master/blob/s3blob/s3blob.go#l180" target="_blank" rel="noopener">go-cloud/blob/s3blog.go</a> から引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenBucket returns a *blob.Bucket backed by S3.</span></span><br><span class="line"><span class="comment">// AWS buckets are bound to a region; sess must have been created using an</span></span><br><span class="line"><span class="comment">// aws.Config with Region set to the right region for bucketName.</span></span><br><span class="line"><span class="comment">// See the package documentation for an example.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenBucket</span><span class="params">(ctx context.Context, sess client.ConfigProvider, bucketName <span class="keyword">string</span>, opts *Options)</span> <span class="params">(*blob.Bucket, error)</span></span> &#123;</span><br><span class="line">drv, err := openBucket(ctx, sess, bucketName, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> blob.NewBucket(drv), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>こちらを利用することで実現できるのですが、実装側がクラウドごとの仕様に汚染されることが想像できます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkBlobFileContent</span><span class="params">(bucketName, key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// S3固有の処理になってしまう</span></span><br><span class="line">  sess := session.Must(session.NewSession(&amp;aws.Config&#123;&#125;))</span><br><span class="line">  bucket, err := s3blob.OpenBucket(context.Background(), sess, bucketName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>認証系を扱いたい場合はどうしても、処理を各クラウドごとに分ける必要があります。</p><p>ですが、<code>Bucket</code> オブジェクトを生成する関数と利用する関数を分けることで汚染先を減らすことができます。</p><p>私が実際に実装したコードはだいたい、下記の通りにしております。ビジネスロジック側には、 <code>Bucket</code> オブジェクトを渡すことでクラウド SDK ごとの依存を <code>New 関数</code> 内に閉じ込めています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session は各クラウドごとの認証情報を格納する struct</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">S3Config        *aws.Config</span><br><span class="line">GCSCredential   *google.Credentials</span><br><span class="line">AzureCredential *azblob.SharedKeyCredential</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(ctx context.Context, urlstr <span class="keyword">string</span>, sess Session)</span> <span class="params">(*blob.Bucket, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 切り替えは url schema で実現されているため raw url で受け取って変換</span></span><br><span class="line">u, err := url.Parse(urlstr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go Cloud側の実装に合わせて、schemaでswitchさせる</span></span><br><span class="line"><span class="keyword">switch</span> u.Scheme &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"s3"</span>:</span><br><span class="line">sess, err := session.NewSession(sess.S3Config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"create s3 session failed: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s3blob.OpenBucket(ctx, sess, u.Host, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"gs"</span>:</span><br><span class="line">token := gcp.CredentialsTokenSource(sess.GCSCredential)</span><br><span class="line">client, err := gcp.NewHTTPClient(gcp.DefaultTransport(), token)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gcsblob.OpenBucket(ctx, client, u.Host, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"azblob"</span>:</span><br><span class="line">pipeline := azureblob.NewPipeline(sess.AzureCredential, azblob.PipelineOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> azureblob.OpenBucket(ctx, pipeline, azureblob.AccountName(sess.AzureCredential.AccountName()), u.Host,</span><br><span class="line">&amp;azureblob.Options&#123;Credential: sess.AzureCredential&#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mem"</span>:</span><br><span class="line"><span class="keyword">return</span> blob.OpenBucket(ctx, urlstr)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unsupported scheme: %v"</span>, u.Scheme)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このあたりは、 正直あまりイケていないので、もっと良い実装がしたいなと思っています。</p><p><a href="https://github.com/google/wire" target="_blank" rel="noopener">Wire</a> を利用することで解決できないかなと、もやもや考えてます。<br>(Wireとは、過去Go Cloudリポジトリに同梱されていて、今は別リポジトリで管理されている DI ツールです。コード生成をすることで、DIを実現しています。)</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Go Cloud の概要と目指す先について、また Blob のサンプル実装について解説しました。</p><p>プロジェクト自体で実現したいことも非常に面白いかつ有用ですし、実際に Blob で利用してみて、オブジェクト生成部分のみ気を使えば、GCS,Azure Storage などの接続先をかんたんに追加できました。また、OSS ですので内部のコードを追うことで SDK の利用方法についても知ることができます。Go Cloud側で SDK を適切に使えているかチェックすることもできますし(安心)、利用したことのない SDK の参考実装を調べることもできます。Azure Storage は初めて利用したのですが、GoDoc を追うことでなにの情報を渡せば接続できるか等が簡単に理解できました。このように、学習する範囲を狭めてくれる点も、良い点ではないかと思いました。  </p><p>今後も、活用していきたいですし、動向をWatchしていきたいです。</p><hr><p>Go Cloud記事はこちらもご参考ください。</p><ul><li>Go Cloud#1 概要とBlobへの活用方法（この記事です）</li><li><a href="https://future-architect.github.io/articles/20191112/">Go Cloud#2 Pub/Subの概要紹介</a></li><li><a href="/articles/20191113/">Go Cloud#3 Go CloudのDocStoreを使う</a></li><li><a href="/articles/20191114/">Go Cloud#4 URLを編集するパッケージ</a></li><li><a href="/articles/20191115/">Go Cloud#5 AWSのローカルモック環境であるLocalStackを活用する</a></li><li><a href="/articles/20191119/">Go Cloud#6 GCPのローカルエミュレータを活用する</a></li><li><a href="/articles/20191128/">Go Cloud#7 PubSubドライバー(pubだけ)を実装してみる</a></li></ul><p>関連記事：</p><ul><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20191030/">GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;TIG DX Unit所属の多賀です。今回は、Go Cloudシリーズとしていくつか Go Cloudに関する記事をリレー形式で書いていきた
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>インフラ入門vol.3(ネットワーク冗長化構成)</title>
    <link href="https://future-architect.github.io/articles/20191107/"/>
    <id>https://future-architect.github.io/articles/20191107/</id>
    <published>2019-11-07T02:01:01.000Z</published>
    <updated>2019-11-07T02:20:36.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、TIG所属インフラエンジニアの市川です。</p><p>記事のテーマについてvol.2との棲み分けをどうしようかと思っていたのですが、前職がゴリゴリのネットワークエンジニアということもあり、折角なのでネットワークを深掘りしたいと思います。</p><p>クラウド全盛期の今でも社内ネットワークや既存のオンプレシステムなどネットワークなしにシステムを語ることはできません。いつでも繋がるネットワークを構築するために、サービスをエンドユーザー様に快適に使っていただくために、冗長化設計は避けて通れません。とは言え、ネットワークは簡単に作り直せない分、古き良き？構成が残ったままになりがちです。</p><p>お客様先でもまだまだ課題となっている冗長化構成の改善について、打ち合わせについていった新人さんが「なんだ、、、この呪文は、、、」とならないための入門記事をしたためようと思います。</p><p><strong>⚠️[WARNING]この記事はとても長いです⚠️</strong></p><h2 id="過去記事について"><a href="#過去記事について" class="headerlink" title="過去記事について"></a>過去記事について</h2><ol><li><a href="https://future-architect.github.io/articles/20170109/">インフラ入門vol.1</a>：インフラ全般に興味を持ってもらうためのアツい記事です。</li><li><a href="https://future-architect.github.io/articles/20170704/">インフラ入門vol.2(ネットワーク)</a>：ネットワークって何さ？から仕様検討の上での入門知識が書かれた記事です。</li><li>インフラ入門vol.3(ネットワーク冗長化構成)：この記事。冗長構成にスポットライトをあてた若干ニッチな記事です。</li></ol><h2 id="なぜ冗長化？？？"><a href="#なぜ冗長化？？？" class="headerlink" title="なぜ冗長化？？？"></a>なぜ冗長化？？？</h2><p>そもそもなぜ冗長化なのでしょう。というか冗長って何でしょうか。</p><p><a href="https://ja.wikipedia.org/wiki/%E5%86%97%E9%95%B7%E5%8C%96" target="_blank" rel="noopener">Wikipedia</a>によると…</p><blockquote><p>冗長化（じょうちょうか）とは、システムの一部に何らかの障害が発生した場合に備えて、障害発生後でもシステム全体の機能を維持し続けられるように、予備装置を平常時からバックアップとして配置し運用しておくこと。冗長化によって得られる安全性は冗長性と呼ばれ、英語ではredundancyと呼ぶ。</p><p>常に実用稼動が可能な状態を保ち、使用しているシステムに障害が生じたときに瞬時に切り替えることが可能な仕組みを持つ。障害によってシステムが本来の機能を失うと、人命や財産が失われたり、企業活動が大きな打撃を受けるような場合には、冗長性設計が必須となっている。</p></blockquote><p>ナルホド。1段落目にとっても重要なことが書いてあります。</p><p>ネットワークが、サーバが、故障しました！<br>→ ヤバい！予備がない！<br>→ 発注して、データセンタへの設置のために色々申請をして。<br>→ バックアップがあればそこから戻して・・・あ！機器の構成管理してない！<br>→ 手動でコンフィグのインストールして・・・。</p><p>―― おそらくこの時点で2, 3ヶ月はかかっているでしょう。<br>何故こうなったか説明を求められるでしょうし、もしかしたら賠償になるかも。人命に関わることもあるかもしれません。まぁ、この例は流石に杜撰すぎますが。</p><p>今やネットワークインフラやその上で提供される数多のサービスは電気や水道のように生活になくてはならない<strong>ライフライン</strong>です。一般的な日本語では冗長は「無駄」という意味合いがありますが、冗長設計をすることは決して無駄でなく、<strong>お客様とその快適な生活を守るために必要な最低限考慮すべき事項</strong>です。</p><h2 id="何をどこまでやるのか"><a href="#何をどこまでやるのか" class="headerlink" title="何をどこまでやるのか"></a>何をどこまでやるのか</h2><p>冗長化とは<strong>SPOF（Single Point of Failure / 単一障害点）</strong>を排除することだと認識しています。</p><p>SPOF排除における基本的な考え方は、</p><ul><li>負荷分散及び障害時の迂回経路を提供するActive/Active構成</li><li>障害時に自動で切り替わるような迂回経路を提供するActive/Standby構成</li></ul><p>上記は<strong>ホットスタンバイ</strong>といい、冗長機器は常に稼働し続け、<strong>「自動」</strong>での切り替わりを提供します。<br>一般にデータセンタや中・大規模な顧客拠点（オフィスネットワーク）、保守員のいない遠隔地ではこの構成が取られます。</p><p>また、小規模な顧客拠点などでは<strong>コールドスタンバイ</strong>という構成を取ることもあります。ホットスタンバイなActive/Standby構成をとった場合、Standbyの機器に通信がやってくるのは障害時かメンテナンス時くらいです。</p><p>もしかしたらラックのスペースがないかもしれませんし、電気が足りないかも・・・。お金もかかる。そういう場合には予め本番機同等の設定をした予備機を用意することで障害時に差し替えを行い、障害時間をある程度短縮するといった手法が取られます。</p><p>さて、上記の構成が取られることはわかりましたが、実際問題どこまで対策すればよいのでしょうか。</p><ul><li>LANケーブルや光ケーブル、電源を複数持たせればOK？</li><li>機器筐体そのものを複数もたせる？</li><li>この際回線も複数もたせる？衛星回線用意する？<ul><li>回線事業者分けたり、通る収容局分けたり、収容される機器分けたり！？（どこまで対応してくれるかですが。）</li></ul></li><li>都内数カ所とかにデータセンタを複数構築する？</li><li>大規模災害起きたらだから、BCP（Business continuity planning / 事業継続計画）拠点も作る？</li></ul><p><a href="https://future-architect.github.io/articles/20170704/">インフラ入門vol.2(ネットワーク)</a>にもありますが、「<strong>機械の故障等による停止はどの程度まで許容できるのか</strong>」が重要なポイントです。モノの納期や金銭的問題、例えばBCP発動時の手順の整備・訓練など対策を講じれば講じるほど運用は難度を増します。</p><p><strong>非機能要件定義</strong>の段階で十分にお客様と調整を行いましょう。</p><p>※よく打ち合わせなんかでMTBFとかMTTRなんて言葉も出てくるので、覚えておきましょう。</p><ul><li>MTBF: Mean Time Between Failures / 平均故障間隔</li><li>MTTR: Mean Time To Repair / 平均復旧時間</li></ul><h2 id="具体的な設計について"><a href="#具体的な設計について" class="headerlink" title="具体的な設計について"></a>具体的な設計について</h2><p>前置きが長くなりました。</p><p>さて、冗長構成はレイヤごとに分けて考えるとたくさんやることがあります。</p><p>よくインフラ屋さんが使う言葉に<strong>OSI参照モデル</strong>というものがあります。いわゆるネットワークの統一規格で下記の7層に分けることができます。</p><table><thead><tr><th>レイヤ</th><th>層名称</th><th>役割</th></tr></thead><tbody><tr><td>1</td><td>物理層</td><td>LANケーブル、光ケーブル、無線などの信号規約などを提供する</td></tr><tr><td>2</td><td>データリンク層</td><td>機器間のデータ伝送や経路選択を提供する</td></tr><tr><td>3</td><td>ネットワーク層</td><td>複数のネットワークにまたがった経路選択を提供する</td></tr><tr><td>4</td><td>トランスポート層</td><td>ネットワーク接続された端末間のエンドツーエンドの通信を提供する</td></tr><tr><td>5</td><td>セッション層</td><td>通信の開始から終了の規定を提供する</td></tr><tr><td>6</td><td>プレゼンテーション層</td><td>文字コードや圧縮形式、暗号化の方法などを提供する</td></tr><tr><td>7</td><td>アプリケーション層</td><td>サービスプロトコル（HTTP/FTPなど）にネットワーク機能を提供する</td></tr></tbody></table><p>ここからはそれぞれのレイヤごとに対策を見ていきましょう。<br>※筆者はCisco機器を扱うことが多かったので、Cisco用語がそれとなく出てきます。あしからず。</p><h2 id="レイヤ1（物理層）"><a href="#レイヤ1（物理層）" class="headerlink" title="レイヤ1（物理層）"></a>レイヤ1（物理層）</h2><p>※実際は信号規約なのでアレですが広義に捉えます。広い心で。</p><h3 id="電源冗長（RPS-Redundant-Power-Supply）"><a href="#電源冗長（RPS-Redundant-Power-Supply）" class="headerlink" title="電源冗長（RPS / Redundant Power Supply）"></a>電源冗長（RPS / Redundant Power Supply）</h3><p>ネットワーク機器やサーバにはモジュラタイプの電源を複数搭載可能なモデルがあります。<br>筐体（機械）の本体を開けたりドライバーがなくても引っこ抜いて差し込む作業だけで電源の交換が可能です。<br>RPSを利用するなら最低限電源を取得する分電盤もPS（Power Supply）ごとに分けるようにしましょう。</p><h3 id="FAN冗長"><a href="#FAN冗長" class="headerlink" title="FAN冗長"></a>FAN冗長</h3><p>コレは割とオマケですが、サーバの中には冗長FANを搭載できるモデルがあります。<br>熱で死んでいった機械をたくさん見てきたので、CPUぶん回す処理が多いことがわかっていたら備えておきましょう。<br>そもそも空調設計的なものもかかわってきますが。</p><h2 id="レイヤ2（データリンク層）"><a href="#レイヤ2（データリンク層）" class="headerlink" title="レイヤ2（データリンク層）"></a>レイヤ2（データリンク層）</h2><h3 id="Teaming-Link-Aggregation"><a href="#Teaming-Link-Aggregation" class="headerlink" title="Teaming / Link Aggregation"></a>Teaming / Link Aggregation</h3><img src="/images/20191107/layer2.png"><p>NIC（ネットワークインターフェースカード）を複数搭載した機器同士の物理リンクを束ねて一本の物理リンクとして取り扱う機能で、NICやケーブルの障害対策、あるいは負荷分散のために利用されます。</p><p>ちなみにドキュメントに記載された名称がベンダによって違います。</p><ul><li>WIndows系 → チーミング（Teaming）</li><li>Linux系 → ボンディング（Bonding）</li><li>Cisco系 → イーサチャンネル（Ether channel） ※Port channelと呼ぶことも。</li><li>その他① → リンクアグリゲーション（Link Aggregation） ※この呼び方をよく使っていました。<strong>LAG</strong>ですね。</li><li>その他② → ポートトランキング（Port trunking） ※ProCurveなどがこの呼び方。</li></ul><p>また、束ねるケーブルがFastEther（100Mbps）だと<strong>FEC</strong>、GigabitEther（1Gbps）だと<strong>GEC</strong>とか言ったりします。</p><p>重要なのが、サーバでは<strong>NICそのものの障害</strong>、L2SW/L3SWでは<strong>ASIC</strong>（Application Specific Integrated Circuit / スイッチング用の専用回路）の障害、シャーシ型の場合はスイッチングモジュールの障害を念頭に置く必要があります。</p><p>せっかく冗長化しててもPCIeスロットが同じNICを使ってたり、同じASICやスイッチングモジュールに所属するポートを利用していては可用性が低下します。サービスレベルによっては上記のような点もしっかり抑えておきましょう。</p><p><strong>【動作モード】</strong><br>Teaming / Link Aggregationでは静的あるいは動的に同じグループとして束ねられるポートを選択します。</p><p>また、ややこしいことにこのモード次第で負荷分散方式が変わったりします。</p><ul><li><p><strong>「スイッチに依存しない」モード</strong></p><ul><li>負荷分散を行わないActive/Standby構成（フォールトトレランス）やActive/Active構成でもサーバから送信されるトラフィックのみ負荷分散を行うモード。</li></ul></li><li><p><strong>「静的 / static」モード</strong></p><ul><li>Active/Active構成で送受信ともに負荷分散を行うが、機械にネゴシエーションをさせず、手動で割当を決める方式。</li><li>正直後述のLACPに対応してるなら選定することはほぼないかなという所感。</li></ul></li><li><p><strong>「動的 / LACP」モード</strong></p><ul><li>Active/Active構成で送受信ともに負荷分散を行い、障害時にメンバーポートをLAG（Link Aggregation Group）から切り離します。</li><li>Cisco独自のPAgPというモードもありましたが、機器を選ぶので選定することはないはずです。</li></ul></li></ul><p><strong>【ハッシュポリシー】</strong><br>負荷分散の際に何を基準にして分散するか、を選択できます。ちょっと脇道なので、サラッと説明しますが、Layer2、Layer2+3、Layer3+4などの種類があります。詳しくは<a href="https://access.redhat.com/documentation/ja-jp/red_hat_enterprise_linux/7/html/networking_guide/sec-using_channel_bonding" target="_blank" rel="noopener">RHELのドキュメントに・・・</a></p><p>推奨はLayer3+4ですが、IPパケットフラグメントなど無視できない問題があったりするので、Layer2+3を選ぶことが多い印象です。</p><h3 id="スパニングツリー（Spanning-Tree）"><a href="#スパニングツリー（Spanning-Tree）" class="headerlink" title="スパニングツリー（Spanning Tree）"></a>スパニングツリー（Spanning Tree）</h3><img src="/images/20191107/spanning_tree.png"><p>L2スイッチでは通常、受信したフレームの宛先が不明な場合など特定の状況下で、一旦すべてのポートにそのフレームを転送します。（<strong>フラッディング</strong>）上図のようにその動作を円環（ループ構成）で行ったらどうなるでしょう。<br>フレームはぐるぐると機器間を回り続け、ネットワークが使用不可になってしまいます。（<strong>ブロードキャストストーム</strong>）</p><p>これを防ぐためのプロトコルが<strong>Spanning Tree Protocol</strong>と呼ばれるものです。<br>簡単に説明すると下図のように「利用可能な経路の一つをバックアップ用として利用不可にすることでループ構成を排除する」というものになります。（いくつかのルールによって木構造を構成します。）<br><img src="/images/20191107/spanning_tree_block.png"></p><p>非常に単純なプロトコルなのですが、ベンダごとの（というかCiscoの）独自実装や既存機器の設定によって影響を受けることもあり、数多くのネットワークエンジニアを泣かせた機能だと（勝手に）思っています。</p><p>STP関連のプロトコルは実装は複数あり、</p><ul><li>CST（Common Spanning Tree）: すべての仮想LAN（VLAN）で同じ木構造を取る。</li><li>PVST+（Per Vlan Spanning Tree Plus）：各VLANで個別の木構造を取ることが可能。</li><li>RST（Rapid Spanning Tree）：CSTの高速化版。障害発生時最大50秒の通信断が発生していたが、RSTPでは1秒未満に短縮。</li><li>RPVST+（Rapid Per Vlan Spanning Tree Plus）：PVSTの高速化版。障害発生時最大50秒の通信断が発生していたが、RPVST+では1秒未満に短縮。</li><li>MST（Multiple Spanning Tree）：RPVST+と似た実装。設計は複雑になりがちだが、RPVST+より負荷が軽く、効率が良い。</li></ul><p>遅いCSTやPVST+を積極的に採用することはないですが、小型機はこれらしかサポートしてない場合もあります。<br>そして厄介なことにSTPトポロジ内に一個でもCSTやPVST+が混ざっていると、全体がそちらに引っ張られて収束が遅くなるので注意・・・・。<br>中規模でCiscoロックインであればRPVST+（一部HPEのスイッチなどは互換性がある。）、Vlanの数が非常に多い、あるいは複数ベンダ機器が混在する場合はMSTで実装すると良いでしょう。<br>とはいえ、既存ネットワークの状態、運用者のスキルにもよるので、ヒアリングを欠かさないこと。</p><p>STPの構成ではどうしても一つ利用されない経路が存在します。これを利用するようにするにはPVSTやMSTでもある程度解決できますが、より実装が複雑になったり、思わぬ動作を引き起こす場合があります。<br>帯域の利用率が非常に高いネットワークでは後述のスタックなど、別な方法で冗長化構成を取るべきです。</p><h3 id="スタック、バーチャルシャーシ（StackWise-VSS-IRF）など"><a href="#スタック、バーチャルシャーシ（StackWise-VSS-IRF）など" class="headerlink" title="スタック、バーチャルシャーシ（StackWise / VSS / IRF）など"></a>スタック、バーチャルシャーシ（StackWise / VSS / IRF）など</h3><img src="/images/20191107/stack_virtual_chassis.png"><p>スタック、バーチャルシャーシは<strong>物理的に2台のスイッチを仮想的に1台として</strong>扱うことのできる技術です。<br>コンフィグの管理も1台分だけすればよく、設定管理などが簡素になります。（機種によっては3台以上をまとめることも可能）<br>また、未使用帯域が存在するなどのSTPの問題を解決する構成が可能となります。<br>スタックは通常BOX型のスイッチの、バーチャルシャーシはシャーシ型のスイッチでの呼び方となります。</p><p>最も有効な構成としてはLink Aggregationと組み合わせた構成があります。<br>下図の構成では、三角形のループ構造のように見えますが、実際は上図と同じ様にループフリー構成として運用が可能です。<br>MECとありますが、Multi Chassis Ether Channelの略です。</p><img src="/images/20191107/stack_virtual_chassis_mec.png"><p>が、この技術も若干デメリットが有り、下記の制約があります。</p><ul><li>同じファームウェアバージョンである必要がある</li><li>フィーチャーセット（機能レベル）が同じ必要がある</li><li>SDMテンプレートが同一である必要がある（Ciscoの場合）</li></ul><p>上記制約のため、機器が対応していない場合は容易にOSのアップデートができない、メンテナンス時の通信の片寄時に通信断が発生する可能性があるなどの問題が発生する場合があります。</p><p>なお、スイッチ間をつなぐケーブルにはDAC（Direct Attach Cable）と言われるSFP+と光ケーブルがセットになったケーブルや、個別にSFP+と光ケーブルを購入してつなぐ、などのパターンがあります。購入し忘れに注意しましょう。</p><h3 id="Ethernet-Fabric"><a href="#Ethernet-Fabric" class="headerlink" title="Ethernet Fabric"></a>Ethernet Fabric</h3><img src="/images/20191107/Ethernet_Fabric.png"><p>これまではツリー型構造を前提としたネットワーク構成での冗長化がベースでしたが、より大規模なデータセンターネットワークにおいてレイヤ2の概念を置き換える考え方が登場しました。<br>ツリー構造ではなくメッシュ構造に近く、非常に柔軟なネットワークを提供することができます。</p><p>ベースとなっているのは以下の技術です。</p><ul><li>Trill（Transparent Interconnect of Lots of Links）</li><li>SPB（Shortest Path Bridging）</li></ul><p>ざっくりというと下記の特徴があります。（ベンダごとに細かい拡張があるのでそこは割愛）</p><ul><li>STPフリー：L2スイッチのような筐体はモジュールとして動作するため、仮想的に1つの筐体のポートとして扱える。</li><li>コンフィグの一元化：スタック同様、中央集中的にコンフィグの管理が可能</li></ul><p>機器が非常に高価なのと、高密度に集約されることでケーブル配線やラック配置の設計難度があがります。</p><h2 id="レイヤ3（ネットワーク層）"><a href="#レイヤ3（ネットワーク層）" class="headerlink" title="レイヤ3（ネットワーク層）"></a>レイヤ3（ネットワーク層）</h2><h3 id="VRRP-HSRP-GLBP"><a href="#VRRP-HSRP-GLBP" class="headerlink" title="VRRP / HSRP / GLBP"></a>VRRP / HSRP / GLBP</h3><img src="/images/20191107/stack_mec.png"><p>VRRP（Virtual Router Redundancy Protocol）とHSRP（Hot Standby Router Protocol）は基本的にActive/Standbyの<strong>ゲートウェイ冗長化</strong>機能を提供する機能です。（2台以上での冗長化も可能）</p><ul><li>HSRPはCisco独自機能で、VRRPは標準規格です。若干の仕様の違いはあれどすごく雑に言うと概ね同じ仕組みで動作します。</li><li>VRRPではMulti-Group、HSRPではMultiple実装があり、グループごとに主系/副系を変えることで簡易的にActive/Activeな構成を取ることも可能です。</li><li>GLBP（ Gateway Load Balancing Protocol ）は、またものすごくざっくりいうとゲートウェイに対応したMACアドレスをラウンドロビン方式で順番に返すことで標準でActive/Activeな構成を取る事ができるCisco独自機能です。（変更可能）</li></ul><p>基本的にはVRRPが後発でプロトコル実装的にIPパケットで動作するので、VRRPを使うことが多いです。<br>　※HSRPはUDPで動作しますので、若干のオーバーヘッドを嫌いたくなります。<br>　※GLBPは上述のEthernet FabricのCisco版で使うことがあるかも。（使ったことはないですが・・・）</p><h3 id="ECMP（Equal-Cost-Multi-Path）"><a href="#ECMP（Equal-Cost-Multi-Path）" class="headerlink" title="ECMP（Equal Cost Multi Path）"></a>ECMP（Equal Cost Multi Path）</h3><img src="/images/20191107/floating-static-2.png"><p>動的ルーティングプロトコルでは経路交換時に同じ宛先の経路が複数ある場合、最もコストが低い経路をルーティングテーブルに読み込みます。<br>このとき各経路のコストが等しい場合、複数の経路をルーティングテーブルに持ち、負荷分散することが可能です。これをEMCPと呼びます。</p><p>EMCPはそのバランシングにより下記の2つの実装があります。</p><ul><li><p>Per packet ECMP</p><ul><li>パケットごとに経路を振り分けてくれる。</li><li>理想的にバランシングされる一方、リンクに求められる遅延差がシビアで、実は障害に弱い（影響を受けやすい）。<ul><li>TCPやUDPにおいてフラグメントされたパケットの処理やパフォーマンスに問題が出ることも。</li></ul></li></ul></li><li><p>Per flow ECMP</p><ul><li>フローごとに経路を振り分けてくれる。（フローの定義はベンダによって異なる）</li><li>Per packet ECMPで起きる問題が発生しない。</li><li>バランシングを完璧にこなすのは考慮事項が多く、非常に困難。</li><li>一般的にはこちらが採用されている。</li></ul></li></ul><p>よく利用されるルーティングプロトコルにはBGP、OSPFがあり、概ね以下の区分けです。</p><ul><li>OSPF（Open Shortest Path Fast）：内部ネットワークでの経路交換に利用されるプロトコル。</li><li>BGP（Border Gateway Protocol）：外部ネットワークとの経路交換に利用されるプロトコル。最近内部ネットワークでもレイヤ2排除のために使われる。</li></ul><h2 id="レイヤ4（トランスポート層）／レイヤ7（アプリケーション層）"><a href="#レイヤ4（トランスポート層）／レイヤ7（アプリケーション層）" class="headerlink" title="レイヤ4（トランスポート層）／レイヤ7（アプリケーション層）"></a>レイヤ4（トランスポート層）／レイヤ7（アプリケーション層）</h2><p>主にロードバランサ、ファイアウォール、セキュリティアプライアンス系がこの層に該当します。</p><blockquote><p>図がシングル構成になっていますが、コレまで紹介した機能と心の目で冗長化してみてください。</p></blockquote><h3 id="ロードバランサ"><a href="#ロードバランサ" class="headerlink" title="ロードバランサ"></a>ロードバランサ</h3><p>ロードバランサ（LB）の構成は通信経路の途中に横付けするワンアーム構成（LANが1本だから）と経路に挟み込むツーアーム（インライン）構成があります。<br>大まかにワンアームとツーアームはどっち選べば！？という点については個人的にはワンアームが良いと考えています。<br>現状動作しているネットワークにLBを挟み込む場合でも物理構成に変更を与えることなく追加が可能な点と、経路上にLBが存在しないため、メンテナンスし易いことが挙げられます。</p><h4 id="ワンアーム（One-arm）構成／SNAT-DSR構成"><a href="#ワンアーム（One-arm）構成／SNAT-DSR構成" class="headerlink" title="ワンアーム（One-arm）構成／SNAT/DSR構成"></a>ワンアーム（One-arm）構成／SNAT/DSR構成</h4><p>ワンアーム構成一つとっても（知ってる限りで）3つの構成を取ることができます。</p><p>1つ目はリアルサーバ、バーチャルサーバ、デフォルトGWを同一セグメントにする、あるいはリアルサーバのデフォルトGWをバーチャルサーバ（LB）のIPアドレスを指定する場合です。<br>すべての通信はわかりやすくLBを通過するため、セグメントに余裕があれば構成しやすいのがメリットかなと思います。<br><img src="/images/20191107/photo_20191107_01.png" style="border:solid 1px #000000"></p><p>2つ目はSNAT構成です。例えばリアルサーバ群がVMなど横にスケールする構成で、もうIPの空きに余裕がない、とか、通信要件でリアルサーバのGWはL3SWでないとダメ。といった場合にはSNATという機能を使います。</p><p>行き帰りの通信経路が異なる場合、LBはセッションを確立することができないため、NAT（Network Address Translation）機能を利用して、送信元IPをLBのIPに変換することで強制的にLBを通すということが可能です。<br><img src="/images/20191107/photo_20191107_02.png" style="border:solid 1px #000000"></p><p>3つめはDSR（Direct Server Return）構成です。<br>DSRはその名の通り、ロードバランサに着信したクライアントからのパケットを帰りは<strong>LBを経由せずに直接</strong>クライアントに返す構成です。イマドキのLB構成においてDSRは敢えて選択する方式ではないという認識です。</p><p>ちなみにこの構成もL3DSRとL2DSRです。</p><img src="/images/20191107/photo_20191107_03.png" style="border:solid 1px #000000"><p><strong>メリット</strong></p><ul><li>LBでSNATなどの処理を行う必要がなくなるため、リソースに余裕ができる＆スループットが向上する。</li></ul><p><strong>デメリット</strong></p><ul><li>L4ロードバランサとしてしか利用できない（SSL終端とかは無理）</li><li>みんな大好きARP/GARP（L2機能）を使うため、面倒を見るレイヤがちょっと広くなる。（L2DSRの場合）</li><li>方式によるが、MTU（トンネル方式）やDSCP（DSCP方式）の値に制限がでる（L3DSRの場合）</li></ul><p>そもそも最近の（大手だと）BIG-IPやA10のロードバランサは十分な処理速度があり、SSLもなんならLBのアクセラレータを通したほうがスループット向上に寄与したりするので、必要でなければDSR以外を選びたいところです。</p><h4 id="ツーアーム（Two-arm）構成"><a href="#ツーアーム（Two-arm）構成" class="headerlink" title="ツーアーム（Two-arm）構成"></a>ツーアーム（Two-arm）構成</h4><p>ツーアーム構成はその名の通り2本の腕で通信経路中に挟み込まれる構成です。</p><p>ネットワークエンジニアとサーバエンジニアが分かれているときなど、ネットワーク屋さんだけでLBを構成する場合はこちらの構成が単純で問題も少ないです。<br>こんな構成にするんじゃない、って話ですが、下図のような構成をとったときにLBに関係ないサーバもLBを通るという状況が発生しますので注意が必要なのと、帯域は十分に確保したほうが良いです。</p><blockquote><p>だってL3SWに空きポートが無いんだもんとか、歴史的理由によりサーバは子のSW配下にしかつけちゃダメとかの背景でやむを得ずこんな構成になったり</p></blockquote><img src="/images/20191107/photo_20191107_04.png" style="border:solid 1px #000000"><h3 id="セキュリティアプライアンス"><a href="#セキュリティアプライアンス" class="headerlink" title="セキュリティアプライアンス"></a>セキュリティアプライアンス</h3><p>ニッチ＆ニッチですが、Fire eyeなどのセキュリティアプライアンスを導入する場合も構成方法が複数あります。<br>当然ですが、セキュリティアプライアンスはそれを通過するパケットを監視します。したがって、何らかの方法でパケットをセキュリティアプライアンスに入れてあげることが必要です。</p><h4 id="スパン・タップ構成"><a href="#スパン・タップ構成" class="headerlink" title="スパン・タップ構成"></a>スパン・タップ構成</h4><p>ネットワーク機器にはSPAN（Switched Port Analyzer）という機能が存在する機種があります。<br>要は特定のポートを通過したパケットを別なポートにコピーする機能です。当然といえば当然ですが、SPANはCPUを使った処理になるので、ルータやスイッチの負荷が上がりがちです。</p><img src="/images/20191107/photo_20191107_05.png" style="border:solid 1px #000000"><p>上記問題を解決するためにタップという機器もあります。通信経路に挟み込んで信号を分岐するための機器で、電源故障時も通信をバイパスすることで可用性を下げることなく（機種によります）導入することが可能です。高価ですが・・・。</p><img src="/images/20191107/photo_20191107_06.png" style="border:solid 1px #000000"><p>通信に影響をあたえることがないため、インライン構成よりこちらの構成がおすすめです。ネットワーク的には。<br>とはいえ、セキュリティアプライアンスの機能をフルに活用する場合にはインライン構成の方がベターだったりしますので、要件次第ですね。</p><h4 id="インライン構成"><a href="#インライン構成" class="headerlink" title="インライン構成"></a>インライン構成</h4><p>セキュリティアプライアンスに搭載されている冗長化（HA）機能を利用することが一般的です。<br>構成としてはLBと同じくとてもわかり易いですね。</p><img src="/images/20191107/photo_20191107_07.png" style="border:solid 1px #000000"><h3 id="ファイアウォール"><a href="#ファイアウォール" class="headerlink" title="ファイアウォール"></a>ファイアウォール</h3><p>前提として<strong>ステートフルフェイルオーバー</strong>に対応しているか否かを事前に確認しましょう。<br>だいたい対応しているとは思いますが、対応していない場合はVRRPでの冗長構成が一般的ですが、そもそもセッションなどのステート（状態）を引き継がないため、切り替わり時に通信断が発生するなど、辛い現実を突きつけられることも。。。</p><img src="/images/20191107/photo_20191107_08.png" style="border:solid 1px #000000"><h4 id="Active-Passive"><a href="#Active-Passive" class="headerlink" title="Active/Passive"></a>Active/Passive</h4><p>この構成は単純で、よくある構成です。<br><strong>ステートフルフェイルオーバー</strong>に対応したファイアウォールではスタンバイ機への同期は常に行われ、障害時の切り替わりに備えています。<br>OSのバージョンアップなどのメンテナンス行為もしやすく、通信路の帯域などが許す場合はこちらがおすすめです。</p><h4 id="Active-Active"><a href="#Active-Active" class="headerlink" title="Active/Active"></a>Active/Active</h4><p>この構成では常に両方のファイアウォールでのトラフィック検査を行います。<br><strong>ステートフルフェイルオーバー</strong>に対応したファイアウォールでは相互にセッションのやり取りを同期します。<br>機種によっては行き帰りのトラフィックが異なるファイアウォールを通る場合、破棄される可能性があります。十分に検証しましょう。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>まとめと言ってもとっちらかってしまうのですが、ココまで読まれたアナタは鋼のメンタルがあるのでぜひ一緒にインフラ屋さんをやりましょう。</p><p><strong>動いて当たり前</strong>なネットワークインフラの背景にはネットワークエンジニアがアレコレ頭を捻ったネットワークトポロジが存在しています。</p><p>前述しましたとおり、クラウドサービスの台頭でなかなかガッツリ触ることのなくなってきたネットワークですが、ネットワーク技術がなくなることは今後もないでしょうし、オンプレのネットワークに触れるときがあればこんな記事があったな、と思いだしてもらえると幸いです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、TIG所属インフラエンジニアの市川です。&lt;/p&gt;
&lt;p&gt;記事のテーマについてvol.2との棲み分けをどうしようか
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="Network" scheme="https://future-architect.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>AWS Glueの開発エンドポイントがそこそこお高いのでローカル開発環境を用意しました</title>
    <link href="https://future-architect.github.io/articles/20191101/"/>
    <id>https://future-architect.github.io/articles/20191101/</id>
    <published>2019-11-01T04:37:19.000Z</published>
    <updated>2019-11-01T05:22:10.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG DXチームの村瀬です。</p><p>AWS Glue利用していますか？ETL処理をする上で大変便利ですよね。しかしながら開発に必要不可欠な開発エンドポイントが少々お高く、もう少し安価に利用できればなーと思っていたところ、さすがAWSさん素敵なリリースをしてくれました。</p><img src="/images/20191101/1.png" class="img-middle-size" style="border:solid 1px #000000"><p><a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/08/aws-glue-releases-binaries-of-glue-etl-libraries-for-glue-jobs/" target="_blank" rel="noopener">https://aws.amazon.com/jp/about-aws/whats-new/2019/08/aws-glue-releases-binaries-of-glue-etl-libraries-for-glue-jobs/</a></p><h1 id="AWS-Glueとは"><a href="#AWS-Glueとは" class="headerlink" title="AWS Glueとは"></a>AWS Glueとは</h1><p>過去のこちらの記事もご参考ください。</p><ul><li><a href="/articles/20180828/">5TB/日 のデータをAWS Glueでさばくためにやったこと（概要編</a></li><li><a href="/articles/20181205/">5TB/日 のデータをAWS Glueでさばくためにやったこと（性能編）</a></li></ul><h1 id="ローカルPCの環境を汚さない為に"><a href="#ローカルPCの環境を汚さない為に" class="headerlink" title="ローカルPCの環境を汚さない為に"></a>ローカルPCの環境を汚さない為に</h1><p>作業を開始する前に確認したところ、Glueバージョン1.0を動かす場合にはSpark2.4.3が必要でそのSparkを動かす為にはJava 8が必要でまたPythonも3.6が必要とのこと。<br>依存関係が結構ありそうですね。</p><p>GlueをローカルPCで動かす為にJavaやPythonのバージョン変えるの嫌だなぁ。チームメンバーも嫌がるだろうし環境構築の為の手順用意するの面倒だしトラブった時に対応したくないなと思ったのでローカルPCの環境を汚さないように今回はDockerで用意してみることにしました。</p><p><a href="https://docs.aws.amazon.com/ja_jp/glue/latest/dg/aws-glue-programming-etl-libraries.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/ja_jp/glue/latest/dg/aws-glue-programming-etl-libraries.html</a><br>を参考にPython,Java,Glueライブラリ,Maven,Glueアーティファクトを取得・インストールするよう記載したDockerfileを用意して実行してみると…<br>(※Dockerfileは後ほど出てきます)</p><h1 id="ハマリポイント"><a href="#ハマリポイント" class="headerlink" title="ハマリポイント"></a>ハマリポイント</h1><p>./aws-glue-libs/bin/gluepyspark 実行時にエラー発生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">～中略～</span><br><span class="line">py4j.protocol.Py4JJavaError: An error occurred while calling None.org.apache.spark.api.java.JavaSparkContext.</span><br><span class="line">: java.lang.NoSuchMethodError: io.netty.buffer.PooledByteBufAllocator.defaultNumHeapArena()I</span><br><span class="line">        at org.apache.spark.network.util.NettyUtils.createPooledByteBufAllocator(NettyUtils.java:113)</span><br><span class="line">        at org.apache.spark.network.client.TransportClientFactory.&lt;init&gt;(TransportClientFactory.java:106)</span><br><span class="line">        at org.apache.spark.network.TransportContext.createClientFactory(TransportContext.java:99)</span><br><span class="line">        at org.apache.spark.rpc.netty.NettyRpcEnv.&lt;init&gt;(NettyRpcEnv.scala:71)</span><br><span class="line">        at org.apache.spark.rpc.netty.NettyRpcEnvFactory.create(NettyRpcEnv.scala:461)</span><br><span class="line">        at org.apache.spark.rpc.RpcEnv$.create(RpcEnv.scala:57)</span><br><span class="line">        at org.apache.spark.SparkEnv$.create(SparkEnv.scala:249)</span><br><span class="line">        at org.apache.spark.SparkEnv$.createDriverEnv(SparkEnv.scala:175)</span><br><span class="line">        at org.apache.spark.SparkContext.createSparkEnv(SparkContext.scala:257)</span><br><span class="line">        at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:424)</span><br></pre></td></tr></table></figure><p>すんなり行きませんでした。<br>エラーを確認するとio.netty.buffer.PooledByteBufAllocator.defaultNumHeapArena()なんて無いよと言われていますね。</p><p>無いと言われているものを探してみます。<br><code>find / -name *netty*</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/opt/spark-2.4.3-bin-spark-2.4.3-bin-hadoop2.8/jars/netty-3.9.9.Final.jar</span><br><span class="line">/opt/spark-2.4.3-bin-spark-2.4.3-bin-hadoop2.8/jars/netty-all-4.1.17.Final.jar</span><br><span class="line">～中略～</span><br><span class="line">/aws-glue-libs/jarsv1/netty-3.6.2.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-all-4.0.23.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-buffer-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-codec-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-codec-http-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-common-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-handler-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-resolver-4.1.17.Final.jar</span><br><span class="line">/aws-glue-libs/jarsv1/netty-transport-4.1.17.Final.jar</span><br></pre></td></tr></table></figure><p>？？？<br>いっぱい見つかりますね。</p><p>先人の知恵を借りましょう。<br><a href="https://stackoverflow.com/questions/50388919/spark-2-3-java-lang-nosuchmethoderror-io-netty-buffer-pooledbytebufallocator-me" target="_blank" rel="noopener">stackoverflow Spark 2.3 java.lang.NoSuchMethodError: io.netty.buffer.PooledByteBufAllocator.metric</a></p><p>どうやらNettyのjarのバージョンが合ってないことが原因のようです。<br>改めて比較して確認してみるとspark側のjarのバージョンの方が新しいですね。</p><figure class="highlight sh"><figcaption><span>spark</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/netty-3.9.9.Final.jar</span><br><span class="line">/netty-all-4.1.17.Final.jar</span><br></pre></td></tr></table></figure><figure class="highlight sh"><figcaption><span>aws-glue-libs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/netty-3.6.2.Final.jar</span><br><span class="line">/netty-all-4.0.23.Final.jar</span><br></pre></td></tr></table></figure><p>またまた先人の知恵を借りましょう。<br><a href="https://github.com/awslabs/aws-glue-libs/issues/25" target="_blank" rel="noopener">GitHub gluepyspark errors on local development #25</a></p><p>どうやらaws-glue-libsを参照せずにsparkのjarファイルを参照すれば良いようです。<br><code>ln -s ${SPARK_HOME}/jars /aws-glue-libs/jarsv1</code></p><p>これでdocker buildがエラーなく成功し、docker runした上でdocker execでコンテナに入り、この状態で以下のコマンドを実行すると<br><code>./aws-glue-libs/bin/gluepyspark</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">～中略～</span><br><span class="line">19/10/25 09:58:38 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &apos;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.4.3</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.8 (default, Aug  7 2019 17:28:10)</span><br><span class="line">SparkSession available as &apos;spark&apos;.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>無事にSparkを起動することができました。</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>みんなお待ちかねのDockerファイルはこちら</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> Future y.murase</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://omohikane.com/centos7_docker_python36/ を参考にpythonとjavaをインストール</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y bzip2 bzip2-devel gcc gcc-c++ make openssl-devel readline-devel zlib-devel wget curl unzip vim epel-release git &amp;&amp; yum install -y tig jq vim-enhanced bash-completion net-tools <span class="built_in">bind</span>-utils \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install -y https://centos7.iuscommunity.org/ius-release.rpm \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install -y python36u python36u-libs python36u-devel python36u-pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install -y java java-1.8.0-openjdk-devel \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/cache/yum/*</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> localedef -f UTF-8 -i ja_JP ja_JP.UTF-8</span></span><br><span class="line"><span class="keyword">ENV</span> LANG ja_JP.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> LC_CTYPE <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_NUMERIC <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_TIME <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_COLLATE <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_MONETARY <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_MESSAGES <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_PAPER <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_NAME <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_ADDRESS <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_TELEPHONE <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_MEASUREMENT <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_IDENTIFICATION <span class="string">"ja_JP.UTF-8"</span></span><br><span class="line"><span class="keyword">ENV</span> LC_ALL ja_JP.UTF-<span class="number">8</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Glueライブラリ取得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> -b glue-1.0 --depth 1  https://github.com/awslabs/aws-glue-libs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maven取得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -OL https://archive.apache.org/dist/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzvf apache-maven-3.6.2-bin.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv apache-maven-3.6.2 /opt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /opt/apache-maven-3.6.2 /opt/apache-maven</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/lib/jvm/java-<span class="number">1.8</span>.<span class="number">0</span>-openjdk/jre/</span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:/opt/apache-maven/bin</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -version</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Glueアーティファクト取得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -OL https://aws-glue-etl-artifacts.s3.amazonaws.com/glue-1.0/spark-2.4.3-bin-hadoop2.8.tgz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzvf spark-2.4.3-bin-hadoop2.8.tgz </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv spark-2.4.3-bin-spark-2.4.3-bin-hadoop2.8 /opt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /opt/spark-2.4.3-bin-spark-2.4.3-bin-hadoop2.8 /opt/spark</span></span><br><span class="line"><span class="keyword">ENV</span> SPARK_HOME /opt/spark</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.6を利用する設定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> unlink /bin/python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /bin/python3 /bin/python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /bin/pip3.6 /bin/pip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 異なるバージョンのjarがsparkとglueに混在するので適切なバージョンのみを見るよう設定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s <span class="variable">$&#123;SPARK_HOME&#125;</span>/jars /aws-glue-libs/jarsv1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./aws-glue-libs/bin/gluepyspark</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"while :; do sleep 10; done"</span>]</span></span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>少々苦労しましたが先人の知恵を借りて問題解決できました。<br>これで複数いる開発メンバーにDockerイメージさえ渡せばローカル環境を汚すことなく簡単にかつお財布にやさしくローカルPCにGlueの開発環境が用意できますね。<br>Glueのローカル開発環境構築にチャレンジしたけどエラーが出て諦めてしまった人の手助けになれたら幸いです。</p><p>なお、この記事を作成する上で以下のページを参考にさせていただきました。<br><a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/08/aws-glue-releases-binaries-of-glue-etl-libraries-for-glue-jobs/" target="_blank" rel="noopener">https://aws.amazon.com/jp/about-aws/whats-new/2019/08/aws-glue-releases-binaries-of-glue-etl-libraries-for-glue-jobs/</a><br><a href="https://docs.aws.amazon.com/ja_jp/glue/latest/dg/aws-glue-programming-etl-libraries.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/ja_jp/glue/latest/dg/aws-glue-programming-etl-libraries.html</a><br><a href="https://omohikane.com/centos7_docker_python36/" target="_blank" rel="noopener">https://omohikane.com/centos7_docker_python36/</a><br><a href="https://stackoverflow.com/questions/50388919/spark-2-3-java-lang-nosuchmethoderror-io-netty-buffer-pooledbytebufallocator-me" target="_blank" rel="noopener">https://stackoverflow.com/questions/50388919/spark-2-3-java-lang-nosuchmethoderror-io-netty-buffer-pooledbytebufallocator-me</a><br><a href="https://github.com/awslabs/aws-glue-libs/issues/25" target="_blank" rel="noopener">https://github.com/awslabs/aws-glue-libs/issues/25</a></p><hr><p>関連記事：</p><ul><li><a href="/articles/20180828/">5TB/日 のデータをAWS Glueでさばくためにやったこと（概要編</a></li><li><a href="/articles/20181205/">5TB/日 のデータをAWS Glueでさばくためにやったこと（性能編）</a></li><li><a href="/articles/20191009/">AWS Session Managerでセッションを切断されにくくする方法</a></li><li><a href="/articles/20190902/">AWS IAMロールの信頼関係の気になる動作</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG DXチームの村瀬です。&lt;/p&gt;
&lt;p&gt;AWS Glue利用していますか？ETL処理をする上で大変便利です
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>GoでCUEのバリデーション機能を利用しつつ、.cue/.json/.yaml形式の設定ファイルを読み込む</title>
    <link href="https://future-architect.github.io/articles/20191030/"/>
    <id>https://future-architect.github.io/articles/20191030/</id>
    <published>2019-10-30T02:01:41.000Z</published>
    <updated>2019-11-01T04:32:28.624Z</updated>
    
    <content type="html"><![CDATA[<p>人間が読み書きする設定ファイルについて、2つのエントリーを紹介してきました。今回は第3段です。</p><ul><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li></ul><p>前回のエントリーで、<a href="https://cuelang.org/" target="_blank" rel="noopener">CUE</a>はテキストファイルのフォーマットでありつつもJSON/YAMLと同等の表現力（階層が持てて、文字列や数値などを扱える）を持ち、なおかつCUEコマンドやライブラリでは.cue/.json/.yamlを同列に入力ファイルとして扱えるということを紹介しました。また、.cueファイルにスキーマを定義して、バリデーションが行えることも紹介しました。</p><p>今回は、Goのパッケージを利用して、.cue/.json/.yaml形式の設定ファイル読み込み機能をアプリケーションに組み込んでみます。本家の一次資料としては次のサイトになりますので、細かい機能やAPIを知りたい場合はこちらを参照してください。</p><ul><li><a href="https://cuelang.org/docs/integrations/go/" target="_blank" rel="noopener">https://cuelang.org/docs/integrations/go/</a></li></ul><p><strong>10/31修正</strong> @apstndbさんに構造体へのタグのマッピングの部分で<a href="https://twitter.com/apstndb/status/1189435828025491456" target="_blank" rel="noopener">指摘</a>をいただいて修正しました</p><h1 id="全体の流れと利用するパッケージ"><a href="#全体の流れと利用するパッケージ" class="headerlink" title="全体の流れと利用するパッケージ"></a>全体の流れと利用するパッケージ</h1><p>次の処理をまとめて行ってみます。</p><ul><li>アプリケーションは設定ファイルを読み込みます。<ul><li>設定ファイルのフォーマットは.cue/.json/.yamlのすべてのフォーマットに対応するものとします。</li></ul></li><li>読み込んだあとにスキーマによるチェック、デフォルト値の補完を行い、エラーがなければ構造体に値をマップしてアプリケーション本体に結果を渡します。</li></ul><p>Goのencoding/jsonなどはフォーマットさえ合っていればエラーを返すことはありません。アプリケーション側で必須な値が省略されてもゼロ値になるだけで、エラーにしたりしてくれませんし、省略時にデフォルト値を入れることもできません。それらはすべてアプリケーションコードで行う必要がありました。</p><p>CUEのGo用のライブラリを使うと、バリデーションと補完をすべてスキーマファイル任せにできますので、プログラムはシンプルになります。</p><p>CUEのAPIはいくつかのパッケージに分かれています。今回紹介するのは次の4つです。</p><ul><li><a href="https://godoc.org/cuelang.org/go/cue" target="_blank" rel="noopener">“cuelang.org/go/cue”</a>: あらゆるパッケージに共通の型定義や変換、.cueファイルの入出力など</li><li><a href="https://godoc.org/cuelang.org/go/encoding/gocode/gocodec" target="_blank" rel="noopener">“cuelang.org/go/encoding/gocode/gocodec”</a>: Goの構造体への値のマッピングなど</li><li><a href="https://godoc.org/cuelang.org/go/encoding/json" target="_blank" rel="noopener">“cuelang.org/go/encoding/json”</a>: JSON形式による入出力</li><li><a href="https://godoc.org/cuelang.org/go/encoding/yaml" target="_blank" rel="noopener">“cuelang.org/go/encoding/yaml”</a>: YAML形式による入出力</li></ul><h1 id="スキーマの定義"><a href="#スキーマの定義" class="headerlink" title="スキーマの定義"></a>スキーマの定義</h1><p>テスト用の設定のスキーマは.cueで書きます。リアルなユースケースではもっと多くなるでしょうが、とりあえず必須属性のポート番号と、ログレベル（省略時は”info”）の2つだけにしておきます。</p><figure class="highlight plain"><figcaption><span>schema.cue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port:      uint16</span><br><span class="line">logLevel:  &quot;debug&quot; | *&quot;info&quot; | &quot;warn&quot; | &quot;error&quot; | &quot;critical&quot;</span><br></pre></td></tr></table></figure><p>プログラムには、文字列型としてそのまま取り込んでおきます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="string">`</span></span><br><span class="line"><span class="string">    port:      uint16</span></span><br><span class="line"><span class="string">    logLevel:  "debug" | *"info" | "warn" | "error" | "critical"</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h1 id="処理の流れ"><a href="#処理の流れ" class="headerlink" title="処理の流れ"></a>処理の流れ</h1><p>それでは実装していきます。</p><h2 id="cueファイルを読み込んでバリデーション"><a href="#cueファイルを読み込んでバリデーション" class="headerlink" title=".cueファイルを読み込んでバリデーション"></a>.cueファイルを読み込んでバリデーション</h2><p>前回のエントリーで、CUEのバリデーションの基本的な戦術について次のように紹介しました。</p><blockquote><p>CUEはJSONと違って、同じキーの定義が複数あってもエラーになりません。登場するたびに、制約が掛け合わされていくような感じです。これを応用して型定義を行なっていきます。複数の条件をかけあわせていく中で矛盾が出ると「コンフリクトがあった」といった感じでエラーになります。</p></blockquote><p>GoのAPIも流れとしては同じです。アプリケーションの設定ファイルと、スキーマ定義の両方のインスタンスを作成し、その２つのインスタンスをマージします。そうすると実際の値とスキーマの条件が両方定義されたインスタンスが作成できるので、バリデーションを行います。</p><p>スキーマも同じフォーマットに従っているので、アプリケーションの設定フォーマットに.cueを使えば、利用者側で新しく制約を追加することも可能です。例えば、デプロイ用の環境はproduction/staging/performancetest/developmentから選ぼう、それから外れたものはエラーにする、みたいなことが可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ランタイムの宣言（ゼロ初期化でOK）</span></span><br><span class="line"><span class="keyword">var</span> r cue.Runtime</span><br><span class="line"></span><br><span class="line"><span class="comment">// スキーマのインスタンスを作成</span></span><br><span class="line">schemaInstance, err := r.Compile(<span class="string">"schema.cue"</span>, schema)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 設定ファイルの方のインスタンスを作成</span></span><br><span class="line">valueInstance, err := r.Compile(filePath, reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse CUE file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// マージすると、また同じ形式(cue.Instance)の合成されたインスタンスが作られる</span></span><br><span class="line">merged := cue.Merge(schemaInstance, valueInstance)</span><br><span class="line"><span class="comment">// バリデーション</span></span><br><span class="line">err = merged.Value().Validate()</span><br></pre></td></tr></table></figure><p><code>r.Compile()</code>の最後の引数は、ドキュメントを見るとinterface{}型の引数ですが、io.Readerでも、[]byteでも、stringでも動くというAPIになっています。他には見ない設計で面白いですね。</p><h2 id="JSON-YAMLも読み込む"><a href="#JSON-YAMLも読み込む" class="headerlink" title="JSON/YAMLも読み込む"></a>JSON/YAMLも読み込む</h2><p>JSON/YAMLファイルを読み込み、.cueと同様にcue.Instanceのインスタンスを作成してみます。最初のコードは.cueしか読みませんが、拡張子を見て他の形式も読み込めるようにします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> valueInstance *cue.Instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> filepath.Ext(filePath) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".cue"</span>:</span><br><span class="line">valueInstance, err = r.Compile(filePath, reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse CUE file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".json"</span>:</span><br><span class="line">decoder := json.NewDecoder(&amp;r, filePath, reader)</span><br><span class="line">valueInstance, err = decoder.Decode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse JSON file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".yaml"</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".yml"</span>:</span><br><span class="line">valueInstance, err = yaml.Decode(&amp;r, filePath, reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse YAML file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"file extension should be .cue, .json, .yaml or .yml, but %s"</span>, filepath.Ext(filePath))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意ポイントとしては、.cueも.jsonも.yamlも、それぞれのパッケージで定義されている関数を読み込むだけですが、それぞれ、関数の形が結構違っていて、パッケージ名だけを書き換えればOKとはいかない点です。</p><h2 id="構造体へのマッピング"><a href="#構造体へのマッピング" class="headerlink" title="構造体へのマッピング"></a>構造体へのマッピング</h2><p>encoding/jsonなどの標準パッケージ同様に、タグが付与されている構造体に設定ファイル内部の値を読み込んで割り当てていくことが可能です。そのために構造体を定義します。このマッピング用の構造体は基本的にJSON用のものとほぼ同じです。JSON用のタグがそのまま利用できます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Port <span class="keyword">uint16</span> <span class="string">`json:"port"`</span></span><br><span class="line">LogLevel <span class="keyword">string</span> <span class="string">`json:"logLevel"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>読み込むコードはencoding/jsonパッケージを使ったことがあればおなじみですが、JSONの場合はjsonからGoの構造体に値を入れるのをDecode、Goの構造体からシリアライズしてio.Writerを使ってファイルに変換したりする方をEncodeと呼びましたが、cueはなぜか逆転しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config Config</span><br><span class="line">codec := gocodec.New(&amp;r, &amp;gocodec.Config&#123;&#125;)</span><br><span class="line"><span class="comment">// 最初紹介した、スキーマと設定ファイルをマージしたcueのインスタンスを受け取り、構造体にマップ</span></span><br><span class="line">err = codec.Encode(merged.Value(), &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Encode error: %w"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://godoc.org/cuelang.org/go/encoding/gocode/gocodec#Codec.ExtractType" target="_blank" rel="noopener">また、<code>cue</code> タグを使うことで、構造体の中に制約を書くことができます</a>。プログラムと近いところにスキーマ定義を置いておきたい場合にはこちらの方がスムーズでしょう。</p><h1 id="完成したコード"><a href="#完成したコード" class="headerlink" title="完成したコード"></a>完成したコード</h1><p>今まで紹介してきた処理をまとめたのが次のコードです。io.Reader(ファイルでも何でも)と、フォーマット識別のためのファイル名を受け取ると、バリデーション・補完をした結果を構造体にマップして返します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"path/filepath"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"cuelang.org/go/cue"</span></span><br><span class="line"><span class="string">"cuelang.org/go/encoding/gocode/gocodec"</span></span><br><span class="line"><span class="string">"cuelang.org/go/encoding/json"</span></span><br><span class="line"><span class="string">"cuelang.org/go/encoding/yaml"</span></span><br><span class="line"><span class="string">"go.pyspa.org/brbundle"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="string">`</span></span><br><span class="line"><span class="string">port: uint16</span></span><br><span class="line"><span class="string">logLevel:  "debug" | *"info" | "warn" | "error" | "critical"</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Port <span class="keyword">uint16</span> <span class="string">`json:"port"`</span></span><br><span class="line">LogLevel <span class="keyword">string</span> <span class="string">`json:"logLevel"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getConfig</span><span class="params">(filePath <span class="keyword">string</span>, reader io.Reader)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r cue.Runtime</span><br><span class="line"></span><br><span class="line">schemaInstance, err := r.Compile(<span class="string">"schema"</span>, schema)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> valueInstance *cue.Instance</span><br><span class="line"><span class="keyword">switch</span> filepath.Ext(filePath) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".cue"</span>:</span><br><span class="line">valueInstance, err = r.Compile(filePath, reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse CUE file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".json"</span>:</span><br><span class="line">decoder := json.NewDecoder(&amp;r, filePath, reader)</span><br><span class="line">valueInstance, err = decoder.Decode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse JSON file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".yaml"</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".yml"</span>:</span><br><span class="line">valueInstance, err = yaml.Decode(&amp;r, filePath, reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Parse YAML file error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"file extension should be .cue, .json, .yaml or .yml, but %s"</span>, filepath.Ext(filePath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merged := cue.Merge(schemaInstance, valueInstance)</span><br><span class="line">err = merged.Value().Validate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Validation error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config Config</span><br><span class="line">codec := gocodec.New(&amp;r, &amp;gocodec.Config&#123;&#125;)</span><br><span class="line">err = codec.Encode(merged.Value(), &amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Encode error: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;config, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用する側のコードはこんな感じですかね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"go.uber.org/zap"</span></span><br><span class="line">    <span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> configPath = flag.String(<span class="string">"conf"</span>, <span class="string">"config.cue"</span>, <span class="string">"Config file"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    c, err := os.Open(*configPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Can't open config file %s: %v"</span>, *configPath, err)</span><br><span class="line">    &#125;</span><br><span class="line">    config, err := getConfig(*configPath, c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Can't read config file %s: %v"</span>, *configPath, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ↓ここから先は正しい設定ファイルが読み込めて設定済みの状態でロジックを書き始められる</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ロガーのZapのログレベル設定</span></span><br><span class="line">    <span class="keyword">var</span> level zapcore.Level</span><br><span class="line">    <span class="keyword">var</span> zc zap.Config</span><br><span class="line">    zc.Level.SetLevel(level.Set(config.LogLevel))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTPサーバーのポートの設定</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(fmt.Sprintf(<span class="string">":%d"</span>, config.Port), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>CUEのGoのAPIを使ってみました。</p><p>構造体へのマップ機能を使ってしまえば、アプリケーション側での準備はJSONとそれほど変わりませんし（読み込み部分は今回のサンプルのほぼコピペで毎回カバーできるはず）、アプリケーションコード側で設定を利用するときにコード補完も利用できて実装は捗るでしょう。その構造体も、前々回のエントリーで紹介したように、最初にJSONの設定ファイルのサンプルを作ればJSON-to-Goを利用してマッピング用の構造体もかんたんに作れることも紹介しました。</p><p>Goは文法がシンプルが故に、設定値の異常チェックやら、値が設定されてなかったらデフォルト値を利用するというコード（JSやRubyの <code>config.port || 8080</code>とかPythonの<code>config.port or 8080</code>みたいなやつ）が冗長になりがちです。特にライブラリとして不特定多数から利用されるのを想定して丁寧にエラー処理をしようとすると手間暇が多くなります。</p><p>CUEのissueにも上がっているように、まだエラーメッセージが少々わかりにくいというのはありますが、CUE経験値が上がれば素早く問題を見つけられるようになるでしょうし、今後勝手に改善されていくでしょう。</p><p>今回のサンプルでかんたんに説明するためにログレベルだとかポートだとかを設定するという例にしましたが、本来、これらは環境変数でも設定できるようにするのが筋ですし、どちらかというとdocker-compose並に複雑な設定ファイルが必要となるような構成情報の記述とかをすると、俄然CUEの能力が発揮されてくるでしょう。個人的にもそのようなケースでちょうど設定ファイルを作る要件があったのでCUEを利用し始めていたところです。今すぐCUEを全面的に使おう、というのをおすすめするわけではなく、大規模な設定ファイルが必要な案件があったときのために、ツールボックスに備えておくと憂いなしかな、と思いました。</p><hr><p>関連記事：</p><ul><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li><li><a href="/articles/20191002/">CUEを試して見る</a></li><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人間が読み書きする設定ファイルについて、2つのエントリーを紹介してきました。今回は第3段です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/articles/20191001/&quot;&gt;一周回って、人間が読み書きする設定ファイルはJSONが良いと思った&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
      <category term="JSON" scheme="https://future-architect.github.io/tags/JSON/"/>
    
      <category term="CUE" scheme="https://future-architect.github.io/tags/CUE/"/>
    
  </entry>
  
  <entry>
    <title>フロントエンドでシステム開発を2年半続けてハマったことから得た教訓3つ</title>
    <link href="https://future-architect.github.io/articles/20191029/"/>
    <id>https://future-architect.github.io/articles/20191029/</id>
    <published>2019-10-29T13:40:26.000Z</published>
    <updated>2019-10-29T02:05:41.303Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。フューチャー 3 年目の柏木です。</p><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>React、Next.js を触り始めて２年半ほど経ちました。<br>これまでによくつまずいたポイントから、自分なりのノウハウを言語化してみます。</p><h1 id="想定する読者"><a href="#想定する読者" class="headerlink" title="想定する読者"></a>想定する読者</h1><ul><li>React、Redux（、Next.js）を初めて触る人</li><li>システム開発の中で初めてフロントエンドを担当することになった人</li></ul><h1 id="開発で使用している技術要素"><a href="#開発で使用している技術要素" class="headerlink" title="開発で使用している技術要素"></a>開発で使用している技術要素</h1><ul><li>Node.js（10.5.0）</li><li>Express（4.16.3）</li><li>Next.js（5.1.0）</li><li>React.js（16.4.1）</li><li>Redux（3.7.2）</li></ul><h1 id="ノウハウたち"><a href="#ノウハウたち" class="headerlink" title="ノウハウたち"></a>ノウハウたち</h1><p>次の1~4について順番に説明していきます</p><ol><li>フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない</li><li>React の各ライフサイクルで適切な処理を行う</li><li>更新を React が正しく検知してくれるよう、値はコピーしてまるっと置き換える</li><li>（おまけ）ライブラリやフレームワークを導入するときは CSS をどれだけカスタマイズできるか注意する</li></ol><h2 id="1-フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない"><a href="#1-フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない" class="headerlink" title="1. フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない"></a>1. フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない</h2><ul><li>データベースに登録する値は、業務要件にもよりますが、出来るだけ冗長な構造を避け、シンプルであるべきだとよく聞きます。</li><li>一方、フロントエンドでは、データベースにある形のままデータを持つことが必ずしもベストではないこともあります。</li><li>例えば、データベースでは下記のような配列のデータを持っていたとします。</li></ul><figure class="highlight json"><figcaption><span>data.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"deta_1"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">      <span class="attr">"param_1"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">      <span class="attr">"param_2"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">      <span class="attr">"param_3"</span>: <span class="string">"xxx"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"yyy"</span>,</span><br><span class="line">      <span class="attr">"param_1"</span>: <span class="string">"yyy"</span>,</span><br><span class="line">      <span class="attr">"param_2"</span>: <span class="string">"yyy"</span>,</span><br><span class="line">      <span class="attr">"param_3"</span>: <span class="string">"yyy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"zzz"</span>,</span><br><span class="line">      <span class="attr">"param_1"</span>: <span class="string">"zzz"</span>,</span><br><span class="line">      <span class="attr">"param_2"</span>: <span class="string">"zzz"</span>,</span><br><span class="line">      <span class="attr">"param_3"</span>: <span class="string">"zzz"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>フロントでもこのままの形を維持した場合、<code>id</code>が”yyy” であるオブジェクトにアクセスしたい場合、<code>deta_1</code>の配列で For 文を回して検索することになります。</li><li>これでは、<code>deta_1</code>のオブジェクトが 10000 ある場合や、検索したい<code>id</code>が”yyy”の他にいくつもある場合、描画処理のたびに大きな負担がかかってしまいます。</li><li>フロント側で面倒な処理を重ねることは、描画のタイムラグに直結、使うユーザーのストレスを増やしかねません。</li><li>そこでこのデータを、配列ではなく<strong>id をキーとしたオブジェクト</strong>で持つようにします。</li><li>変換するタイミングは、データを取得してフロントに返ってきた直後です。</li><li>例えば私のプロジェクトでは、API コールは画面初期表示時の場合<code>getInitialProps</code>（Next.js の機能）の中、イベント発火の場合<code>actions</code>（Redux の機能）内で行っています。下記例は<code>actions</code>内でデータ取得した時の想定です。</li></ul><figure class="highlight javascript"><figcaption><span>例）xxx/actions/testpage.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrangeDataForFront = <span class="function"><span class="params">data_1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...data_1.map(<span class="function"><span class="params">data</span> =&gt;</span> (&#123; [data.id]: data &#125;)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> searchTest = <span class="function"><span class="params">parameter</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> dispatch =&gt; &#123;</span><br><span class="line">    <span class="comment">//APIコールでデータを取得</span></span><br><span class="line">    <span class="keyword">const</span> result = res.json();</span><br><span class="line">    <span class="keyword">const</span> data_1ForFront = arrangeDataForFront(result.data_1);</span><br><span class="line">    <span class="built_in">console</span>.log(data_1ForFront);</span><br><span class="line">    <span class="comment">//&#123; xxx:</span></span><br><span class="line">    <span class="comment">//    &#123; id: 'xxx', param_1: 'xxx', param_2: 'xxx', param_3: 'xxx' &#125;,</span></span><br><span class="line">    <span class="comment">//  yyy:</span></span><br><span class="line">    <span class="comment">//    &#123; id: 'yyy', param_1: 'yyy', param_2: 'yyy', param_3: 'yyy' &#125;,</span></span><br><span class="line">    <span class="comment">//  zzz:</span></span><br><span class="line">    <span class="comment">//    &#123; id: 'zzz', param_1: 'zzz', param_2: 'zzz', param_3: 'zzz' &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//フロントではdata_1ForFrontでやりとりする</span></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ***,</span><br><span class="line">      data_1: data_1ForFront,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>これで、目的のデータには<code>deta_1[yyy]</code>で参照できるようになりました。</li><li>このようにアクセスしやすいデータの形を作ることは、描画の際の負担を減らし、無駄な処理によるバグを生みだしにくくすることに繋がります！</li></ul><h2 id="2-React-の各ライフサイクルで適切な処理を行う"><a href="#2-React-の各ライフサイクルで適切な処理を行う" class="headerlink" title="2. React の各ライフサイクルで適切な処理を行う"></a>2. React の各ライフサイクルで適切な処理を行う</h2><ul><li><a href="https://ja.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">React</a>には様々なライフサイクルのメソッドがあります。また、<a href="https://nextjs-docs-ja.netlify.com/docs/#%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%83%95%E3%82%A7%E3%83%83%E3%83%81%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB" target="_blank" rel="noopener">Next.js</a>も親コンポーネントで使えるデータ取得のメソッドが存在します。（それぞれのメソッドの特徴については上記公式ドキュメントに詳細に記載されているので割愛します。）</li><li>これらのライフサイクルをそれぞれのコンポーネントで使い分け、<strong>必要な時に必要な処理が適切に行われる</strong>ことが、React での開発の鍵なのではないかと個人的に思っています。</li><li>ハマった失敗談の例<ul><li>画面をリロードした時は検索して描画するまで想定通りに動くが、画面上でボタンをクリックして検索するとエラーになってしまう。実は<code>getInitialProps</code>に実装した必要な処理は、初期描画の時しか呼ばれていなかった !</li><li>子供コンポーネントでのイベント発火時に親コンポーネントの<code>onChange</code>メソッドをコールパックしたら、子供コンポーネントの値が変わる度に親コンポーネントも再描画され、レンダリングに大変な時間がかかってしまった！</li></ul></li><li>このように自分の予期せぬところで値が更新されてしまうと、不具合がおきた時の切り分けが難しくなってしまいます。</li><li>それぞれのメソッドで適切な処理をコードにまとめると以下のような感じです。</li></ul><figure class="highlight javascript"><figcaption><span>testpage.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="comment">//画面初期表示のとき一度だけ呼ばれる</span></span><br><span class="line">        <span class="comment">//（例）サーバー通信の不要な初期値の定義（stateなど）、メソッドのbind</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getInitialProps(&#123; query &#125;) &#123;</span><br><span class="line">        <span class="comment">//画面初期表示のとき一度だけ呼ばれる</span></span><br><span class="line">        <span class="comment">//Next.jsの機能で、サーバーサイドで処理が行われる</span></span><br><span class="line">        <span class="comment">//（例）APIをコールして初期値を取得する</span></span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">//画面初期表示のとき一度だけ呼ばれる</span></span><br><span class="line">        <span class="comment">//クライアント側でしか行えない処理</span></span><br><span class="line">        <span class="comment">//（例）タイムスタンプのデータをクライアントのタイムゾーンの日付に変換する</span></span><br><span class="line">    &#125;</span><br><span class="line">    onChangeXXX()&#123;</span><br><span class="line">        <span class="comment">//イベント発火時に呼ばれる</span></span><br><span class="line">        <span class="comment">//bindしていないメソッドだとレンダリングの度に呼ばれることがあるので注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">//画面をレンダリングする度に呼ばれる</span></span><br><span class="line">        <span class="comment">//描画のためだけに使う変数の定義</span></span><br><span class="line">        <span class="comment">//（例）const isXXX = this.props.xxx;</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">//isXXXを用いたコンポーネントの描画</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestPage;</span><br></pre></td></tr></table></figure><ul><li>データの流れがわからなくなってしまったら、書こうとしている処理が、どういったタイミングで行われて欲しいかを一度図にして整理してみると、すっきりすると思います。</li></ul><img src="/images/20191029/photo_20191029_01.png"><p>※<a href="https://www.atmarkit.co.jp/ait/articles/1803/12/news012.html" target="_blank" rel="noopener">BFF（Backend For Frontend）</a> とは</p><h2 id="3-更新を-React-が正しく検知してくれるよう、値はコピーしてまるっと置き換える"><a href="#3-更新を-React-が正しく検知してくれるよう、値はコピーしてまるっと置き換える" class="headerlink" title="3. 更新を React が正しく検知してくれるよう、値はコピーしてまるっと置き換える"></a>3. 更新を React が正しく検知してくれるよう、値はコピーしてまるっと置き換える</h2><ul><li>配列で持っているデータの値を更新したはずなのに、描画してみたらうまく行かない、、、、、となったことはありませんか。</li><li>実は、React では差分検知は「<strong>浅い比較</strong>」で行われます。</li><li>そのため、下記のデータの項目<code>paramC</code>の値を更新したい場合、</li></ul><figure class="highlight json"><figcaption><span>arrayA.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">"object1"</span> : &#123;</span><br><span class="line">        <span class="attr">"paramC"</span> : <span class="string">"xxx"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"object2"</span> : &#123;</span><br><span class="line">        <span class="attr">"paramC"</span>: <span class="string">"yyy"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"object3"</span> : &#123;</span><br><span class="line">        <span class="attr">"paramC"</span>: <span class="string">"zzz"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>reducer を下記のように実装するとデータは更新されるが再レンダリングは行われない状態になります。</li></ul><figure class="highlight javascript"><figcaption><span>reducers/test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionで`arrayA`を作り直してreducerに渡してしまうと差分が検知されない</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> testReducer = <span class="function">(<span class="params">&#123; arrayA = [] &#125; = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"NG_ASSIGNMENT"</span>:</span><br><span class="line">      <span class="keyword">if</span> (action.arrayA) &#123;</span><br><span class="line">        arrayA = action.arrayA;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    arrayA</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>そこで下記のようにスプレッド演算子でコピーするようにします。</li></ul><figure class="highlight javascript"><figcaption><span>reducers/test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionからは`objectB`を渡し、reducerで`arrayA`に含める処理を行う</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> testReducer = <span class="function">(<span class="params">&#123; arrayA = [] &#125; = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"OK_ASSIGNMENT"</span>:</span><br><span class="line">      <span class="keyword">if</span> (action.objectB) &#123;</span><br><span class="line">        arrayA = [...arrayA, ...action.objectB];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    arrayA</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>こうすることで、<code>arrayA</code>の更新が画面でも検知され、再レンダリングが行われます。</li><li>注意すべきなのは、スプレッド演算子は第一階層までしかコピーできないことです。</li><li>そのため下記のようなデータ構造で<code>paramC</code>を更新するためには、<code>JSON.stringify()</code>を用いて強制的に値の変更を検知させるか、<code>arrayA</code>でなく<code>object1</code>で更新するなど、更新検知のオブジェクトの粒度を見直した方が良いでしょう。</li></ul><figure class="highlight json"><figcaption><span>arrayA.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">"object1"</span> : &#123;</span><br><span class="line">        <span class="attr">"arrayB"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"paramC"</span>: <span class="string">"xxx"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="4-（おまけ）ライブラリやフレームワークを導入するときは-CSS-をどれだけカスタマイズできるか注意する"><a href="#4-（おまけ）ライブラリやフレームワークを導入するときは-CSS-をどれだけカスタマイズできるか注意する" class="headerlink" title="4. （おまけ）ライブラリやフレームワークを導入するときは CSS をどれだけカスタマイズできるか注意する"></a>4. （おまけ）ライブラリやフレームワークを導入するときは CSS をどれだけカスタマイズできるか注意する</h2><ul><li>Javasript 関連のライブラリは多種多様であり、加えて「npm」というパッケージ管理ツールのおかげで、コマンドを打つだけでやりたいことをやってくれる外部ライブラリがサクッと入られます。</li><li>また、React であれば Material UI などのフレームワークも充実しており、見た目が統一しやすく簡単に実装できるので取り入れるメリットは大きいと思います。</li><li>ただ一点注意が必要なのは、ライブラリやフレームワークの内部で設定されている CSS のカスタマイズには工夫が必要であるということです。<ul><li>過去失敗談として、要件に適したライブラリを導入し、要望の画面イメージに合わせていざ見た目を整えようとしたところ、調整に１日ほど溶かし、結果的に<code>!important</code>で内部の CSS をオーバーライドする羽目になったことがあります。。</li></ul></li><li>例えば前述の Material UI は<a href="https://material-ui.com/customization/components/" target="_blank" rel="noopener">公式ドキュメント</a>にも記載があるようにユーザーがカスタマイズしやすいフレームワークですが、このように、見た目のためのプロパティ（＝ライブラリ・フレームワークを使う人が調整可能な部分）がどれだけ準備されているかを最初に把握して、自分たちの作るデザインとどれだけすり合わせが必要かを知っておくといいと思います。</li></ul><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><ul><li>これまでにお伝えしたこと</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">フロントで持つべきデータの形とデータベースに登録するデータの形は必ずしもイコールではない</span><br><span class="line">Reactの各ライフサイクルで適切な処理を行う</span><br><span class="line">更新をReactが正しく検知してくれるよう、値はコピーしてまるっと置き換える</span><br><span class="line">（おまけ）ライブラリやフレームワークを導入するときはCSSをどれだけカスタマイズできるか注意する</span><br></pre></td></tr></table></figure><ul><li>React に限らず、フロントエンドはデータのやり取り・描画・見た目が密接に関連しており、同時に考えることが多いですが、思った通りに動いた時は本当に楽しいです！使う人に一番近く、いろんなフィードバックをいただけるのもフロント開発の醍醐味だと思います。</li><li>少しでも開発の手が止まった時のヒントになれば幸いです。</li></ul><hr><p>関連記事：</p><ul><li><a href="/articles/20190612/">TypeScript教育用コンテンツ公開のお知らせ</a></li><li><a href="/articles/20190814/">WAFとして go-swagger を選択してみた</a></li><li><a href="/articles/20191001/">一周回って、人間が読み書きする設定ファイルはJSONが良いと思った</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。フューチャー 3 年目の柏木です。&lt;/p&gt;
&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;React、Next.js を触り始めて２年半ほど経ちました。
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="React" scheme="https://future-architect.github.io/tags/React/"/>
    
      <category term="Frontend" scheme="https://future-architect.github.io/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>Anthosについて改めて知る(GCPUG Anthos day 参加レポ)</title>
    <link href="https://future-architect.github.io/articles/20191025/"/>
    <id>https://future-architect.github.io/articles/20191025/</id>
    <published>2019-10-25T03:38:13.000Z</published>
    <updated>2019-10-25T03:51:28.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>初めまして、TIG DXユニットの伊藤です。9月にフューチャーに入社しました。前職ではRuby on Railsを使ったWebサイトの開発を行っており、フロントからインフラまで管理をしておりました。現在は日々知識を取り入れながら、GCPの開発支援を担当しております。<br>プライベートでは、<a href="https://cloudnativedays.jp/cndt2019/" target="_blank" rel="noopener">CloudNative Days Tokyo 2019/OpenStack Days Tokyo 2019</a>のボランティアスタッフをやったり、現在も来年に向けたミーティングなどに参加しております。</p><h1 id="GCPUG-Anthos-dayに参加した"><a href="#GCPUG-Anthos-dayに参加した" class="headerlink" title="GCPUG Anthos dayに参加した"></a>GCPUG Anthos dayに参加した</h1><p>2019/10/16(水)に開催された<a href="https://gcpug-tokyo.connpass.com/event/149049/" target="_blank" rel="noopener">GCPUG Anthos day</a>に参加してきました。今年のGoogle Cloud Next ‘19 サンフランシスコで発表されて以来話題にはなっているけど、まだまだ事例も少なくてわからないことが多いAnthosについて知るいい機会になりました。ここでは、Anthos dayで聞いたこと、少し追加で調べたことを書いていきます。</p><h2 id="Anthosとは"><a href="#Anthosとは" class="headerlink" title="Anthosとは"></a>Anthosとは</h2><p>コンテナ化されたアプリケーションをクラウドとオンプレミスのどちらでも実行可能にするプラットフォームで、コアのサービスはGKEになります。前身はGoogle Service Platformであり、今年のGoogle Cloud NextでAnthosとして正式発表されました。今回のセッション中では「ハイブリッド・マルチクラウド環境で利用できる<strong>アプリケーション管理プラットフォーム</strong>」と表現されていました。オンプレミス環境や他のクラウドベンダー環境をGCP環境から管理できるサービスです。<br>通常のGCP環境は従量課金制を取っていましたが、Anthosはライセンス契約となっています。ライセンスに含まれるのは</p><ul><li>コンテナ管理</li><li>クラスター管理</li><li>ポリシー管理</li><li>サービス管理</li><li>サーバレス</li></ul><p>の5つであり、サーバー自体の管理とVMware製のvSphereについては各々が管理する必要があります。また、ライセンスにはGCP上のみで利用するケースと、オンプレミス上のみで利用するケースの2パターンがあります。<br>Anthosのコアコンポーネントは以下の5つになります。</p><ul><li>GKE</li><li>GKE On-Prem</li><li>Anthos Config Management</li><li>Istio on GKE</li><li>Migrate for Anthos</li></ul><p>今回はこの中からピックアップして紹介していきます。</p><h3 id="GKE-On-Prem"><a href="#GKE-On-Prem" class="headerlink" title="GKE On-Prem"></a>GKE On-Prem</h3><p>VMware製のvSphere上で動作するGKEです。マネージドなKubernetesをオンプレミス環境などで運用できるため、自前で構築するより簡便にできるメリットがあります。GKE On-Premのアップグレード検証はGoogle側が行い、またCloud Consoleを介してクラウドとオンプレのクラスタを管理できるため、モニタリングやポリシー管理も一括して行えます。</p><h4 id="Googleでサポートしている環境"><a href="#Googleでサポートしている環境" class="headerlink" title="Googleでサポートしている環境"></a>Googleでサポートしている環境</h4><ul><li>vSphere6.5以上</li><li><a href="https://www.f5.com/ja_jp/products/big-ip-services" target="_blank" rel="noopener">F5 BIG-IP</a><ul><li>上記以外のロードバランサーを使いたい場合はマニュアルにすればCitrixなどのロードバランサーも使用可能</li><li>F5以外のロードバランサーはサポート外なのでコンテナをデプロイしたあと、各ノードポートにフォワーディングする必要あり</li></ul></li></ul><p>また、GKEでは対応しているノードプールやクラスターオートスケールには今のところ対応していないようです。</p><h4 id="必要なマシンリソース"><a href="#必要なマシンリソース" class="headerlink" title="必要なマシンリソース"></a>必要なマシンリソース</h4><ul><li>40 vCPU</li><li>100 GB以上のRAM</li><li>770 GB以上のディスク</li></ul><h3 id="Anthos-Config-Management"><a href="#Anthos-Config-Management" class="headerlink" title="Anthos Config Management"></a>Anthos Config Management</h3><p>複数のKubernetesクラスタにまたがるポリシー管理を簡単にしてくれる機能です。各クラスターにはConfig Management OperatorというDeploymentがインストールされていて、Gitリポジトリと常に同期しているそのため、差分比較をして、差分が見つかった場合はGitリポジトリを正として各クラスタに対してポリシーを適用してくれます。万が一、人為的にポリシーがクラスターから削除されてもGitを正として再適用されます。</p><h3 id="Anthos-Service-Mesh"><a href="#Anthos-Service-Mesh" class="headerlink" title="Anthos Service Mesh"></a>Anthos Service Mesh</h3><p>Googleが提供するフルマネージドのIstioです。GKEの場合にはマスターはGoogle管理になり、ノードはユーザーが管理する一方でAnthos Service MeshについてはIstioのコントロールプレーン相当についてはGoogleの管理になりますが、サイドカープロキシ(データプレーン)についてはユーザー管理となります。<br>以下が図示したものになります。</p><img src="/images/20191025/photo_20191025_01.png"><p>こちらの図では、PodのアプリケーションコンテナとサイドカーコンテナとしてデプロイされているEnvoy Proxy、またIstioのコントロールプレーンを示しています。Pod内にあるサイドカープロキシがIstioのコントロールプレーンと通信していることで、可観測性、トラフィックコントロールが実現します。また可観測性の中にはモニタリングと言っても、サービス間の依存関係や通信状況、サービス間の様々なメトリクスを収集して可視化できるようになります。セキュリティについては各アプリケーションコンテナがサイドカープロキシにlocalhostで接続し、他のアプリケーションコンテナとプロキシを介して通信することで保たれます。</p><h2 id="料金形態"><a href="#料金形態" class="headerlink" title="料金形態"></a>料金形態</h2><p>これまででも少し触れましたが、GCPは使った分だけ支払う従量課金制を取っている一方で、Anthosはライセンス販売になります。そのため、使用するに当たっては事前にGoogle側への問い合わせなどが必要になってきます。およその料金感はコア数に比例して値段が上がっていくようです。</p><h2 id="ユースケース"><a href="#ユースケース" class="headerlink" title="ユースケース"></a>ユースケース</h2><h3 id="マルチクラウド利用"><a href="#マルチクラウド利用" class="headerlink" title="マルチクラウド利用"></a>マルチクラウド利用</h3><ul><li>リージョン障害が発生した時にGCP環境とその他のクラウド環境とのスイッチを行えるようにしておく<ul><li>GCP環境はActive、他環境はStandbyにして有事のときはトラフィックを切り替える</li><li>肝になってくるのがDBの同期<ul><li>DB自体のクラスタリングの機能</li><li>ニアリアルで同期させるツールの使用(Aloomaなど)</li></ul></li></ul></li></ul><h3 id="オンプレは使いたいがモダナイズされた環境も使いたい"><a href="#オンプレは使いたいがモダナイズされた環境も使いたい" class="headerlink" title="オンプレは使いたいがモダナイズされた環境も使いたい"></a>オンプレは使いたいがモダナイズされた環境も使いたい</h3><ul><li>セキュリティレベルとして、オンプレにデータを置かなければならない場合<ul><li>医療系や金融系のデータ</li></ul></li><li>オンプレ環境から一部モダナイズさせたい場合</li></ul><h2 id="ハマりどころ"><a href="#ハマりどころ" class="headerlink" title="ハマりどころ"></a>ハマりどころ</h2><h3 id="バージョンアップ"><a href="#バージョンアップ" class="headerlink" title="バージョンアップ"></a>バージョンアップ</h3><ul><li>リリースノートに乗らないマイナーアップデートが起こる<ul><li>突然の挙動が変更されてなおかつ下位互換性がほぼない</li><li>現段階の解決策は消してもいいテスト環境を事前に作成しておいてパスしたら本環境のアップデートをすることを勧められていました。また、安定したバージョンになるまで待つことも大事です。</li><li>ドキュメントは疑ってかかる必要ありだそう。</li></ul></li></ul><h3 id="特にオンプレに作る場合-初期デザイン"><a href="#特にオンプレに作る場合-初期デザイン" class="headerlink" title="(特にオンプレに作る場合)初期デザイン"></a>(特にオンプレに作る場合)初期デザイン</h3><ul><li>初期から作ると結合デザインで考慮することが多く、設計、検証で潰す必要がある<ul><li>サブネットの切り直しが大変</li><li>解決策<ul><li>現時点で対応できないものを含めて、優先度を決める</li><li>可能であれば、vSphereなど専門性が必要だから、コンテナ導入とかと分けて体制を組んだほうが早くできる</li><li>ベストプラクティスはみんなで共有</li></ul></li></ul></li></ul><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Anthosは発表されて以来、あまり情報が飛び交っていない(Anthosで調べても4月の記事がとても多い)と思っていましたが、今回料金体系や実際の稼働の仕組みなど調べているだけでは分からない情報が多く聞けました。<br>ベータ版になっているサービスもいくつかありますが、それらも情報を常に目を光らせながら、GAを待ちましょう！</p><hr><p>関連記事：</p><ul><li><a href="http://localhost:4000/articles/20191017/" target="_blank" rel="noopener">GKEクラスタに割り当てるCIDRを設計する</a></li><li><a href="/articles/20190820/">初めてのGCPで環境構築してハマったこと</a></li><li><a href="/articles/20190927/">Let’s Try GCP #2 ～Cloud FunctionをVPC connectorと一緒に使ってみる～</a></li><li><a href="/articles/20190909/">Let’s Try GCP #1 ～Cloud Run Buttonを使った楽々コンテナデプロイをやってみた～</a></li><li><a href="/articles/20190827/">GKEのPodから異なるプロジェクトのIPアドレスへ接続できずハマった話</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;初めまして、TIG DXユニットの伊藤です。9月にフューチャーに入社しました。前職ではRuby on Railsを使ったWe
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="Anthos" scheme="https://future-architect.github.io/tags/Anthos/"/>
    
  </entry>
  
  <entry>
    <title>テキストアナリティクスシンポジウム開催報告&amp;ACL2019参加報告</title>
    <link href="https://future-architect.github.io/articles/20191024/"/>
    <id>https://future-architect.github.io/articles/20191024/</id>
    <published>2019-10-24T01:36:57.000Z</published>
    <updated>2019-10-24T01:48:47.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>みなさんこんにちは😃</p><p>Strategic AI Group (SAIG)の水本です。</p><p>2019年9月27日、28日にフューチャーにて、第15回テキストアナリティクス・シンポジウムが開催され、SAIGから貞光、田中と私が講演を行いましたので、そちらを紹介したいと思います。</p><p>また、少し前のことになりますが2019年7月28日〜8月2日にイタリアのフィレンツェで開催された自然言語処理分野の国際会議に参加して、ワークショップですが前職の研究成果を発表してきましたので、合わせて報告したいと思います。</p><h1 id="第15回テキストアナリティクス・シンポジウム開催報告"><a href="#第15回テキストアナリティクス・シンポジウム開催報告" class="headerlink" title="第15回テキストアナリティクス・シンポジウム開催報告"></a>第15回テキストアナリティクス・シンポジウム開催報告</h1><p>9月27日、28日にフューチャーのオフィスでシンポジウムが開催されました！自然言語処理の研究会はいくつかあるのですが、その中でも産業界の方の参加が多いテキストアナリティクス・シンポジウムをフューチャーで開催できるということで楽しみにしていました。<br>また、フューチャー開催ということもあり、SAIGチームからも3件の講演を行いました！</p><p>シンポジウムでは、2日間でおよそ130名の参加者にお集まりいただき、活発な議論が交わされていました。<br>プログラムはこちら↓↓<br><a href="http://www.ieice.org/~nlc/tm15a.html" target="_blank" rel="noopener">http://www.ieice.org/~nlc/tm15a.html</a></p><p>フューチャーからは、以下3件の講演を行いました。</p><ol><li>特別講演「人工知能によるプロフェッショナルの理解に向けて～ 言語・音声・画像・グラフ処理を活用した社会実装 ～」　貞光</li><li>依頼講演「ICLR2019参加報告」　貞光、田中</li><li>依頼講演「ACL2019参加報告」　水本</li></ol><h2 id="特別講演"><a href="#特別講演" class="headerlink" title="特別講演"></a>特別講演</h2><p>特別講演では、従来語られることの多かったBPOやギグ・エコノミーに関するAIの取り組みではなく、高い専門性が要求される、プロフェッショナルの仕事に関するAIの取り組みに焦点を当ててお話ししました。<br>このような各領域の深ーい話は普段あまり触れる機会がありませんので、多くの方に興味を持っていただけたと思います。なお、本講演に関連するプレスリリースを本blogの末尾にリンクしておきますので、よろしければ是非ご覧ください。</p><img src="/images/20191024/photo_20191024_01.jpeg" class="img-middle-size"><h2 id="ICLR参加報告"><a href="#ICLR参加報告" class="headerlink" title="ICLR参加報告"></a>ICLR参加報告</h2><p>前半はICLR2019の統計と言語以外に関する研究に注目した紹介となっています。PDFを中まで解析して組織毎に採択数をカウントしているのが頑張りポイントです。（自動処理のため、数え間違い等についてはご容赦ください！）</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/uH0rJgYwGmi7hG" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/TomoyaMizumoto/iclr2019" title="ICLR2019参加報告前半@テキストアナリティクスシンポジウム" target="_blank">ICLR2019参加報告前半@テキストアナリティクスシンポジウム</a> </strong> from <strong><a href="https://www.slideshare.net/TomoyaMizumoto" target="_blank">Tomoya Mizumoto</a></strong> </div><p>後半は、田中から自然言語処理に関連する論文を2本紹介しました。最終日の午前中にNLP系の発表が多くありました。ACLなどと比較しマルチモーダルな研究が多かったです！</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/rDYUSKHcmDgkqV" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/TomoyaMizumoto/iclr2019-183399240" title="ICLR2019参加報告後半@テキストアナリティクスシンポジウム" target="_blank">ICLR2019参加報告後半@テキストアナリティクスシンポジウム</a> </strong> from <strong><a href="https://www.slideshare.net/TomoyaMizumoto" target="_blank">Tomoya Mizumoto</a></strong> </div><img src="/images/20191024/photo_20191024_02.jpeg" class="img-middle-size"><h2 id="ACL参加報告"><a href="#ACL参加報告" class="headerlink" title="ACL参加報告"></a>ACL参加報告</h2><p>シンポジウム内で参加報告が2件あったため、私の方は研究内容の紹介よりも、会議の概要に力を入れた発表内容になっています。シンポジウム中の発表では時間の関係上1件しか論文を紹介できませんでしたが、スライドの方には2件とも載せていますので、シンポジウム参加者の方でも興味があればぜひご覧ください。</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/F6qKpC5oWUlciy" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/TomoyaMizumoto/acl2019" title="ACL2019参加報告@テキストアナリティクスシンポジウム" target="_blank">ACL2019参加報告@テキストアナリティクスシンポジウム</a> </strong> from <strong><a href="https://www.slideshare.net/TomoyaMizumoto" target="_blank">Tomoya Mizumoto</a></strong> </div><img src="/images/20191024/photo_20191024_03.jpeg" class="img-middle-size"><p>ICLRに関しては、すでにフューチャーブログで参加報告を書いているので軽めですが、ACLの方はせっかくなのでもう少し紹介したいと思います。</p><h1 id="ACL2019参加報告"><a href="#ACL2019参加報告" class="headerlink" title="ACL2019参加報告"></a>ACL2019参加報告</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>ACL (Annual Meeting of the Association for Computational Linguistics)は、自然言語処理分野のトップ国際会議で、今年で57回目の開催となりました。<br>バッソ要塞という要塞内での開催でした。</p><img src="/images/20191024/photo_20191024_04.jpeg"><p>外は要塞っぽい雰囲気でしたが、中に入ってしまうと現代的な会議施設でした笑<br>イタリアということで、ピザやパスタは本場の味という感じで美味しかったです。また、フィレンツェの街並みもきれいで見応えがありました〜。<br><img src="/images/20191024/photo_20191024_05.jpeg"></p><p>オープニングで主催者の方も強調していましたが、今年のACLは非常に大規模なものでした。参加者の数が3180人 (2018年は1322人)、論文投稿数が2905件 (2018年は1544件)、発表件数が660件 (2018年が384件)と昨年に比べ2倍程度の規模になっています。</p><p>ACLトレンドとしてここ3年の論文タイトルで特徴的なものを調べた結果、2017年・2018年は<em>neural</em>、<em>learning</em>という単語が特徴的なのに対して、2019年は<em>summarization</em>や<em>unsupervised</em>、<em>generation</em>といった単語が特徴的になっており変化が見られ面白いです。</p><p>個人的に今回のACLでホットだと思った分野は以下の4つでした。</p><ul><li>Bias</li><li>Health</li><li>Evaluation</li><li>Interpretability</li></ul><p>それぞれセッションが独立であったりワークショップがあったりと盛り上がってるテーマでした。<em>Bias</em>は性別や人種など最近世界全体で話題に上がることも多く、自然言語処理でもそのあたり注意した方が良いということで研究が盛んになってきた感じです。<em>Health</em>に関してもカルテの電子化なども進んできたりしてることもあり、言語処理でサポートしたいという動きが出てきているように思います。<em>Evaluation</em>は多様な表現を生成できるようになったた生成系タスク（翻訳、要約など）をちゃんと評価したいということで注目が集まっているように思います。<em>Interpretability</em>は画像や機械学習分野の会議でも盛んに研究されていますが、言語処理でも機械の判断根拠を知るための方法について注目が集まっています。<br>参加報告の論文紹介ではこの中から”Health”、”Evaluation”に関する以下の2本の論文を紹介しました（スライドは↑↑）。</p><ul><li>Extracting Symptoms and their Status from Clinical Conversations</li><li>HighRES: Highlight-based Reference-less Evaluation of Summarization</li></ul><p>実際の医者と患者の会話から症状や状態を抜き出す論文と、要約の評価をリファレンス（正解）を使うのではなく元記事の方の重要単語を使って要約文を評価するといった論文で、新しい方向性ということで紹介しました。</p><h2 id="BEA2019ワークショップ"><a href="#BEA2019ワークショップ" class="headerlink" title="BEA2019ワークショップ"></a>BEA2019ワークショップ</h2><p>前職理研AIPでの研究をACLのワークショップの一つ”<a href="https://sig-edu.org/bea/current" target="_blank" rel="noopener">14th Workshop on Innovative Use of NLP for Building Educational Applications</a>“ (BEA2019)で発表してきましたのでそちらも簡単に紹介します。</p><p>BEA2019は自然言語処理の教育分野への応用についてのワークショップで、文法誤り訂正・自動採点について多く研究発表がされています。”Duolingo”、”Grammarly”、”ETS”などの教育分野で有名な分野がスポンサーになっており、自然言語処理の教育応用分野では最大規模のワークショップです。ACLで参加者や投稿数が増えているという話をしましたが、BEA2019も投稿数が80件程度あり、採択率は約40％とワークショップとしては難しいと言える採択率でした。</p><p>さて、発表した研究ですが、”<a href="https://www.aclweb.org/anthology/W19-4433.pdf" target="_blank" rel="noopener">Analytic Score Prediction and Justification Identification in Automated Short Answer Scoring</a>“というもので、短答式問題の自動採点に関する研究です。</p><p>短答式の問題で日本人に馴染みが深いのは、入試問題でよくある長文読解の記述式問題だと思います。従来の短答式問題の自動採点では、1つの解答に対して1つの点数（全体点）を予測するタスクとして扱っていましたが、本研究では1つの解答に対して複数の点数（項目点）を予測するタスクを新しく提案しました。下の図で”holistic score”となっているのが従来の全体点、”analytic score”となっているのが本研究で新しく扱う項目点です。全体点は項目点の足し算になっており、図の例では減点があるため、3+2-1=4になります。</p><p>項目点は採点基準を元に決められます。項目の数などは問題ごとに異なります。加えて新しいタスクとして、項目点の根拠になる箇所（justification cue）を推定するタスクも提案しました。<br><img src="/images/20191024/photo_20191024_06.png"></p><p>本研究の貢献は、</p><ol><li>2つの新しいタスクの提案、2. 新タスクのためのデータセットの構築、3. 新タスクのための手法の提案の3つです。</li></ol><p>手法としては工夫した点は、</p><ol><li>項目点だけでなく全体点を使って項目点の推定を学習可能</li><li>教師ありアテンションを使うことで、項目点推定性能、根拠の推定性能を向上させる<br>などがあります。</li></ol><p>詳しく知りたい人はぜひ論文を読んでもらえればと思います！</p><p>短答式問題の自動採点は、記述式問題が大学入試の共通試験に導入されるなど、ホットな分野になってきているので、今後ますます色々と研究され発展していく分野の一つだと思います。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>いかがでしたでしょうか😃</p><p>SAIGチームでは国際会議にも積極的に参加し、最先端の技術の情報収集も怠らずに行っています。また、このような参加報告も<strong>力を入れて</strong>行っていますので、これからのSAIGにもご期待くださいー。</p><hr><h1 id="講演に関連するプレスリリース"><a href="#講演に関連するプレスリリース" class="headerlink" title="講演に関連するプレスリリース"></a>講演に関連するプレスリリース</h1><ul><li><a href="https://prtimes.jp/main/html/rd/p/000000336.000004374.html" target="_blank" rel="noopener">ワコールの新しい接客サービス「３D smart &amp; try」のオムニチャネル基盤を開発</a></li><li><a href="https://prtimes.jp/main/html/rd/p/000000332.000004374.html" target="_blank" rel="noopener">ORBISアプリコンテンツ「パーソナルAIメイクアドバイザー」に深層学習技術を提供</a></li><li><a href="https://prtimes.jp/main/html/rd/p/000000322.000004374.html" target="_blank" rel="noopener">メイクアップの第一人者である小林照子のコミュニケーション技術をAI解析</a></li><li><a href="https://prtimes.jp/main/html/rd/p/000000297.000004374.html" target="_blank" rel="noopener">大阪大学、ファンペップと抗体誘導ペプチドを効率的に開発するAIについて共同研究</a></li></ul><hr><p>関連記事：</p><ul><li><a href="/articles/20190627/">人工知能学会（JSAI2019） 参加報告</a></li><li><a href="/articles/20191016/">Software Design 後記</a></li><li><a href="/articles/20190617/">ICLR2019 参加報告ブログ</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;みなさんこんにちは😃&lt;/p&gt;
&lt;p&gt;Strategic AI Group (SAIG)の水本です。&lt;/p&gt;
&lt;p&gt;2019
      
    
    </summary>
    
      <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
      <category term="MachineLearning" scheme="https://future-architect.github.io/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>工場をハックするための基本知識　前編</title>
    <link href="https://future-architect.github.io/articles/20191023/"/>
    <id>https://future-architect.github.io/articles/20191023/</id>
    <published>2019-10-23T00:04:03.000Z</published>
    <updated>2019-10-23T03:03:45.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>初めまして、TIG DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属の栗田です。宇宙物理を専攻して人工衛星を打ち上げた後、とある鉄鋼会社の社内SEとして勤務したのち、フューチャーに入社しました。制御系を中心にしながら、各種システムを担当しています。また、プライベートでも開発を行っており、最近では<a href="https://www.slideshare.net/ShinKurita/my-browser-with-python3-172131107" target="_blank" rel="noopener">PyConJP 2019のLT</a>にて発表を行うなどしています。</p><p>Industry4.0が打ち出されて以降、多くの工場にて各種IT技術を導入しようという試みが行われていますが、基幹系やWeb系を行ってきた方と、従来制御系を取り扱ってきた方の間に大きな隔たりがあるのを見てきました。特に制御系の世界は独特な空間が大きいので、そもそもどのような構成になっているかを説明します。</p><p>以下、一般的な範囲で述べます。</p><h1 id="工場をつくろう"><a href="#工場をつくろう" class="headerlink" title="工場をつくろう"></a>工場をつくろう</h1><p>今回は一番大規模なプロジェクトとして、工場建設をテーマにします。プロジェクトによっては既設の工場に対して手をいれるケースもありますが、基本的な全体構成としては変わりません。よって、気をつけるべきポイントも同様です。</p><p>工場と一言に述べても、規模はさまざまです。下町ロケットにみられるような町工場から、複数の工程からなる大規模工場までさまざまです。複数の工程からなる大規模工場も製鉄のような素材系工場から、自動車工場のように消費者向け製品を直接製造する工場まであります。自動車工場のような所は比較的TVなどにも映りますので、今回は大規模工場をイメージしていきます。</p><h2 id="工場を作る流れ"><a href="#工場を作る流れ" class="headerlink" title="工場を作る流れ"></a>工場を作る流れ</h2><p>工場建設のため今回新たにプロジェクトチームが組織されました。プロジェクトリーダー（PL）を筆頭に、各種関係要素部隊が組織されます。</p><ul><li>プロジェクトリーダー（PL）<ol><li>工場建設部隊<ol><li>土木建設部隊（工場の基礎やガワを作る部隊）</li><li>機械設備部隊（中に設置する機械を担当する部隊）</li><li>電気系統部隊（各種機械へ電源を供給する部隊）</li><li><strong>システム関連部隊（機械を制御したりデータのやり取りをする部隊）</strong></li></ol></li><li>運用部隊<ol><li>現場部隊（工場で働く部隊）</li><li>整備部隊（完成後の工場設備をメンテする部隊）</li><li>システム関連部隊（いわゆるシステムインフラ部隊）</li></ol></li></ol></li></ul><p>各要素舞台はそれぞれベンダを調達し、プロジェクト体制を整えていきます。今回対象とするIT系の方がプロジェクトに入った場合、「工場建設部隊」の「システム関連部隊」になるとします。工場建設部隊は、PLの元、経営戦略で示された内容や運用部隊からのヒアリングを行い、要件定義をして、設計を進めていきます。その中で他のチームに対して要求を行い、一体となって動く工場を設計していきます。その中でお金の勘定や機器の手配スケジュールなどが絡んできますが、今回はシステムを動かすための設計に終始して述べていきます。</p><h1 id="既設含めた全体システム構成"><a href="#既設含めた全体システム構成" class="headerlink" title="既設含めた全体システム構成"></a>既設含めた全体システム構成</h1><p>我々はシステム関連部隊で、現場の各機器へ制御コマンドを送信したり、製造された製品の実績を収集し、適切に管理する必要があります。そのためには、そもそも既設のシステムがどのようになっているかを知る必要があります。そのために、会社全体としてのシステムがどのような形をしているか考えます。</p><h2 id="工場系持つ会社のシステム構成"><a href="#工場系持つ会社のシステム構成" class="headerlink" title="工場系持つ会社のシステム構成"></a>工場系持つ会社のシステム構成</h2><p>ざっくりと、会社のシステム系統をざっくり3つに分離します。もちろん、会社によって分類は違いますので、あくまでざっくりイメージです。</p><img src="/images/20191023/photo_20191023_01.png"><ul><li>基幹系システム：いわゆる業務系システムと呼ばれる部分です。企業の情報システム部分であり、エンタープライズシステムなどとも呼ばれます。POSシステムや人事給与、あるいは財務会計がここに分類されます。</li><li>情報系システム：社内外のコミュニケーションや事務処理の効率化を行うための部分です。所謂OA機器が繋がる領域になります。この情報系システムと基幹系システムが、社内情報システム部隊の範囲のイメージです。</li><li>制御系システム：実際に工場内のNWで各種情報のやり取りを行い、現場の機器を制御する部分です。複数ベンダが入っている場合は比較的汎用なシステムが導入されていることもありますが、特定のベンダによる独自システムが導入され、ロックインされていることもあります。社内SEが担当していることもありますが、ベンダに外注していることも多々あります。</li></ul><p>基幹系と情報系はハードウェア的にも非常に密接していますし、IT系だと基幹系システムのリプレイス案件も少なくないため、馴染み深い方もいらっしゃると思います。外部NWと接続することを前提としているため、セキュリティ対策も十分に行う必要があります。</p><p>一方、制御系システムはリアルタイム制御が必要であり、ウイルス対策ソフトによるスキャンや、OSによるファイアウォールですら嫌われます。そのため制御システムはセキュリティ的に非常に脆弱となり、基幹系と限られた接点で接続されているか、あるいは完全に独立した、クローズドなシステムが構築されていることもあります。</p><h2 id="制御系システムの詳細"><a href="#制御系システムの詳細" class="headerlink" title="制御系システムの詳細"></a>制御系システムの詳細</h2><p>基幹システム側から見ると、制御系システムの入口は何らかのサーバーですが、工場の末端はなんらかの機械設備だったりセンサーだったりします。つまり、その間を繋ぐシステムが必要です。ここで登場するのが、PLC<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>やDCS<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>といった制御系でよく使われるシステムになります。というわけで、制御系システムを細かく分割します。</p><img src="/images/20191023/photo_20191023_02.png"><p>現場の機械類、具体的にはモーターなどを駆動させるのは電気系の制御システム（PLCなど）が入ります。センサや流体制御においては、計装系の制御システム（DCSなど）が入ります。電気系制御システムや計装系制御システムはそれぞれ独立した制御画面を提供あるいは基幹システムと通信していることもありますが、より現場に近い制御系システムはリアルタイム制御が得意な一方で複雑な制御命令が必ずしも得意ではありません。そのバッファとして、制御系の統括管理システム（LinuxやWindowsといったPC。製鉄だと、プロセスコンピュータ、などと呼ぶ。）が、間に入ることもあります。ここは基幹系システムから受けた製造命令を元に適宜PLCやDCSにコマンドを送り、実績データを適宜編集して基幹系システムに結果を返します。昨今流行りの工場IoTなどマイコンを直接現場NWに接続するようなケースだと、此処の統合管理システムを担当する部隊が兼ることもあります。</p><p>我々はIT系技術者なので、このうち統合管理システムを担当するとします。</p><h1 id="システムを動かすために必要な物"><a href="#システムを動かすために必要な物" class="headerlink" title="システムを動かすために必要な物"></a>システムを動かすために必要な物</h1><p>システム構成がなんとなくわかったので、これでどんな機能が必要か定義できます。機能配置が定義できたら、今度は物理的にどんなものが必要かを考えます。平たく言えば、我々が作るのはUIを提供できる（IoT機器などの付帯設備のついた）PCだと考えられるので、ハード配置・電源・ネットワーク配線が必要な要素となります。</p><h2 id="ハード配置"><a href="#ハード配置" class="headerlink" title="ハード配置"></a>ハード配置</h2><p>定義された要件と機能配置から、</p><ul><li>どんなサーバスペックが必要で</li><li>どこに何台のどんなモニタが必要で</li><li>サーバ等を保護するためにどんな容量のUPSが必要で</li><li>どんなIoTデバイス（カメラなど）が必要で</li><li>上記を設置するのにどんな治具やラックが必要で</li><li>etc</li></ul><p>ということが決まります。定めたハード構成に併せて機器を手配する他に、機器を据え付ける為に工事の手配も行います。これを怠ると、例えば工場の天井裏につけるべきカメラを、素人である自分たちでつけるハメになります。</p><h2 id="電源"><a href="#電源" class="headerlink" title="電源"></a>電源</h2><p>どこにどんなハードを設置するか決まると、必要な電気容量が決まります。通常の電化製品のW(ワット)ではなく、VA（ブイエー）単位で計算をし、電気系統部隊に要求をかけておきます。</p><p>電気系統部隊は電力会社から高圧電源を引き込み、それを適宜降圧しながら各設備へ電源供給します。接続されている機器の電気容量に合わせて保護協調の設計をしたりしていますので、正しい電気容量が伝えられていない場合、最悪敷地全体を停電させてしまいます。また、どこにどれだけの電力が必要かを伝えていないとそもそも電気配線の工事がなされたいため、電源が取れずに機器が動かせないということになりかねません。それを防ぐためにも、正しく必要な電源容量を伝える必要があります。また、必要であれば、システム部隊の責任で電気工事の手配をする必要があります。</p><p>電源もネットワーク配線も、中々決まらない事もあるかと思います。その場合は、おおよその値ででも伝える必要があります。というのも、例えばネットワーク配線を地中に埋めるような場合、配管を通しておいてあとからケーブルを通すなどします。おおよその配線量を伝えておくことで、あとから調整が可能となります。仮に配管に余裕がないと、追加が発生した際、敷設を最初からやり直す必要が出てきます。</p><h2 id="ネットワーク配線"><a href="#ネットワーク配線" class="headerlink" title="ネットワーク配線"></a>ネットワーク配線</h2><p>電源と同様に、ハードの位置に併せてネットワーク配線も敷設しないといけません。ネットワーク配線はEthernetケーブルやRS232Cのようなものなどがあります。それを適切に配線してもらうよう、手配する必要があります。なお、他のシステムと接続するネットワーク配線の場合、より明確に「どちらの責任でLANケーブルを引き、どこのHUBに接続するか」のレベルで責任分界点を明確にしておかないと、配線の漏れが発生しうるので注意が必要です。距離によっては光ケーブルを敷設してもらうことにもなります。</p><p>ネットワーク設計においてデータ量に合わせて途中のHUBやルーターのスペックを考えることは当然ですが、Ethernetケーブルの規格も考える必要があります。Cat6やCat6e、最近だとCat7など規格があるので、要件に合わせて適切なケーブルを敷設して貰う必要があります。また、設計によっては予備線を何本か引いておいてもよいかもしれません。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>ここまで、工場建設のスタートからハードウェア的に気にするべきところまでをまとめてきました。後編では、実際に制御系システムと通信制御しようとしたときに、何を考える必要があるかを述べていきます。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.nipponsteel.com/tech/report/nssmc/pdf/411-04.pdf" target="_blank" rel="noopener">製鉄プロセス制御への汎用システム適用技術の開発</a></li><li><a href="https://www.nipponsteel.com/tech/report/nssmc/pdf/411-02.pdf" target="_blank" rel="noopener">製鉄設備におけるシステム・計測制御技術の進歩と展望</a></li><li><a href="http://www.shinkoen-m.jp/product/infosystem/factory.html" target="_blank" rel="noopener">情報システムのエンジニアリング&amp;メンテナンス</a></li><li><a href="https://www.nipponsteel.com/common/secure/news/20150407_100_01.pdf" target="_blank" rel="noopener">名古屋製鉄所におけるコークス火災事故および受配電設備の調査に関する報告</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">TIGとはTechnology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Programmable Logic Controllerのこと。シーケンサとも。従来工場の制御盤にはあった「リレー回路」を置き換える制御装置であり、「ラダー言語」と呼ばれる論理回路の記述方法を用いる。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Distributed Control System（分散制御システム）のこと。制御システムの一つで、制御装置が1つではなく、複数の制御装置からなるシステムである。制御装置はNWによって互いに監視し、化学プラントや水管理システムなど流体を始めとした工場制御システムで見られる。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;初めまして、TIG DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnot
      
    
    </summary>
    
      <category term="IoT" scheme="https://future-architect.github.io/categories/IoT/"/>
    
    
      <category term="Network" scheme="https://future-architect.github.io/tags/Network/"/>
    
      <category term="Factory" scheme="https://future-architect.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>第1回社内ロボコン開催記-ライントレーサー編-</title>
    <link href="https://future-architect.github.io/articles/20191018/"/>
    <id>https://future-architect.github.io/articles/20191018/</id>
    <published>2019-10-18T00:44:58.000Z</published>
    <updated>2019-10-18T10:12:55.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Strategic AI Group所属兼、電子工作部の勝村です。</p><p>電子工作部はフューチャーの社内サークルの一つとして約1年半ほど前に設立されました。電子工作を始めたいという社員の思いから始まったサークルということもあり、未経験者の割合が非常に多いサークルです。<br>※もちろん大ベテランの方も一部参加されています。</p><p>しかし残念なことに個々人では業務やプライベートで電子工作に邁進していたメンバーもいたのですが、サークルとしてのメイン活動はチャットでの情報交換（雑談）となっていました。</p><p>そんな状況の中、1年ほど穏やかな時間を過ごしたのですが、あるメンバーの一言をきっかけに活動の流れが変わり…3ヶ月程で…</p><p>$\huge{社内ロボコンを開催しました‼}$</p><p>今回はロボコン開催の経緯からロボコン当日の様子までご紹介します。</p><h1 id="ロボコン開催のキッカケ"><a href="#ロボコン開催のキッカケ" class="headerlink" title="ロボコン開催のキッカケ"></a>ロボコン開催のキッカケ</h1><p>いつものようにサークルのメイン活動であったチャットで雑談をしていのですが、<br>あるメンバーの一言から大きくサークル活動の流れが変わりました。</p><blockquote><p><a href="https://www.amazon.com/dp/B07JMHRKQG" target="_blank" rel="noopener">AWS Deep Racer</a><br>走らせて遊びたい。</p></blockquote><!----><blockquote><p>ミニ四駆AIとかライントレーサーとか社内にコース作ってコンテストしたくないですか？</p></blockquote><!----><blockquote><p>超やりたい。最終的にはオープンコンテスト化したい。</p></blockquote><!----><blockquote><p>初開催ですしハードでの勝負よりは機材がシンプルでアルゴリズムでの勝負の割合が大きいものが良いですね。<br>ライントレースロボットが良いと思います。</p></blockquote><!----><blockquote><p>ロボコン開催に向けたキックオフってことでMTGをやりましょう。いつが良いですか？</p></blockquote><!----><p>こうして1年間雑談しかしていなかったのが嘘のようにキックオフが設定されコンテスト開催が決定しました。</p><h1 id="コンテストルール"><a href="#コンテストルール" class="headerlink" title="コンテストルール"></a>コンテストルール</h1><p>コンテストのルールはシンプルです。</p><blockquote><p>白い板に黒いテープを張り付けて作った環状コースで、自動制御された車型の機体を走らせる。<br>一番早くコースを周回した機体を優勝とする。</p></blockquote><!----><p>たったこれだけです。いわゆる<strong>「ライントレース」</strong>と呼ばれる競技です。</p><p>コンテスト企画の初期段階では、世間一般のロボコンに倣い、機体は各自で作って持ち込み競わせるルールとする予定でした。しかしながら、今回のコンテストでは普段電子回路をはじめとするハードウェアの扱いに慣れていない社員にも簡単に楽しんで貰えるように機体（<strong>リファレンスモデル</strong>）を提供しました。これにより、ソフトウェアの改良によって競技性をもたせるルールとしました。また、組み込み向けのプログラムは普段の業務でのプログラミングとは少し勝手が違うかなと思い、リファレンスモデルに加え簡単なサンプルコードも提供しました。最低限の動作を保証したサンプルコードを提供することで全くの未経験者であってもロボットの制御の感覚を掴むことが可能となり、コンテストへの参加に繋がりました。</p><h1 id="リファレンスモデルの紹介"><a href="#リファレンスモデルの紹介" class="headerlink" title="リファレンスモデルの紹介"></a>リファレンスモデルの紹介</h1><p>実際に提供したリファレンスモデルはこちらです。<br><img src="/images/20191018/photo_20191018_01.jpeg"></p><p><font color="red">赤い基板</font>も映えてとってもかっこいいですね!!</p><img src="/images/20191018/photo_20191018_02.jpeg"><p><font color="blue">少年心</font>をくすぐられますね!!</p><h3 id="走行機構"><a href="#走行機構" class="headerlink" title="走行機構"></a>走行機構</h3><p>ライントレーサーはラインに沿って走る機体なので、操舵を含む走行機構が必要です。</p><p>今回のリファレンスモデルは出来る限りシンプルにしてコストを下げたかったので、左右のタイヤの回転数の差を制御することで操舵を行う方式としました。後輪に左右で独立したギヤボックスとタイヤを配置し、前輪には従動輪とするためのボールキャスターを使用しました。</p><img src="/images/20191018/photo_20191018_03.jpeg"><h3 id="ライン検知"><a href="#ライン検知" class="headerlink" title="ライン検知"></a>ライン検知</h3><p>ラインの検知は、フォトリフレクタという赤外線 LED と赤外線を検知するフォトトランジスタの組み合わせからなるセンサを用いて行います。ライントレーサーのコースは、黒い床（白い床）に白い線（黒い線）を引くことによって作ります。床に向かって赤外線を照射し、反射光をフォトトランジスタで検知しますが、黒い床と白い床では光の反射の度合いが異なるので、この変化をもって線の位置を特定する仕組みです。</p><p>仕組みのイメージとしては以下のようなものになります。<br><img src="/images/20191018/photo_20191018_04.png" class="img-middle-size"></p><p>※イメージ図ではフォトリフレクタが3つですが、リファレンスモデルは5つ搭載しています。</p><img src="/images/20191018/photo_20191018_05.jpeg"><p>実際のフォトリフレクタ搭載部分</p><h3 id="モータードライブ"><a href="#モータードライブ" class="headerlink" title="モータードライブ"></a>モータードライブ</h3><p>フォトリフレクタによって検知した姿勢によって操舵方向を制御することになるのですが、ここで必要になってくるのがモーターの回転数制御です。 今回使用するのはモーターの中でも「ブラシ付き DC モーター」と呼ばれるものです。このモーターの回転数制御は「PWM 制御」と呼ばれる方式が一般的で、これを採用します。ざっくり言うと、モーターに流す電流を高速に ON/OFF させ、ON と OFF の時間の比率（デューティー比）によって回転数を上げたり下げたりする、マイコンと相性の良い方式です。</p><h3 id="マイコン"><a href="#マイコン" class="headerlink" title="マイコン"></a>マイコン</h3><p>ライントレーサーは、前述したライン検知を入力として受け取り、適切なモータードライブを行うことによって走行します。この入力と出力の間を取り持つのがマイコンになります。 このマイコンは選択肢が非常に多様なのですが、今回は ESP32-WROOM-32（以下 ESP32 と呼びます）というマイコン（モジュール）を採用しました。</p><p>ESP32を採用した理由としては下記のようなものです。</p><ul><li>申し分無い処理性能と機能</li><li>フォトリフレクタを直接接続できる</li><li>WiFi・Bluetoothを搭載しているので、スマートフォンからコントロールできるなど今後の発展の余地がある</li><li>MicoroPython 、Mongoose OS のESP32向け実装があり、C言語に明るくない人でも Python や JavaScript で開発ができる</li></ul><p>また、他の選択肢として、Arduino シリーズや Raspberry Pi も使用可能です。 </p><h3 id="開発言語・環境"><a href="#開発言語・環境" class="headerlink" title="開発言語・環境"></a>開発言語・環境</h3><p>Mongoose OS や MicroPython も便利なのですが、ESP32 の開発を最も簡単に始められるのは Arduino  IDE を使用した方法です。Arduino IDE は、拡張機能をインストールすることによって、Arduino シリーズのマイコンボード以外にも様々なもののプログラミングを行うことが可能です。これによって ESP32 では、Arduino 言語（C 言語）で開発を始められます。 </p><p>しかし Arduino  IDE は、日頃 Eclipse のようなリッチな IDE や、Vim や Emacs のようなエディタをカスタマイズして使っているソフトウェアエンジニアの皆さんからすると、お世辞にも使いやすいとは言えないものです。</p><p>そこで今回は、<strong>PlatformIO IDE</strong> というものを標準開発環境としてサポートすることにしました。PlatformIO のインストールは非常に簡単で、Visual Studio Code にプラグインをインストールするだけです。コンパイラなどのツールセットや、書き込み用のプログラムも自動でインストールされますし、マルチ OS 対応です。これで、使いやすい VSCode 上で開発を行うことが可能になります。 </p><p>このように、PlatformIO  +  Arduino という組み合わせの開発環境を標準とすることで、「開発環境の構築が簡単なので、社内でのハンズオンがスムーズに行える」、「比較的とっつきやすい Arduino スタイルのプログラミング」という、ロボコン初心者への間口を広げるのに大きなメリットを得ることが出来ました。 </p><h1 id="コンテスト開催！"><a href="#コンテスト開催！" class="headerlink" title="コンテスト開催！"></a>コンテスト開催！</h1><p>さっそくですが本番のコースはこちらです。<br>モータースポーツが好きな方なら見たことがあるコースかもしれませんね!<img src="/images/20191018/photo_20191018_06.jpeg"></p><p>このような難関コースでありながらもコースを走破し優秀タイムを叩き出した機体もいましたが、多くの機体はタイムを競うコンテストでありながら、走破すら許されませんでした…。コースを作る時にはしゃぎすぎました。</p><p>コンテスト終了後は走破すら許されなかった現実を目の当たりしたメンバーを中心にエンジニアハートに火が付いたようで、走らせる→デバックを延々と繰り返すメンバーに溢れ、コンテス終了後の方が盛り上がりました!!</p><p>「これでダメだったら帰る」というセリフを同じ人から5回程聞きました。<br>次回の開催では予選と決勝を同日に行い、予選終了後に回数制限をつけた中でプログラムの改修とコース試走を許可するような仕組みを導入して、この盛り上がりをコンテストに反映させようと考えています!!</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>今回は社内でロボコンを開催した話をご紹介しました。</p><p>運営から携わりタイトなスケジュールでしたが、非常に面白く技術の勉強にもなりました。フューチャーでは<strong>「無いものは作る」</strong>というワードを良く耳にします。稀かもしれませんが、作るべきものがハードウェアから携わる必要があるものだった時もこの活動を続けていると回路や基板の設計に強くなれる気がしてます!</p><p>メンバーも絶賛募集中です。</p><p>もしこのブログを読んで「自分の会社でもやりたい!」となられた方は、是非Twitter（<a href="https://twitter.com/future_techblog" target="_blank" rel="noopener">@future_techblog</a>）に連絡ください。</p><p>共同開催・企業対抗戦やりましょう!!</p><hr><p>関連記事：</p><ul><li><a href="/articles/20190826/">ソフトとハードの垣根を越えろ - IoTハードウェアの開発をソフト屋視点で解説します</a></li><li><a href="/articles/20190723/">Future IoTのstackshareを公開しました</a></li><li><a href="/articles/20170127/">3Dプリンタを使ってサービス開発やってみた</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、Strategic AI Group所属兼、電子工作部の勝村です。&lt;/p&gt;
&lt;p&gt;電子工作部はフューチャーの社内
      
    
    </summary>
    
      <category term="IoT" scheme="https://future-architect.github.io/categories/IoT/"/>
    
    
      <category term="IoT" scheme="https://future-architect.github.io/tags/IoT/"/>
    
      <category term="Robot" scheme="https://future-architect.github.io/tags/Robot/"/>
    
  </entry>
  
  <entry>
    <title>GKEクラスタに割り当てるCIDRを設計する</title>
    <link href="https://future-architect.github.io/articles/20191017/"/>
    <id>https://future-architect.github.io/articles/20191017/</id>
    <published>2019-10-16T23:02:12.000Z</published>
    <updated>2019-10-17T02:14:15.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>お久しぶりです。<a href="https://www.spartanrace.jp/en" target="_blank" rel="noopener">スパルタン</a>になった椎名@417yskです。</p><p><a href="/articles/20190820/">前回投稿したGCP記事</a>で紹介したGKEクラスタのCIDR設計について、深堀りした記事になります。</p><blockquote><p><strong>1-5. 共有VPC上のGKEクラスタのセカンダリCIDR設計</strong></p><p><strong>事象</strong>: オンプレ環境と接続する1つの共有VPC上にproduction, stagingなど複数プロジェクトを相乗りさせる場合、各プロジェクトで利用するセカンダリCIDRの設計が必要。<br><strong>対応</strong>: GKEで必要なセカンダリCIDRを本腰入れて設計しました。スタンダードなこれと言った解はなく、必要な環境数、オンプレ環境から割り当てられたIP範囲から適宜設計する必要があります。</p></blockquote><p>記載通りですが、GKEクラスタを構築する際に、実際に設計した内容を元に制約や設計のポイントを紹介したいと思います。</p><h1 id="GKEとは"><a href="#GKEとは" class="headerlink" title="GKEとは"></a>GKEとは</h1><blockquote><p>コンテナ化されたアプリケーションをデプロイするための、本番稼働に対応したマネージド型環境です。<br><a href="https://cloud.google.com/kubernetes-engine/" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/</a></p></blockquote><h1 id="CIDRとは"><a href="#CIDRとは" class="headerlink" title="CIDRとは"></a>CIDRとは</h1><blockquote><p>Classless Inter-Domain Routing（CIDR、サイダー）は、インターネット上のルーターにおけるルーティングテーブルの肥大化速度を低減させるための機構であり、ISPや組織にクラスA、B、Cを全部ではなく部分的に割り当てることでIPアドレスの浪費を防ぐ機構である。CIDR記法でアドレスを記述でき、アドレスの集約的表現が可能で、アドレスブロックの委譲も容易である。<br>「CIDR」の読みは「サイダー」とするのが一般的である<br><a href="https://ja.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/Classless_Inter-Domain_Routing</a></p></blockquote><p>CIDR記法は <code>10.0.0.0/8</code>、<code>172.16.0.0/12</code>、 <code>192.168.0.0/16</code> といったIPアドレスとビット数を指定する方法です。</p><p>詳細は次項で説明していきますが、ある条件でGKEクラスタを構築すると、このCIDR設計が必須になってきます</p><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>アーキテクチャ設計上の要件と、GKEクラスタの制約の2つが設計上の考慮事項となります。</p><h2 id="アーキクチャ設計上の要件"><a href="#アーキクチャ設計上の要件" class="headerlink" title="アーキクチャ設計上の要件"></a>アーキクチャ設計上の要件</h2><p>今回GKEクラスタを構築する上で2つの前提がありました。</p><ol><li><a href="https://cloud.google.com/vpc/docs/shared-vpc" target="_blank" rel="noopener">共有VPC</a>を利用すること</li><li>パブリックエンドポイントへのアクセスが制限された<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters" target="_blank" rel="noopener">限定公開クラスタ</a>にすること</li></ol><p>※オンプレ環境とインターネットVPNで繋ぐため1つのVPCを複数環境で利用したかったのと、セキュリティポリシーから外部アクセス禁止となっていたためです。</p><h3 id="共有VPCとは"><a href="#共有VPCとは" class="headerlink" title="共有VPCとは"></a>共有VPCとは</h3><p>共有VPCとは、あるホストとなるプロジェクトのVPCを、複数のGCPプロジェクトがリソースとして利用できるようになる機能です。これにより、サブネット、ルート、ファイアウォールなどのネットワーク リソースを集中管理しながら、インスタンスの作成や管理などの管理責任をサービス プロジェクト管理者に委任できます。</p><p>以下は<a href="/articles/20190820/">前回投稿したGCP記事</a>で紹介した構成図です。Shared VPCと書かれた領域にある、Subnetをサービスと呼ばれる別GCPプロジェクトが利用しています。</p><img src="/images/20191017/1.png"><p>VPC Peeringとの違いはいくつかありますが、ホストとなるプロジェクト側でファイアウォールルールなどを集中管理できる点などが異なります。（今回はこの点が重視し共有VPCを選択しました）</p><h3 id="限定公開クラスタとは"><a href="#限定公開クラスタとは" class="headerlink" title="限定公開クラスタとは"></a>限定公開クラスタとは</h3><blockquote><p>限定公開クラスタでは、ノードに RFC 1918 の内部 IP アドレスのみがあるため、ワークロードが公共のインターネットから隔離されるようになります。<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters</a></p></blockquote><p>引用文そのままですが、限定公開クラスタの設定を行うと、各GKEノードにPublic IPを付与せずGKEクラスタを構築することができます。セキュリティ要件からこちらの設定が必須となりました。</p><h2 id="GKEクラスタの制約"><a href="#GKEクラスタの制約" class="headerlink" title="GKEクラスタの制約"></a>GKEクラスタの制約</h2><ol><li>共有VPC上にGKEクラスタ構築する制約<br>クラスタの<strong>ポッド</strong>と<strong>サービス</strong>に使用するサブネットとセカンダリCIDRを指定する必要があります。<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-shared-vpc#verify_usable_subnets" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-shared-vpc#verify_usable_subnets</a></li><li>パブリックエンドポイントへのアクセスが制限された限定公開クラスタによる制約<br>クラスタ<strong>マスター</strong>が使用する /28 分の RFC 1918 アドレス範囲を指定する必要があります。<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#public_master" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#public_master</a></li><li>セカンダリCIDRの上限によるクラスタ数の制約<br>ポッドとサービスに対して割り当てるセカンダリCIDRですが、1サブネット内に設定可能なセカンダリCIDR数に上限があり、この上限数/2が構築可能なクラスタ数になります。<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-shared-vpc#notes_about_secondary_ranges" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-shared-vpc#notes_about_secondary_ranges</a><br>私が構築した時点ではセカンダリCIDRの上限は5つだったためクラスタの上限は2つでしたが、現在はセカンダリCIDRの上限は30まで拡張されており15クラスタまで作成可能なのでさほど設計上の制約にはならないかもしれません。<br>※日本語ドキュメントはまだ5のままにですが英語では30になっています。（2019/10/17時点）</li></ol><h1 id="実際に設計してみる"><a href="#実際に設計してみる" class="headerlink" title="実際に設計してみる"></a>実際に設計してみる</h1><p>本編です。</p><p>前項の制約から1GKEクラスタに対して <strong>3つのCIDR(ポッド、サービス、マスター)を割り当てる必要</strong> が出てきました。またこれらは <strong>同一の共有VPC上に構築するため構築される全てのプロジェクトをまたいで全てのCIDRが被ってはいけない</strong> という制約もあります。</p><p>この辺りに注意してCIDR設計したいと思います。</p><h2 id="1-全体の設計方針"><a href="#1-全体の設計方針" class="headerlink" title="1. 全体の設計方針"></a>1. 全体の設計方針</h2><p>設定上はプロジェクトが異なればポッドやサービスのCIDRは全く異なる範囲や体系で設定可能です。<br>ですが、各プロジェクト（環境）毎に設計のポリシーを合わせるために全プロジェクトに対してポッド、サービス、マスタ別にCIDRを概念的に割り当て、そこから各プロジェクトごとに実際のCIDRを割り当てるといった設計方針をとりました。</p><h2 id="2-ポッド＆サービスCIDR"><a href="#2-ポッド＆サービスCIDR" class="headerlink" title="2. ポッド＆サービスCIDR"></a>2. ポッド＆サービスCIDR</h2><h3 id="2-1-共有VPC上の全プロジェクトに対するCIDR"><a href="#2-1-共有VPC上の全プロジェクトに対するCIDR" class="headerlink" title="2.1. 共有VPC上の全プロジェクトに対するCIDR"></a>2.1. 共有VPC上の全プロジェクトに対するCIDR</h3><p>こちらは172.16.0.0/12（クラスB）を概念的に割り当てました。<br>GKEのポッド＆サービスに割り当て可能なCIDRはRFC 1918 ブロック（10.0.0.0/8、172.16.0.0/12、または 192.168.0.0/16）の制約があります。<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/routes-based-cluster#pod_address_range" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/routes-based-cluster#pod_address_range</a></p><p>10.0.0.0/8はGCP環境以外も含めたシステム全体で利用しているのと、192.168.0.0/16は後述のマスタのアドレス範囲に利用するためクラスB（172.16.0.0/12）を選択しました。</p><p>なお基本的にはクラスBの範囲を使うことができますが、公式ドキュメントには<code>172.17.0.0/16</code>を利用することができない旨の記載があります。<br>該当範囲を指定してもクラスタ構築時にエラーとなるわけではないのでご注意下さい。</p><blockquote><p>Restrictions<br>Private clusters have the following restrictions:<br>You cannot use a cluster master, node, Pod, or Service IP range that overlaps with 172.17.0.0/16.<br><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#restrictions" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#restrictions</a></p></blockquote><h3 id="2-2-各プロジェクトにおけるCIDR"><a href="#2-2-各プロジェクトにおけるCIDR" class="headerlink" title="2.2. 各プロジェクトにおけるCIDR"></a>2.2. 各プロジェクトにおけるCIDR</h3><p>こちらに対してはさらに3段階の概念でCIDRを設計しました。</p><ul><li>プロジェクト毎のCIDR</li><li>ポッド/サービス毎のCIDR</li><li>クラスタ毎のCIDR</li></ul><p>まずプロジェクトごとのCIDRですが、全体でいくつのプロジェクトを作成するかを設計します。<br>本番、ステージングはよくある環境ですが、他に非機能テスト、開発時の機能検証用を想定すると4面、これに加えて実データ使ったデモ環境、並行して動かす別バージョン環境・・などを考慮し最大7断面を想定しました。<br>これによって172.16.0.0/12以下に3bit加えて以下のCIDRが割当たります。</p><table><thead><tr><th align="left">環境</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">172.18.0.0/15</td></tr><tr><td align="left">ステージング</td><td align="left">172.20.0.0/15</td></tr><tr><td align="left">非機能</td><td align="left">172.22.0.0/15</td></tr><tr><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><p>※172.16.0.0/15は前述の172.17.0.0/16を含むため利用しませんでした。</p><p>次にポッド/サービスですが、これは2値のため次の1bitを割り当てます</p><table><thead><tr><th align="left">環境</th><th align="left">CIDR</th><th align="left">種別</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">172.16.0.0/15</td><td align="left">ポッド</td><td align="left">172.18.0.0/16</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.19.0.0/16</td></tr><tr><td align="left">ステージング</td><td align="left">172.18.0.0/15</td><td align="left">ポッド</td><td align="left">172.20.0.0/16</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.21.0.0/16</td></tr><tr><td align="left">非機能</td><td align="left">172.20.0.0/15</td><td align="left">ポッド</td><td align="left">172.22.0.0/16</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.23.0.0/16</td></tr><tr><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><p>そして最後に実際にクラスタに割り当てるCIDRに分割します。<br>ここは実際に構築するクラスタ数に応じて細分化します。</p><table><thead><tr><th align="left">環境</th><th align="left">CIDR</th><th align="left">種別</th><th align="left">CIDR</th><th align="left">クラスタ</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">172.16.0.0/15</td><td align="left">ポッド</td><td align="left">172.18.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.18.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">ポッド</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.18.64.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.19.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.19.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.19.64.0/18</strong></td></tr><tr><td align="left">ステージング</td><td align="left">172.18.0.0/15</td><td align="left">ポッド</td><td align="left">172.20.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.20.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">ポッド</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.20.64.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.21.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.21.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.21.64.0/18</strong></td></tr><tr><td align="left">非機能</td><td align="left">172.20.0.0/15</td><td align="left">ポッド</td><td align="left">172.22.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.22.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">ポッド</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.22.64.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.23.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.23.0.0/18</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.23.64.0/18</strong></td></tr><tr><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><p>なお前述の1環境2クラスタの制限（2019/10/17時点では制約が緩和され15クラスタまで可能なはず）から以下のような切り方も出来たのですが、</p><table><thead><tr><th align="left">環境</th><th align="left">CIDR</th><th align="left">種別</th><th align="left">CIDR</th><th align="left">クラスタ</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">172.16.0.0/15</td><td align="left">ポッド</td><td align="left">172.16.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.18.0.0/17</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">ポッド</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.18.128.0/17</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.17.0.0/16</td><td align="left">クラスタA</td><td align="left"><strong>172.19.0.0/17</strong></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left"></td><td align="left">クラスタB</td><td align="left"><strong>172.19.128.0/17</strong></td></tr><tr><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><p>以下の理由で/18のアドレス範囲としました。</p><ul><li>今後制約が緩んだ時の拡張性を持たせる<ul><li>クラスタ再作成を覚悟すれば、後で拡張可能であろうという前提です</li></ul></li><li>/18で切ったアドレス範囲内でポッドとサービスの数は十分足りる</li></ul><h3 id="2-3-アドレスに対する意味付け"><a href="#2-3-アドレスに対する意味付け" class="headerlink" title="2.3. アドレスに対する意味付け"></a>2.3. アドレスに対する意味付け</h3><p>ここまでのアドレス設計と並行して、アドレスから容易に環境や用途を判断できるように考慮しました。<br>今回のアドレス設計ではアドレスの２か所に意味を持たせています。</p><p>アドレス体系：172.<strong>XXX.YYY</strong>.0/18</p><ul><li><strong>XXX</strong>の箇所で環境を表す<br>本番（18,19）、ステージング（20,21）・・・</li><li><strong>XXX</strong>の箇所で種別を表す<br>偶数がポッド、奇数がサービスとなっています。</li><li><strong>YYY</strong>の箇所にはクラスタ。<br>クラスタA（0）、クラスタB（64）</li></ul><h2 id="3-マスターCIDR"><a href="#3-マスターCIDR" class="headerlink" title="3. マスターCIDR"></a>3. マスターCIDR</h2><h3 id="3-1-共有VPC上の全プロジェクトに対するCIDR"><a href="#3-1-共有VPC上の全プロジェクトに対するCIDR" class="headerlink" title="3.1. 共有VPC上の全プロジェクトに対するCIDR"></a>3.1. 共有VPC上の全プロジェクトに対するCIDR</h3><p>こちらは192.168.0.0/16（クラスC）を概念的に割り当てました。</p><p>これは10.0.0.0/8（クラスA）の一部をプライマリCIDRで利用していたのと172.16.0.0/12（クラスB）をポッドとサービスのセカンダリCDIRで利用していたためです。</p><p>また制約上/28のCDIRを割り当てればよいため、クラスCのアドレス範囲で十分と判断しました。</p><h3 id="3-2-各プロジェクトにおけるCIDR"><a href="#3-2-各プロジェクトにおけるCIDR" class="headerlink" title="3.2. 各プロジェクトにおけるCIDR"></a>3.2. 各プロジェクトにおけるCIDR</h3><p>こちらに対しては2段階の概念でアドレス範囲を設定しました。</p><ul><li>プロジェクト毎のCIDR</li><li>クラスタ毎のCIDR</li></ul><p>ただし、アドレス範囲を無駄なくキレイには使わずに、分かりやすさを考慮して以下のアドレス範囲を割り当てています。</p><table><thead><tr><th align="left">環境</th><th align="left">クラスタ</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">クラスタA</td><td align="left">192.168.16.0/28</td></tr><tr><td align="left"></td><td align="left">クラスタB</td><td align="left">192.168.17.0/28</td></tr><tr><td align="left">ステージング</td><td align="left">クラスタA</td><td align="left">192.168.32.0/28</td></tr><tr><td align="left"></td><td align="left">クラスタB</td><td align="left">192.168.33.0/28</td></tr><tr><td align="left">非機能</td><td align="left">クラスタA</td><td align="left">192.168.48.0/28</td></tr><tr><td align="left"></td><td align="left">クラスタB</td><td align="left">192.168.49.0/28</td></tr><tr><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><h3 id="3-3-アドレスに対する意味付け"><a href="#3-3-アドレスに対する意味付け" class="headerlink" title="3.3. アドレスに対する意味付け"></a>3.3. アドレスに対する意味付け</h3><p>ここでもアドレスから容易に環境や用途を判断できるように考慮しました。<br>今回のアドレス設計ではアドレスの２か所に意味を持たせています。</p><p>アドレス体系：192.168.<strong>XXX</strong>.0/28</p><ul><li><strong>XXX</strong>の箇所で環境を表す<br>本番（16,17）、ステージング（32,33）・・・</li><li><strong>XXX</strong>の箇所でクラスタを表す<br>偶数がクラスタA、奇数がクラスタBとなっています。</li></ul><h2 id="4-全体サマリ"><a href="#4-全体サマリ" class="headerlink" title="4. 全体サマリ"></a>4. 全体サマリ</h2><p>全体のアドレスをまとめると以下になります。</p><table><thead><tr><th align="left">環境</th><th align="left">クラスタ</th><th align="left">種別</th><th align="left">CIDR</th></tr></thead><tbody><tr><td align="left">本番</td><td align="left">クラスタA</td><td align="left">ポッド</td><td align="left">172.18.0.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.19.0.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">マスター</td><td align="left">192.168.16.0/28</td></tr><tr><td align="left"></td><td align="left">クラスタB</td><td align="left">ポッド</td><td align="left">172.18.64.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.19.64.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">マスター</td><td align="left">192.168.17.0/28</td></tr><tr><td align="left">ステージング</td><td align="left">クラスタA</td><td align="left">ポッド</td><td align="left">172.20.0.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.21.0.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">マスター</td><td align="left">192.168.32.0/28</td></tr><tr><td align="left"></td><td align="left">クラスタB</td><td align="left">ポッド</td><td align="left">172.20.64.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">サービス</td><td align="left">172.21.64.0/18</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">マスター</td><td align="left">192.168.33.0/28</td></tr><tr><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td><td align="left">・・・</td></tr></tbody></table><h1 id="あとがき"><a href="#あとがき" class="headerlink" title="あとがき"></a>あとがき</h1><p>今回は実際に設計した事例を元にGCP上の制約や設計時に考えたことを紹介させて頂きました。<br>この辺りの設計は制約や重視するポイントで結構変わってくるのでこれと言った正解はありませんが、１つの例として構築の際にお役に立てれば幸いです。</p><hr><p>関連記事：</p><ul><li><a href="/articles/20190820/">初めてのGCPで環境構築してハマったこと</a></li><li><a href="/articles/20190927/">Let’s Try GCP #2 ～Cloud FunctionをVPC connectorと一緒に使ってみる～</a></li><li><a href="/articles/20190909/">Let’s Try GCP #1 ～Cloud Run Buttonを使った楽々コンテナデプロイをやってみた～</a></li><li><a href="/articles/20190827/">GKEのPodから異なるプロジェクトのIPアドレスへ接続できずハマった話</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;お久しぶりです。&lt;a href=&quot;https://www.spartanrace.jp/en&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
</feed>
