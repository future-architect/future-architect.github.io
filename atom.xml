<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Future Tech Blog - フューチャーアーキテクト</title>
  
  <subtitle>フューチャーアーキテクト開発者ブログ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2019-09-18T05:40:43.118Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <author>
    <name>Future Architect Consultants</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>サステナブルなエンジニア組織デザイン（後編） ～デザインパターンと10のリファクタリング～</title>
    <link href="https://future-architect.github.io/articles/20190918/"/>
    <id>https://future-architect.github.io/articles/20190918/</id>
    <published>2019-09-17T23:37:42.000Z</published>
    <updated>2019-09-18T05:40:43.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="サステナブルなエンジニア組織デザイン-後編"><a href="#サステナブルなエンジニア組織デザイン-後編" class="headerlink" title="サステナブルなエンジニア組織デザイン 後編"></a>サステナブルなエンジニア組織デザイン 後編</h1><p>前編ではエンジニア組織のよくある設計とジレンマについて紹介しました。</p><ul><li><a href="/articles/20190917/">前編：サステナブルなエンジニア組織デザイン ～よくある設計とジレンマ～</a></li><li>後編：サステナブルなエンジニア組織デザイン ～デザインパターンと10のリファクタリング～</li></ul><p>後編ではサステナブルなエンジニア組織に向けたデザインパターンとリファクタリングのプラクティスについて紹介します。</p><h1 id="対象者"><a href="#対象者" class="headerlink" title="対象者"></a>対象者</h1><p>エンジニアに敬意を払える正しい認識を持ってることを前提として以下のような方々を対象としています。</p><ul><li>スタートアップなどでエンジニア組織をこれから作っていこうとされている方</li><li>エンジニア組織駆動でビジネスをスケールさせていこうと思っている方</li><li>他、エンジニア組織に対して様々な課題認識を持っていられる方<ul><li>エンジニアの獲得がうまくいかずに組織が大きくならない</li><li>エンジニアがどんどん離れていってしまっている</li><li>エンジニアのモチベーションがアップするような仕事環境を与えられていない</li><li>エンジニアが好き勝手やるので収益に結びつかない</li><li>エンジニアのキャリア形成がうまくいっていない</li><li>エンジニアのレジェンド達が新しいチャレンジを許さない</li><li>エンジニアとは名ばかりでベンダーコントロールするだけの組織になっている</li></ul></li></ul><h1 id="エンジニア組織のデザインパターン"><a href="#エンジニア組織のデザインパターン" class="headerlink" title="エンジニア組織のデザインパターン"></a>エンジニア組織のデザインパターン</h1><p>今まで試行したことのある主だったエンジニア組織のデザインパターンを整理してみました。<br><img src="/images/20190918/photo_20190918_01.png"></p><p>組織全体への適用だったり、部分適用だったりと多少の違いはありますが、いずれかのパターンの組み合わせでリファクタリングしています。それぞれのパターンに特徴があり、万能な組織デザインは存在しません。組織デザイン検討にあたってはリファレンスになるデザインパターンとして適宜組み合わせてみたりしてもらえるとよいかと思います。<a href="/articles/20190917/">前編</a>で少し触れたティールは遠目で見ればホラクラシーに分類できるので以降はそう読み替えてもらっても大きくミスリードはしないかと思います。</p><h3 id="アーキテクチャ型組織デザインパターン（A型）"><a href="#アーキテクチャ型組織デザインパターン（A型）" class="headerlink" title="アーキテクチャ型組織デザインパターン（A型）"></a>アーキテクチャ型組織デザインパターン（A型）</h3><p>技術領域カットで組織を構成し技術専門性の強化を重視します。技術領域を細分化すると専門性を強化することができるメリットがあります。また組織機能重複もなく合理的な組織デザインです。ただし、特定の技術領域だけでは成り立たないようなプロジェクトでは分業制が進みやすくなり、プロジェクトのオーナーシップやカルチャー形成が分断されていく課題が頻発します。またフルスタック志向のエンジニアのキャリア形成にはこの分業制が足枷になりやすい構造です。</p><h3 id="プロジェクト型組織デザインパターン（P型）"><a href="#プロジェクト型組織デザインパターン（P型）" class="headerlink" title="プロジェクト型組織デザインパターン（P型）"></a>プロジェクト型組織デザインパターン（P型）</h3><p>事業領域のテーマやプロジェクトカットで組織を構成し機動性を重視します。一気通貫でプロジェクトに携わることによって個人の裁量も増え、個人のオーナーシップが醸成しやすいです。一方で各プロジェクトに組織機能が重複するためノウハウ蓄積が課題になりやすい構造です。目に見える形での成果は出しやすい一方で技術領域の専門性などが犠牲になりやすい構造とも言えます。</p><h3 id="マトリクス型組織デザインパターン（M型）"><a href="#マトリクス型組織デザインパターン（M型）" class="headerlink" title="マトリクス型組織デザインパターン（M型）"></a>マトリクス型組織デザインパターン（M型）</h3><p>技術領域とプロジェクト領域のマトリクスで組織を構成し、A型とP型のいいとこどりを狙った組織デザインパターンです。それぞれの弱点を補完する組織として個々のエンジニアの思考やスキルセットに応じてバランスがとりやすい構造です。プロジェクト型よりも組織機能の重複が減り合理的な組織デザインでもあります。一見すると万能な組織デザインに見えますが、エンジニア個人からみると技術領域とプロジェクト領域の二つのレポートラインが存在するため負担増になり、優先順位が明確でなければ組織のガバナンスに歪みが出やすい構造です。また技術領域を細目に分けてしまうことは余計に負担増が発生してしまうためアンチパターンになります。</p><h3 id="ホラクラシー型組織デザインパターン（H型）"><a href="#ホラクラシー型組織デザインパターン（H型）" class="headerlink" title="ホラクラシー型組織デザインパターン（H型）"></a>ホラクラシー型組織デザインパターン（H型）</h3><p>ヒエラルキーを排除し、エンジニアや小チームが有機的につながりプロジェクトを遂行する組織デザインパターンです。ミッションや価値観が共有されていてゴールイメージが明確であれば、チームワークは活性化され成果を最大化しやすい構造です。エンジニア個人のキャリアにも効果的であり、組織的なノウハウ蓄積に加えノウフー（Know Who）による集合知形成がしやすくなります。ただし、個人に多くの判断を委ねられることが多くなるため属人化が進み、結果的に組織機能の重複が多くなる傾向があります。組織全体にボトルネックやグレーゾーンが生まれやすくなり、関係者が増えれば増えるほど共有すべき価値観は希薄化し、大きなプロジェクトを遂行するには無理が生じやすい構造でもあります。</p><p>まとめると、こんな感じでしょうか。いずれも相対的な評価です。</p><table><thead><tr><th align="left">観点</th><th align="left">内容</th><th align="center">A型</th><th align="center">P型</th><th align="center">M型</th><th align="center">H型</th></tr></thead><tbody><tr><td align="left">オーナーシップ</td><td align="left">仕事に対してオーナーシップが育まれやすいか？</td><td align="center">△</td><td align="center">◯</td><td align="center">△</td><td align="center">△</td></tr><tr><td align="left">オペレーション</td><td align="left">組織のオペレーションに重複がないか？</td><td align="center">◯</td><td align="center">×</td><td align="center">△</td><td align="center">×</td></tr><tr><td align="left">モビリティ</td><td align="left">個人やチームの機動性はあるか？</td><td align="center">×</td><td align="center">◯</td><td align="center">△</td><td align="center">◯</td></tr><tr><td align="left">カルチャー</td><td align="left">生まれたカルチャーが維持されやすいか？</td><td align="center">△</td><td align="center">◯</td><td align="center">◯</td><td align="center">◯</td></tr><tr><td align="left">ノウハウ</td><td align="left">ノウハウが蓄積されやすいか？</td><td align="center">◯</td><td align="center">△</td><td align="center">◯</td><td align="center">？</td></tr><tr><td align="left">プレッシャー</td><td align="left">個人やチームの負担はあるか？</td><td align="center">◯</td><td align="center">△</td><td align="center">△</td><td align="center">×</td></tr><tr><td align="left">パフォーマンス</td><td align="left">個人やチームの成果がでやすいか？</td><td align="center">△</td><td align="center">◯</td><td align="center">△</td><td align="center">？</td></tr><tr><td align="left">モチベーション</td><td align="left">個人のモチベーションが維持されやすいか？</td><td align="center">△</td><td align="center">◯</td><td align="center">△</td><td align="center">◯</td></tr><tr><td align="left">キャリア</td><td align="left">キャリア形成がしやすいか？</td><td align="center">△</td><td align="center">△</td><td align="center">◯</td><td align="center">◯</td></tr></tbody></table><p>ホラクラシー型に「？」があるのはうまく機能させるには前提条件があるからです。ホラクラシー型には行動指針といった価値観の共有が不可欠です。それらが価値基準として各個人まで血の巡りのように隅々までいきわたっていることが前提条件です。</p><p>参考までに2010年頃に当時30名ぐらいだったメンバーに対して共有した一枚を紹介します。</p><img src="/images/20190918/photo_20190918_02.png"><p>当時は20代の頃でプロジェクトが佳境の中、勢いで書いたペーパーなので今みるとちょっと恥ずかしいですが、、、当時のメンバー各人が強烈な「課題認識」をもち、課題に対して「自発的行動」を促し、エンジニア同士が「有機的協調」して、課題の根本解決に向けた「技術（自己）投資」を継続しながら成果に「コミットメント」する。そのサイクルが更に新たな成果を生んでいく、といったことができていた組織でした。過去を美化している感はありますが、当時は言葉の定義もなかったホラクラシー型組織のいくつかの要素を満たしていたのではないかと思っています。</p><h3 id="ホラクラシーとマズロー"><a href="#ホラクラシーとマズロー" class="headerlink" title="ホラクラシーとマズロー"></a>ホラクラシーとマズロー</h3><p>非常に有名な「マズローの5段階欲求」の最上位欲求「自己実現欲求」は知的好奇心が旺盛なエンジニアには特に強い傾向があると思います。この欲求を刺激することはエンジニアのキャリア形成にとっても非常に大事です。ただし、それだけではエンジニアのサステナブルな組織化は難しいというモヤモヤがずっとありました。それに対してマズロー自身が晩年になって更に上位に6段階目の欲求「自己超越欲求」について言及していたことを恥ずかしながらつい最近知りました。</p><img src="/images/20190918/photo_20190918_03.png"><p>ホラクラシー型を目指すことは「自己超越欲求」に応えることだと勝手解釈して個人的に納得してます。エンジニア個人の自己実現という狭い視野からチーム成長を通して自己超越したいという欲求を満たすこと、つまりはチーム＝自分自身という感覚を養っていくということではないかと整理してます。</p><h1 id="10の症状とリファクタリング"><a href="#10の症状とリファクタリング" class="headerlink" title="10の症状とリファクタリング"></a>10の症状とリファクタリング</h1><p>エンジニア組織の様々なジレンマを解消できるような西洋医学的な特効薬は存在しません。組織としての成熟度や課題認識に応じて適切なタイミングで東洋医学的に組織デザインをリファクタリングし続ける継続力が重要です。</p><p>リファクタリングのタイミングを見計らうのに利用したのがチームビルディング理論として有名な「タックマンモデル」です。</p><img src="/images/20190918/photo_20190918_04.png"><p>タックマンが提唱したこの理論はチームが機能的に進化する過程を表しているもので、あまりに普遍的なモデルなのでチームビルディングを志す人なら目にされた方も多いかと思います。</p><p>タックマンモデルの説明は他に任せるとして割愛しますが、ここでお伝えしたいことはエンジニアに異変を感じた時に即リアクションして必要に応じてリファクタリングすることの重要性です。組織が成長するタイミングで起きる歪みはエンジニアの行動変化から始まります。変化に敏感に気がついて早期にリアクションして適切な処方をしないと機能的な組織デザインには進化しません。</p><p>以下、組織のリファクタリングのきっかけとなる10の症状と処方箋を紹介します。</p><img src="/images/20190918/photo_20190918_05.png"><h3 id="一、老害シンドローム"><a href="#一、老害シンドローム" class="headerlink" title="一、老害シンドローム"></a>一、老害シンドローム</h3><p>エンジニアから「俺らの頃は～」という表現がよく聞こえてくるようになったのなら絶好のリファクタリングのタイミングです。特にレジェンド達が過去の成功体験を語り続けているなら気を付けた方がよいでしょう。過去の経験は尊いものですが、成功体験による自信は行き過ぎると過信へと変わります。過信は停滞を生む大きな原因の一つです。成功体験しか言わないレジェンドには別の役割を与えた方がいいでしょう。書籍『<a href="https://www.amazon.co.jp/dp/B00KD2IK4S/" target="_blank" rel="noopener">チーズはどこに消えた？</a>』でも渡しておくといいかもしれません。また、この症状の場合はヒエラルキーが深くなっていることが可能性が高いため、組織デザインをよりフラットにするような処方が効果的です。</p><p>　　→　処方箋：組織デザイン変更（P型、H型など）</p><h3 id="二、安定シンドローム"><a href="#二、安定シンドローム" class="headerlink" title="二、安定シンドローム"></a>二、安定シンドローム</h3><p>エンジニアの「実績を重視して～」という表現がよく聞こえてくるようになったのなら絶好のリファクタリングのタイミングです。実績は非常に大事ではありますが、意思決定に実績しか選択理由がない場合は安定という名の思考停止をしている可能性がありますので気を付けた方がよいでしょう。現状維持の安易な選択は変化を拒んでいる証拠です。技術的負債の正体は現状維持バイアスです。これが続くとエンジニア組織の癌細胞になる可能性があります。まだ小さいうちに対処して取り除いておくことが大事です。</p><p>　　→　処方箋：組織デザイン変更（A型、M型など）</p><h3 id="三、テクハラシンドローム"><a href="#三、テクハラシンドローム" class="headerlink" title="三、テクハラシンドローム"></a>三、テクハラシンドローム</h3><p>技術的な専門性で尖ったエンジニアが専門外の人に対してテクハラ（テクノロジー・ハラスメント）を見かけるようになったら注意喚起が必要です。チーム間に壁が生まれている可能性があります。一度築かれてしまった壁はなかなか崩れないので協調型に変えるなどといった大きなリファクタリングも必要になると覚悟した方がいいでしょう。</p><p>　　→　処方箋：組織デザイン変更（P型、M型など）</p><h3 id="四、燃え尽きシンドローム"><a href="#四、燃え尽きシンドローム" class="headerlink" title="四、燃え尽きシンドローム"></a>四、燃え尽きシンドローム</h3><p>大きなプロジェクトが終わりそうなタイミングはリファクタリングを検討するタイミングにもなります。大きなプロジェクトが終わると達成感を超えて燃え尽きてしまうことがあります。一度燃え尽きてしまうとなかなか回復するのに時間がかかるので早い段階での検知が不可欠です。燃え尽き状態になるネガティブな要因の一つは、偏ったプレッシャーを長い期間与え続け、エンジニアを低温火傷のように思考停止状態にさせてしまった点が挙げられます。回避させるためには日頃から定期的なメンタリングやキャリア相談がしやすい組織デザインへとリファクタリングしましょう。</p><p>　　→　処方箋：組織デザイン変更（M型など）</p><h3 id="五、内向性愚痴シンドローム"><a href="#五、内向性愚痴シンドローム" class="headerlink" title="五、内向性愚痴シンドローム"></a>五、内向性愚痴シンドローム</h3><p>エンジニアから所属チームに対する不平・不満が増えてきたタイミングでは対症療法的に一つ一つ改善させていくことが先決です。大きなリファクタリング（異動・交代、方針転換など）はかえって傷を大きくしやすいため、目の前の不平・不満がコツコツと改善する様子をエンジニア自身に感じてもらうことが重要です。大きなリファクタリングによる荒治療は最終手段に取っておきましょう。</p><p>　　→　処方箋：チーム内改善</p><h3 id="六、外向性愚痴シンドローム"><a href="#六、外向性愚痴シンドローム" class="headerlink" title="六、外向性愚痴シンドローム"></a>六、外向性愚痴シンドローム</h3><p>エンジニアから所属チーム外に対する不平・不満が増えてきたタイミングでは、言う側と言われる側のどちらの問題なのかをきっちり見極めて大きなリファクタリング（異動・交代）を考えましょう。チーム外に対する不平・不満は多くの場合で周囲に一気に広がる進行性の癌になりえます。組織が若いうちは特に進行が早いため配置転換も早ければ早いほどよいでしょう。</p><p>　　→　処方箋：異動・交代</p><h3 id="七、成長痛シンドローム"><a href="#七、成長痛シンドローム" class="headerlink" title="七、成長痛シンドローム"></a>七、成長痛シンドローム</h3><p>組織内の一つのチームに所属するエンジニア数が一定のラインを超えてくると、それまではうまくいっていたことがうまくいかない事態が起きてきます。ほとんどの場合は成長痛なので一度超えてしまえばチームの成長に繋がりますが、私自身の経験上ではチームあたり8名程度までが最適なメンバー数で30名程度になると直接的な指揮系統の限界を迎えます。限界を超えると必然的にヒエラルキーが深くなりやすく、それによるエンジニアに対する弊害が多くなるため、メンバー数が一定ラインを超えたチームはチーム分解を検討するのがよいでしょう。</p><p>　　→　処方箋：チームの分解</p><h3 id="八、血行不良シンドローム"><a href="#八、血行不良シンドローム" class="headerlink" title="八、血行不良シンドローム"></a>八、血行不良シンドローム</h3><p>エンジニアが同じチームに仲間が変わらない状況下で長期間所属している状況は、多くの場合チャレンジが減り現状維持バイアスという名の血行障害になるリスクがあります。この症状になると組織全体にいい影響を与えないことが多いため、日ごろからの心がけて血行を促進する必要があります。チームの所属期間をモニタリングするなどして、チームメンバーの流動性を維持管理していることが重要です。定期的な人材シャッフルなども有効でしょう。</p><p>　　→　処方箋：異動・交代</p><h3 id="九、マンネリシンドローム"><a href="#九、マンネリシンドローム" class="headerlink" title="九、マンネリシンドローム"></a>九、マンネリシンドローム</h3><p>エンジニアに対して「何かやりたいことがないのか？！」、「あなたの分身を育てようよ？！」という投げかけを頻繁に聞くようになったらチームが停滞しはじめている黄色信号です。ミッションや後継育成はリーダーが組織的にやることであって、エンジニアにそれを求めるようになってることはチームに成長の伸びしろがない証拠です。チームの可能性の幅を模索できないようならチーム解散も含む大きなリファクタリングを計画していく好機です。</p><p>　　→　処方箋：チーム解散</p><h3 id="十、うわべだけシンドローム"><a href="#十、うわべだけシンドローム" class="headerlink" title="十、うわべだけシンドローム"></a>十、うわべだけシンドローム</h3><p>エンジニアの真の声が聞こえなくなった、エンジニアからキャリア相談される機会が減った、ソースコードを書く/見る機会が減った、エンジニアの活動の評価を数字貢献だけでみるようになった、・・・などエンジニアとの距離感が遠くなったことに焦りを感じずにうわべだけのマネジメントになっている場合はもはや組織のリーダーシップとしては末期状態に近づきつつあります。リファクタリングの時期を逸している可能性が高いため、その時に考えるべきことは一つしかありません。</p><p>　　→　処方箋：あなた自身が退く</p><h1 id="後編まとめ"><a href="#後編まとめ" class="headerlink" title="後編まとめ"></a>後編まとめ</h1><p>サステナブルなエンジニア組織に向けたデザインパターンとリファクタリングのプラクティスについて紹介しました。</p><h3 id="エンジニア組織デザインのヒント"><a href="#エンジニア組織デザインのヒント" class="headerlink" title="エンジニア組織デザインのヒント"></a>エンジニア組織デザインのヒント</h3><ul><li>組織デザインパターンは万能ではなく各々にメリットとデメリットがある</li><li>組織デザインパターンは適宜組み合わせることで組織のデメリットを補強できる</li><li>エンジニアの行動指針や価値観の共有は組織を強くする</li><li>エンジニア組織が成熟していく時間軸をコントロールしてレベルアップさせる</li><li>エンジニアに対して紳士に向き合った対話を心掛ける</li><li>エンジニアの行動変化や異変を素早く検知・予想する</li><li>検知された異変に対して適切なタイミングで適切な処方をする</li><li>組織デザインのリファクタリングを継続することがサステナブルな組織へと進化させる</li></ul><h3 id="リーダーがやってはいけないことリスト"><a href="#リーダーがやってはいけないことリスト" class="headerlink" title="リーダーがやってはいけないことリスト"></a>リーダーがやってはいけないことリスト</h3><ul><li>実態の伴わない組織デザイン</li><li>エンジニアとの心理的な距離感</li><li>チーム間の壁の許容</li><li>深いヒエラルキーの許容</li><li>変化に対する意思決定の遅延</li><li>問題は時間が解決するという楽観主義</li><li>エンジニアの力を信じない悲観主義</li><li>現状に甘んじて自身を律することをしない甘え</li></ul><h3 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h3><ul><li><a href="/articles/20190917/">前編：サステナブルなエンジニア組織デザイン ～よくある設計とジレンマ～</a></li><li>後編：サステナブルなエンジニア組織デザイン ～デザインパターンと10のリファクタリング～</li></ul><h3 id="おまけ"><a href="#おまけ" class="headerlink" title="おまけ"></a>おまけ</h3><p>本稿のテーマに直接的に関連はしませんが個人的に組織デザインに影響を受けた書籍を紹介します。</p><p>2002年にダニエル・カーネマンがノーベル経済学賞を受賞して以来、脚光を浴びるようになった学問が行動経済学です。人間がかならずしも合理的には行動しないことに着目し、経済モデルに人間の心理を取り入れることで、トラディショナルな経済学ではうまく説明不能だった経済行動を実証的に捉えようとしたものです。</p><p>経済学の専門家でもないのでさらっと読める書籍の紹介になりますが、エンジニア組織デザインが経営学でいう組織論などとは合致しない点が多くてもやもやしていたのですが、行動経済の別視点で組織を眺めると多少なりとも参考になる点が多く応用できました。エンジニア組織に起きていた行動のいくつかが説明つくこともあるので予測可能な行動は先手を打つべく個人的に重宝しています。</p><p>何かの参考になれば。</p><img src="/images/20190918/photo_20190918_06.jpg" class="img-small-size" style="border:solid 1px #000000"><p>『<a href="https://www.amazon.co.jp/dp/B00K1A75N4/" target="_blank" rel="noopener">予想どおりに不合理</a>』　ダン・アリエリード(著)</p><hr><p>Yosuke Miyahara<br>Vice President/Technology Innovation Group/Future Corporation.<br><a href="https://newspicks.com/user/147180" target="_blank" rel="noopener">https://newspicks.com/user/147180</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;サステナブルなエンジニア組織デザイン-後編&quot;&gt;&lt;a href=&quot;#サステナブルなエンジニア組織デザイン-後編&quot; class=&quot;headerlink&quot; title=&quot;サステナブルなエンジニア組織デザイン 後編&quot;&gt;&lt;/a&gt;サステナブルなエンジニア組織デザイン 後編&lt;/
      
    
    </summary>
    
      <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
      <category term="組織論" scheme="https://future-architect.github.io/tags/%E7%B5%84%E7%B9%94%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>サステナブルなエンジニア組織デザイン（前編） ～よくある設計とジレンマ～</title>
    <link href="https://future-architect.github.io/articles/20190917/"/>
    <id>https://future-architect.github.io/articles/20190917/</id>
    <published>2019-09-17T02:00:42.000Z</published>
    <updated>2019-09-18T02:18:13.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>ここ数年来で人材マーケットにおけるIT人材の需要が高まり人材獲得合戦が過熱しています。経済産業省が2018年に公開したレポート「2025年の崖」では2025年にはIT人材不足が約43万人まで拡大すると指摘しています。やや煽り気味だなーと思えるぐらいにメディアも一斉に取り上げました。「今のうちにIT人材を大量獲得せよ！」とトップダウン指示を受けて、人材の囲い込み合戦に参戦して大変になられている人事担当の方も多いだろうなと想像しています。</p><p>※当社ではIT人材をコンサルタント＋エンジニア≒アーキテクトと呼称しますが、本稿では便宜上エンジニアと表記します。</p><h3 id="エンジニアの住む世界"><a href="#エンジニアの住む世界" class="headerlink" title="エンジニアの住む世界"></a>エンジニアの住む世界</h3><p>迫り来る将来の危機が人材不足というエンジニアの量の問題なのかというとそれは湾曲した認識です。エンジニアはソースコードは短ければ短いほど美しいと思う人種で、クラウドネイティブな作品が増えてきてからはこぞってアーキテクチャデザインの美しさを互いに誇りあい、難解で複雑な問題を抽象化して解こうとする、そんなアートの世界にエンジニアは暮らしています。エンジニアをいつまでも「人月の神話」の世界で飼い慣らそうとする発想のままでは問題の本質をミスリードします。エンジニアは量ではなく質で評価されるべきで、質の高いアウトプット価値を人月で評価することは失礼にあたります。この認識を改めなければ誇り高きエンジニアはまず集められないでしょう。</p><p>いかにエンジニアが成長しやすい環境を継続的に改善していき、成長したエンジニアによる成果をどうビジネスに直結させるかを追求できれば、人材不足に対して量で補おうとする負のスパイラルから脱却できるだろうと思います。</p><h3 id="サステナブルな組織デザイン"><a href="#サステナブルな組織デザイン" class="headerlink" title="サステナブルな組織デザイン"></a>サステナブルな組織デザイン</h3><p>私はここ十年ぐらい大中小の様々なエンジニア組織をリードしてきました。幾度もエンジニア組織の統廃合を繰り返しながら試行錯誤してきましたが、組織を持続的に成長させることの難しさは身をもって知っているつもりです。未だ正解と言えるような組織デザインは見つかっておらず今もなお試行錯誤中なのが正直なところです。</p><p>そんな中で今までの統廃合の歴史を振り返ると、組織は8名→30名→80名→200名超と年々大きくなっていき、その過程の中で進化してきた組織デザインはマーケット変化やあらゆる危機感に都度対応してきた進化論（結果論？）だったように思えてなりません。</p><p>失敗や成功体験の中にエンジニアに特化した組織デザインのヒントがあると信じてサステナブルな組織デザインについて2部構成でまとめてみました。</p><ul><li>前編：サステナブルなエンジニア組織デザイン～よくある設計とジレンマ～</li><li>後編：<a href="/articles/20190918/">サステナブルなエンジニア組織デザイン～デザインパターンと10のリファクタリング～</a></li></ul><p>前編ではエンジニア組織でよく遭遇するジレンマについて紹介します。</p><h1 id="対象者"><a href="#対象者" class="headerlink" title="対象者"></a>対象者</h1><p>エンジニアに敬意を払える正しい認識を持ってることを前提として以下のような方々を対象としています。</p><ul><li>スタートアップなどでエンジニア組織をこれから作っていこうとされている方</li><li>エンジニア組織駆動でビジネスをスケールさせていこうと思っている方</li><li>他、エンジニア組織に対して様々な課題認識を持っていられる方<ul><li>エンジニアの獲得がうまくいかずに組織が大きくならない</li><li>エンジニアがどんどん離れていってしまっている</li><li>エンジニアのモチベーションがアップするような仕事環境を与えられていない</li><li>エンジニアが好き勝手やるので収益に結びつかない</li><li>エンジニアのキャリア形成がうまくいっていない</li><li>エンジニアのレジェンド達が新しいチャレンジを許さない</li><li>エンジニアとは名ばかりでベンダーコントロールするだけの組織になっている</li></ul></li></ul><h1 id="散見されるエンジニア組織の現状"><a href="#散見されるエンジニア組織の現状" class="headerlink" title="散見されるエンジニア組織の現状"></a>散見されるエンジニア組織の現状</h1><p>ビジネスモデルや技術革新スピードが激変する今、業種業態を問わず企業は異次元のスピードで変化対応力が求められています。ITを「誰かに作ってもらうもの（外製）」から「自ら作るもの（内製）」へと経営の舵を切り、IT組織を強化しようとするのは必然の流れです。空前の内製化ブームの是非はおいといてもこのウェーブに乗るっきゃないと思った企業は非常に多いです。</p><p>多くのクライアントからなかなか思い通りにいかないといった種の相談を受ける機会がここ数年来で増えてきました。「エンジニアを集められない」、仮に集められても「エンジニア組織が機能していない」という話が大半です。それをエンジニアの意識の問題やHRマーケティングの問題にすり替えながら、組織名に「イノベーション」、「デジタル」、「DX」、「ラボ」などの流行り言葉を並べてどうにかエンジニアの関心を惹けるよう組織の名称から試行錯誤されている企業も多いなと思います。</p><p>当の私が執行責任をもっている組織名も「Technology Innovation Group」と名付けているので同じ試行錯誤をした輩です。エンジニア組織をどうビルディングしていくかは非常に普遍的な課題だなと思います。</p><h1 id="エンジニア組織のジレンマ"><a href="#エンジニア組織のジレンマ" class="headerlink" title="エンジニア組織のジレンマ"></a>エンジニア組織のジレンマ</h1><p>エンジニア組織をビルディングをするにはエンジニアの持つ価値観の性質をしっかりと理解しなければなりません。そしてエンジニア組織が成熟していく過程ではエンジニアの性質起因で繰り広げられる様々なジレンマが存在します。代表的なジレンマをいくつか紹介します。</p><h3 id="1-オープンな活動-vs-クローズドな活動"><a href="#1-オープンな活動-vs-クローズドな活動" class="headerlink" title="1) オープンな活動 vs クローズドな活動"></a>1) オープンな活動 vs クローズドな活動</h3><p>「技術ノウハウをオープンにして外部のコミュニティとの接点を多くするか、企業の競争戦略上クローズドに内部に留めようとするか」</p><p>このジレンマで踏み止まってる企業は多く、歴史の長い組織であればあるほどその傾向は強いなと感じます。このジレンマにはエンジニアのモチベーションとノウハウ流出リスクとのトレードオフがあります。エンジニアは総じてOSS活動や勉強会などが大好きな性質をもっています。これを利用するとオープンなコミュニティで様々な出会いがあるのでHRマーケティングが大いに期待ができます。一方でノウハウ流出にはエンジニア自身のヒトも含まれます。外部の接点が増える分だけ他企業に目移りしてしまう確率を上げてしまうことは避けられない事実です。</p><p>エンジニアのモチベーションはポジティブなパワーを生むのでカルチャー形成には有効です。流出リスクを理解しつつもオープンな活動に振り切って、エンジニアの集まるカルチャー形成をすることが先決です。エンジニアが好むカルチャーさえあれば、焦らずとも自然とエンジニアは集まってきます。</p><p>人が集まってきたら次はエンジニアを組織化するフェーズに移行した時のジレンマです。</p><h3 id="2-競争型の運営-vs-協調型の運営"><a href="#2-競争型の運営-vs-協調型の運営" class="headerlink" title="2) 競争型の運営 vs 協調型の運営"></a>2) 競争型の運営 vs 協調型の運営</h3><p>「個人やチームに対して技術や成果責任を競わせる形で運営するか、協調性を重視して明確な責任を持たせないで運営するか」</p><p>これにはプロジェクト（当社ではプロジェクト制のため関連する一連の仕事をプロジェクトと以降も表記します）に対するオーナーシップと技術ノウハウの蓄積との間にトレードオフがあります。互いに競争することで担当領域に対するオーナーシップは強固になりますが、逆に領域に固執しすぎてしまうとエンジニア間に壁が生まれ、ノウハウが分断されて技術力は相対的に停滞しがちです。一方で協調性を重視すると技術ノウハウ共有が進み技術力は相乗的に向上しやすくなりますが、緊張関係のない過度な協調は他力に頼りやすくなり、組織が大きくなるにつれてプロジェクトのオーナーシップが欠如する事態も起こりえるでしょう。</p><p>ここでもトレードオフを顧みながら競争と協調のバランスをとって使い分けることが重要です。オーナーシップの欠如が垣間みえるようになると、組織はそれ以上大きくできない黄色信号だと捉えるとよいかと思います。仮に大きくできても機能しない組織になるだけです。エンジニア組織に技術や成果に対して適度な競争原理を導入することは組織成長のスパイスになりえます。</p><p>エンジニア組織が大きくなると、ビジネスとしての成果を求められるようになるのは必然な流れかと思います。次は組織成果の最大化させるフェーズに移行した時のジレンマです。</p><h3 id="3-ヒエラルキー-vs-ホラクラシー"><a href="#3-ヒエラルキー-vs-ホラクラシー" class="headerlink" title="3) ヒエラルキー vs ホラクラシー"></a>3) ヒエラルキー vs ホラクラシー</h3><p>「マネージャーが管理するヒエラルキーか、管理者不在のホラクラシーとするか」</p><p>エンジニアは管理されることが基本的に嫌いという性質をもっています。マネージャーはエンジニアの成果を時間やアウトプット量をメジャーにしがちなのでエンジニアの価値観にギャップが生じます。とはいえ、マネージャーがいると成果にコミットしやすくなるのも事実です。一方で成果に対する極度なコミットメントは失敗を恐れるあまり保守的になりやすく、積極的な技術チャレンジが減少し、結果的に技術的負債を生みやすくなります。一方で管理者不在のホラクラシーに移行するとエンジニアの自立を促すことができ、技術的なチャレンジが活性化され、プロのエンジニアとして大きくブレークスルーする可能性も飛躍的に高くなります。ただし、エンジニアにゴールや価値観が共有できていないと組織は機能せずに、エンジニアの活動が趣味の世界に入りやすく自己満足に陥りやすい傾向もあります。</p><p>ここでもトレードオフを顧みながら使い分けることでビジネスの成果が最大化され、エンジニアやそのチームにプロ意識が芽生えてきます。エンジニアのプロ意識は暫くすると自主経営へと進化し、ヒト・モノ・カネ・ノウハウといった組織のリソースに対する権限委譲を要求してくるでしょう。次は持続可能な自主経営フェーズに移行した時のジレンマです。</p><h3 id="4-権限委譲-vs-アカウンタビリティ"><a href="#4-権限委譲-vs-アカウンタビリティ" class="headerlink" title="4) 権限委譲 vs アカウンタビリティ"></a>4) 権限委譲 vs アカウンタビリティ</h3><p>「個人やチームにあらゆる権限を委譲するか、その代わりにアカウンタビリティをどう果たすか」</p><p>権限委譲によりエンジニアによる自主経営が進み、短期的な収益を気にするようなP/L思考から技術投資などのB/S思考へと意識が変わり、結果的に中長期的な活動が増えることでサステナブルな組織へのグレードアップが期待できます。権限委譲を推し進めることは経営に対するアカウンタビリティを果たすことも同時に要求されることにもなります。エンジニアの投資的な活動のほとんどはテクノロジートレンドなどに即した知的好奇心から始まることが常です。それ自体はイノベーションの原動力にもなりうるので否定すべきものではありません。ただし、知的好奇心だけでは総じてエモーショナルな動機ばかりが周囲の目に映りやすく、透明性が損なわれた活動には組織内外からの応援者が得られずに、その活動範囲は狭くなりがちです。自由（権限委譲）には責任がつきものですので個人レベルまでその意識を徹底、および維持し続ける覚悟が必要になります。</p><h1 id="エンジニア組織の資本は人と技術"><a href="#エンジニア組織の資本は人と技術" class="headerlink" title="エンジニア組織の資本は人と技術"></a>エンジニア組織の資本は人と技術</h1><p>いずれのジレンマもゼロかイチの選択ではなく、その時その瞬間にどこに軸足をおいてバランスをとるかが重要です。組織デザインにはバランス能力が問われています。エンジニア組織の資本は人と技術。組織デザインの落とし穴は至るところにあり、バランス感覚を失うと人は疲弊して技術は陳腐化します。エンジニア組織の資本が擦り減っていく負のサイクルに陥いれば組織は急激に傷んでいきます。</p><img src="/images/20190917/photo_201909017_01.png" style="border:solid 1px #000000"><p>逆に言えば各種ジレンマを突破すれば、エンジニア組織の資本力が強化されサステナブルな組織に向けて組織は大きく飛躍する可能性を秘めています。</p><p>可能性を開花させるには組織デザインが重要な役割を果たします。</p><h3 id="エンジニア組織デザインの救世主？"><a href="#エンジニア組織デザインの救世主？" class="headerlink" title="エンジニア組織デザインの救世主？"></a>エンジニア組織デザインの救世主？</h3><p>2018年に救世主のような組織デザインとしてティール組織がフィーチャーされました。ティールは以下の書籍で非常に有名になり、旧来型組織から一線を画した大変興味深い組織論です。これがエンジニア組織を救う手立てになりうるかが気になるポイントかと思います。</p><img src="/images/20190917/photo_201909017_02.jpeg" class="img-middle-size"><p>『<a href="https://www.amazon.co.jp/dp/B078YJV9ZW/" target="_blank" rel="noopener">ティール組織――マネジメントの常識を覆す次世代型組織の出現</a>』　フレデリック・ラルー(著)</p><p>今では解説サイトが世にたくさんあるので詳しい説明はそちらにお任せして割愛しますが、ティール組織が評価される一方で現在エンジニア組織の課題に直面している方々にとっては少しピンとこなかったという話もよく聞きます。マインドフルネスとかホールネスなどといったスピリチュアルの言葉が多く、頭では共感できていても行動に移すには遠い印象があるのではないかと思います。その印象の深淵にはエンジニア特有のリアリティが欠けているからであると理解しています。エンジニアの中にある根源的な欲求に応えずにティール組織を目指すことには全く意味を成しません。</p><h3 id="エンジニア組織には感情がある"><a href="#エンジニア組織には感情がある" class="headerlink" title="エンジニア組織には感情がある"></a>エンジニア組織には感情がある</h3><p>エンジニアは技術に対して「損得」でなく「善悪」で動きます。つまりエンジニア組織には純粋な感情が存在しています。組織にある感情を読み解いてバランスを取りながらエンジニア組織のジレンマを乗り越えるためにはどうやったとしても時間が必要になります。ティール組織を鵜呑みにして大上段から形から入ってもいいことはないので、目の前にいるエンジニアたちの間で今まさに起きている事象に対して目を向けることの方が先決です。組織の成長に近道はないので今を知った上で適切に組織デザインをリファクタリングしていくことが大切です。</p><p>後編ではエンジニア組織デザインのリファクタリングのプラクティスを紹介します。</p><ul><li>前編：サステナブルなエンジニア組織デザイン～よくある設計とジレンマ～</li><li>後編：<a href="/articles/20190918/">サステナブルなエンジニア組織デザイン～デザインパターンと10のリファクタリング～</a></li></ul><h1 id="前編まとめ"><a href="#前編まとめ" class="headerlink" title="前編まとめ"></a>前編まとめ</h1><p>エンジニア組織の現状とその中にあるジレンマを紹介しました。</p><h3 id="エンジニア組織デザインのヒント"><a href="#エンジニア組織デザインのヒント" class="headerlink" title="エンジニア組織デザインのヒント"></a>エンジニア組織デザインのヒント</h3><ul><li>エンジニアをリスペクトする</li><li>エンジニアが成長しやすい環境を継続的に維持改善する</li><li>オープンな活動を通してカルチャーを作る</li><li>競争型・協調型のバランスでエンジニアの自立化を促す</li><li>深いヒエラルキーを排除したフラットな組織が成果を最大化する</li><li>エンジニアの慢性的な疲弊と技術的負債が最大の敵と認識する</li><li>権限委譲とアカウンタビリティの両立が中長期的な視点を養う</li><li>エンジニア組織に生まれる感情をコントロールしながら組織を運営する</li></ul><h3 id="リーダーがやってはいけないことリスト"><a href="#リーダーがやってはいけないことリスト" class="headerlink" title="リーダーがやってはいけないことリスト"></a>リーダーがやってはいけないことリスト</h3><ul><li>無理な組織合理化の追求</li><li>外部コミュニティとの遮断</li><li>現状維持バイアスの許容</li><li>マイクロマネジメント</li><li>レジェンド価値観の強要</li><li>選択肢なき自由の許容</li><li>360°評価の形骸化</li><li>オーナーシップの義務化</li></ul><h3 id="おまけ"><a href="#おまけ" class="headerlink" title="おまけ"></a>おまけ</h3><p>本稿のテーマに直接的に関連はしませんが個人的に組織デザインに影響を受けた書籍を紹介します。</p><p>2005年に刊行された「社員をサーフィンに行かせよう」から時を経て2012年出版の書籍でパタゴニアのサステナビリティについての書籍です。体系的に整理されているわけではないですが、組織デザインの様々なヒントを与えてくれます。社員のカルチャー形成、価値観の共有、思い立った時の行動力、ブランディング。</p><p>短期的ではなく長期的な視点でサステナブルなカンパニーを追求しつつ、存在意義そのものがカルチャーになっています。それでいて繊細な部分もしっかりとリファクタリングしているカンパニーだなと思います。「社員がパタゴニアの服を着ることが環境問題に直結する」という感覚があるカンパニーで、エンジニアの書くコードにも同様な正義が求められると素晴らしいのではないかと考えさせられました。</p><p>何かの参考になれば。<br><img src="/images/20190917/photo_201909017_03.jpeg" class="img-middle-size"><br>『<a href="https://www.amazon.co.jp/dp/B00P76TVKW/" target="_blank" rel="noopener">レスポンシブル・カンパニー</a>』　イヴォン・シュイナード(著)</p><hr><p>Yosuke Miyahara<br>Vice President/Technology Innovation Group/Future Corporation.<br><a href="https://newspicks.com/user/147180" target="_blank" rel="noopener">https://newspicks.com/user/147180</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;ここ数年来で人材マーケットにおけるIT人材の需要が高まり人材獲得合戦が過熱しています。経済産業省が2018年に公開したレポー
      
    
    </summary>
    
      <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
      <category term="組織論" scheme="https://future-architect.github.io/tags/%E7%B5%84%E7%B9%94%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>Google Cloud Kubernetes Day セッションレポート</title>
    <link href="https://future-architect.github.io/articles/20190910/"/>
    <id>https://future-architect.github.io/articles/20190910/</id>
    <published>2019-09-10T00:13:03.000Z</published>
    <updated>2019-09-10T01:48:41.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG(Technology Innovation Group)/DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属の村田と申します！</p><p>私は現在<a href="https://stackshare.io/future-corporation/futureiot" target="_blank" rel="noopener">Future IoT</a>プロジェクトに携わっており、最近はクラウドインフラ設計構築に従事しています。</p><p>其の中で、Kubernetesは特に重要なプロダクトであると捉えているため、業務の合間を縫ってGoogle Cloud Kubernetes Dayに参加してきました。</p><h1 id="Google-Cloud-Kubernetes-Dayは"><a href="#Google-Cloud-Kubernetes-Dayは" class="headerlink" title="Google Cloud Kubernetes Dayは"></a>Google Cloud Kubernetes Dayは</h1><p>「コンテナを使った最新の開発アプローチを学ぶ」というスローガンで開催されているイベントです。第1回目は2019年3月に、9月3日に今回の第2回目が開催されました。</p><p><a href="https://inthecloud.withgoogle.com/kubernetes-day-1909/register.html" target="_blank" rel="noopener">https://inthecloud.withgoogle.com/kubernetes-day-1909/register.html</a></p><h1 id="セッションレポート"><a href="#セッションレポート" class="headerlink" title="セッションレポート"></a>セッションレポート</h1><p>以下の2セッションに参加しました。それぞれについて簡単に紹介していきます。</p><ol><li>失敗しないアプリケーションモダナイゼーションの考え方</li><li>Anthosで実現するモダンなアプリケーション管理プラットフォーム</li></ol><h2 id="１．失敗しないアプリケーションモダナイゼーションの考え方"><a href="#１．失敗しないアプリケーションモダナイゼーションの考え方" class="headerlink" title="１．失敗しないアプリケーションモダナイゼーションの考え方"></a>１．失敗しないアプリケーションモダナイゼーションの考え方</h2><p>FUJIFILMさんとFreakOutさんの事例をベースに、アプリケーションのモダナイゼーションおよびDevOpsについてのセッションでした。</p><h3 id="モダナイゼーションとは"><a href="#モダナイゼーションとは" class="headerlink" title="モダナイゼーションとは"></a>モダナイゼーションとは</h3><ul><li>100人100通りの答えが返ってくるテーマである</li><li>大事な要素に以下4点がある<ol><li>Twelve factor app</li><li>マイクロサービス</li><li>クラウドネイティブ</li><li>クラウドの利用</li></ol></li></ul><h3 id="パネルディスカッションパート"><a href="#パネルディスカッションパート" class="headerlink" title="パネルディスカッションパート"></a>パネルディスカッションパート</h3><h4 id="自己紹介"><a href="#自己紹介" class="headerlink" title="自己紹介"></a>自己紹介</h4><ul><li>モハマド氏（<a href="https://pg-ja.fujifilm.com/home" target="_blank" rel="noopener">FUJIFILM Prints &amp; Gifts</a>担当の方）</li><li>西口氏（<a href="https://www.fout.co.jp/" target="_blank" rel="noopener">FreakOut</a>の方）</li></ul><h4 id="各々のPJ概要について"><a href="#各々のPJ概要について" class="headerlink" title="各々のPJ概要について"></a>各々のPJ概要について</h4><ul><li>FUJIFILM Prints &amp; Giftsのバックエンドシステムである<a href="https://cloud.google.com/blog/ja/topics/customers/gcp-google-kubernetes-engine-fujifilm" target="_blank" rel="noopener">オーダー管理システム</a>（以下、OMS）のモダナイゼーションについて<ul><li>スケーラビリティに課題があったので、モダナイゼーションによるレガシーシステムのリプレイスへと踏み切った</li><li>その手段が「マイクロサービス化」であった</li></ul></li><li>FreakOutの開発した広告プラットフォームである<a href="https://www.fout.co.jp/freakout/product/rfp/" target="_blank" rel="noopener">Red for Publishers</a>のアーキテクチャ<ul><li>GKEを利用した広告の仕組みを構築している</li></ul></li></ul><h4 id="アーキテクチャ選定の考え方について"><a href="#アーキテクチャ選定の考え方について" class="headerlink" title="アーキテクチャ選定の考え方について"></a>アーキテクチャ選定の考え方について</h4><ul><li>広告はスピードが大事なので、そこを重視してアーキテクチャ選定を行った(西口氏)</li><li>サーバレスは1stチョイスでもよいが、システムが複雑になってきて相互に協調し合う場合にはインフラ側に介入できる方がよいと考えGKEを選択(西口氏)</li></ul><h4 id="チーム編成について"><a href="#チーム編成について" class="headerlink" title="チーム編成について"></a>チーム編成について</h4><ul><li>OMSにおける組織・開発<ul><li>周り、特に経営層の理解を得ることが重要だった</li><li>知識や実績が無かったので、失敗リスクを最小化するために、技術学習のみならず説明行脚やスタートをなるべく小さくするなど様々な手段を講じた</li><li>Googleカスタマーサポートの支援がなければ達成はできなかった</li><li>チームが連帯感を持つことが重要であった</li></ul></li><li>Red for Publishersにおける組織・開発<ul><li>Kubernetesのバージョンアップデートなど大規模なインフラ構成変更はSRE(2名)が中心に行っている</li><li>SREチームでは徐々にTerraformを導入している</li><li>ConfigMap修正やテーブルのスキーマ変更など日々の構成変更はDeveloper(11名)も行う</li></ul></li></ul><h3 id="これからモダナイズしている企業に向けて"><a href="#これからモダナイズしている企業に向けて" class="headerlink" title="これからモダナイズしている企業に向けて"></a>これからモダナイズしている企業に向けて</h3><h4 id="モハマド氏"><a href="#モハマド氏" class="headerlink" title="モハマド氏"></a>モハマド氏</h4><ul><li>マイクロサービス・サービスメッシュ・サーバレスなど技術スタックが揃っているため、クラウドを前提にした設計を進めると良い</li><li>人材の適材適所を意識する</li><li>ノウハウ・経験が無い場合にはスモールスタートが良い</li></ul><h4 id="西口氏"><a href="#西口氏" class="headerlink" title="西口氏"></a>西口氏</h4><ul><li>いまはGKEの事例がたくさんあるので参考にしながら設計すると良い</li><li>GKEはとても良いプロダクトなのでぜひ利用すると良い</li></ul><h3 id="DevOps解説パート"><a href="#DevOps解説パート" class="headerlink" title="DevOps解説パート"></a>DevOps解説パート</h3><h4 id="DevOpsの重要性"><a href="#DevOpsの重要性" class="headerlink" title="DevOpsの重要性"></a>DevOpsの重要性</h4><p>DevOpsの考えを現場に持ち込むことで目標達成率が1.53倍になると言われている</p><h4 id="Kubernetes登場による変化"><a href="#Kubernetes登場による変化" class="headerlink" title="Kubernetes登場による変化"></a>Kubernetes登場による変化</h4><p>アプリの変更・インフラの変更・サービスの監視がそれぞれ連続的な依存関係を持つものではなくなった</p><h4 id="DevOpsで発生する問題点"><a href="#DevOpsで発生する問題点" class="headerlink" title="DevOpsで発生する問題点"></a>DevOpsで発生する問題点</h4><ul><li>開発と運用のインセンティブが一致しない</li><li>開発はAgilityを、運用はReliabilityを優先する</li><li>よくある問題としてあげられるのは「合理的でない安定性(Reliability)の定義」</li><li>顧客は99.999999999%を求めているわけではないので、潜在的な安定性を明確に定義することが大事</li><li>安定性の考え方<ul><li>数値の差分を説明できるかどうか、で考える</li><li>なぜそのレベルになるか、を言葉にすることができるか</li></ul></li><li>安定性の計測方法は「Availability = good time / total time」</li></ul><h3 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h3><ul><li>ソフトウェアがビジネスの中心となり、DevOpsの重要性が増している</li><li>Kubernetesの登場により、技術的にDevOpsの実現が容易になった</li><li>Opsには安定性(Reliability)が求められ、役割は以前にも増して重要になってくる</li></ul><h3 id="セッションの感想"><a href="#セッションの感想" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>第1回でも話を聞いた2つの企業の方の後日談ということで、非常に興味深くて面白かったです！本TechBlogにも<a href="(https://future-architect.github.io/articles/20190729/)">記事</a>があがってますが、SRE本の輪読会が社内で開催され筆者も参加していたので、安定性の話などはとても理解しやすく、良い復習となりました。</p><h2 id="２．Anthosで実現するモダンなアプリケーション管理プラットフォーム"><a href="#２．Anthosで実現するモダンなアプリケーション管理プラットフォーム" class="headerlink" title="２．Anthosで実現するモダンなアプリケーション管理プラットフォーム"></a>２．Anthosで実現するモダンなアプリケーション管理プラットフォーム</h2><p>先日のGoogle Cloud NextでもAnthosの話を聞かせてくださったSAの長谷部さんと、ハイブリッドクラウドスペシャリストの篠原さんによるセッションでした。AnthosおよびGKE On-Premについてデモも含めて詳しく説明してくださりました！！</p><h3 id="「2025年の崖」"><a href="#「2025年の崖」" class="headerlink" title="「2025年の崖」"></a>「2025年の崖」</h3><p>経産省が出したDXレポートにて言及されている単語で、2025年までにDXの種をまいておかないとDXの実現が困難になると言われている。DXの実現が達成できない場合、2025年以降日本全体で年12兆円もの損失になるとも試算されている。</p><p>主な理由には下記のようなものが挙げられる。</p><ul><li>IT人材不足</li><li>データの爆発</li><li>技術的負債の増加<ul><li>似たような仕組みの乱立</li><li>過剰なカスタマイズ(日本では特にシステムを業務に合わせることが多い)</li></ul></li></ul><h3 id="これから作るものはどうする？"><a href="#これから作るものはどうする？" class="headerlink" title="これから作るものはどうする？"></a>これから作るものはどうする？</h3><ul><li>Agility（敏捷性）・ Flexibility（柔軟性）・ Maintainability（保守性）の3つを満たすことが大事</li><li>新しい考え方を取り入れ、モダンなアプリケーション開発へ</li></ul><h4 id="コンテナ基盤におけるデファクトスタンダード-Kubernetes"><a href="#コンテナ基盤におけるデファクトスタンダード-Kubernetes" class="headerlink" title="コンテナ基盤におけるデファクトスタンダード = Kubernetes"></a>コンテナ基盤におけるデファクトスタンダード = Kubernetes</h4><ul><li>今や国内コンテナ導入企業の65.3%が利用するコンテナオーケストレーションツール(IDCの調査による)</li><li>Kubernetesを本格導入する時にぶつかる問題<ol><li>【問題】どこで動かすのか？</li><li>【問題】運用が大変</li><li>【問題】複数環境でのKubernetesはどう扱うのか？</li><li>【問題】足りない機能はどう補うのか？</li></ol></li><li>1〜4の課題を自社のエンジニアリングで突破する、というのももちろんありだが、すべての会社がこの策をとるのは困難である</li><li>Anthos + GCPがKubernetesをProduct Readyへ！<ol><li>【答え】ハイブリッド+マルチクラウド</li><li>【答え】GKE</li><li>【答え】マネージドの管理機能で複数環境の一元管理</li><li>【答え】GCPの各種サービス</li></ol></li></ul><h3 id="Anthos-Deep-Dive"><a href="#Anthos-Deep-Dive" class="headerlink" title="Anthos Deep Dive"></a>Anthos Deep Dive</h3><h4 id="オンプレミス側の構成について"><a href="#オンプレミス側の構成について" class="headerlink" title="オンプレミス側の構成について"></a>オンプレミス側の構成について</h4><ul><li>DC(データセンター)のVMWare上でKubernetesが稼働する</li><li>GCPのコンテナエコシステムとの連携が可能</li><li>GKE On-Prem論理構成<ul><li>AdminのKubernetesが他のKubernetesを管理する構成</li><li>Admin Clusterの下に50のUser clusterをぶら下げることができる</li><li>Admin Clusterに対しては、<code>kubectl</code>コマンド以外にも<code>gkectl</code>というAdmin Cluster配下を管理するコマンドを実行可能</li></ul></li></ul><h4 id="クラスター管理"><a href="#クラスター管理" class="headerlink" title="クラスター管理"></a>クラスター管理</h4><ul><li>管理コンソールで一元管理が可能</li><li>DC側のGKE connect agentからGCPへの通信があるのみで、GCP側からポーリング等で状態をチェックするような通信はない</li><li>GKE On-PremではL7のLBはIstioにて制御しており、L7のIngressはL4のLBを経由する形で実現される</li><li>すでにMarket PlaceにはGKE On-Prem対応のものがいくつか存在しており、GCPコンソールからデプロイを行うとオンプレ側のGKEクラスタへアプリケーションがデプロイされる</li></ul><h4 id="ポリシー管理"><a href="#ポリシー管理" class="headerlink" title="ポリシー管理"></a>ポリシー管理</h4><ul><li>namespaceやresource quotaを各クラスタごとに別々に管理していると大変なので<a href="https://cloud.google.com/anthos-config-management" target="_blank" rel="noopener">ACM(Anthos Config Management)</a>を使う</li><li><a href="https://www.weave.works/technologies/gitops/" target="_blank" rel="noopener">GitOps</a>に準拠しており、予め指定したrepositoryからconfigの差分を検知し取得、自動的にクラスタへ適用してくれる</li></ul><h4 id="サービス管理"><a href="#サービス管理" class="headerlink" title="サービス管理"></a>サービス管理</h4><ul><li><a href="https://cloud.google.com/service-mesh/?hl=ja" target="_blank" rel="noopener">Google Cloud Service Mesh</a> (alpha) <ul><li>端的に言ってしまえばマネージドIstioのこと</li></ul></li><li>アーキテクチャ構成についての説明<ul><li><a href="https://istio.io/docs/concepts/what-is-istio/" target="_blank" rel="noopener">Istio公式</a>のアーキテクチャ図とほぼ同じだが、<code>Managed CA</code>(元のIstioで言うところのCitadel)だったりControl Planeのサービス群がしっかりとマネージドであることが謳われている</li></ul></li></ul><h3 id="セッションの感想-1"><a href="#セッションの感想-1" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>まさかGKE On-Premのデモを見られるとは思ってなかったのでとても興奮しました！オンプレ側の通信詳細については筆者のネットワーク知識不足によりついていけない場面もありましたが、今後Anthos、GKE On-Premに関わっていくあたりあたり自身の課題が浮き彫りになったのでとても良い機会となりました。</p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>今回は2セッションの参加のみでしたが、非常に有意義に過ごすことができました！特にAnthos、GKE On-Premについては今回はじめて具体的なアーキテクチャやデモを見ることができてとても良かったです。</p><p>Google Cloud Nextで語られていた「ハイブリッドクラウドの実現」に向けて、キープロダクトと定めているKubernetesをオンプレ側で使える準備が着々と整ってきているんだなと感じさせられました。ハイブリッドクラウドのメリットとして「オンプレ側でクラウドサービスの恩恵を最大限に享受する」というのがあると思いますが、今後もKubernetesやその他クラウドネイティブの文脈で登場する様々なプロダクト・サービスについての学びを止めてはいけないなと感じました！</p><p>今回も読んで頂きありがとうございました。良ければシェア・いいねをよろしくお願いします！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">DXユニットとはデジタルトランスフォーメーションに関わる仕事を主に推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG(Technology Innovation Group)/DXユニット&lt;sup id=&quot;fnref:1&quot;
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title> Let&#39;s Try GCP #1 ～Cloud Run Buttonを使った楽々コンテナデプロイをやってみた～</title>
    <link href="https://future-architect.github.io/articles/20190909/"/>
    <id>https://future-architect.github.io/articles/20190909/</id>
    <published>2019-09-09T00:30:42.000Z</published>
    <updated>2019-09-09T00:38:44.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG(Technology Innovation Group)/DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属の村田です。</p><p>昨今よく耳にする「クラウド」「サーバレス」といった単語に関連して、各クラウドベンダーからは日々様々なサービスがリリースされていますが、それらを素早くキャッチアップしつつ上手に活用していくというのは少々大変と思う方が多いと思います。</p><p>この記事はそういった方向けに、”素早くサービスの使い所を把握してもらう”ことや”新しいサービスをさっと試す手助けをする”ことを目的にした記事の第一弾です。そのため今までのFutureのTechBlogは業務で得た知見をまとめた記事が多めですが、本記事はもっと気軽にクラウドに慣れ親しんでもらうためのコンテンツを中心に作成していく予定です。</p><h1 id="Cloud-Runとは？"><a href="#Cloud-Runとは？" class="headerlink" title="Cloud Runとは？"></a>Cloud Runとは？</h1><p>Cloud RunはGCPが提供するサービスのひとつで、コンテナベースのサーバレスアプリケーションアーキテクチャを実現してくれます。（注：2019年9月7日時点、Betaです）</p><blockquote><p>Run stateless containers on a fully managed environment or in your own GKE cluster.</p></blockquote><p><a href="https://cloud.google.com/run/" target="_blank" rel="noopener">https://cloud.google.com/run/</a></p><p>上記は公式ページからの引用ですが、Cloud Runは完全なマネージド環境あるいは自前のGKE上にコンテナアプリケーションをデプロイできます。</p><p>既存のAppEngineやCloud Functionのようにコードベースのサーバレスアーキテクチャではなく、コンテナベースのサーバレスアーキテクチャであるという点が、新しく・面白いと感じられますね！これからはコンテナベースもどんどん増えてくるはずですし、コードベースに取り組んでいた方も新たな移行先としてこのCloud Runを検討候補にあげてみてはいかがでしょうか。</p><p>Cloud Runについては先日のGoogle Cloud Nextでもたくさんの話が出ていました。興味ある方はぜひ<a href="https://future-architect.github.io/articles/20190804/">Google Cloud Nextへの参加レポート記事</a>をご覧ください。</p><h1 id="Try-Cloud-Run-with-Cloud-Run-Button"><a href="#Try-Cloud-Run-with-Cloud-Run-Button" class="headerlink" title="Try Cloud Run with Cloud Run Button"></a>Try Cloud Run with Cloud Run Button</h1><p>では本題である「Cloud Run Buttonを使ったコンテナデプロイ」にチャレンジしていきましょう！</p><h2 id="Cloud-Run-Buttonとは？"><a href="#Cloud-Run-Buttonとは？" class="headerlink" title="Cloud Run Buttonとは？"></a>Cloud Run Buttonとは？</h2><blockquote><p>Today, we are introducing the Cloud Run Button, an image and link you can add to the README of your source code repositories to allow others to deploy your application to Google Cloud Platform using Cloud Run.</p></blockquote><p>これは先日8月22日に公開された<a href="https://cloud.google.com/blog/products/serverless/introducing-cloud-run-button-click-to-deploy-your-git-repos-to-google-cloud" target="_blank" rel="noopener">GCPのProduct News</a>からの引用ですが、Cloud Run Buttonというサービスが発表されました。</p><p>私は普段Cloud Runを使っていますが、Google Container Registryにimageをpushして、それをDeployして…って何回もやってるとやはり面倒になってきます。「CI/CDを組む」というのが正攻法だとは思いますが、そこまで手間をかけたくないケースもあると思います。</p><p>Cloud Run Buttonを利用すると、ソースコードリポジトリのREADMEに記載しておくことでボタンひとつでCloud Runへアプリケーションをデプロイすることができます。新しいクラウドサービスをさくっと試したいときの障害のひとつはデプロイ手順を整備することだと思いますが、Cloud Run Buttonは手順をボタン一つに集約できるため、非常に活躍してくれそうです。</p><h2 id="実際にやってみた"><a href="#実際にやってみた" class="headerlink" title="実際にやってみた"></a>実際にやってみた</h2><p><a href="https://github.com/GoogleCloudPlatform/cloud-run-button" target="_blank" rel="noopener">Cloud Run ButtonのGitHubページ</a>にサンプルアプリケーションをデプロイできるCloud Run Buttonが配置されているので早速デプロイを行ってみましょう。</p><img src="/images/20190909/photo_20190909_01.png" style="border:solid 1px #000000"><p>この青いボタンが例のボタンです。</p><p>下記の記述をREADMEに追記してあげるだけでボタンが表示されます。<code>&lt;YOUR_HTTP_GIT_URL&gt;</code>の部分を自分のGitRepository URLに変更するだけです。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Run on Google Cloud](https://storage.googleapis.com/cloudrun/button.svg)](https://console.cloud.google.com/cloudshell/editor?shellonly=true&amp;cloudshell_image=gcr.io/cloudrun/button&amp;cloudshell_git_repo=&lt;YOUR_HTTP_GIT_URL&gt;)</span><br></pre></td></tr></table></figure><p>ちなみに<code>Run on Google Cloud</code>という文字はすでに画像ファイルとして用意されているので、文言等変えたい場合には自分で別途作成して上げる必要があります。</p><p>基本的にはrepositoryのrootディレクトリに存在する<code>Dockerfile</code>を検知して<code>docker build</code>が実行されますが、無い場合には<a href="https://buildpacks.io/" target="_blank" rel="noopener">CNCF Buildpacks</a>が利用されます。</p><p>もしサブディレクトリ内でビルドを実施して欲しい場合には、<code>cloudshell_working_dir=&lt;SUBDIR&gt;</code>のクエリパラメータを追加してあげましょう。</p><p>また、<code>master</code>以外の特定ブランチのアプリケーションをデプロイしたい場合には<code>cloudshell_git_branch=&lt;BRANCH_NAME&gt;</code>を追加してあげると任意のブランチからデプロイすることが可能です。</p><p>他にも<code>app.json</code>を記載することでより詳細なカスタマイズも可能になっているので気になった方は<a href="https://github.com/GoogleCloudPlatform/cloud-run-button#customizing-deployment-parameters" target="_blank" rel="noopener">READMEの”Customizing deployment parameters”パート</a>を参照してみてください！</p><p>さて、ではついにボタンを押してみましょう。</p><img src="/images/20190909/photo_20190909_03.png" style="border:solid 1px #000000"><p>Cloud Shellの起動を確認するダイアログが出てくるので<code>続行</code>を押して次へ…</p><img src="/images/20190909/photo_20190909_04.png" style="border:solid 1px #000000"><p><code>cloudshell_git_repo</code>にて指定されてたrepositoryをcloneして、デプロイ対象のプロジェクトがリストで表示されます。すでにGoogleアカウントにログインしていれば、そのアカウントに紐づくプロジェクトが表示されます。</p><img src="/images/20190909/photo_20190909_05.png" style="border:solid 1px #000000"><p>さてプロジェクト選びが完了すると、次はリージョンの選択です。デフォルトだとカーソルは<code>us-central1</code>に合わさっていますが、ついに東京リージョンでも利用可能になったので、せっかくですし<code>asia-northeast1</code>を選択してみることにしましょう。</p><img src="/images/20190909/photo_20190909_06.png" style="border:solid 1px #000000"><p>コンテナのビルドが始まりました！…ワクワク</p><img src="/images/20190909/photo_20190909_07.png" style="border:solid 1px #000000"><p>ビルドが完了すると自動的にGCRへのイメージのpushも行ってくれます。そしてGCRのイメージをもとにCloud Runのデプロイがスタートします。こういったところを自動でやってくれるのがありがたいですね。</p><img src="/images/20190909/photo_20190909_08.png" style="border:solid 1px #000000"><p>そして待つこと少々…ついにアプリケーションがデプロイされました。早速コンソールからデプロイされたアプリを確認してみましょう。</p><img src="/images/20190909/photo_20190909_09.png" style="border:solid 1px #000000"><p>いました。<code>cloud-run-hello</code>というアプリケーションが無事にデプロイされています！</p><img src="/images/20190909/photo_20190909_10.png" style="border:solid 1px #000000"><p>詳細画面も覗いてみましょう。デプロイされたアプリケーションにアクセスしてみると…</p><img src="/images/20190909/photo_20190909_11.png" style="border:solid 1px #000000"><p>上記のような画面が表示されます。「動いてますよ！」とのことです。ホッとしました。</p><p>というわけでCloud Run Buttonを利用したコンテナデプロイはこれにて完了です。</p><h2 id="やってみての所感"><a href="#やってみての所感" class="headerlink" title="やってみての所感"></a>やってみての所感</h2><p>まず、とても簡単でした！</p><p>ボタンを押すとCloud Shellが立ち上がり、デプロイ先のプロジェクトとリージョンを選択するだけで簡単にデプロイできてしまうのは非常にスムーズでストレスが無いなと感じました。</p><p>ちなみに筆者は、最初試した時clone待ちの時間でEnter連打しすぎてこのプロジェクト選択の場面で一番上のプロジェクトを秒で選択することになってしまいました。正しいデプロイ先を選ぶには落ち着きが大切です（笑）</p><p>軽く前述しましたが、このCloud Run Buttonの良いところは<code>docker build</code> <code>docker push</code> <code>gcloud run deploy</code>などのコマンドをすべて隠蔽化して一気に実行してくれる点にあると思います。「さっと何度もデプロイしたい、でもCI/CD作り込むのはちょっと…」といったシチュエーションにこれ程までに適したソリューションは無いんじゃないかと思うくらいの使い勝手でした。</p><p>そしてもう一点の良さは「READMEに埋め込めること」ではないでしょうか。</p><p>GitHubなどに公開しているアプリケーションを世間のユーザに利用してもらう際には、READMEにデプロイコマンドを記載してユーザ側にその実行を委ねていたかと思います。しかし、Cloud Run Buttonを埋め込んでおくだけで、ユーザ側に求めるのはデプロイ先のプロジェクトとリージョンの選択だけになります。もちろんユーザがGCPプロジェクトを保有していることが前提になりますが、ユーザ側にとっても利用までの敷居がより一層低くなるはずです。</p><p>とても簡単なのでぜひ一度試してみてください。皆さんのコンテナライフがより一層豊かなものになりますように。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>Let’s Try GCPの第一弾、いかがだったでしょうか。定期的な更新を世の中にコミットするためにあえて「#1」という連番をタイトルに含めております。</p><p>読んで頂きありがとうございました！良かったなと思ってくださった方はぜひTwitterやFacebookでのシェアもよろしくお願いします！</p><p>続編もご期待ください！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">DXユニットとはデジタルトランスフォーメーションに関わる仕事を主に推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG(Technology Innovation Group)/DXユニット&lt;sup id=&quot;fnref:1&quot;
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>Terraformのベストなプラクティスってなんだろうか</title>
    <link href="https://future-architect.github.io/articles/20190903/"/>
    <id>https://future-architect.github.io/articles/20190903/</id>
    <published>2019-09-03T06:20:52.000Z</published>
    <updated>2019-09-04T23:49:36.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の木村です。</p><p>入社以降ずっと触ってきたTerraformですが、巷ではWorkspace派だったり、module派だったり、ディレクトリ完全分離派だったり、様々な流派(プラクティス)が乱立しているのを目にします。私自身ベストな構成を模索していく中で辿り着いた結論は、ケースバイケースで全てのデザインパターンに対応できる万能なものは存在しないのかな (当たり障りないですね..)ということです。</p><p>そんなわけで、様々なTerraformの流派を紹介し、各流派がどのようなパターンに向いているのか(はたまた不向きなのか)の個人的見解をまとめてみました。</p><p>※本記事中のサンプルコードはすべて Terraform <code>0.12</code>、 provider <code>google cloud</code> で解説してます</p><h1 id="Terraformとは？"><a href="#Terraformとは？" class="headerlink" title="Terraformとは？"></a>Terraformとは？</h1><p>当社過去記事に解説があります。Terraformの概要や、0.12におけるシンタックス変更点や便利機能が詳細に記載されていますので、ぜひ併せてご覧ください。</p><ul><li><a href="https://future-architect.github.io/articles/20190816/">はじめてのTerraform 0.12 ～環境構築～</a></li><li><a href="https://future-architect.github.io/articles/20190819/">はじめてのTerraform 0.12 ～実践編～</a></li></ul><h1 id="環境をどのように分けるか"><a href="#環境をどのように分けるか" class="headerlink" title="環境をどのように分けるか"></a>環境をどのように分けるか</h1><p>開発環境、検証環境、本番環境といった環境間の構成やパラメータ差異をどのように扱うのがベストなのでしょうか。</p><p>以下の順番で各流派について説明していきます。</p><ol><li>Workspace</li><li>Module</li><li>ディレクトリ分離</li></ol><h2 id="1-Workspace派"><a href="#1-Workspace派" class="headerlink" title="1. Workspace派"></a>1. Workspace派</h2><p>Terraform ver 0.10 から導入された機能で、同一Terraformソースに対して、Workspaceを切り替えることで環境が切替可能となります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace select &#123;workspace名&#125;</span><br></pre></td></tr></table></figure><h3 id="メリット"><a href="#メリット" class="headerlink" title="メリット"></a>メリット</h3><ul><li>workspace名を変数のkey名に設定することで、環境依存の変数のみ切り出せるので可読性が高くなります。</li><li>また、環境間でソースを共用するという性質上、特定環境のみへの設定抜け・漏れが発生しにくいです。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 変数定義側</span></span><br><span class="line">locals &#123;</span><br><span class="line">  instance_web = &#123;</span><br><span class="line">    production = &#123;</span><br><span class="line">      machine_type   = <span class="string">"n1-standard-4"</span></span><br><span class="line">      bootdisk_size  = 500</span><br><span class="line">    &#125;</span><br><span class="line">    staging = &#123;</span><br><span class="line">      machine_type   = <span class="string">"n1-standard-2"</span></span><br><span class="line">      bootdisk_size  = 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 変数呼び出し側</span></span><br><span class="line">resource <span class="string">"google_compute_instance"</span> <span class="string">"web"</span> &#123;</span><br><span class="line">  name         = <span class="string">"web-server"</span></span><br><span class="line">  machine_type = local.instance_web[terraform.workspace][machine_type]</span><br><span class="line">  boot_disk &#123;</span><br><span class="line">    <span class="built_in">source</span>     = google_compute_disk.web.self_link</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_disk"</span> <span class="string">"web"</span> &#123;</span><br><span class="line">  name  = <span class="string">"web-server"</span></span><br><span class="line">  size  = local.instance_web[terraform.workspace][bootdisk_size]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="デメリット"><a href="#デメリット" class="headerlink" title="デメリット"></a>デメリット</h3><ul><li>環境間で構成差異が大きい場合は、差分を吸収するためのロジックを組み込む必要があり、かえって可読性が悪くなりメンテが大変になることがあります</li></ul><p>以下の例は、本番環境のみに存在するリソースと検証環境のみに存在するリソースをcountを使って制御しています。見通しが悪いですね。</p><figure class="highlight bash"><figcaption><span>環境間で構成の差異が大きい場合の例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  instance_web = &#123;</span><br><span class="line">    production = &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    staging = &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance_ap = &#123;</span><br><span class="line">    production = &#123;</span><br><span class="line">      count          = 1</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    staging = &#123;</span><br><span class="line">      count          = 0</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance_proxy = &#123;</span><br><span class="line">    production = &#123;</span><br><span class="line">      count          = 0</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    staging = &#123;</span><br><span class="line">      count          = 1</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_instance"</span> <span class="string">"web"</span> &#123;</span><br><span class="line">  name         = <span class="string">"web-server"</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_instance"</span> <span class="string">"ap"</span> &#123;</span><br><span class="line">  count        = local.instance_ap[terraform.workspace][count]</span><br><span class="line">//count        = <span class="string">"<span class="variable">$&#123;terraform.workspace == "production" ? 1 : 0&#125;</span>"</span> <span class="comment"># こういう書き方もあるけどいずれにしろ可読性悪い</span></span><br><span class="line">  name         = <span class="string">"ap-server"</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_instance"</span> <span class="string">"proxy"</span> &#123;</span><br><span class="line">  count        = local.instance_proxy[terraform.workspace][count]</span><br><span class="line">  name         = <span class="string">"proxy-server"</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="こんなケースにおすすめ"><a href="#こんなケースにおすすめ" class="headerlink" title="こんなケースにおすすめ"></a>こんなケースにおすすめ</h3><ul><li>環境間で構成差異が少ない場合は、Workspaceの利用がおすすめです。</li><li>また、リリースフローとして 本番と同等の環境での事前検証-&gt; リリース判定 -&gt; 本番環境構築 といった流れが義務付けられている場合は、 Workspaceを切り替えるだけなので、本番環境適用時のデグレ発生のリスクは減らせそうで精神衛生上良さそうです。</li></ul><h2 id="2-Module派"><a href="#2-Module派" class="headerlink" title="2. Module派"></a>2. Module派</h2><p>module自体は、複数リソースから構成されるサービス(たとえばLB)や特定リソースをテンプレ化する機能です。 <code>module</code>ディレクトリ内でテンプレ化するリソースを定義し、Moduleを呼び出す側( <code>production</code>, <code>staging</code> 等)で環境差異を制御できます。</p><figure class="highlight plain"><figcaption><span>モジュール利用時のディレクトリ構成例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── module</span><br><span class="line">│   ├── gce</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── output.tf</span><br><span class="line">│   │   └── variables.tf</span><br><span class="line">│   └── iam</span><br><span class="line">│   └── ...</span><br><span class="line">├── production</span><br><span class="line">│   ├── main.tf</span><br><span class="line">│   └── variable.tf</span><br><span class="line">└── staging</span><br><span class="line">    ├── main.tf</span><br><span class="line">    └── variable.tf</span><br></pre></td></tr></table></figure><h3 id="メリット-1"><a href="#メリット-1" class="headerlink" title="メリット"></a>メリット</h3><ul><li>複数resourceから構成されるサービス(LB等)をテンプレ化することでmodule利用側のソースは簡潔になります</li></ul><p>以下の例はGCEをmodule化した例です。instance、internal ip、diskといった個別リソースをひとつのmoduleとして定義することで、モジュール呼び出し側は、リソース間の依存関係やパラメータ以外の固定値を意識しなくてよいのは嬉しいですね。</p><figure class="highlight bash"><figcaption><span>module/gce/main.tf(モジュール定義側)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"google_compute_address"</span> <span class="string">"template"</span> &#123;</span><br><span class="line">  name = <span class="string">"<span class="variable">$&#123;var.name&#125;</span>-internal"</span></span><br><span class="line"></span><br><span class="line">  address_type = <span class="string">"INTERNAL"</span></span><br><span class="line">  address      = <span class="string">"var.internal_ip"</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_instance"</span> <span class="string">"template"</span> &#123;</span><br><span class="line">  name         = <span class="string">"<span class="variable">$&#123;var.name&#125;</span>"</span></span><br><span class="line">  machine_type = var.machine_type</span><br><span class="line"></span><br><span class="line">  boot_disk &#123;</span><br><span class="line">    <span class="built_in">source</span>     = google_compute_disk.template.self_link</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    network_ip    = google_compute_address.template.address</span><br><span class="line">    access_config = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"google_compute_disk"</span> <span class="string">"template"</span> &#123;</span><br><span class="line">  name  = <span class="string">"<span class="variable">$&#123;var.name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">type</span>  = <span class="string">"pd-ssd"</span></span><br><span class="line">  size  = var.bootdisk_size</span><br><span class="line">  image = centos-cloud/centos-7<span class="string">"</span></span><br><span class="line"><span class="string">  ...  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>production/main.tf(モジュール呼び出し側)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">"gce_web"</span> &#123;</span><br><span class="line">  <span class="built_in">source</span> = <span class="string">"../module/gce"</span></span><br><span class="line">  </span><br><span class="line">  name         = <span class="string">"web"</span></span><br><span class="line">  internal_ip  = <span class="string">"10.xx.xx.xx"</span></span><br><span class="line">  machine_type = <span class="string">"n1-standard-4"</span></span><br><span class="line">  boot_disk    = <span class="string">"500"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>また、 <a href="https://registry.terraform.io/" target="_blank" rel="noopener">Terraform Module Registry</a>でHashiCorp社公認のmoduleが公開されており、これらを使うことができます。</p><h3 id="デメリット-1"><a href="#デメリット-1" class="headerlink" title="デメリット"></a>デメリット</h3><ul><li>moduleを定義する際に、どこまでmoduleを汎化(変数化)させるかを決めるのが難しいです。moduleへの変更は、 そのmoduleを利用するすべての呼び出し元へ影響を与えます。安易にmoudle内に固定値を設定しておくと、後ほどその値がパラメータ(変数)となった際の手当てが大変です。とはいえ、何でもかんでも汎化すると、moduleを利用する旨味がなくなってしまいます。</li><li>設定方法が複雑で、Terraform初心者には運用が難しいです。初心者含む不特定多数のメンバーがterraformを触る機会がある場合や、運用担当者のスキルレベルを考慮した際に導入が難しい場合があるかもしれません。</li></ul><h3 id="こんなケースにおすすめ-1"><a href="#こんなケースにおすすめ-1" class="headerlink" title="こんなケースにおすすめ"></a>こんなケースにおすすめ</h3><ul><li>moduleは、Terraformにある程度精通したメンバーが運用する前提で利用されることになるかと思います。</li><li>また、リソースの利用にあたり、共通化された規約や思想が前提としてある場合は、moduleを利用することで、固定化された部分を運用側に意識させず、ガバナンスを効かせることができます。</li></ul><h2 id="3-環境毎にディレクトリで分離派"><a href="#3-環境毎にディレクトリで分離派" class="headerlink" title="3. 環境毎にディレクトリで分離派"></a>3. 環境毎にディレクトリで分離派</h2><p>環境毎に完全にディレクトリを分離し、個別にTerraformソースを用意する(Workspaceもmoduleも一切利用しない)流派です。</p><figure class="highlight plain"><figcaption><span>完全分離派のディレクトリ構成例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── production</span><br><span class="line">│   ├── backend.tf</span><br><span class="line">│   ├── compute_address.tf</span><br><span class="line">│   ├── compute_firewall.tf</span><br><span class="line">│   ├── compute_instance.tf</span><br><span class="line">│   ├── project.tf</span><br><span class="line">│   ├── variable.tf</span><br><span class="line">│   └── ...</span><br><span class="line">└── staging</span><br><span class="line">    ├── backend.tf</span><br><span class="line">    ├── compute_address.tf</span><br><span class="line">    ├── compute_firewall.tf</span><br><span class="line">    ├── compute_instance.tf</span><br><span class="line">    ├── project.tf</span><br><span class="line">    ├── variable.tf</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure><h3 id="メリット-2"><a href="#メリット-2" class="headerlink" title="メリット"></a>メリット</h3><ul><li>各環境の構成が各ディレクトリ内で完結しているため、最も直感的で理解しやすくTerraformに精通していないメンバーに易しい構成です。</li><li>Terraformソースが環境毎に独立しているため(Workspace派のデメリットで紹介したような)環境間の差異を意識する必要がありません。</li></ul><h3 id="デメリット-2"><a href="#デメリット-2" class="headerlink" title="デメリット"></a>デメリット</h3><ul><li>全ての環境へ同じ変更を加えたい場合、各ディレクトリ配下のtfソースに変更を加える必要があり、2度手間3度手間になるうえに、特定環境への変更に抜け漏れが生じる可能性があります。</li><li>環境間の差異を把握するのが難しく見通しが悪いです。</li></ul><h3 id="こんなケースにおすすめ-2"><a href="#こんなケースにおすすめ-2" class="headerlink" title="こんなケースにおすすめ"></a>こんなケースにおすすめ</h3><ul><li>環境間で構成の差異が大きいケースは、環境間の差異を吸収するロジックを組み込む必要がない本構成が使えます。</li><li>デメリットで上げたような特定環境への変更漏れ等のリスクはありますが、Terraform初心者や運用担当者のスキルレベルによっては最もシンプルな本構成が、運用負荷が低く、運用しやすいかもしれません。</li></ul><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>今回は、各機能を独立して利用した場合のシンプルでベーシックな流派を紹介しましたが、moduleとWorkspaceを組み合わせる(環境依存の変数をWorkspaceで切り替える)流派なども存在します。最後のディレクトリ完全分離パターンは、個人的には利用したくないパターンですが、Terraform初心者でも運用可能な点でいうと、一概に否定はできないのかなと思っています。</p><p>本記事が、Terraformを利用する上での参考になれば幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">TIGとはTechnology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnot
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="Terraform" scheme="https://future-architect.github.io/tags/Terraform/"/>
    
  </entry>
  
  <entry>
    <title>AWS IAMロールの信頼関係の気になる動作</title>
    <link href="https://future-architect.github.io/articles/20190902/"/>
    <id>https://future-architect.github.io/articles/20190902/</id>
    <published>2019-09-01T23:17:51.000Z</published>
    <updated>2019-09-01T23:50:38.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして。TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の村瀬です。2019年6月に中途入社しました。</p><p>最近当社Tech Blogが活発ですがより弾みをつける為、参加いたしました。</p><p>AWSのIAMロール便利ですよね。利用していますか？今回は <strong>IAMロールの信頼関係</strong> で気になる動作を確認したので検証してみました。</p><h1 id="IAMロールとは"><a href="#IAMロールとは" class="headerlink" title="IAMロールとは"></a>IAMロールとは</h1><p>公式ドキュメントより抜粋します。</p><blockquote><p>IAM ロールは、特定のアクセス権限を持ち、アカウントで作成できる IAM アイデンティティです。IAM ロールは、 AWSで許可/禁止する操作を決めるアクセス権限ポリシーが関連付けられている AWS アイデンティティであるという点で、IAM ユーザーと似ています。ただし、ユーザーは 1 人の特定の人に一意に関連付けられますが、ロールはそれを必要とする任意の人が引き受けるようになっています。また、ロールには標準の長期認証情報 (パスワードやアクセスキーなど) も関連付けられません。代わりに、ロールを引き受けると、ロールセッション用の一時的なセキュリティ認証情報が提供されます。</p></blockquote><blockquote><p>ロールを使用して、通常は AWS リソースへのアクセス権のないユーザー、アプリケーション、サービスにそのアクセス権を委任できます。たとえば、AWS アカウントのユーザーに、通常はないリソースに対するアクセス許可を付与したり、ある AWS アカウントのユーザーに、別のアカウントのリソースに対するアクセス許可を付与したりできます。または、モバイルアプリに AWS リソースの使用を許可しても、(キーの更新が困難であり、キーの抽出が可能である) アプリへの AWS キーの埋め込みは禁止する場合があります。AWS の外部 (社内ディレクトリなど) に ID をすでに持っているユーザーに AWS へのアクセスを許可することが必要になる場合があります。または、リソースを監査できるように、アカウントへのアクセス権を第三者に付与することが必要になる場合もあります。</p></blockquote><p><a href="https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_roles.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_roles.html</a></p><h1 id="別のAWSアカウントのIAMユーザからスイッチ可能なIAMロール作成手順"><a href="#別のAWSアカウントのIAMユーザからスイッチ可能なIAMロール作成手順" class="headerlink" title="別のAWSアカウントのIAMユーザからスイッチ可能なIAMロール作成手順"></a>別のAWSアカウントのIAMユーザからスイッチ可能なIAMロール作成手順</h1><p>1.マネジメントコンソールで信頼されたエンティティの種類の選択で別のAWSアカウントを選択しアカウントIDを入力し、次のステップへ<br>2.必要なポリシーをアタッチして<br>3.ロール名を入力してロールの作成<br>4.作成したロールの信頼関係の編集でポリシードキュメントを修正し信頼ポリシーの更新</p><figure class="highlight json"><figcaption><span>信頼関係jsonイメージ</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Principal"</span>: &#123;</span><br><span class="line">        <span class="attr">"AWS"</span>: <span class="string">"arn:aws:iam::123456789012:user/murase"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"sts:AssumeRole"</span>,</span><br><span class="line">      <span class="attr">"Condition"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これに対して信頼関係の編集で存在しないエンティティを下図のように指定するとエラーとなり、保存できませんでした。裏でエンティティの存在確認が行われているんですね。</p><img src="/images/20190902/err.png" style="border:solid 1px #000000" alt="存在しないIAMユーザを指定してエラーになった図"><h1 id="検証"><a href="#検証" class="headerlink" title="検証"></a>検証</h1><h3 id="検証1"><a href="#検証1" class="headerlink" title="検証1"></a>検証1</h3><p>では、存在するエンティティ(IAMユーザ)を指定してIAMロールを作成し、その後IAMユーザを削除したらどうなるでしょうか？</p><p>手順は省略しますが、結果は以下の通りです。</p><figure class="highlight json"><figcaption><span>IAMユーザ削除後の信頼関係jsonイメージ</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Principal"</span>: &#123;</span><br><span class="line">        <span class="attr">"AWS"</span>: <span class="string">"AIDA3ZFZ4X6FO5HB76XYS"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"sts:AssumeRole"</span>,</span><br><span class="line">      <span class="attr">"Condition"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信頼されたエンティティが意図しない文字列「AIDA3ZFZ4X6FO5HB76XYS」に変わりました。</p><h3 id="検証2"><a href="#検証2" class="headerlink" title="検証2"></a>検証2</h3><p>では、先ほど削除したIAMユーザと同名のIAMユーザを再作成するとロールの信頼されたエンティティがどうなるか見てみましょう。</p><p>またまた手順は省略しますが、結果は以下の通りです。</p><figure class="highlight json"><figcaption><span>同名IAMユーザ作成後の信頼関係jsonイメージ</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Principal"</span>: &#123;</span><br><span class="line">        <span class="attr">"AWS"</span>: <span class="string">"AIDA3ZFZ4X6FO5HB76XYS"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"sts:AssumeRole"</span>,</span><br><span class="line">      <span class="attr">"Condition"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信頼されたエンティティは相変わらず意図しない文字列のままでした。再作成したIAMユーザと合致しない為、スイッチロールできませんね。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>削除したIAMユーザとたまたま同名のIAMユーザを作成して意図しないロールが利用できてしまうのは問題ですし、セキュリティを考慮するとこのような動作をするのは納得できます。</p><p>実際のケースとしてプロジェクトからの離脱などの理由によりIAMユーザを削除することがあるかと思います。削除後に復帰することがなければ良いのですが、復帰することがあり以前のロールが利用できることを望むのであればIAMユーザを削除するのではなくコンソールへのアクセスの無効化やアクセスキーの削除にてIAMユーザをログインできないようにする運用が得策です。</p><p>また、信頼されたエンティティを更新する際にエンティティの存在チェックがなされるので意図しない文字列がある場合にはそれを削除しないと更新ができません。CloudFormationやTerraformでIAMロールが管理されていればそれほど手間なく更新可能かと思いますが、手運用の場合には気を付けましょう。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;はじめまして。TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnot
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>GKEのPodから異なるプロジェクトのIPアドレスへ接続できずハマった話</title>
    <link href="https://future-architect.github.io/articles/20190827/"/>
    <id>https://future-architect.github.io/articles/20190827/</id>
    <published>2019-08-27T14:39:01.000Z</published>
    <updated>2019-09-01T23:57:34.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、TIG所属DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の市川燿と申します。</p><p>現在は、プロジェクト内で利用しているGoogle Cloud Platform(以下GCP)の環境構築と、Go言語でバックエンドアプリの開発などをしています。</p><p>今回は、GCPのKubernetesサービスである<a href="https://cloud.google.com/kubernetes-engine/" target="_blank" rel="noopener">Google Kubernetes Engine</a>(以下GKE)を利用している際にハマった事象について共有します。</p><h2 id="本記事について"><a href="#本記事について" class="headerlink" title="本記事について"></a>本記事について</h2><p>(2019/09/02) GKEのクラスタがルートベースである旨を追記<br>(2019/09/02) Export設定について追記</p><h2 id="GKEとは"><a href="#GKEとは" class="headerlink" title="GKEとは"></a>GKEとは</h2><blockquote><p>コンテナ化されたアプリケーションをデプロイするための、本番稼働に対応したマネージド型環境です。<br><a href="https://cloud.google.com/kubernetes-engine/?hl=ja" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/?hl=ja</a></p></blockquote><h2 id="ハマった事象"><a href="#ハマった事象" class="headerlink" title="ハマった事象"></a>ハマった事象</h2><p><strong>GKE内のPodから他のGCPプロジェクトのプライベートIPアドレスに対し接続できない</strong>ことです。<br>もちろんFirewall Ruleの設定上は接続できる状態です。</p><img src="/images/20190828/photo_20190828_01.png"><p>具体的には、CurlによるHTTPやTelnetはもちろん、pingによるICMPも接続ができません。不思議なことにGKEを構成するGCEノードにssh接続し、そこから外部のプライベートIPアドレスを持つリソースに対しては”接続が可能”でした。</p><p>実はパブリックIPが付与されていた、といったオチもありません。全てプライベートIPのみを持っているインスタンスです。</p><h2 id="システム構成前提"><a href="#システム構成前提" class="headerlink" title="システム構成前提"></a>システム構成前提</h2><p>今回の環境は以下の設定を使用しています。</p><ul><li><p>VPC</p><ul><li>専有VPCを利用</li></ul></li><li><p>GKE</p><ul><li>バージョン: v1.12.7-gke.10</li><li><a href="https://cloud.google.com/vpc/docs/legacy" target="_blank" rel="noopener">レガシーネットワーク</a>を利用<ul><li>クラスタのネットワークは<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/routes-based-cluster" target="_blank" rel="noopener">ルートベース</a></li></ul></li></ul></li><li><p>他GCPプロジェクトとの接続</p><ul><li><a href="https://cloud.google.com/vpc/docs/vpc-peering" target="_blank" rel="noopener">VPCネットワークピアリング</a>を設定済み</li></ul></li></ul><p>各サービスは以下のCIDRが設定してある前提で説明します。</p><table><thead><tr><th>サービス</th><th>CIDR</th><th>レンジ</th></tr></thead><tbody><tr><td>接続元プロジェクト</td><td>10.1.0.0/16</td><td>10.1.0.0～10.1.255.254</td></tr><tr><td>接続先プロジェクト</td><td>10.2.0.0/16</td><td>10.2.0.0～10.2.255.254</td></tr><tr><td>接続元のGKE</td><td>172.16.0.0/16</td><td>172.16.0.0～172.16.255.254</td></tr></tbody></table><h2 id="設定・接続状況"><a href="#設定・接続状況" class="headerlink" title="設定・接続状況"></a>設定・接続状況</h2><p>設定や接続確認し情報を整理したところ以下のことが分かっています。</p><img src="/images/20190828/photo_20190828_02.png"><ul><li>GKE内Podから他プロジェクト内GCEへの接続は不可能 <strong>(<em>a</em>)</strong></li><li>GKE内Pod(my-pod)から自プロジェクト内GCE(test-gce-01)への接続は可能 <strong>(<em>b</em>)</strong></li><li>自プロジェクトと接続先のプロジェクトとのVPC Peeringは設定済み</li><li>自プロジェクトのGCE上(test-gce-01)から他プロジェクトGCE(target-gce-01)へ接続は可能 <strong>(<em>c</em>)</strong></li><li>GKE内Podが稼働している物理Node(gke-node-02)から他プロジェクトGCEへの接続も可能</li></ul><p>GKE内Podとプロジェクト内GCE、テスト用GCEと他プロジェクトGCEはそれぞれきちんと繋がるのに、GKE内Podと他プロジェクトGCEは繋がらないので、そんなことありうるのかと当時とても焦りました。</p><h2 id="Pod-gt-他Project-IPへの接続がうまくいかない原因"><a href="#Pod-gt-他Project-IPへの接続がうまくいかない原因" class="headerlink" title="Pod=&gt;他Project IPへの接続がうまくいかない原因"></a>Pod=&gt;他Project IPへの接続がうまくいかない原因</h2><p>GKE用のCIDRが接続先PJのCloud Routerに上手く連携されていないため、戻りのルーティング失敗していると思われます(未確認)。</p><p>「Pod=&gt;同一Project IP」への接続については、GKEクラスタを作成した際に以下のようなルートがGKE物理ノードごとに自動作成されます。<br>そのため、同一PJの同一VPC内のPod通信は問題有りませんでした。</p><table><thead><tr><th>名前</th><th>説明</th><th>送信先 IP 範囲</th><th>優先度</th><th>インスタンス タグ</th><th>ネクストホップ</th><th>ネットワーク</th></tr></thead><tbody><tr><td>my-gke-default-pool-xxx</td><td>k8s-node-route</td><td>172.25.0.0/24</td><td>1000</td><td>なし</td><td>インスタンス my-gke-default-pool-xxx（ゾーン asia-northeast1-a）</td><td>my-network</td></tr></tbody></table><h2 id="試した方法その1-プロキシサーバ経由でアクセス"><a href="#試した方法その1-プロキシサーバ経由でアクセス" class="headerlink" title="試した方法その1: プロキシサーバ経由でアクセス"></a>試した方法その1: プロキシサーバ経由でアクセス</h2><p>解決手段としてまず思いついたのは手軽にnginxなどをプロキシサーバ代わりにして方法です。</p><ul><li>通信経路<br>GKE内Pod =&gt; nginxなどのプロキシサーバ =&gt; 他プロジェクトGCE</li></ul><p>しかし、GKE内Podとしてnginxを作ってしまうとnginxと他プロジェクトGCE間での通信ができず目的が達成できません。</p><p>nginxをGCE上にインストールしてインストールする必要があります。</p><img src="/images/20190828/photo_20190828_03.png"><figure class="highlight nginx"><figcaption><span>nginx.conf(設定サンプル)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">  <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> <span class="number">10.2.0.1:80</span>; <span class="comment"># target-gce-01</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この方法で不格好ですが、無事にGKE内Podから他プロジェクトGCEにアクセスすることができました。<br>GCE上にプロキシサーバをインストールしているため、冗長性やオートヒーリングとしてKubernetesの機能が利用できず<br>別の方法で担保する必要があります。</p><h2 id="試した方法その2-IPマスカレードエージェントを利用してアクセス-本題"><a href="#試した方法その2-IPマスカレードエージェントを利用してアクセス-本題" class="headerlink" title="試した方法その2: IPマスカレードエージェントを利用してアクセス (本題)"></a>試した方法その2: IPマスカレードエージェントを利用してアクセス (本題)</h2><p>やっと本題です。</p><p>もう少し調べてみるとkubernetes-incubator配下にIPマスカレードエージェント(ip-masq-agent)というプロダクトがあり今回のケースに使えそうなことが分かりました。</p><p>IPマスカレードエージェントを利用することで、PodのアドレスからPodが稼働している物理Nodeのアドレスへとアドレスの変換を行い、物理Nodeのアドレスとして接続GKE外部のアドレスに接続しに行きます。</p><img src="/images/20190828/photo_20190828_04.png"><p>GKEでもバージョン1.7以上で<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#how_ipmasq_works" target="_blank" rel="noopener">一定条件を満たすと</a>デフォルトで有効になっており、追加インストール作業が不要で利用できます。</p><p>IPマスカレードエージェントの使い方はとても簡単で、kubernetesのconfig mapを登録だけで適用されます。</p><p>GKE内部のネットワーク(172.16.0.0/16)と自プロジェクトネットワーク(10.1.0.0/16)のみIPマスカレードエージェントの<strong>対象外</strong>としたい場合には、以下のようにファイルを編集し<strong>config</strong>のファイル名で保存した後、</p><figure class="highlight yaml"><figcaption><span>config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nonMasqueradeCIDRs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span> <span class="comment"># my-gke-cluster CIDR</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span>   <span class="comment"># my-project CIDR</span></span><br><span class="line"><span class="attr">resyncInterval:</span> <span class="number">60</span><span class="string">s</span></span><br></pre></td></tr></table></figure><p>以下のコマンドを実行することで適用されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap ip-masq-agent --from-file config --namespace kube-system</span><br></pre></td></tr></table></figure><p>※<strong>config</strong>以外の名前でファイルを保存すると上手く適用されないため注意</p><p>私の環境ではkubectlコマンド実行から1分ほどで、設定が適用されアクセスできるようになりました。</p><figure class="highlight bash"><figcaption><span>GKE内Podから他プロジェクトIPへの確認コマンド</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> my-pod -- curl http://10.2.0.1/health</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>この方法であれば、GKE内で完結し、コマンドも1コマンドだけなので、とてもスマートに実現できます。</p><h2 id="2019-09-02-追記-カスタムルートのimport-export"><a href="#2019-09-02-追記-カスタムルートのimport-export" class="headerlink" title="(2019/09/02 追記) カスタムルートのimport/export"></a>(2019/09/02 追記) カスタムルートのimport/export</h2><p><code>--import-custom-routes</code>, <code>--export-custom-route</code>の設定を追加してVPC Peeringの構築をすれば、異なるGCP PJのVPC間でもGKEのルートが上手くExport/Importされるようです。</p><blockquote><p>If you have GKE clusters without VPC native addressing, you might have multiple static routes to direct traffic to VM instances that are hosting your containers. You can export these static routes so that the containers are reachable from peered networks.<br><a href="https://cloud.google.com/vpc/docs/vpc-peering#benefits_of_exchanging_custom_routes" target="_blank" rel="noopener">https://cloud.google.com/vpc/docs/vpc-peering#benefits_of_exchanging_custom_routes</a></p></blockquote><p>今回のように、 172.16.0.0/16のようなGKEのPODに割り当てるCIDRが、接続先のGCP PJで重複していない前提であればこちらの手法のほうが良いかもしれません。</p><h2 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h2><p>今回は試しませんでしたが、紹介した2の方法以外にも以下の方法も検討していました。<br>ケースによっては検討するのも有りだと思います。</p><ul><li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips" target="_blank" rel="noopener">Nativeクラスタ</a>を利用</li><li><a href="https://cloud.google.com/vpc/docs/shared-vpc" target="_blank" rel="noopener">共有VPC</a>を利用</li><li>Publicなネットワーク経由での利用</li></ul><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>GKE内Podから他プロジェクトのIPへの接続する方法について紹介しました。本記事ではGCPの別PJでしたが、AWSへのVPC Peeringであったり、オンプレミスに対するVPN接続でも同じ事象が発生しうると思います。</p><p>IPマスカレードエージェントを利用することで、プロキシサーバなど余分なサーバを作る必要なくアクセスできます。</p><p>本記事を通して、皆さまのGCP・GKEライフが少しでも快適になれば幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、TIG所属DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footno
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>ソフトとハードの垣根を越えろ - IoTハードウェアの開発をソフト屋視点で解説します</title>
    <link href="https://future-architect.github.io/articles/20190826/"/>
    <id>https://future-architect.github.io/articles/20190826/</id>
    <published>2019-08-25T23:30:52.000Z</published>
    <updated>2019-08-25T23:44:00.179Z</updated>
    
    <content type="html"><![CDATA[<p>はじめまして。筒井と申します。</p><p>簡単に自己紹介をさせていただくと、新卒でフューチャーに入社後に<a href="https://www.future.co.jp/company_profile/future_group/" target="_blank" rel="noopener">フューチャーグループ</a>のTrexEdgeへ出向しました。現在は右手に半田ごて、左手にHHKBでハード・ソフトにこだわらず仕事をしています。</p><p>TrexEdgeでは、「スマートビレッジ」という言葉をキーとして、テクノロジーを用いて地方の価値を最大化することを目指しています。</p><p>具体的には、地方における主産業である「農業」に目を向け、農業経営を支援するアプリ「Agrion」の運営をメインの事業としています。</p><p><a href="https://www.agri-on.com/" target="_blank" rel="noopener">https://www.agri-on.com/</a></p><p>今回は農業の話ではなく、また別の地方特有の課題を技術で解決しようとしている話をさせていただきます。</p><h2 id="獣害問題"><a href="#獣害問題" class="headerlink" title="獣害問題"></a>獣害問題</h2><p>獣害問題と言っても都会の方にはあまり馴染みのない話かもしれません。イノシシやシカを見かけるのはジビエ料理店くらいでしょうか。</p><p>しかし農村部では、多くの農家が獣害に頭を悩ませており、その被害額は年間160億円以上との報告も出ています。<br><a href="http://www.maff.go.jp/j/seisan/tyozyu/higai/h_zyokyo2/h29/181026.html" target="_blank" rel="noopener">http://www.maff.go.jp/j/seisan/tyozyu/higai/h_zyokyo2/h29/181026.html</a></p><p>そのため獣害被害は農家にとってはとても大きな問題なのですが、この対処を行う猟友会員（ハンター）もまた、高齢化というまた別の問題に直面しています。</p><p>今回紹介する京都府の与謝野町という街においても、猟友会の平均年齢は毎年1歳ずつ高くなっている状況です。</p><h2 id="害獣檻センサーについて"><a href="#害獣檻センサーについて" class="headerlink" title="害獣檻センサーについて"></a>害獣檻センサーについて</h2><p>害獣の管理捕獲の方法には銃猟、網猟、わな猟とあるのですが、TrexEdgeではわな猟に用いる箱罠に取り付けるセンサー端末を開発しました。</p><p>与謝野町は海と山に囲まれた風光明媚な土地なのですが、イノシシやシカを捕らえる箱罠は、彼らが人里へ降りてこないよう山中に設置されています。</p><p>これがまた、四駆の軽トラじゃないと入っていけないような、すごいところに設置されています。</p><img src="/images/20190826/photo_20190826_01.jpeg"><p>こんなすごいところに設置している訳ですから獣がかかっているかどうかの見回りもまた一苦労で、この負担を軽減するために、箱罠にセンサーを設置することになりました。<br>（ここはまだ舗装されているのでマシな方だったりします。）</p><h2 id="センサー端末の開発方法"><a href="#センサー端末の開発方法" class="headerlink" title="センサー端末の開発方法"></a>センサー端末の開発方法</h2><p>「ここはテックブログだぞ」という天の声が聞こえてきましたので、前置きはここまでにして、ここからは技術の話をします。</p><p>さて、「ハードウェアを作る」という目的を持ったとき、その実現方法は多種多様です。</p><p>ものすごくざっくりですが、IoTセンサー端末の構成要素は主に以下の四つになります。</p><ol><li>センサー<br>箱罠の作動を検知するセンサー類です。今回は開閉センサー（マグネット式）を使いました。</li><li>バッテリー<br>電源が確保出来る場所ならば不要ですが、今回は山林部への設置なのでバッテリーが必要です。</li><li>基板<br>無線のコントローラーや、制御用のマイコンを載せる基板です。</li><li>筐体<br>上記を収めるケースですね。</li></ol><p>これらの要素をそれぞれ揃えていく必要があるのですが、ここで「自分で作る」と「買ってくる」という選択肢が出てきます。<br>フルスクラッチで作るか、何らかのパッケージ等を導入するかといったところです。</p><p>非常に悩ましい二択ですが、仕様を満たせるかどうか、コストはどうかという観点で決めていきます。</p><h3 id="センサー、バッテリー"><a href="#センサー、バッテリー" class="headerlink" title="センサー、バッテリー"></a>センサー、バッテリー</h3><p>センサーを自分で作ることはなかなか難しい話です。バッテリーは言わずもがなでございます。</p><p>レモン数個に銅板と亜鉛板でリチウムイオン電池並の性能が出ればとってもエコなのですが。</p><p>開閉センサーは、<a href="http://akizukidenshi.com/catalog/g/gP-04209/" target="_blank" rel="noopener">リードスイッチ</a>と永久磁石を買ってきて構成することも可能ではありますが、出来合いの開閉センサーが特別高いものでもなく、またこれらを組み立てる手間のほうが高コストとなるので、買ってきて済ませることにしました。</p><h3 id="筐体"><a href="#筐体" class="headerlink" title="筐体"></a>筐体</h3><p>筐体を「自分で作る」ことにした場合、金型を起こす、3Dプリンタでプリントする、切削加工で作る…などまた様々な選択肢が現れます。</p><p>一方「買ってくる」ことにした場合は、筐体メーカーさんのプリメイドなケースを購入し、目的に合わせて追加工を施すことになります。</p><p>3Dプリンタは、意匠性の高い筐体を1点から気楽に作れることがメリットです。<br>一方で、イニシャルコストが低い代わりに多量生産するとそのコストメリットが薄れます。<br>また安価なFDM方式では寸法精度や強度を出すことが難しいという問題もあります。</p><p>金型は、ほぼ3Dプリンタの逆です。<br>イニシャルコストは非常に高くなりますが、量産時のコストはとても安くなります。</p><p>最後に買ってきて追加工をするパターンですが、出来合いのものを買うためケースの大きさ・見た目に自由は効かなくなりますが、ひとつあたりのコストも安く、お手軽です。</p><p>今回の害獣檻センサーでは、防水性が求められるために3Dプリンタでは製作が難しいこと、また現時点で金型への投資を回収するだけの製造数を予定していないことから、<a href="https://www.takachi-el.co.jp/" target="_blank" rel="noopener">タカチ電機工業</a>さんのケースを購入しました。</p><h3 id="基板"><a href="#基板" class="headerlink" title="基板"></a>基板</h3><p>さて、今回の主題となる基板についてすが、これもまた、買ってくるのか、自分で作るのかが選べます。あ、よく間違えている方がいるので書いておきますが、「基盤」では無く「基板」です。基板がCircuit Boardで、基盤はInfrastructureです。</p><p>基板を買ってくる場合は、Arduinoを始めとするマイコンボードに、<a href="https://www.seeedstudio.com/category/Grove-c-1003.html" target="_blank" rel="noopener">Grove</a>のような各種モジュールを組み合わせて使うことが考えられます。このパターンでは、初期投資を小さく抑えて、素早くプロトタイピング、機能の検証が行えるのが魅力です。</p><p>一方で、Arduinoは万人に使いやすいように作られているために、特定の目的で性能・コストを突き詰めようとした場合には小回りが利かなくなってきます。その最たるところのひとつが消費電力です。Arduinoは常時点灯する電源LEDやUSBシリアル変換ICなどが搭載されているため、消費電力は大きくなってしまっています。</p><p>今回の害獣檻センサーは見回りの負担軽減が目的ですので、バッテリー交換の頻度も極力抑えることが求められます。そのため、低消費電力化はひとつの大きな課題であり、基板を作ることに決めました。基板を自分で作るとなった場合には、プリント基板を製作するか、<a href="https://www.murata.com/ja-jp/campaign/ads/japan/elekids/ele/craft/knack/universal" target="_blank" rel="noopener">ユニバーサル基板に手半田で回路を作成する</a>か、といった選択肢が現れます。</p><p>ユニバーサル基板のメリットは、基板をすぐに作り始められること、初期コストが小さく済むことです。プリント基板を製作するとなった場合には、（自前で製造設備を持っている方は別ですが）外部に基板を発注することになるため、製造のための時間がかかってしまいます。また回路にミスがあって修正をいれる場合にも、修正→再製造とさらに時間・お金がかかってしまいますが、その点ユニバーサル基板では配線の修正も容易です。ソフトウェアの開発に無理やり例えれば、「デバッグ・デプロイが容易なスクリプト言語」と言ったところでしょうか。</p><p>一方ユニバーサル基板のデメリットは、製造に技量が求められること、一点あたりの製造時間が長いこと、複数台の製造時に品質を安定させることが難しいことです。<a href="http://elm-chan.org/docs/wire/wiring.html" target="_blank" rel="noopener">この方</a>のようなユニバーサル基板の達人になれば、ワンオフで基板を作るにはとても良い選択肢なのですが、複数の基板を製造するには割に合わなくなってきます。</p><p>これに対してプリント基板は、「ビルドに時間はかかるが性能の良いコンパイル言語」という感じです。</p><p>基板のアートワーク（後述します）にこそ時間はかかりますが、一度デザインが出来てしまえばエンジニアの手を離れて製造が進んでいきます。最近は中国（主に深セン）のプリント基板製造メーカーさんが台頭しており、基板製造だけならば1,000円未満から始めることが出来るため、お金の面で言えばユニバーサル基板と対等になってきています。</p><p>長々と書いてきましたが、目的に応じた手段をまとめると以下のようになると思います。</p><h4 id="Q-目的はプロジェクトのコンセプト検証やデモで、何より早く検証を進めたい？"><a href="#Q-目的はプロジェクトのコンセプト検証やデモで、何より早く検証を進めたい？" class="headerlink" title="Q. 目的はプロジェクトのコンセプト検証やデモで、何より早く検証を進めたい？"></a>Q. 目的はプロジェクトのコンセプト検証やデモで、何より早く検証を進めたい？</h4><ul><li>Yes<br>Arduinoと各種モジュールを組み合わせたプロトタイプを作る。<br>またはユニバーサル基板で製作する。</li><li>No, コンセプトの検証は済んでいて、更に小型化したい / コストを下げたいなど<br>ユニバーサル基板 or プリント基板の製作</li></ul><h4 id="Q-必要な台数はせいぜい数台で、今後仕様変更が入る可能性が大きい？"><a href="#Q-必要な台数はせいぜい数台で、今後仕様変更が入る可能性が大きい？" class="headerlink" title="Q. 必要な台数はせいぜい数台で、今後仕様変更が入る可能性が大きい？"></a>Q. 必要な台数はせいぜい数台で、今後仕様変更が入る可能性が大きい？</h4><ul><li>Yes<br>ユニバーサル基板で製作する。</li><li>No, 仕様もほぼ固まっていて台数も必要<br>プリント基板で製作する。</li></ul><p>害獣檻センサーの開発では、すでにコンセプト検証は済んでおり、また数十台の製造が必要なことから、プリント基板を製造することに決定しました。</p><h2 id="プリント基板の設計から製造まで"><a href="#プリント基板の設計から製造まで" class="headerlink" title="プリント基板の設計から製造まで"></a>プリント基板の設計から製造まで</h2><p>ここからは、害獣檻センサー製造時の具体的なプリント基板設計・製造の話をしていきます。</p><p>プリント基板を作るには、一般に下記のような手順で進めていきます。</p><ol><li>仕様を定義する</li></ol><ul><li>何はともあれ仕様を決めるところからです。これはソフトウェアもハードウェアも変わりませんね。<br>業務要件を基板の仕様へブレークダウンしていきます。</li></ul><ol start="2"><li>回路を設計する</li></ol><ul><li>仕様を満たすための回路を設計します。<br>システム開発に例えるならば、詳細設計のフェーズにあたるかと思います。</li></ul><ol start="3"><li>部品を選定する</li></ol><ul><li>設計した回路に用いる部品を選定します。<br>同じ目的を満たすためにも、様々なメーカーから複数の電子部品が出ています。<br>システム開発に例えるならば、技術スタックを選定するフェーズにあたるかと思います。</li></ul><ol start="4"><li>アートワークを描く</li></ol><ul><li>3で選定した部品をプリント基板上に配置し、<br>配線を描いて2の回路を作り上げていく作業です。<br>システム開発に例えるならば、コーディングにあたるかと思います。</li></ul><ol start="5"><li>基板を製造する</li></ol><ul><li>4で描いたアートワークを基にプリント基板を製造します。</li></ul><ol start="6"><li>部品を実装する</li></ol><ul><li>5で出来上がったプリント基板に、3で選定した部品を実装していきます。<br>5と6はシステム開発に例えるのが難しいのですが・・・強いて言うならコンパイル・ビルドでしょうか。</li></ul><p>これらについてすべて紹介してしまうと指輪物語並の大作になってしまうため、<br>この投稿では4のアートワークと5の基板製造に絞って詳しく紹介させていただきます。</p><h3 id="アートワークを描く"><a href="#アートワークを描く" class="headerlink" title="アートワークを描く"></a>アートワークを描く</h3><p>基板のアートワークを描くには、専用の基板CADと呼ばれるソフトウェアが必要です。<br>有名どころでは<a href="https://www.autodesk.co.jp/products/eagle/overview" target="_blank" rel="noopener">Eagle</a>、<a href="https://www.innotech.co.jp/products/orcad/products/orcad-capture/overview/" target="_blank" rel="noopener">OrCAD</a>などがあります。</p><p>今回は、オープンソースの<a href="http://www.kicad-pcb.org/" target="_blank" rel="noopener">KiCAD</a>を使用しました。<br>小規模なプリント基板の製作には十分な機能を備えていますし、Windows、macOS、Linuxの全てで動作するのも嬉しいところです。</p><p>アートワークを描き始めるにあたって、なんらかの制約条件が無いと効率的に進めていくのは難しいでしょう。<br>最も一般的な制約は、基板の大きさ・形状かと思います。<br>既に筐体の大きさが定められていて、基板形状もそれに縛られるパターンです。<br>特に制約が無い場合は、はじめに基板の大きさを決めてしまうのがおすすめです。<br>プリント基板の製造コストはほぼ大きさで決まるため、小さいに越したことはありません。</p><img src="/images/20190826/photo_20190826_02.png">これは害獣檻センサーのものではありませんがKiCADでのアートワーク中のキャプチャです。<p>アートワーク作業は、端的に言うと「終わりのないパズル」です。<br>大電流が流れる配線は太く短くなど様々な考慮をしつつ、部品と配線の配置を描いては消し、描いては消し…を繰り返していきます。</p><p>鼻歌交じりに部品を配置し、配線を進めていくと、「基板の中に収まらない～～！！！」ということも多々生じます。<br>お茶を飲んで一息ついてから、部品の配置を改善して配線をやり直します。<br>終わりのないパズルは、非常に泥臭い作業です。</p><p>基板の中に収めるだけでなく、以下のような点を心に留めながらアートワークを描いていく必要があります。</p><ul><li>電源ラインは太く短く</li><li>パスコンはICの近くに配置する</li><li>コネクタ類はケースに収めたときに作業性が良いように配置する</li><li>手半田で実装する場合はコテ先を取り回しやすいように部品を配置する</li><li>電解コンデンサは発熱する部品から離して配置する</li><li>GNDループが出来ないように</li><li>ベタGNDがアンテナ状にならないように</li><li>etc…</li></ul><p>また、一通り配線を終えた後にも、「ここはもう少しスマートに配線出来そうだな…」とか、「この部品配置は性能が悪くなりそうだな…」という点が出てきます。<br>これはソフトウェアで言うところのリファクタリングに近い作業になります。<br>全くやらないのも問題ですが、気を付けないと沼にはまります。<br>（本職の基板屋さんは良い方法論をお持ちかもしれません。教えてほしいです。）</p><h3 id="手戻り"><a href="#手戻り" class="headerlink" title="手戻り"></a>手戻り</h3><ol start="2"><li>回路を設計する</li><li>部品を選定する</li><li>アートワークを描く</li></ol><p>基板づくりの手順を上記のように順序付けて紹介していましたが、私の場合は4から2へ、3から2へと何度か戻っていました。</p><p>アートワークを描く中でどうしても部品が基板に収まらないので一回り小さい部品に変更する、部品選定と見積もりを進めていたら部品コストが思ったよりも高くなったので、部品の削減・共通化のために回路を修正する、<br>といったことを行っていました。<br>他にもマイコンを使った回路の場合、配線をスマートにするために使用するピンを変更することもあります。</p><p>それぞれの手順で担当者が違う場合には大変なことかもしれませんが、私の場合は回路設計から部品調達までを一人で担当していたので、<br>はじめから手戻り覚悟で、ある程度「えいや」で回路を決めたりしていました。</p><p>今回の害獣檻センサーの製造で最も大変だった手戻りは、1608と呼ばれるサイズのMLCC（チップ積層セラミックコンデンサ）が世界的な品薄で手に入らず、<br>すべて1005と呼ばれるサイズのものに変更したことです。<br>そこに関わる配線はすべて引き直しです・・・。<br>※ 1005のMLCCも品薄ではあるのですが、P板.comさんに実装をお願いする場合は無料でP板.comさんの標準在庫品を使ってもらえます。</p><h3 id="基板製造・発注"><a href="#基板製造・発注" class="headerlink" title="基板製造・発注"></a>基板製造・発注</h3><p>アートワークが完成したら、いよいよ発注です。</p><p><a href="https://www.marutsu.co.jp/contents/shop/marutsu/mame/60.html" target="_blank" rel="noopener">感光基板</a>を使えば自前で基板を作ることも可能ですが、<br>設備や薬品が必要で大変なので今回は外注しました。</p><p>先述しましたが、最近は<a href="https://www.elecrow.com/services.html" target="_blank" rel="noopener">Elecrow</a>さんや<a href="https://www.pcbgogo.jp/" target="_blank" rel="noopener">PCBgogo</a>さんなど、中国のプリント基板製造メーカーさんが台頭しています。<br>こういったところに頼めば格安で基板の製造が可能ですが、<br>今回の部品の自動実装まで頼みたかったため、<a href="https://www.p-ban.com/" target="_blank" rel="noopener">P板.com</a>さんを利用しました。</p><p>自動実装を利用する理由は、選定した部品の中に<a href="https://ja.wikipedia.org/wiki/%E3%82%A6%E3%82%A8%E3%83%8F%E3%83%BC%E3%83%AC%E3%83%99%E3%83%ABCSP" target="_blank" rel="noopener">とても手半田ができそうに無い部品</a>があり、<br>機械での実装・半田をせざるを得なかったことと、数十台分の半田付けを手作業で行うにはそれなりの時間がかかってしまうためです。<br>（個人差があるかもしれませんが、私は長時間半田付けをしていると目がショボショボになります）</p><p>基板を発注する前には、<em>必ずアートワークのダブルチェックを行いましょう。</em><br>基板のサイズと実際の部品や筐体のサイズが合わない、なんてことになったら大惨事です。</p><p>私は普段は、完成したアートワークを原寸大で紙に印刷し、実際に部品をあてがってみて大きさに問題が無いかなどを確認しています。<br>基板CADにもDRC（Design Rule Check）やERC（Electrical Rule Check）というLinterのような機能がついていますが、これに頼り切らずきちんと自分の目で確認します。</p><h3 id="完成！"><a href="#完成！" class="headerlink" title="完成！"></a>完成！</h3><p>さあ、苦労して設計した基板が手元に届いたときの感動はひとしおです。<br>プリント基板とユニバーサル基板の比較を長々と書いたりもしましたが、メーカーさんに頼んで作ってもらったプリント基板は<em>何よりも美しく</em>、「製品」として見栄えするものになります。<br>ケースの蓋を閉めたら、見えなくなってしまいますが…。</p><img src="/images/20190826/photo_20190826_03.jpeg">※ 一部お見せできないシリアルなどにボカシを入れています。<p>この基板が、檻の状態を検知する各種センサーの情報を処理し、LoRaWANという無線通信を経由してクラウドへデータを送信します。<br>試算ではありますが、バッテリー（単1乾電池）は1年ほどは持つ予定のため、猟友会の方の見回りにかかる負担を大きく軽減できるはずです。</p><h2 id="完成した害獣檻センサーの設置とこぼれ話"><a href="#完成した害獣檻センサーの設置とこぼれ話" class="headerlink" title="完成した害獣檻センサーの設置とこぼれ話"></a>完成した害獣檻センサーの設置とこぼれ話</h2><p>以上のような苦労を経て完成した害獣檻センサーは、現在与謝野町でイノシシ・シカの捕獲を検知しています。</p><img src="/images/20190826/20190826-3.png" class="img-middle-size"><p>（設置の様子を京都新聞さんなどに取り上げていただきました。写真右の”業者”が私です。）</p><p>これは設置の後日談になるのですが、イノシシ・シカを捕獲するための罠に、まれにクマがかかることがあります。<br>そのクマに害獣檻センサーを壊されてしまいました。</p><p>害獣檻センサーは、ケース内蔵の人感センサーおよび振動センサーと、ケースからケーブルで引き伸ばした開閉センサーからなっているのですが、このケーブルをクマに引きちぎられてしまいました。</p><p>外に出ているケーブルが痛みやすいであろうことは認識していてコルゲートチューブで保護していたのですが、まさかクマに切られてしまうとは・・・恐ろしいパワーです。</p><p>こうしたこともあり現在は、壊れやすい開閉センサーを使わず、人感センサーと振動センサーのみの値で捕獲の検知が出来ないかどうか、機械学習の利用も含めてバージョンアップの検討を進めています。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>このテックブログを見ている方のほとんどはソフトウェアエンジニアの方と思い、ところどころソフトウェア開発に例えて解説をしてみました。</p><p>その例え話を考える中で自分自身、こと開発手法という点においてはハード・ソフトの垣根を越えて活かせる知見が数多くあるんじゃないか？と思いました。<br>それぞれの分野のエンジニア同士が知見を共有する機会があれば面白いかもしれません。</p><p>プリント基板づくりはまだまだ奥が深い話なのですが、「脱ブレッドボード！まずは簡単に作ってみよう」というだけなら、さほどコストもかかりません。<br>皆さんにも挑戦していただけたら幸いです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;はじめまして。筒井と申します。&lt;/p&gt;
&lt;p&gt;簡単に自己紹介をさせていただくと、新卒でフューチャーに入社後に&lt;a href=&quot;https://www.future.co.jp/company_profile/future_group/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="IoT" scheme="https://future-architect.github.io/categories/IoT/"/>
    
    
      <category term="IoT" scheme="https://future-architect.github.io/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>システム開発で得たRedis利用ノウハウ</title>
    <link href="https://future-architect.github.io/articles/20190821/"/>
    <id>https://future-architect.github.io/articles/20190821/</id>
    <published>2019-08-20T23:53:57.000Z</published>
    <updated>2019-08-21T00:37:30.523Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。初投稿です。<br>2012年新卒入社の竹内です。入社当時を振り返るとOracle10g,11gを良く利用していおり、データモデリングなどテーブル設計が好きで、2018年4月ぐらいまでRDBとバッチに浸ってました。</p><p>さて、現在プロジェクトでRedisを使っているのですが、いままでRDB人間だっただけにKVSやRedisならではの特徴に四苦八苦してます。</p><p>苦しんだ分、色々な知見を得ることができているので、その内容をご紹介します！</p><h2 id="対象者"><a href="#対象者" class="headerlink" title="対象者"></a>対象者</h2><ul><li>Redisの業務システム導入を検討している方</li><li>RDBとRedisの違いを知りたい方</li><li>現場的なRedisの利用方法を知りたい方</li></ul><h2 id="書いてないこと"><a href="#書いてないこと" class="headerlink" title="書いてないこと"></a>書いてないこと</h2><ul><li>データ型やコマンドなど、HelloWorld的に公式ドキュメントを見て得られる情報</li><li>インストールなど、Redisを利用できるまでの手順</li><li>フェイルオーバーやバックアップをはじめとする運用に関する内容</li><li>データ永続化に関する内容</li></ul><h2 id="書いてること"><a href="#書いてること" class="headerlink" title="書いてること"></a>書いてること</h2><ul><li>設計・実装に関わる以下の内容<ul><li>公式ドキュメントに書いてあるけど、よく読まなきゃ見落としてしまうような落とし穴</li><li>公式ドキュメントに書いてある内容から一歩踏み込んだ挙動（「それってつまりどういうこと？」）</li><li>と、それに対する私の考え（「じゃあどうすればいい？」）</li></ul></li></ul><h2 id="検証用サーバ情報"><a href="#検証用サーバ情報" class="headerlink" title="検証用サーバ情報"></a>検証用サーバ情報</h2><ul><li>redis_version:4.0.10</li><li>redis_mode:standalone</li><li>os:Amazon ElastiCache</li><li>マスタ・スレーブ構成（スレーブ１つ）</li></ul><h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><ul><li><ol start="0"><li>Redisとは（教科書的なサマリ）</li></ol></li><li><ol><li>シングルスレッド</li></ol></li><li><ol start="2"><li>Transaction の実現方法</li></ol></li><li><ol start="3"><li>Hash型はMultiGetできない</li></ol></li><li><ol start="4"><li>KEYSは怖い</li></ol></li><li><ol start="5"><li>おまけ：データ量試算時の注意</li></ol></li><li><ol start="6"><li>今後試したいこと</li></ol></li><li><ol start="7"><li>所感</li></ol></li><li><ol start="8"><li>ためになるサイト</li></ol></li></ul><h2 id="0-Redisとは（教科書的なサマリ）"><a href="#0-Redisとは（教科書的なサマリ）" class="headerlink" title="0. Redisとは（教科書的なサマリ）"></a>0. Redisとは（教科書的なサマリ）</h2><ul><li>Redis はキーと５種類の値型の対応関係を格納する非リレーショナルデータベース(NoSQL)。</li><li>メモリ上にデータを持つインメモリDBのため、非常に高速。</li></ul><h2 id="1-シングルスレッド"><a href="#1-シングルスレッド" class="headerlink" title="1. シングルスレッド"></a>1. シングルスレッド</h2><p>Redisサーバはシングルスレッド<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>で動作します。（厳密には他にもスレッドあるがクエリ処理をするスレッドは1つ）</p><p>..これだと、「あっそうなんだ」で終わっちゃいますよね。<br>しかしながら、以下の点に注意してください。</p><ul><li><strong>Keysのような重いクエリは本番運用禁止！</strong><ul><li>高速なはずのRedisで簡単に待ちが発生します。詳細・対策は後述</li></ul></li><li><strong>性能検証でCPU使用率余裕♪と思いきや…</strong><ul><li>あなたのRedisサーバは何コアですか？</li><li>4コア？それなら性能計測した <strong>RedisのCPU使用率はその4倍</strong> として考える必要があります。</li></ul></li></ul><p>AWSでは<strong>EngineCPUUtilization</strong>というメトリクスを使えば、上記を加味したCPU使用率が見れます。性能検証等で測定する際は<a href="https://aws.amazon.com/jp/about-aws/whats-new/2018/04/amazon-elastiCache-for-redis-introduces-new-cpu-utilization-metric-for-better-visibility-into-redis-workloads/" target="_blank" rel="noopener">こちらの指標</a>を使いましょう。</p><h2 id="2-トランザクションの実現方法"><a href="#2-トランザクションの実現方法" class="headerlink" title="2. トランザクションの実現方法"></a>2. トランザクションの実現方法</h2><p>トランザクション中は、クエリをQueueに溜めます。</p><ul><li>RDBでいうCommitのタイミングでそのクエリを順に(FIFOで)実行します（<code>EXEC</code>）</li><li>RDBでいうRollbackはQueueを取り消すことで実現しています（<code>DISCARD</code>）</li></ul><p>…これも、「あっそうなんだ」と思いますよね。<br>しかしながら、以下の点に注意してください。</p><ul><li><strong>Commit前のデータはRDBと異なり自分のトランザクション中で取得できない</strong><ul><li>Queueに溜めているだけなので、Redisのデータは一切更新されていないです</li><li><code>INCR</code>というValueを+1してその結果をReturnするコマンドがありますが、トランザクション中に実行するとNULLがReturnされます。トランザクションを使わない場合は更新後の値が取得できます</li></ul></li><li><strong>Commitするまで実行されない＝実行順注意</strong><ul><li>例えば、Javaで実装した1~4の作り替え処理で、データが作成されない事象が発生しました。</li></ul></li></ul><p>1．Transaction開始<br>2．Redisのデータを複数DELETE<br>3．Redisのデータを作成（並列処理） ←並列処理でDELETEが入ったQueue以外のQueueが作成<br>4．Transaction終了</p><p>並列処理で新たなQueueが作られた結果、トランザクション終了のタイミングでDELETE処理を含んでいないQueue、DELETE処理を含んでいるQueueを同時に<code>EXEC</code>。同時に動いた結果、3の登録が先に処理されあとで2のDELETEで消されたデータがいたようです。並列化をやめることで解消しました。</p><p>RDBでは都度データを書き換えに行くため、実行順の入替は起こりません。</p><h2 id="3-Hash型はMultiGetできない"><a href="#3-Hash型はMultiGetできない" class="headerlink" title="3. Hash型はMultiGetできない"></a>3. Hash型はMultiGetできない</h2><p>Hash型はKeyの中に複数のFieldとValueを持てるため、RDB慣れしているとついつい使いたくなります。<br>ここに落とし穴があります。</p><p>Hash型はString型のデータと違い複数レコードを一括取得するメソッドが提供されていません。</p><p>複数レコードを取得して表示しようとすると1件ずつループ処理で取得することになり、NWのオーバーヘッドでとたんに遅いという性能問題になりかねません<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><h3 id="回避策"><a href="#回避策" class="headerlink" title="回避策"></a>回避策</h3><p>自分達もハマり、色々悩んだのでいくつか回避策を紹介します。</p><h4 id="3-1-Hashを捨てる！"><a href="#3-1-Hashを捨てる！" class="headerlink" title="3-1. Hashを捨てる！"></a>3-1. Hashを捨てる！</h4><p>潔くHashを捨てます。以下のようにString型で持つことで複数キーを一括で取得する<code>MGET</code>が使えるようになります。Hashとして考えていたまとまりの概念はRedisにアクセスするEntityや、RedisのデータをGETするAPIが吸収すれば、大きな影響はないと思います。</p><figure class="highlight json"><figcaption><span>Hashイメージ.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"sales:111"</span>, </span><br><span class="line">  <span class="attr">"value"</span>: &#123;</span><br><span class="line">     <span class="attr">"name"</span>: <span class="string">"REDBULL"</span>,</span><br><span class="line">     <span class="attr">"amount"</span>: <span class="string">"200"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>Hashを捨てたイメージ.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">"key"</span>: <span class="string">"sales:111:name"</span>, <span class="attr">"value"</span>: <span class="string">"REDBULL"</span>&#125;</span><br><span class="line">&#123;  <span class="attr">"key"</span>: <span class="string">"sales:111:amount"</span>, <span class="attr">"value"</span>: <span class="string">"200"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-HashのMultiGetを実装する！"><a href="#3-2-HashのMultiGetを実装する！" class="headerlink" title="3-2. HashのMultiGetを実装する！"></a>3-2. HashのMultiGetを実装する！</h4><p>標準機能ではないようですが、以下2つの方法でHashの一括取得を実装できます。</p><h5 id="実装方法1-Luaスクリプト"><a href="#実装方法1-Luaスクリプト" class="headerlink" title="実装方法1. Luaスクリプト"></a>実装方法1. Luaスクリプト</h5><p>RDBには、複数クエリ実行やIF文・ループ処理などの一連の手続きを一回のクエリでRDB上で実行できるストアドプロシージャやストアドファンクションというものがあります。Luaスクリプトを使えばRedisでもそれと同様のことができます。</p><p>実際にHash型のKeyを一度に複数渡して処理できるスクリプトを作ってみました。試したところ、検証サーバでは1件7msかかってたHGETALLでしたが、10000件一括取得で400msぐらいでデータ取得できました。注意ですが、Luaスクリプトもクエリ処理用のスレッド（シングルスレッド）で動作するため、重い処理は避けるべきです。</p><p>※Javaから実行する方法は<a href="https://blog.kakakikikeke.com/2015/01/javaluaredis.html" target="_blank" rel="noopener">こちら</a>を参考ください。</p><p>luaスクリプト</p><figure class="highlight lua"><figcaption><span>hmgetall.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- param1: hmgetallで取得したいkeyの数 param2~: 取得したいkey（半角スペース区切りで複数可能）</span></span><br><span class="line"><span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, KEYS[<span class="number">1</span>] <span class="keyword">do</span></span><br><span class="line">  result[i] = &#123;<span class="string">'"key"'</span>, KEYS[i+<span class="number">1</span>] ,redis.call(<span class="string">'HGETALL'</span>, KEYS[i + <span class="number">1</span>])&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>使い方</p><figure class="highlight shell"><figcaption><span>hmgetall.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; --eval ./hmgetall.lua 2 sales:111 sales:222</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Return　Data</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1) 1) "\"key\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#    2) "sales:111"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#    3)  1) "\"name\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        2) "REDBULL"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        3) "\"amount\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        4) "200"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2) 1) "\"key\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#    2) "sales:222"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#    3)  1) "\"name\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        2) "MILK"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        3) "\"amount\""</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#        4) "165"</span></span></span><br></pre></td></tr></table></figure><h5 id="実装方法2-syncAndReturnAll"><a href="#実装方法2-syncAndReturnAll" class="headerlink" title="実装方法2. syncAndReturnAll"></a>実装方法2. syncAndReturnAll</h5><p>Redisのライブラリによっては、1件ずつ同期的に処理するのではなく、<strong>「Queueに詰めて一括で実行して、その結果をまとめて取得する」ってことができるようです</strong>（JavaはJedisでできることを確認済）。使用する言語でいいライブラリがあればLuaスクリプトよりもこちらの方がよいと思います。</p><p>Queueに詰めた実行順でレスポンスも返ってくるので、Keyとのマッピングもできます。keyがない場合も空のMapが返るのでマッピング順がずれることはないです。<br><a href="http://tool.oschina.net/uploads/apidocs/jedis-2.1.0/redis/clients/jedis/Pipeline.html#syncAndReturnAll%28%29" target="_blank" rel="noopener">http://tool.oschina.net/uploads/apidocs/jedis-2.1.0/redis/clients/jedis/Pipeline.html#syncAndReturnAll%28%29</a></p><figure class="highlight java"><figcaption><span>hMGetAll.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Jedis jedis = <span class="keyword">new</span> Jedis (host, port );</span><br><span class="line">  Pipeline pipe = jedis.pipelined();</span><br><span class="line">  pipe.hgetAll(<span class="string">"sales:111"</span>);</span><br><span class="line">  pipe.hgetAll(<span class="string">"sales:222"</span>);</span><br><span class="line">  pipe.hgetAll(<span class="string">"sales:NotExist"</span>);</span><br><span class="line">  List&lt;Object&gt; result=  pipe.syncAndReturnAll();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">結果</span></span><br><span class="line"><span class="comment">result= &#123;ArrayList@14772&#125;  size = 3</span></span><br><span class="line"><span class="comment"> 0 = &#123;HashMap@14777&#125;  size = 2</span></span><br><span class="line"><span class="comment">  ""name"" -&gt; "REDBULL"</span></span><br><span class="line"><span class="comment">  ""amount"" -&gt; "200"</span></span><br><span class="line"><span class="comment"> 1 = &#123;HashMap@14778&#125;  size = 2</span></span><br><span class="line"><span class="comment">  ""name"" -&gt; "MILK"</span></span><br><span class="line"><span class="comment">  ""amount"" -&gt; "165"</span></span><br><span class="line"><span class="comment"> 2 = &#123;HashMap@14779&#125;  size = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="4-KEYSは怖い"><a href="#4-KEYSは怖い" class="headerlink" title="4. KEYSは怖い"></a>4. KEYSは怖い</h2><p>ここで、Redisに登録されたKey一覧を取得する<code>KEYS</code>というコマンドをご紹介します。</p><p>例えば <code>KEYS &quot;sales:*&quot;</code> と実行すれば正規表現（※）でkey検索できます。</p><p>keysの正規表現は機能に制限があり以下だけです。<br>? ・・・ 任意の1文字<br>* ・・・ 任意の文字列<br>[ ] ・・・ 角カッコ内の文字のどれか1文字</p><p>なんとなく便利そうな気、しますよね。</p><p>しかしながら、以下の点に注意してください。</p><ul><li>この<code>KEYS</code>はRDBのINDEXを用いた前方一致での効率的な検索をしません。O(N)となりめっちゃ遅いです<ul><li>計測時は約9百万の中から10件検索するようなクエリで1秒かかりました</li></ul></li><li>その間のRedisはシングルスレッドでクエリ捌くため、他のリクエストを捌けません。ReadもWriteの両方ともさばけません。</li></ul><p>Jedis（Java用ライブラリ）だとデフォルトtimeoutが2秒なので、2，3人がkeysを2発ぐらい実行するとそれだけでtimeoutエラーが出たりします。公式でもWARNINGって書いてます。<a href="https://redis.io/commands/keys" target="_blank" rel="noopener">https://redis.io/commands/keys</a></p><blockquote><p>While the time complexity for this operation is O(N), the constant times are fairly low. For example, Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds.<br>Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don’t use KEYS in your regular application code. If you’re looking for a way to find keys in a subset of your keyspace, consider using SCAN or sets.</p></blockquote><br><h3 id="KEYSの代替方法"><a href="#KEYSの代替方法" class="headerlink" title="KEYSの代替方法"></a>KEYSの代替方法</h3><p>「今の設計には<code>KEYS</code>が必要なんだ！」っていうことありますよね。代替方法、そろえてます。<br><br></p><h4 id="RDBから取得"><a href="#RDBから取得" class="headerlink" title="RDBから取得"></a>RDBから取得</h4><p>一定の条件が揃えば使える方法。例えば販売のトランザクションデータはRDBでその日の商品別のサマリデータはRedisという時です。<br>RDBから販売トランや商品マスタを<code>SELECT DISTINCT</code>すれば…<br><br></p><h4 id="Sets型利用"><a href="#Sets型利用" class="headerlink" title="Sets型利用"></a>Sets型利用</h4><p>Redisのデータ型には、Sets型という同じデータは無視する「重複なしリスト型」が存在します。</p><p>これに保持しているKey情報を登録しておくようにします。</p><p>例えば販売のサマリデータを作成・更新する際に、Sets型にデータ追加のコマンド（<code>SADD</code>）を都度発行します。※Redisの登録は高速（Pipeline処理で計測時は0.01ms程度）なので追加の<code>SADD</code>処理の性能影響は無視できるものと考えてます。</p><figure class="highlight shell"><figcaption><span>redis_sets_command.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sets型のデータ登録</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># データ登録</span></span></span><br><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; SADD sales:keys sales:111</span><br><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; SADD sales:keys sales:222</span><br><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; SADD sales:keys sales:111</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># データ取得</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 全件取得</span></span></span><br><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; SMEMBERS sales:keys    #sales:111 とsales:222が返ってくる</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## カーソル的に一定件数ずつ取得することも可能</span></span></span><br><span class="line">redis-cli -h $&#123;REDIS_HOST&#125; -p $&#123;PORT&#125; SSCAN sales:keys 0 COUNT 1000</span><br></pre></td></tr></table></figure><br><h4 id="抜け道：KEYSは使う。負荷を下げる。"><a href="#抜け道：KEYSは使う。負荷を下げる。" class="headerlink" title="抜け道：KEYSは使う。負荷を下げる。"></a>抜け道：KEYSは使う。負荷を下げる。</h4><p>今更変えられないよ！抜け道ないの！？ということでこれも検討しました。<br>設計・実装変えれないときの最終手段に近い位置づけです。最初から選択すべき内容ではないです。</p><br><h5 id="DBを分ける"><a href="#DBを分ける" class="headerlink" title="DBを分ける"></a>DBを分ける</h5><p><code>KEYS</code>の検索対象はRedisの同一DBの範囲に閉じられています。DBを分けて、<code>KEYS</code>の対象減らすことで負荷を下げることができます。ただし、DBごとにスレッドが分かれるわけではないです。別DBへのクエリも同じシングルスレッドで処理されます。<br><br></p><h5 id="参照用レプリカ使用"><a href="#参照用レプリカ使用" class="headerlink" title="参照用レプリカ使用"></a>参照用レプリカ使用</h5><p>DBではなく別インスタンスを使おう、<code>KEYS</code>専用にレプリカ使おうっていう考えです。</p><p>この方法はDB分けとは違い、インスタンスが分かれるので、<code>KEYS</code>実行中にもマスター側でクエリを処理することが可能です。</p><br><h4 id="視点を変える-本当にKEYSが必要？-処理方式を見直そう"><a href="#視点を変える-本当にKEYSが必要？-処理方式を見直そう" class="headerlink" title="視点を変える:本当にKEYSが必要？ ~ 処理方式を見直そう ~"></a>視点を変える:本当にKEYSが必要？ ~ 処理方式を見直そう ~</h4><p>RDB脳だった自分にはなかなか思いつかなかった設計方式を記載しておきます。</p><h5 id="CASE1-Redisは毎日リセットしたい。対象データを一括で消したい。"><a href="#CASE1-Redisは毎日リセットしたい。対象データを一括で消したい。" class="headerlink" title="CASE1: Redisは毎日リセットしたい。対象データを一括で消したい。"></a>CASE1: Redisは毎日リセットしたい。対象データを一括で消したい。</h5><p>一括で消すには、<code>KEYS</code>で一覧取得が必要。なんてとき。</p><ul><li>見直し検討1:flushdbの利用<ul><li>一括で消したい単位でDBを分けておけば、<code>FLUSHDB</code>の1コマンドで削除できます</li></ul></li><li>見直し検討2:データ有効期間の設定<ul><li><code>EXPIRE</code>でデータに有効期限を設定できます。期限切れになると自動削除されます</li></ul></li></ul><h5 id="CASE2-数値を合計するためにKEYSで対象データがほしい。"><a href="#CASE2-数値を合計するためにKEYSで対象データがほしい。" class="headerlink" title="CASE2: 数値を合計するためにKEYSで対象データがほしい。"></a>CASE2: 数値を合計するためにKEYSで対象データがほしい。</h5><p>「店舗商品別データの売上金額」から、「店舗合計の売上金額」を取得するために、該当店舗のkey一覧取得→それぞれのデータをGETしてサマリしよう。なんてとき。</p><p><strong>見直し検討:最初から店舗合計のデータを作成する</strong><br>一括処理（更新・取得）はRDBの得意領域。細かく持って集計してっていうバッチ処理はRDB的考え方です。<br>Redisは数件を書き込む・読み込むことが高速。販売がある度に、店舗別に商品別のデータと、店舗合計のデータを更新すればいいじゃない。Redisの更新は速いので。数値の更新時は<code>INCR</code>を使えば、事前にロックとか考えずに数値を+-できます。</p><br><h2 id="5-おまけ：データ量試算時の注意"><a href="#5-おまけ：データ量試算時の注意" class="headerlink" title="5. おまけ：データ量試算時の注意"></a>5. おまけ：データ量試算時の注意</h2><p><strong>Hash型でデータを持たせた場合、HashのField名も含めることを忘れずに。</strong><br>RDBのテーブルのレコードのイメージでHash型を使うと、うっかりカラム名の試算を忘れがちなので注意です。<br>Valueが数値だったりすると、主にField名で容量喰いますｗ</p><br><h2 id="6-今後試したいこと"><a href="#6-今後試したいこと" class="headerlink" title="6. 今後試したいこと"></a>6. 今後試したいこと</h2><h3 id="Sets型を使ってRedisだけでKey検索も行う"><a href="#Sets型を使ってRedisだけでKey検索も行う" class="headerlink" title="Sets型を使ってRedisだけでKey検索も行う"></a>Sets型を使ってRedisだけでKey検索も行う</h3><p>業務システムでは「条件によって絞り込んで一覧表示する」ということが多いでしょう。</p><p>属性情報を元に該当するKeyを調べるため、RDBのマスタにアクセスすることになるかと思いますが、このKey検索もRedisだけで実現したいという内容です。</p><p>Sets型和集合(Union)、積集合(Intersection)、差集合(Difference)をサポートしてるので、属性情報に応じたKeyの検索も実装できそうです。例えば、飲み物のSets、今日売れたものSetsがあれば、積集合で「今日売れた飲み物」のキー一覧を取得できます。</p><p>…ここまでやるかって内容ですね。</p><h3 id="Hash型で列指向でデータを持たせる。"><a href="#Hash型で列指向でデータを持たせる。" class="headerlink" title="Hash型で列指向でデータを持たせる。"></a>Hash型で列指向でデータを持たせる。</h3><p>ついつい行指向で考えがち。数値情報を扱いたい場合、列指向で持たせると <code>HGETALL</code> で一度にまとめて取得できるので、列指向で持たせる方がいいかもしれません。<br>※<code>HSCAN</code>っていうカーソル的にデータ取得できるコマンドあるぐらいなのでそっちを想定しているのかも。<br>※同じKey内でフィールドの重複許さないので、列指向的な持ち方だとSets型 + String型の要素を足した扱い方ができますね。Sets型のような集合演算はできませんが。</p><h2 id="7-所感"><a href="#7-所感" class="headerlink" title="7. 所感"></a>7. 所感</h2><p>正直、RDBだとこんなの簡単にできるのにーと思うことが多々あり、最初はRedisを嫌いになりかけました。しかしRedisはKVSの中でもかなりRDBの人達に歩み寄ってくれてると感じます（Sets型やHash型はすごく好感持てます）。色々な可能性が見えてきて、今では気になる存在です。</p><p>この記事を読んでRedisを気にする仲間が増えればめちゃ嬉しいですー。</p><h2 id="8-ためになるサイト"><a href="#8-ためになるサイト" class="headerlink" title="8. ためになるサイト"></a>8. ためになるサイト</h2><ul><li>データイメージがわかりやすいサイト：<a href="http://redisgate.jp/redis/command/commands.php" target="_blank" rel="noopener">http://redisgate.jp/redis/command/commands.php</a></li><li>トランザクション：<a href="https://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/transactions.html" target="_blank" rel="noopener">https://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/transactions.html</a></li><li>spring での設定系（記事古め）：<a href="http://fits.hatenablog.com/entry/2015/08/27/205539" target="_blank" rel="noopener">http://fits.hatenablog.com/entry/2015/08/27/205539</a></li><li>RedisサーバのCPU負荷対策パターン：<a href="https://blog.yuuk.io/entry/redis-cpu-load" target="_blank" rel="noopener">https://blog.yuuk.io/entry/redis-cpu-load</a></li><li>Luaスクリプトは書き方ここに載ってます：<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">https://redis.io/commands/eval</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">厳密には、バックグラウンドプロセス等は別スレッドで動くため、完全なシングルスレッドというわけではないです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">検証サーバで計測したときは、1件取得で7ms程度かかりました。1000件取得するとなると7秒かかりますね...</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。初投稿です。&lt;br&gt;2012年新卒入社の竹内です。入社当時を振り返るとOracle10g,11gを良く利用していおり、データモデリングなどテーブル設計が好きで、2018年4月ぐらいまでRDBとバッチに浸ってました。&lt;/p&gt;
&lt;p&gt;さて、現在プロジェクトでRedi
      
    
    </summary>
    
      <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
      <category term="Redis" scheme="https://future-architect.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初めてのGCPで環境構築してハマったこと</title>
    <link href="https://future-architect.github.io/articles/20190820/"/>
    <id>https://future-architect.github.io/articles/20190820/</id>
    <published>2019-08-20T00:19:49.000Z</published>
    <updated>2019-08-27T15:15:51.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして。TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属、ゲームとボルダリング好きなエンジニアの椎名@417yskです。</p><p>お仕事でGCP使って環境を構築することがあったのですが、色々とハマることが多かったので供養を兼ねて共有したいと思います。</p><p>当時の私の経験値としては「AWSの一部サービスは触ったことがある」程度でクラウド環境を下地から構築するのは初めての経験でした。一度触ってみれば常識だよねって内容が多いですが、初心者が小石につまずいてもすぐに立ち上れるようになれば幸いです。</p><h1 id="今回構築した環境の概要"><a href="#今回構築した環境の概要" class="headerlink" title="今回構築した環境の概要"></a>今回構築した環境の概要</h1><ul><li>既存のオンプレ環境との共存を前提とし、使えるアドレス範囲もオンプレのNWから払い出し</li><li>オンプレ環境とインターネットVPNでつなぐプロジェクトは1つ（ホストプロジェクト）</li><li>各環境（production、staging・・）は共有VPCで接続（サービスプロジェクト）</li></ul><img src="/images/20190820/photo_20190820_01.png"><p>なお、構築はTerraform, Ansibleで行いました。</p><h1 id="GCPで環境構築してハマったこと"><a href="#GCPで環境構築してハマったこと" class="headerlink" title="GCPで環境構築してハマったこと"></a>GCPで環境構築してハマったこと</h1><p>本編です。<br>カテゴリ別に記載しています。</p><h2 id="1-GKE関連"><a href="#1-GKE関連" class="headerlink" title="1. GKE関連"></a>1. GKE関連</h2><h3 id="1-1-GKEのコア数を増やせない"><a href="#1-1-GKEのコア数を増やせない" class="headerlink" title="1-1. GKEのコア数を増やせない"></a>1-1. GKEのコア数を増やせない</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>アカウントあたりの割り当て上限に達していた。</p><h4 id="対応"><a href="#対応" class="headerlink" title="対応"></a>対応</h4><p>制限変更を依頼することで解消しました。<br>自分が依頼したときは数分で対応してくれましたが、常に数分で対応されるかは定かではありません。<br>サービスインする前は想定されるスケール具合に合わせて事前に拡張しておきましょう。<br>割り当て増加の手順は他の方が書かれていますのでこちらをご参考に。<br><a href="https://qiita.com/mouse2/items/dd136453798804f99de7" target="_blank" rel="noopener">https://qiita.com/mouse2/items/dd136453798804f99de7</a><br><a href="https://cloud.google.com/compute/quotas?hl=ja&amp;_ga=1.181298212.2042940000.1483498197" target="_blank" rel="noopener">https://cloud.google.com/compute/quotas?hl=ja&amp;_ga=1.181298212.2042940000.1483498197</a></p><h3 id="1-2-プライベートGKEクラスタからインターネットアクセスできない"><a href="#1-2-プライベートGKEクラスタからインターネットアクセスできない" class="headerlink" title="1-2. プライベートGKEクラスタからインターネットアクセスできない"></a>1-2. プライベートGKEクラスタからインターネットアクセスできない</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>プライベートクラスタではノード（pod）に外部IPが付与されないため。</p><h4 id="対応-1"><a href="#対応-1" class="headerlink" title="対応"></a>対応</h4><p>CloudNATを設定しNAT経由でインターネットに出るようにしました。<br>今回はシステム要件で外部IPの付与が不可でしたが、外部IPが付与されていれば問題なくインターネットアクセスできます。</p><h3 id="1-3-GKEへのデプロイ時、kubectlコマンドが接続できない"><a href="#1-3-GKEへのデプロイ時、kubectlコマンドが接続できない" class="headerlink" title="1-3. GKEへのデプロイ時、kubectlコマンドが接続できない"></a>1-3. GKEへのデプロイ時、kubectlコマンドが接続できない</h3><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>デプロイサーバが外部IPしか持っていなかったため。<br>GKEクラスタはこの時点でプライベートクラスタであった。</p><h4 id="対応-2"><a href="#対応-2" class="headerlink" title="対応"></a>対応</h4><p>システム要件もありデプロイサーバに内部IPを付与し、外部IPを削除しました。<br>その上でGKEクラスタの承認済みネットワークにデプロイサーバの属するサブネットを追加しました。</p><h3 id="1-4-GKEのLBでフロントのIPが固定できない"><a href="#1-4-GKEのLBでフロントのIPが固定できない" class="headerlink" title="1-4. GKEのLBでフロントのIPが固定できない"></a>1-4. GKEのLBでフロントのIPが固定できない</h3><h4 id="事象"><a href="#事象" class="headerlink" title="事象"></a>事象</h4><p>LB作成時にフロントエンドのIPが自動的に割り振られてしまう。</p><h4 id="対応-3"><a href="#対応-3" class="headerlink" title="対応"></a>対応</h4><p>Ingressを利用して意図したIPを割り当てました。<br>詳細は他の方が書かれていますのでこちらをご参考に。<br><a href="https://qiita.com/tinjyuu/items/fd7a97b0b81963dcc7f2" target="_blank" rel="noopener">https://qiita.com/tinjyuu/items/fd7a97b0b81963dcc7f2</a></p><h3 id="1-5-共有VPC上のGKEクラスタのセカンダリCIDR設計"><a href="#1-5-共有VPC上のGKEクラスタのセカンダリCIDR設計" class="headerlink" title="1-5. 共有VPC上のGKEクラスタのセカンダリCIDR設計"></a>1-5. 共有VPC上のGKEクラスタのセカンダリCIDR設計</h3><h4 id="事象-1"><a href="#事象-1" class="headerlink" title="事象"></a>事象</h4><p>オンプレ環境と接続する1つの共有VPC上にproduction, stagingなど複数プロジェクトを相乗りさせる場合、各プロジェクトで利用するセカンダリCIDRの設計が必要。</p><h4 id="対応-4"><a href="#対応-4" class="headerlink" title="対応"></a>対応</h4><p>GKEで必要なセカンダリCIDRを本腰入れて設計しました。<br>スタンダードなこれと言った解はなく、必要な環境数、オンプレ環境から割り当てられたIP範囲から適宜設計する必要があります。<br>ここだけでも1記事くらいのボリュームになりそうなので詳細はまた別途。</p><h3 id="1-6-GKEクラスタが大量に作成できない"><a href="#1-6-GKEクラスタが大量に作成できない" class="headerlink" title="1-6. GKEクラスタが大量に作成できない"></a>1-6. GKEクラスタが大量に作成できない</h3><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>利用可能なセカンダリCIDRの上限に掛かるため。<br>共有VPC上にプライベートGKEクラスタを構築するためには、1クラスタあたりに2つのアドレス範囲（pod/service）を割り当てる必要があるが、1サブネット内にセカンダリCIDRは <del>上限5つまで</del> しか作成できない。</p><p>今回、1プロジェクト=1サブネットを共有するという方針であったため、1プロジェクト当たりに2つしかクラスタを作成できなかった。</p><p>(2019/08/28追記)上限が30までに緩和されたようです。</p><blockquote><p>必要に応じて、サブネットごとに最大 30 個のセカンダリ CIDR ブロックを定義できます。このセカンダリ IP 範囲は、エイリアス IP アドレスにのみ使用できます。この上限を引き上げることはできません。<br><a href="https://cloud.google.com/vpc/docs/quota#per_network" target="_blank" rel="noopener">https://cloud.google.com/vpc/docs/quota#per_network</a></p></blockquote><p><a href="https://twitter.com/urasoko" target="_blank" rel="noopener">@urasoko</a>さん、ご指摘ありがとうございます！</p><p>これで、GKEのクラスタ数を増やしたい時も対応できます。</p><h4 id="対応-5"><a href="#対応-5" class="headerlink" title="対応"></a>対応</h4><p>用途に応じてクラスタを分けるのではなく、ノードプールを分ける方針としました。<br>GKEの設計でクラスタを分けるかノードプールを分けるかはしばしば話に挙がりますが、共有VPC上に構築する場合はノードプールを分けるしかないです。</p><h2 id="2-CloudSQL関連"><a href="#2-CloudSQL関連" class="headerlink" title="2. CloudSQL関連"></a>2. CloudSQL関連</h2><h3 id="2-1-CloudSQLのインスタンスが再作成できない"><a href="#2-1-CloudSQLのインスタンスが再作成できない" class="headerlink" title="2-1. CloudSQLのインスタンスが再作成できない"></a>2-1. CloudSQLのインスタンスが再作成できない</h3><h4 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h4><p>同じインスタンス名は数日間（1週間ほど）は作成できない仕様であったため。</p><h4 id="対応-6"><a href="#対応-6" class="headerlink" title="対応"></a>対応</h4><p>初期構築時は連番やタイムスタンプなどを入れ確実に構築可能なことの保証が取れてから真名で構築することにしました。<br>インスタンス名にタイムスタンプなどを入れてクライアント側の接続情報を変更していく運用も考えましたが、担当した案件では開発に複数社入っていたりする状況もあり諦めました。</p><h3 id="2-2-CloudSQLのアクセス制限"><a href="#2-2-CloudSQLのアクセス制限" class="headerlink" title="2-2. CloudSQLのアクセス制限"></a>2-2. CloudSQLのアクセス制限</h3><h4 id="事象-2"><a href="#事象-2" class="headerlink" title="事象"></a>事象</h4><p>CloudSQLにアクセス可能なインスタンスを同一プロジェクトのインスタンスに絞りたいが、以下の制約がある。</p><ul><li>Firewall Ruleはサブネット単位（今回の構成のプロジェクト単位）で指定できない</li><li>CloudSQLにFirewall Ruleで利用するネットワークタグを設定できない。</li><li>承認済みネットワークにプライベートIPは設定できない</li></ul><h4 id="対応-7"><a href="#対応-7" class="headerlink" title="対応"></a>対応</h4><p>出来上がったCloudSQLのIPを、gcloudで取得して、それをFirewall Ruleに設定しました。なおFirewall Ruleはインスタンスに対して適応されるため、インスタンスからの下りに対して制御をかけることしかできません。</p><p>デフォルトは下りが全てallowされているので、まずはCloudSQLのIP範囲にdenyをかけて、その上で接続するSQLインスタンスのみallowするという対応をしています。<br>Firewall Ruleの話だけで1記事くらいのボリュームになりそうなので詳細はまた別途書きます。</p><h3 id="2-3-CloudSQL-のパスワードが有効では無かった"><a href="#2-3-CloudSQL-のパスワードが有効では無かった" class="headerlink" title="2-3. CloudSQL のパスワードが有効では無かった"></a>2-3. CloudSQL のパスワードが有効では無かった</h3><h4 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h4><p>Terraformでデプロイしていたが、その定義が不正だったため。<br>後述のサンプルだとインスタンス名が正しく紐づかない。GCPは関係なくTerraformの記述ミスが原因でした。</p><h4 id="対応-8"><a href="#対応-8" class="headerlink" title="対応"></a>対応</h4><p>依存関係があるリソースは、ハードコードで名称を設定しない。<br>${xxxxx}を使用して実際に設定されている名称を取得する。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// インスタンスの作成</span></span><br><span class="line">resource <span class="string">"google_sql_database_instance"</span> <span class="string">"db-instance-test"</span> &#123;</span><br><span class="line">    name = <span class="string">"test-instance"</span></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// パスワード設定：NGパターン</span></span><br><span class="line">resource <span class="string">"google_sql_user"</span> <span class="string">"test-postgres-user"</span> &#123;</span><br><span class="line">    name = <span class="string">"postgres"</span></span><br><span class="line">    instance = <span class="string">"test-instance"</span></span><br><span class="line">    password = <span class="string">"postgres"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// パスワード設定：OKパターン</span></span><br><span class="line">resource <span class="string">"google_sql_user"</span> <span class="string">"test-postgres-user"</span> &#123;</span><br><span class="line">    name = <span class="string">"postgres"</span></span><br><span class="line">    instance = <span class="string">"$&#123;google_sql_database_instance.db-instance-test.name&#125;"</span></span><br><span class="line">    password = <span class="string">"postgres"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-CloudSqlProxyを使ってSQLインスタンスにつながらない"><a href="#2-4-CloudSqlProxyを使ってSQLインスタンスにつながらない" class="headerlink" title="2-4. CloudSqlProxyを使ってSQLインスタンスにつながらない"></a>2-4. CloudSqlProxyを使ってSQLインスタンスにつながらない</h3><h4 id="原因-6"><a href="#原因-6" class="headerlink" title="原因"></a>原因</h4><p>Cloud SQL Administration APIが有効化されていないため。<br>CloudSqlProxyを使う際は有効化する必要があります。<br><a href="https://cloud.google.com/sql/docs/postgres/connect-external-app?hl=ja" target="_blank" rel="noopener">https://cloud.google.com/sql/docs/postgres/connect-external-app?hl=ja</a></p><h4 id="対応-9"><a href="#対応-9" class="headerlink" title="対応"></a>対応</h4><p>Cloud SQL Administration APIを有効化します。<br>環境の断面が増えてくると、Administration APIの有効化手順が漏れるので、これもちゃんと<a href="https://www.terraform.io/docs/providers/google/r/google_project_services.html" target="_blank" rel="noopener">Terraformで管理</a>することになりました。<br>（※それまでは手動で有効にしていました☠）</p><h3 id="2-5-CloudSQLの接続CIDRが任意のアドレス範囲で作成されてしまった"><a href="#2-5-CloudSQLの接続CIDRが任意のアドレス範囲で作成されてしまった" class="headerlink" title="2-5. CloudSQLの接続CIDRが任意のアドレス範囲で作成されてしまった"></a>2-5. CloudSQLの接続CIDRが任意のアドレス範囲で作成されてしまった</h3><h4 id="原因-7"><a href="#原因-7" class="headerlink" title="原因"></a>原因</h4><p>IPアドレスの設計前にCloudSQLのインスタンスを立てて検証していたため初期構築時にCIDRの割り当てを明確に行っていなかった。</p><h4 id="対応-10"><a href="#対応-10" class="headerlink" title="対応"></a>対応</h4><p>GCPのSREチーム（米国）へ変更対応を依頼しました（ちょうどクリスマスシーズンだったので大変でした）。2019年1月時点では、このCIDRは一度設定するとGUIやコマンドで変更できないため依頼する必要がありました。<br><del>共有VPCの環境でCloudSQLのアドレス範囲を明示的に定めたい場合は注意しましょう。</del></p><p>(2019/08/28追記) 2019年4月以降は <code>gcloud services vpc-peerings update</code> コマンドで更新できるそうです。<br><a href="https://issuetracker.google.com/issues/118849070" target="_blank" rel="noopener">https://issuetracker.google.com/issues/118849070</a></p><p>これからは、わざわざサポートに連絡を取る必要はありません！間違っても比較的気軽にやり直せるようになったのは嬉しいですね。</p><h3 id="2-6-GCEからCloudSQLへ接続ができない"><a href="#2-6-GCEからCloudSQLへ接続ができない" class="headerlink" title="2-6. GCEからCloudSQLへ接続ができない"></a>2-6. GCEからCloudSQLへ接続ができない</h3><h4 id="原因-8"><a href="#原因-8" class="headerlink" title="原因"></a>原因</h4><p>GCEインスタンスには内部IPのみで外部IPが付与されておらず、SQLインスタンスには外部IPのみで内部IPを付与していなかった（β版のため）。<br>SQL Proxyが上手いことやってくれると淡い期待をしたがダメであった。</p><h4 id="対応-11"><a href="#対応-11" class="headerlink" title="対応"></a>対応</h4><p>他のシステム要件からCloudSQLに内部IPを付与しました</p><h2 id="3-LB関連"><a href="#3-LB関連" class="headerlink" title="3. LB関連"></a>3. LB関連</h2><h3 id="3-1-Internal-特定の通信においてInternal-LBで負荷分散されない"><a href="#3-1-Internal-特定の通信においてInternal-LBで負荷分散されない" class="headerlink" title="3-1. Internal 特定の通信においてInternal LBで負荷分散されない"></a>3-1. Internal 特定の通信においてInternal LBで負荷分散されない</h3><h4 id="原因-9"><a href="#原因-9" class="headerlink" title="原因"></a>原因</h4><p>コネクションを貼って通信していたため。<br>Internal LBでセッションアフィニティをOFFにしてもコネクション貼って通信するものはコネクション貼ったバックエンドに流れる仕様であった。</p><p>※参考<br><a href="https://cloud.google.com/load-balancing/docs/backend-service?hl=ja&amp;_ga=2.47555939.-570213192.1545967516" target="_blank" rel="noopener">https://cloud.google.com/load-balancing/docs/backend-service?hl=ja&amp;_ga=2.47555939.-570213192.1545967516</a><br><a href="https://cloud.google.com/compute/docs/reference/rest/v1/backendServices?hl=ja" target="_blank" rel="noopener">https://cloud.google.com/compute/docs/reference/rest/v1/backendServices?hl=ja</a></p><h4 id="対応-12"><a href="#対応-12" class="headerlink" title="対応"></a>対応</h4><p>クライアント側で定期的にコネクションを貼りなおすようにした。<br>大量のクライアントがいる処理であれば正常時はコネクションを貼る時点で後ろのノードは分散されれるので問題ないですが、ノード障害で別ノードとコネクション貼ってしまうとノード復旧時に再度振り分けられなくなってしまうのを回避するためです。</p><h3 id="3-2-Internal-LBのヘルスチェックが通らない"><a href="#3-2-Internal-LBのヘルスチェックが通らない" class="headerlink" title="3-2. Internal LBのヘルスチェックが通らない"></a>3-2. Internal LBのヘルスチェックが通らない</h3><h4 id="原因-10"><a href="#原因-10" class="headerlink" title="原因"></a>原因</h4><p>Internal LBのヘルスチェックが「130.211.0.0/22」と「35.191.0.0/16」 内のアドレスから送信されるため。<br>これらの接続を許可するようにFirewall Ruleを設定する必要があった。</p><h4 id="対応-13"><a href="#対応-13" class="headerlink" title="対応"></a>対応</h4><p>ヘルスチェックの通信元のIPに対して通信を許可するようにファイアウォールルールを追加しました。</p><h2 id="4-GCPプロジェクト"><a href="#4-GCPプロジェクト" class="headerlink" title="4. GCPプロジェクト"></a>4. GCPプロジェクト</h2><h3 id="4-1-新規に環境構築できない"><a href="#4-1-新規に環境構築できない" class="headerlink" title="4-1. 新規に環境構築できない"></a>4-1. 新規に環境構築できない</h3><h4 id="原因-11"><a href="#原因-11" class="headerlink" title="原因"></a>原因</h4><p>課金プロジェクトの作成数に限りがあったため</p><h4 id="対応-14"><a href="#対応-14" class="headerlink" title="対応"></a>対応</h4><p>サポートに連絡して上限を上げてもらった。<br>コア数の上限同様に事前に確認すべきでした。</p><h3 id="4-2-プロジェクトID-名を指定してリソースにアクセスできない。"><a href="#4-2-プロジェクトID-名を指定してリソースにアクセスできない。" class="headerlink" title="4-2. プロジェクトID/名を指定してリソースにアクセスできない。"></a>4-2. プロジェクトID/名を指定してリソースにアクセスできない。</h3><h4 id="原因-12"><a href="#原因-12" class="headerlink" title="原因"></a>原因</h4><p>プロジェクトID＝プロジェクト名を前提としてリソースにアクセスしていたが、プロジェクトIDとプロジェクト名が異なっていた。</p><h4 id="対応-15"><a href="#対応-15" class="headerlink" title="対応"></a>対応</h4><p>プロジェクトIDとプロジェクト名を同じに変更しました。<br>特に制約が無ければ同じにしておいた方がハマりどころ減ります。</p><h3 id="4-3-突然CloudSQLやGKEにアクセスできなくなった。"><a href="#4-3-突然CloudSQLやGKEにアクセスできなくなった。" class="headerlink" title="4-3. 突然CloudSQLやGKEにアクセスできなくなった。"></a>4-3. 突然CloudSQLやGKEにアクセスできなくなった。</h3><h4 id="原因-13"><a href="#原因-13" class="headerlink" title="原因"></a>原因</h4><p>アカウントが有効なクレジットと紐付いていなかった(!!!)。<br>最初は無料利用枠で動いてしまうため、構築して数日後に発覚した。</p><h4 id="対応-16"><a href="#対応-16" class="headerlink" title="対応"></a>対応</h4><p>アカウントを有効なクレジットと紐付けた。<br>プロジェクト構築時のオペレーションとして手順化した。</p><h2 id="5-踏み台"><a href="#5-踏み台" class="headerlink" title="5. 踏み台"></a>5. 踏み台</h2><h3 id="5-1-踏み台サーバにsshで接続できない"><a href="#5-1-踏み台サーバにsshで接続できない" class="headerlink" title="5-1. 踏み台サーバにsshで接続できない"></a>5-1. 踏み台サーバにsshで接続できない</h3><h4 id="原因-14"><a href="#原因-14" class="headerlink" title="原因"></a>原因</h4><p>IAMの権限不足。<br>「編集者」をベースとしたカスタム権限を作成していたが、GCEのログイン権限が継承されていなかった。</p><h4 id="対応-17"><a href="#対応-17" class="headerlink" title="対応"></a>対応</h4><p>IAMに「編集者」を直接付与する形式に変更。<br>アクセスするメンバーが限られていたため、カスタム権限で細かく制御は不要と判断しました。</p><h3 id="5-2-どの環境の踏み台サーバで作業しているか分からない"><a href="#5-2-どの環境の踏み台サーバで作業しているか分からない" class="headerlink" title="5-2. どの環境の踏み台サーバで作業しているか分からない"></a>5-2. どの環境の踏み台サーバで作業しているか分からない</h3><h4 id="原因-15"><a href="#原因-15" class="headerlink" title="原因"></a>原因</h4><p>踏み台サーバのインスタンス名が全ての環境（productionとかstagingとか）で同一のため。<br>CloudShellだとURL部分にPJ名が出るので判断可能であるがsshのターミナルツールによっては判別できない。</p><h4 id="対応-18"><a href="#対応-18" class="headerlink" title="対応"></a>対応</h4><p>踏み台にはインスタンス名に環境名を付与した。<br>命名規約上他のインスタンスに対して環境名を付けないとしても、実際にログインして作業することが多い踏み台だけは付けてあげた方が優しいです。</p><h2 id="6-その他"><a href="#6-その他" class="headerlink" title="6. その他"></a>6. その他</h2><h3 id="6-1-共有VPC設定ができない"><a href="#6-1-共有VPC設定ができない" class="headerlink" title="6-1. 共有VPC設定ができない"></a>6-1. 共有VPC設定ができない</h3><h4 id="原因-16"><a href="#原因-16" class="headerlink" title="原因"></a>原因</h4><p>共有VPCを設定するためには「共有 VPC 管理者」権限が必要であったが権限がなかった。<br><a href="https://cloud.google.com/vpc/docs/provisioning-shared-vpc#nominating_shared_vpc_admins_for_the_organization" target="_blank" rel="noopener">https://cloud.google.com/vpc/docs/provisioning-shared-vpc#nominating_shared_vpc_admins_for_the_organization</a><br>更には「共有 VPC 管理者」を付与するために「組織管理者」権限が必要であるが、構築メンバーが誰も権限を持っていなかった。</p><h4 id="対応-19"><a href="#対応-19" class="headerlink" title="対応"></a>対応</h4><p>「組織管理者」権限は契約者しか権限持っていなかったため依頼して操作ユーザに対して「組織管理者」権限を付与し、その上で「共有 VPC 管理者」を付与しました。</p><h3 id="6-2-特定アプリケーションのインストールができない"><a href="#6-2-特定アプリケーションのインストールができない" class="headerlink" title="6-2. 特定アプリケーションのインストールができない"></a>6-2. 特定アプリケーションのインストールができない</h3><h4 id="原因-17"><a href="#原因-17" class="headerlink" title="原因"></a>原因</h4><p>外部サイトへアクティベーションが必要であったが外部IPが無く接続できなかったため。</p><h4 id="対応-20"><a href="#対応-20" class="headerlink" title="対応"></a>対応</h4><p>一時的に外部IPを付与してインストールを行った。<br>※前述のCloudNAT導入前だったためこのような対応しています。<br>※CloudNAT導入後であれば問題なく出来たと思われます。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>ここまでお疲れ様でした。<br>忙しい人向けに、全体通してのまとめです。</p><ul><li>全体的にネットワーク、権限周りがハマりどころ多かった。</li><li>GKEは共有VPC、ネットワークの制約によるハマりどころが多かった。</li><li>逆にこの辺りがすんなりいけば簡単に環境作れる感じがした。</li><li>GCP、ネットワーク知識いらないって聞いてた（自分だけ？）けど結構必要。</li><li>オンプレ環境と密な構成は難易度が跳ね上がる。</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;はじめまして。TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnot
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>はじめてのTerraform 0.12 ～実践編～</title>
    <link href="https://future-architect.github.io/articles/20190819/"/>
    <id>https://future-architect.github.io/articles/20190819/</id>
    <published>2019-08-18T22:32:16.000Z</published>
    <updated>2019-08-19T02:25:21.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちはー<br>TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>のゆるふわエンジニアの前原です。</p><p>前回の<a href="https://future-architect.github.io/articles/20190816/">はじめてのTerraform 0.12 ～環境構築～</a>に続き実践編です。実際の構築を通して、最近バージョンアップしたTerraform 0.12の構文がこんな感じで変わったよー的な話を伝えていければと思っています。</p><p>では、Terraformを用いてAWSのリソースを作成していきましょう。</p><h1 id="構築する環境構成図"><a href="#構築する環境構成図" class="headerlink" title="構築する環境構成図"></a>構築する環境構成図</h1><p>下図の環境(VPC, VPC Endpoint, NAT Gatewayなど)をTerraformで構築していきます。</p><img src="/images/20190819/photo_20190819_01.jpeg"><ul><li>VPC</li></ul><p>VPCは、Staging（stg）とProduction（prd）に二つのVPCを構成します。AZ（Availability Zone）は3つのゾーンを利用し、サブネットはパブリックとプライベートに分けて構成します。</p><ul><li>VPC Endpoint</li></ul><p>Endpointとして、S3をセットします。</p><ul><li>NAT Gateway</li></ul><p>パブリックプライベートにNAT Gatewayを構築します。コストを抑えるために1台とします。</p><h1 id="Terraformのディレクトリ構成"><a href="#Terraformのディレクトリ構成" class="headerlink" title="Terraformのディレクトリ構成"></a>Terraformのディレクトリ構成</h1><p>最終的に以下のディレクトリ構成になります。前回の記事でお伝えしたように、1つのディレクトリにtfファイルを配置する設計にします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── backend.tf  // 前回の記事で説明</span><br><span class="line">├── provider.tf // 同上 </span><br><span class="line">├── versions.tf // 同上</span><br><span class="line">|</span><br><span class="line">├── eip.tf</span><br><span class="line">├── igw.tf</span><br><span class="line">├── nat_gateway.tf</span><br><span class="line">├── route.tf</span><br><span class="line">├── route_association.tf</span><br><span class="line">├── route_table.tf</span><br><span class="line">├── subnet.tf</span><br><span class="line">├── variable.tf</span><br><span class="line">├── vpc.tf</span><br><span class="line">└── vpc_endpoint.tf</span><br></pre></td></tr></table></figure><h1 id="VPCの構築"><a href="#VPCの構築" class="headerlink" title="VPCの構築"></a>VPCの構築</h1><p>ここでは前回の記事で作成した<code>backend.tf</code>など以外のtfファイルを作成します。<br>基本的にリソース単位でファイルを分けておりますが、好みでひとまとめにしても問題ありません。</p><h2 id="VPCリソースの定義"><a href="#VPCリソースの定義" class="headerlink" title="VPCリソースの定義"></a>VPCリソースの定義</h2><p>VPCを構築するためのVPCリソースを定義します。<br>このリソースで必須の項目は、<code>cidr_block</code>のみですが、タグを付与したいため記述します。</p><figure class="highlight bash"><figcaption><span>vpc.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_vpc"</span> <span class="string">"vpc"</span> &#123;</span><br><span class="line">  cidr_block = local.vpc_cidr[terraform.workspace]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vpc.tf</code>は、ローカル変数を呼び出しているので、以下のように<code>variable.tf</code>に定義する必要があります。<br>また、<code>variable.tf</code>は、変数を定義するため今後も追記していきますので、これが最終的な内容でありませんのでご注意ください。</p><figure class="highlight bash"><figcaption><span>variable.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  project_name = <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line">  vpc_cidr = &#123;</span><br><span class="line">    stg = <span class="string">"10.0.0.0/16"</span></span><br><span class="line">    prd = <span class="string">"10.1.0.0/16"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>準備ができたのでTerraformを実行します。<br>が、実行する前に構文や設定に問題がないかを確認するためのコマンドを実行します。</p><h3 id="terraform-validate"><a href="#terraform-validate" class="headerlink" title="terraform validate"></a>terraform validate</h3><p>構文に問題ないかを<code>validate</code>コマンドで確認します。<br>問題なければ<code>Success</code>と出力されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform validate</span><br><span class="line">Success! The configuration is valid.</span><br></pre></td></tr></table></figure><h3 id="terraform-fmt"><a href="#terraform-fmt" class="headerlink" title="terraform fmt"></a>terraform fmt</h3><p>次に<code>terraform fmt</code>というインデントなどのスタイルを揃えるコマンドを実行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform fmt</span><br></pre></td></tr></table></figure><h3 id="terraform-plan"><a href="#terraform-plan" class="headerlink" title="terraform plan"></a>terraform plan</h3><p>それでは、設定に問題ないかを確認します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">Refreshing Terraform state <span class="keyword">in</span>-memory prior to plan...</span><br><span class="line">The refreshed state will be used to calculate this plan, but will not be</span><br><span class="line">persisted to <span class="built_in">local</span> or remote state storage.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># aws_vpc.vpc will be created</span></span><br><span class="line">  + resource <span class="string">"aws_vpc"</span> <span class="string">"vpc"</span> &#123;</span><br><span class="line">      + arn                              = (known after apply)</span><br><span class="line">      + assign_generated_ipv6_cidr_block = <span class="literal">false</span></span><br><span class="line">      + cidr_block                       = <span class="string">"10.0.0.0/16"</span></span><br><span class="line">      + default_network_acl_id           = (known after apply)</span><br><span class="line">      + default_route_table_id           = (known after apply)</span><br><span class="line">      + default_security_group_id        = (known after apply)</span><br><span class="line">      + dhcp_options_id                  = (known after apply)</span><br><span class="line">      + enable_classiclink               = (known after apply)</span><br><span class="line">      + enable_classiclink_dns_support   = (known after apply)</span><br><span class="line">      + enable_dns_hostnames             = (known after apply)</span><br><span class="line">      + enable_dns_support               = <span class="literal">true</span></span><br><span class="line">      + id                               = (known after apply)</span><br><span class="line">      + instance_tenancy                 = <span class="string">"default"</span></span><br><span class="line">      + ipv6_association_id              = (known after apply)</span><br><span class="line">      + ipv6_cidr_block                  = (known after apply)</span><br><span class="line">      + main_route_table_id              = (known after apply)</span><br><span class="line">      + owner_id                         = (known after apply)</span><br><span class="line">      + tags                             = &#123;</span><br><span class="line">          + <span class="string">"Env"</span>     = <span class="string">"stg"</span></span><br><span class="line">          + <span class="string">"Name"</span>    = <span class="string">"stg-example"</span></span><br><span class="line">          + <span class="string">"Project"</span> = <span class="string">"example"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Note: You didn<span class="string">'t specify an "-out" parameter to save this plan, so Terraform</span></span><br><span class="line"><span class="string">can'</span>t guarantee that exactly these actions will be performed <span class="keyword">if</span></span><br><span class="line"><span class="string">"terraform apply"</span> is subsequently run.</span><br></pre></td></tr></table></figure><h3 id="terraform-apply"><a href="#terraform-apply" class="headerlink" title="terraform apply"></a>terraform apply</h3><p>最後に<code>apply</code>を実行し、<code>Apply complete!</code>と出力されたら完了です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply</span><br><span class="line"><span class="comment">### 以下の質問が出力されるので`yes`を入力</span></span><br><span class="line">  Enter a value: yes</span><br><span class="line">aws_vpc.vpc: Creating...</span><br><span class="line">aws_vpc.vpc: Creation complete after 9s [id=vpc-0f1c8121f72d84ee9]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure><h2 id="ちょっとした解説①"><a href="#ちょっとした解説①" class="headerlink" title="ちょっとした解説①"></a>ちょっとした解説①</h2><p>ここでは上記で説明できていない部分について解説します。</p><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p><code>vpc.tf</code>で記述されていた<code>${terraform.workspace}</code>についてですが、これはWorkspaceの環境名を割り当てるための変数です。<br>そのため、今回の実行結果を見るとタグに指定した値に<code>stg</code>と入っていることがわかります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### terraform apply結果の抜粋</span></span><br><span class="line">      + tags                             = &#123;</span><br><span class="line">          + <span class="string">"Env"</span>     = <span class="string">"stg"</span></span><br><span class="line">          + <span class="string">"Name"</span>    = <span class="string">"stg-example"</span></span><br><span class="line">          + <span class="string">"Project"</span> = <span class="string">"example"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>また、<code>cidr_block</code>には、<code>10.0.0.0/24</code>のネットワークアドレスが入っていることがわかります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ cidr_block                       = <span class="string">"10.0.0.0/16"</span></span><br></pre></td></tr></table></figure><p>これは、Workspaceによって値が変わる部分のため、以下のように二つ定義をしています。<br>そのため、<code>vpc.tf</code>で呼び出すときは、<code>terraform.workspace</code>を利用します。</p><figure class="highlight bash"><figcaption><span>variable.tf（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  project_name = <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line">  vpc_cidr = &#123;</span><br><span class="line">    stg = <span class="string">"10.0.0.0/16"</span></span><br><span class="line">    prd = <span class="string">"10.1.0.0/16"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Local変数"><a href="#Local変数" class="headerlink" title="Local変数"></a>Local変数</h3><p>タグの<code>project</code>には、<code>example</code>という文字列が入っております。<br>これは、<code>variable.tf</code>で定義したローカル変数が割り当てられています。</p><figure class="highlight bash"><figcaption><span>vpc.tf（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Project = local.project_name</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>variable.tf（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  project_name = <span class="string">"example"</span></span><br></pre></td></tr></table></figure><p>ネットで調べているとVariable変数を使うケースをよく見かけることがあるかと思います。<br>しかし、個人的には、変数の組み込みやコマンド時の変数挿入などを防ぐことができるため、<code>Local変数</code>を利用しています。</p><h1 id="SubnetやNAT-Gatewayなどの構築"><a href="#SubnetやNAT-Gatewayなどの構築" class="headerlink" title="SubnetやNAT Gatewayなどの構築"></a>SubnetやNAT Gatewayなどの構築</h1><p>続いて、残りのリソースも作成していきます</p><h2 id="Subnet"><a href="#Subnet" class="headerlink" title="Subnet"></a>Subnet</h2><p>パブリックサブネットとプライベートサブネットを合計で6つ作成します。<br>以下のtfファイルを作成します。</p><figure class="highlight bash"><figcaption><span>subnet.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_subnet"</span> <span class="string">"public_subnet"</span> &#123;</span><br><span class="line">  for_each          = local.subnet_numbers</span><br><span class="line">  vpc_id            = aws_vpc.vpc.id</span><br><span class="line">  availability_zone = each.key</span><br><span class="line">  cidr_block        = cidrsubnet(aws_vpc.vpc.cidr_block, 8, each.value)</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-private"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_subnet"</span> <span class="string">"private_subnet"</span> &#123;</span><br><span class="line">  for_each          = local.subnet_numbers</span><br><span class="line">  vpc_id            = aws_vpc.vpc.id</span><br><span class="line">  availability_zone = each.key</span><br><span class="line">  cidr_block        = cidrsubnet(aws_vpc.vpc.cidr_block, 8, each.value + 3)</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-private"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Internet-Gatewayとルートテーブル"><a href="#Internet-Gatewayとルートテーブル" class="headerlink" title="Internet Gatewayとルートテーブル"></a>Internet Gatewayとルートテーブル</h2><p>Internet Gatewayを作成します。</p><figure class="highlight bash"><figcaption><span>igw.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_internet_gateway"</span> <span class="string">"igw"</span> &#123;</span><br><span class="line">  vpc_id = aws_vpc.vpc.id</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ルートテーブルを作成します。</p><figure class="highlight bash"><figcaption><span>route_table.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_route_table"</span> <span class="string">"public"</span> &#123;</span><br><span class="line">  vpc_id = aws_vpc.vpc.id</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-public"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_route_table"</span> <span class="string">"private"</span> &#123;</span><br><span class="line">  vpc_id = aws_vpc.vpc.id</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-private"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>パブリックサブネットとプライベートサブネットをルートテーブルに紐付けます。</p><figure class="highlight bash"><figcaption><span>route_association.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_route_table_association"</span> <span class="string">"public"</span> &#123;</span><br><span class="line">  for_each       = local.subnet_numbers</span><br><span class="line">  subnet_id      = aws_subnet.public_subnet[each.key].id</span><br><span class="line">  route_table_id = aws_route_table.public.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_route_table_association"</span> <span class="string">"private"</span> &#123;</span><br><span class="line">  for_each       = local.subnet_numbers</span><br><span class="line">  subnet_id      = aws_subnet.private_subnet[each.key].id</span><br><span class="line">  route_table_id = aws_route_table.private.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ルーティングを定義します。</p><ul><li>パブリックサブネットから<code>0.0.0.0/0</code>にアクセスする場合は、<code>Internet Gatewat</code>への向き先を指定</li><li>プライベートサブネットから<code>0.0.0.0/0</code>にアクセスする場合は、<code>NAT Gatewat</code>への向き先を指定</li></ul><figure class="highlight bash"><figcaption><span>route.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_route"</span> <span class="string">"public"</span> &#123;</span><br><span class="line">  route_table_id         = aws_route_table.public.id</span><br><span class="line">  gateway_id             = aws_internet_gateway.igw.id</span><br><span class="line">  destination_cidr_block = <span class="string">"0.0.0.0/0"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_route"</span> <span class="string">"private"</span> &#123;</span><br><span class="line">  route_table_id         = aws_route_table.private.id</span><br><span class="line">  gateway_id             = aws_nat_gateway.nat_gateway.id</span><br><span class="line">  destination_cidr_block = <span class="string">"0.0.0.0/0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NAT-Gateway"><a href="#NAT-Gateway" class="headerlink" title="NAT Gateway"></a>NAT Gateway</h3><p>パブリックサブネットに<code>NAT Gateway</code>を１台構築します。<br>NAT Gatewayは、固定グローバルIPをアタッチする必要があるので<code>EIP</code>を作成します。<br>また、各サブネットに対してのルートテーブルも定義します。</p><figure class="highlight bash"><figcaption><span>nat_gateway.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_nat_gateway"</span> <span class="string">"nat_gateway"</span> &#123;</span><br><span class="line">  allocation_id = aws_eip.nat_gateway.id</span><br><span class="line">  subnet_id     = aws_subnet.public_subnet[<span class="string">"ap-southeast-2a"</span>].id</span><br><span class="line">  depends_on    = [aws_internet_gateway.igw]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>eip.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_eip"</span> <span class="string">"nat_gateway"</span> &#123;</span><br><span class="line">  vpc        = <span class="literal">true</span></span><br><span class="line">  depends_on = [aws_internet_gateway.igw]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-nat"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="S3-Endpoint"><a href="#S3-Endpoint" class="headerlink" title="S3 Endpoint"></a>S3 Endpoint</h2><p>S3 Endpointを作成します。</p><figure class="highlight bash"><figcaption><span>vpc_endpoint.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_vpc_endpoint"</span> <span class="string">"s3"</span> &#123;</span><br><span class="line">  vpc_id       = aws_vpc.vpc.id</span><br><span class="line">  service_name = <span class="string">"com.amazonaws.<span class="variable">$&#123;local.region&#125;</span>.s3"</span></span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>-s3"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = local.project_name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_vpc_endpoint_route_table_association"</span> <span class="string">"private_s3"</span> &#123;</span><br><span class="line">  vpc_endpoint_id = aws_vpc_endpoint.s3.id</span><br><span class="line">  route_table_id  = aws_route_table.private.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>現在利用しているリージョンをデータリソースから取得し、ローカル変数で定義しています。</p><figure class="highlight bash"><figcaption><span>variable（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data <span class="string">"aws_region"</span> <span class="string">"current"</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  region       = data.aws_region.current.name</span><br></pre></td></tr></table></figure><h2 id="ちょっとした解説②"><a href="#ちょっとした解説②" class="headerlink" title="ちょっとした解説②"></a>ちょっとした解説②</h2><h3 id="リソースの参照"><a href="#リソースの参照" class="headerlink" title="リソースの参照"></a>リソースの参照</h3><p>以下は、先ほど作成したvpcの<code>id</code>を取得するための構文です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vpc_id            = aws_vpc.vpc.id</span><br></pre></td></tr></table></figure><h3 id="cidrsubnet"><a href="#cidrsubnet" class="headerlink" title="cidrsubnet"></a>cidrsubnet</h3><p>本記事のサブネットは、以下のレンジで作成しています。</p><ul><li>Public Subnetework<ul><li>10.0.0.0/24</li><li>10.0.1.0/24</li><li>10.0.2.0/24</li></ul></li><li>Private subnetwork<ul><li>10.0.3.0/24</li><li>10.0.4.0/24</li><li>10.0.5.0/24</li></ul></li></ul><p>そこで役に立つのが、<a href="https://www.terraform.io/docs/configuration/functions/cidrsubnet.html" target="_blank" rel="noopener">cidrsubnet Function</a>です。<br><code>cidrsubnet</code>は、以下のように3つの引数を持つ関数で、IPレンジをいい感じに分割してくれます。</p><blockquote><p>cidrsubnet(prefix, newbits, netnum)</p></blockquote><p>今回のケースで、値を割り当てると以下のかたちになります。</p><ul><li>prefix: 10.0.0.0/16</li><li>newbits: 8</li><li>netnum: 0（ここはcountでインクリメントされる）</li></ul><p>具体的にどう変換されるかを<code>terraform console</code>で確認してみます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ terraform console</span><br><span class="line">&gt; cidrsubnet(<span class="string">"10.0.0.0/16"</span>, 8, 0)</span><br><span class="line">10.0.0.0/24</span><br><span class="line">&gt; cidrsubnet(<span class="string">"10.0.0.0/16"</span>, 8, 1)</span><br><span class="line">10.0.1.0/24</span><br></pre></td></tr></table></figure><p>このようにサブネットの結果が不安な場合は、<code>terraform console</code>を利用すると捗ります。</p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>NAT GatewayとEIPは、Internet Gatewayに依存しています。<br>そこで、<code>depends_on</code>を記述することで明示的に依存関係を記すことで、先にInternet Gatewayを構築し、その後にEIPとNAT Gatewayを構築するという流れを確立できます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends_on = [aws_internet_gateway.igw]</span><br></pre></td></tr></table></figure><h1 id="Production-環境の構築"><a href="#Production-環境の構築" class="headerlink" title="Production 環境の構築"></a>Production 環境の構築</h1><p>コードの変更は不要です。<br>Workspaceの<code>prd</code>に切り替えて<code>terraform apply</code>するだけです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace selece prd</span><br><span class="line">$ terraform plan</span><br><span class="line">$ terraform apply</span><br></pre></td></tr></table></figure><p>めっちゃ簡単ですね！</p><p>ここまででVPCの構築が完了しました。</p><h1 id="最終的なVariable-tf"><a href="#最終的なVariable-tf" class="headerlink" title="最終的なVariable.tf"></a>最終的なVariable.tf</h1><p>本記事で作成した<code>variable.tf</code>です。</p><figure class="highlight bash"><figcaption><span>variable.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data <span class="string">"aws_region"</span> <span class="string">"current"</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  project_name = <span class="string">"example"</span></span><br><span class="line">  region       = data.aws_region.current.name</span><br><span class="line"></span><br><span class="line">  vpc_cidr = &#123;</span><br><span class="line">    stg = <span class="string">"10.0.0.0/16"</span></span><br><span class="line">    prd = <span class="string">"10.1.0.0/16"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subnet_numbers = &#123;</span><br><span class="line">    <span class="string">"ap-southeast-2a"</span> = 0</span><br><span class="line">    <span class="string">"ap-southeast-2b"</span> = 1</span><br><span class="line">    <span class="string">"ap-southeast-2c"</span> = 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Terraform-0-12-変更点"><a href="#Terraform-0-12-変更点" class="headerlink" title="Terraform 0.12 変更点"></a>Terraform 0.12 変更点</h1><p>この章では、Terraform 0.12とそれ以前での変更点をまとめていきます。</p><h3 id="面倒だったブロックが不要になったよ"><a href="#面倒だったブロックが不要になったよ" class="headerlink" title="面倒だったブロックが不要になったよ"></a>面倒だったブロックが不要になったよ</h3><p>ブロックやダブルクォーテーション（<code>&quot;${}&quot;</code>）で囲う必要がなくなりました。<br>ただし、変数同士を繋いで表現する場合（NameやEnv）は、囲う必要があります（tagの部分）</p><h3 id="Terraform-0-11系"><a href="#Terraform-0-11系" class="headerlink" title="Terraform 0.11系"></a>Terraform 0.11系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_vpc"</span> <span class="string">"vpc"</span> &#123;</span><br><span class="line">  cidr_block = <span class="string">"<span class="variable">$&#123;local.vpc_cidr[terraform.workspace]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = <span class="string">"<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Terraform-0-12系"><a href="#Terraform-0-12系" class="headerlink" title="Terraform 0.12系"></a>Terraform 0.12系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_vpc"</span> <span class="string">"vpc"</span> &#123;</span><br><span class="line">  cidr_block = local.vpc_cidr[terraform.workspace]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name    = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>-<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">    Env     = <span class="string">"<span class="variable">$&#123;terraform.workspace&#125;</span>"</span></span><br><span class="line">    Project = <span class="string">"<span class="variable">$&#123;local.project_name&#125;</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="無口なValidateが返信してくれるようになった"><a href="#無口なValidateが返信してくれるようになった" class="headerlink" title="無口なValidateが返信してくれるようになった"></a>無口なValidateが返信してくれるようになった</h3><p><code>terraform validate</code>を実行すると<code>Success!</code>って、反応が返ってくるようになりました。</p><h4 id="Terraform-0-11系-1"><a href="#Terraform-0-11系-1" class="headerlink" title="Terraform 0.11系"></a>Terraform 0.11系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform validate</span><br></pre></td></tr></table></figure><h4 id="Terraform-0-12系-1"><a href="#Terraform-0-12系-1" class="headerlink" title="Terraform 0.12系"></a>Terraform 0.12系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform validate</span><br><span class="line">Success! The configuration is valid.</span><br></pre></td></tr></table></figure><h3 id="Planなどの実行結果がわかりやすくなった"><a href="#Planなどの実行結果がわかりやすくなった" class="headerlink" title="Planなどの実行結果がわかりやすくなった"></a>Planなどの実行結果がわかりやすくなった</h3><p>劇的な変化はないですが、見やすくなりました。</p><h4 id="Terraform-0-11系-2"><a href="#Terraform-0-11系-2" class="headerlink" title="Terraform 0.11系"></a>Terraform 0.11系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  + aws_vpc.vpc</span><br><span class="line">      id:                               &lt;computed&gt;</span><br><span class="line">      arn:                              &lt;computed&gt;</span><br><span class="line">      assign_generated_ipv6_cidr_block: <span class="string">"false"</span></span><br><span class="line">      cidr_block:                       <span class="string">"10.0.0.0/24"</span></span><br><span class="line">      default_network_acl_id:           &lt;computed&gt;</span><br><span class="line">      default_route_table_id:           &lt;computed&gt;</span><br><span class="line">      default_security_group_id:        &lt;computed&gt;</span><br><span class="line">      dhcp_options_id:                  &lt;computed&gt;</span><br><span class="line">      enable_classiclink:               &lt;computed&gt;</span><br><span class="line">      enable_classiclink_dns_support:   &lt;computed&gt;</span><br><span class="line">      enable_dns_hostnames:             &lt;computed&gt;</span><br><span class="line">      enable_dns_support:               <span class="string">"true"</span></span><br><span class="line">      instance_tenancy:                 <span class="string">"default"</span></span><br><span class="line">      ipv6_association_id:              &lt;computed&gt;</span><br><span class="line">      ipv6_cidr_block:                  &lt;computed&gt;</span><br><span class="line">      main_route_table_id:              &lt;computed&gt;</span><br><span class="line">      owner_id:                         &lt;computed&gt;</span><br><span class="line">      tags.%:                           <span class="string">"3"</span></span><br><span class="line">      tags.Env:                         <span class="string">"stg"</span></span><br><span class="line">      tags.Name:                        <span class="string">"stg-example"</span></span><br><span class="line">      tags.Project:                     <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure><h4 id="Terraform-0-12系-2"><a href="#Terraform-0-12系-2" class="headerlink" title="Terraform 0.12系"></a>Terraform 0.12系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># aws_vpc.vpc will be created</span></span><br><span class="line">  + resource <span class="string">"aws_vpc"</span> <span class="string">"vpc"</span> &#123;</span><br><span class="line">      + arn                              = (known after apply)</span><br><span class="line">      + assign_generated_ipv6_cidr_block = <span class="literal">false</span></span><br><span class="line">      + cidr_block                       = <span class="string">"10.0.0.0/24"</span></span><br><span class="line">      + default_network_acl_id           = (known after apply)</span><br><span class="line">      + default_route_table_id           = (known after apply)</span><br><span class="line">      + default_security_group_id        = (known after apply)</span><br><span class="line">      + dhcp_options_id                  = (known after apply)</span><br><span class="line">      + enable_classiclink               = (known after apply)</span><br><span class="line">      + enable_classiclink_dns_support   = (known after apply)</span><br><span class="line">      + enable_dns_hostnames             = (known after apply)</span><br><span class="line">      + enable_dns_support               = <span class="literal">true</span></span><br><span class="line">      + id                               = (known after apply)</span><br><span class="line">      + instance_tenancy                 = <span class="string">"default"</span></span><br><span class="line">      + ipv6_association_id              = (known after apply)</span><br><span class="line">      + ipv6_cidr_block                  = (known after apply)</span><br><span class="line">      + main_route_table_id              = (known after apply)</span><br><span class="line">      + owner_id                         = (known after apply)</span><br><span class="line">      + tags                             = &#123;</span><br><span class="line">          + <span class="string">"Env"</span>     = <span class="string">"stg"</span></span><br><span class="line">          + <span class="string">"Name"</span>    = <span class="string">"stg-example"</span></span><br><span class="line">          + <span class="string">"Project"</span> = <span class="string">"example"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure><h2 id="for-eachの導入"><a href="#for-eachの導入" class="headerlink" title="for_eachの導入"></a>for_eachの導入</h2><p><code>for_each</code>が使えるようになりました！<br>これは個人的には革新的で今まで抱えていた問題を解決する一つの武器となると思っています。</p><h3 id="Terraform-0-11系-3"><a href="#Terraform-0-11系-3" class="headerlink" title="Terraform 0.11系"></a>Terraform 0.11系</h3><p>サブネットを作成するときに以下のように<code>count</code>を利用するケースがありました。</p><figure class="highlight bash"><figcaption><span>sample_subnet.tf（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data <span class="string">"aws_availability_zones"</span> <span class="string">"available"</span> &#123;</span><br><span class="line">  state = <span class="string">"available"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_subnet"</span> <span class="string">"public_subnet"</span> &#123;</span><br><span class="line">  count             = 3</span><br><span class="line">  vpc_id            = aws_vpc.vpc.id</span><br><span class="line">  availability_zone = <span class="string">"<span class="variable">$&#123;data.aws_availability_zones.available.names[count.index]&#125;</span>"</span></span><br><span class="line">  cidr_block        = cidrsubnet(aws_vpc.vpc.cidr_block, 8, count.index + 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一見問題ないように見えるのですが、<code>count</code>を利用しているため、数字をインクリメントしてリストが作成されていきます。<br>その結果、リストの変更などでインデックスがずれてしまう問題が発生する可能性がありました。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aws_subnet.public_subnet[0] will be created</span><br></pre></td></tr></table></figure><h3 id="Terraform-0-12系-3"><a href="#Terraform-0-12系-3" class="headerlink" title="Terraform 0.12系"></a>Terraform 0.12系</h3><p><code>0.12.6</code>から<code>for_each</code>をマップ形式でアクセスできるようになりました。<br>以下のように<code>for_each</code>で定義し、<code>each.key</code>と<code>each.value</code>で各要素にアクセスできます。</p><figure class="highlight bash"><figcaption><span>subnet.tf（抜粋）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">"aws_subnet"</span> <span class="string">"public_subnet"</span> &#123;</span><br><span class="line">  for_each          = local.subnet_numbers</span><br><span class="line">  vpc_id            = aws_vpc.vpc.id</span><br><span class="line">  availability_zone = each.key</span><br><span class="line">  cidr_block        = cidrsubnet(aws_vpc.vpc.cidr_block, 8, each.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"aws_subnet"</span> <span class="string">"private_subnet"</span> &#123;</span><br><span class="line">  for_each          = local.subnet_numbers</span><br><span class="line">  vpc_id            = aws_vpc.vpc.id</span><br><span class="line">  availability_zone = each.key</span><br><span class="line">  cidr_block        = cidrsubnet(aws_vpc.vpc.cidr_block, 8, each.value + 3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for_each</code>で参照する定義をvariable.tfに追記します。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnet_numbers = &#123;</span><br><span class="line">  &quot;ap-southeast-2a&quot; = 1</span><br><span class="line">  &quot;ap-southeast-2b&quot; = 2</span><br><span class="line">  &quot;ap-southeast-2c&quot; = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NAT Gateway</code>のように一つのサブネットに作成したい場合などに役立ちます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subnet_id     = aws_subnet.public_subnet[&quot;ap-southeast-2a&quot;].id</span><br></pre></td></tr></table></figure><p>ちなみに、<code>0.12.6</code>より古いバージョンで<code>terraform validate</code>を実行するとエラーが発生します。</p><figure class="highlight bash"><figcaption><span>Error（terrform0.12.5実行結果）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error: Reserved argument name <span class="keyword">in</span> resource block</span><br><span class="line"></span><br><span class="line">  on subnet.tf line 2, <span class="keyword">in</span> resource <span class="string">"aws_subnet"</span> <span class="string">"public_subnet"</span>:</span><br><span class="line">   2:   for_each          = local.subnet_numbers</span><br><span class="line"></span><br><span class="line">The name <span class="string">"for_each"</span> is reserved <span class="keyword">for</span> use <span class="keyword">in</span> a future version of Terraform.</span><br></pre></td></tr></table></figure><h2 id="lookupについて"><a href="#lookupについて" class="headerlink" title="lookupについて"></a>lookupについて</h2><p>今回の構成では、お伝えすることができなかったのですが、Terraform 0.12からlookupの書き方が変わったので変更点を以下に記載します。</p><h3 id="Terraform-0-11系-4"><a href="#Terraform-0-11系-4" class="headerlink" title="Terraform 0.11系"></a>Terraform 0.11系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance_type               = <span class="string">"<span class="variable">$&#123;lookup(local.ec2_config[terraform.workspace], "instance_type")&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="Terraform-0-12系-4"><a href="#Terraform-0-12系-4" class="headerlink" title="Terraform 0.12系"></a>Terraform 0.12系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance_type               = local.ec2_config[terraform.workspace][<span class="string">"instance_type"</span>]</span><br></pre></td></tr></table></figure><h1 id="Terraform-0-11-14からアップグレードする方法"><a href="#Terraform-0-11-14からアップグレードする方法" class="headerlink" title="Terraform 0.11.14からアップグレードする方法"></a>Terraform 0.11.14からアップグレードする方法</h1><p>ここからは、すでにTerraform0.11系を利用している方のために、ざっくりですが0.12にアップグレードする方法を記載します。</p><h2 id="Terraform-アップグレード"><a href="#Terraform-アップグレード" class="headerlink" title="Terraform アップグレード"></a>Terraform アップグレード</h2><p>Terraform 0.11.14でinitを実行します<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init</span><br></pre></td></tr></table></figure><p>Workspaceを切り替えます（Workspace環境を前提にしています。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">$ terraform workspace select stg</span><br></pre></td></tr></table></figure><p><code>terraform plan</code>を実行します。<br>もし、planを実行し、差分が発生した場合はTerraform 0.12に対応した構文に変更する必要があります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br></pre></td></tr></table></figure><p><code>checklistコマンド</code>を実行し、アップグレード可能な状態かを確認します。<br>問題がなければ<code>Looks good!</code>と出力されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ terraform_0.11 0.12checklist</span><br><span class="line">Looks good! We did not detect any problems that ought to be</span><br><span class="line">addressed before upgrading to Terraform v0.12.</span><br><span class="line"></span><br><span class="line">This tool is not perfect though, so please check the v0.12 upgrade</span><br><span class="line">guide <span class="keyword">for</span> additional guidance, and <span class="keyword">for</span> next steps:</span><br><span class="line">    https://www.terraform.io/upgrade-guides/0-12.html</span><br></pre></td></tr></table></figure><p>terraformのバージョンを0.12に変更し、initを実行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init</span><br></pre></td></tr></table></figure><p><code>upgradeコマンド</code>を実行します。<br>問題がなければ<code>Upgrade complete!</code>と出力されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform 0.12upgrade</span><br><span class="line">Upgrade complete!</span><br></pre></td></tr></table></figure><p><code>plan</code>を実行し、問題が発生しなければアップグレード完了です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terrafrom plan</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>いかがでしたか？</p><p>Terraform 0.12になったことで、構文が変わって戸惑う場面もあるかと思いますが、それ以上に恩恵を授かれることを少しでも感じ取ってもらえたのではないでしょうか。また、これを機にTerraformを触ってみたいぞ！って方が増えたら嬉しいです。</p><p>今回は、VPCの話しかできなかったので、次回は更にこの環境を大きくしていき、皆さんのお役に立てる記事を書いていきたいと思います。</p><p>ありがとうございました！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.terraform.io/upgrade-guides/0-12.html" target="_blank" rel="noopener">Upgrading to Terraform v0.12</a><br><a href="https://www.terraform.io/docs/configuration/resources.html#for_each-multiple-resource-instances-defined-by-a-map-or-set-of-strings" target="_blank" rel="noopener">Resouces</a><br><a href="https://www.hashicorp.com/blog/hashicorp-terraform-0-12-preview-for-and-for-each" target="_blank" rel="noopener">Terraform 0.12 Preview</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Terraformを0.12にアップグレードする場合は、<code>0.11.14</code>まで上げる必要があります。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちはー&lt;br&gt;TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;foot
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
      <category term="Terraform" scheme="https://future-architect.github.io/tags/Terraform/"/>
    
  </entry>
  
  <entry>
    <title>はじめてのTerraform 0.12 ～環境構築～</title>
    <link href="https://future-architect.github.io/articles/20190816/"/>
    <id>https://future-architect.github.io/articles/20190816/</id>
    <published>2019-08-16T03:43:21.000Z</published>
    <updated>2019-08-18T22:35:23.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちはー<br>TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>のゆるふわエンジニアの前原です。</p><p>最近は、プラットフォームを新規で構築するプロジェクトや、既存の環境を運用改善していくプロジェクトに従事しています。その中で私はクラウドインフラ部分を担当しており、アーキテクチャデザインや、Terraform・Ansible・Packerといった構成管理ツールを利用したAWSやGCP環境の構築をしています。</p><p>本記事では、最近バージョンアップしたTerraform 0.12の構文がこんな感じで変わったよー的な話を伝えていきます。</p><p>大きくは以下の流れで進めます。</p><ol><li>Terraformの事始め (今回の記事です)</li><li>Terraform 0.12でVPCを構築する （<a href="https://future-architect.github.io/articles/20190819/">次回の記事</a>で説明します！）</li></ol><p>これからTerraformを触っていきたいといった方にもわかるように書いていきます。<br>そのため少し長めの内容になってしまいますが、お付き合いください。</p><h1 id="Terraformとは"><a href="#Terraformとは" class="headerlink" title="Terraformとは"></a>Terraformとは</h1><p><a href="https://www.terraform.io/" target="_blank" rel="noopener">Terraform</a>は、<a href="https://www.hashicorp.com/" target="_blank" rel="noopener">HashiCorp</a>によって開発された構成管理ツールで、主にクラウド環境（クラウド以外でも利用可能）を構築するときに利用します。</p><p>Terraformなどのツールを利用しない場合は、ブラウザを通してGUIから構築するケースがあるかと思います。その場合は、作業ミスをなくすために設定手順書やパラメータシートを元に構築するかとおもいますが、規模が大きくなったり関わる人が多くなってくると、人による設定ミスなどが発生することも多いのでは無いでしょうか。ミスを回避するために、各種施策やドキュメントの陳腐化を防ぐ方法に時間を費やすことも多々あるでしょう。</p><p>そういったケースにTerraformのような構成管理ツールを利用することで、インフラの構成をコードに落とし込み、状態を定義することができるようになります。</p><p>これにより誰が実行しても結果が同じになることで、ミスを低減することが可能です。また、コードを見ることで常にインフラの最新状態を把握することができます。また、コード化しているため、Gitなどのバージョン管理システムで管理することもできます。</p><p>…と、ここまでメリットについて書きましたが、いざTerraformを使用するとそれなりに学習コストが必要となります。</p><h1 id="Terraformの事始め"><a href="#Terraformの事始め" class="headerlink" title="Terraformの事始め"></a>Terraformの事始め</h1><p>ここでは、Terraformを実行するための環境をつくります。</p><h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><p>Terraformを体験するために以下の環境で行います。</p><ul><li><code>AWS</code></li><li><code>Terraform: 0.12.6</code> &amp; <code>0.11.14</code></li><li><code>tfenv: 1.0.1</code></li><li><code>MacBook Pro Mojave</code> or <code>Windows10 64bit</code></li></ul><h2 id="Terraformのインストール"><a href="#Terraformのインストール" class="headerlink" title="Terraformのインストール"></a>Terraformのインストール</h2><p>Terraformのインストールを行います。</p><h3 id="MacOSの場合"><a href="#MacOSの場合" class="headerlink" title="MacOSの場合"></a>MacOSの場合</h3><p>Terraformの実行環境を準備します。<br>今回は、バージョンの切り替えを楽にしてくれる<a href="https://github.com/tfutils/tfenv" target="_blank" rel="noopener">tfenv</a>を利用します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Install tfenv</span></span><br><span class="line">$ brew install tfenv</span><br><span class="line">$ tfenv -v</span><br><span class="line">tfenv 1.0.1</span><br></pre></td></tr></table></figure><p>tfenvでterraformをインストールし、使用可能なバージョンを確認します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tfenv install latest</span><br><span class="line">$ tfenv install 0.11.14</span><br><span class="line">$ tfenv list</span><br><span class="line">* 0.12.6 (<span class="built_in">set</span> by /usr/<span class="built_in">local</span>/Cellar/tfenv/1.0.1/version)</span><br><span class="line">  0.11.14</span><br></pre></td></tr></table></figure><p>バージョンの切り替えは、<code>use</code>を利用することで簡単に切り替えることができます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tfenv use 0.11.14</span><br><span class="line">[INFO] Switching to v0.11.14</span><br><span class="line">[INFO] Switching completed</span><br></pre></td></tr></table></figure><p>tfenvを使用しない場合は、<a href="https://learn.hashicorp.com/terraform/getting-started/install.html" target="_blank" rel="noopener">こちら</a>のサイトを確認してください。</p><h3 id="Windowsの場合"><a href="#Windowsの場合" class="headerlink" title="Windowsの場合"></a>Windowsの場合</h3><p>Terraformを<a href="https://www.terraform.io/downloads.html" target="_blank" rel="noopener">ダウンロード</a>します。<br>ダウンロードしたファイルを解凍し、<code>C:¥Windows</code>配下に<code>terraform.exe</code>を配置します。<br>コマンドプロントもしくはお使いのターミナルを開き、以下のコマンドを発行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform version</span><br><span class="line">Terraform v0.12.6</span><br></pre></td></tr></table></figure><p>ここでは試しておりませんが、Windowsもtfenv（only git-bash）に対応しているので興味のある方は試して頂ければと思います。  </p><ul><li>GitHub: <a href="https://github.com/tfutils/tfenv" target="_blank" rel="noopener">tfenv</a></li></ul><h2 id="Terraform-を実行するまでにやること"><a href="#Terraform-を実行するまでにやること" class="headerlink" title="Terraform を実行するまでにやること"></a>Terraform を実行するまでにやること</h2><h3 id="環境変数の設定"><a href="#環境変数の設定" class="headerlink" title="環境変数の設定"></a>環境変数の設定</h3><p>AWSのAPIを発行するために必要な設定です。<br>AWSのIAM Userであらかじめユーザを作成し、アクセスキーとシークレットキーを環境変数にセットします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MacOSの場合</span></span><br><span class="line">$ <span class="built_in">export</span> AWS_ACCESS_KEY_ID=xxx</span><br><span class="line">$ <span class="built_in">export</span> AWS_SECRET_ACCESS_KEY=xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windowsの場合</span></span><br><span class="line">$ <span class="built_in">set</span> AWS_ACCESS_KEY_ID=xxx</span><br><span class="line">$ <span class="built_in">set</span> AWS_SECRET_ACCESS_KEY=xxx</span><br></pre></td></tr></table></figure><p>MacOSの場合に限りますが、複数のAWSアカウント扱っている場合は、<a href="https://direnv.net/" target="_blank" rel="noopener">direnv</a>を利用するとディレクトリ単位で環境変数を切り替えることができるため便利です。</p><p>もし、HTTP Proxy配下の環境で実行したい場合は以下のオプションも追加で設定ください。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MacOSの場合</span></span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=https://proxy.example.com:443</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windowsの場合</span></span><br><span class="line"><span class="built_in">set</span> HTTPS_PROXY=https://proxy.example.com:443</span><br></pre></td></tr></table></figure><h3 id="tfstateファイルの管理について"><a href="#tfstateファイルの管理について" class="headerlink" title="tfstateファイルの管理について"></a>tfstateファイルの管理について</h3><p>tfstateファイルは、Terraformで管理しているインフラの状態を管理するためのファイルです。<br>このファイルは非常に大切です。</p><p>通常、tfstateファイルを保存する場所を指定しない場合は、Terraformを実行したディレクトリに保存されます。<br>そのため、複数人でTerraformを実行する環境や、可用性を意識するとローカルでの保存はイケてないです。</p><p>そこで、tfstateファイルを管理するためのS3 バケットを用意します。<br>（<a href="https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/install-macos.html" target="_blank" rel="noopener">AWS CLI</a>が実行できることを前提とします）<br>また、バケットはバージョニングの設定をします。<br>バージョニングすることでtfstateファイルに予期せぬ更新や、壊してしまった時に戻せるようにするためです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### バケットの作成</span></span><br><span class="line">$ aws s3 mb s3://example-bucket --region ap-southeast-2</span><br><span class="line"><span class="comment">### バージョニングの設定</span></span><br><span class="line">$ aws s3api put-bucket-versioning --bucket example-bucket --versioning-configuration Status=Enabled</span><br><span class="line"><span class="comment">### バージョニングの設定ができていることを確認します</span></span><br><span class="line">$ aws s3api get-bucket-versioning --bucket example-bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Status"</span>: <span class="string">"Enabled"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="リージョンの選択"><a href="#リージョンの選択" class="headerlink" title="リージョンの選択"></a>リージョンの選択</h3><p>リージョンは適切に選択してください。<br>もし学習用途であればバージニア（us-east-1）を利用することを個人的におすすめします。<br>理由は、単純に安いからです！</p><p>ただ、本記事は諸事情によりシドニーで構築しています（ap-southeast-2）</p><h2 id="Terraformのディレクトリ構成"><a href="#Terraformのディレクトリ構成" class="headerlink" title="Terraformのディレクトリ構成"></a>Terraformのディレクトリ構成</h2><p>以下のようなフラットなディレクトリ構成で、1つのディレクトリにtfファイルを配置する設計にします。</p><p>以下の3つのtfファイルについては、次章以降で説明します。</p><ul><li>backend.tf</li><li>provider.tf</li><li>versions.tf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── backend.tf</span><br><span class="line">├── provider.tf</span><br><span class="line">├── versions.tf</span><br><span class="line">└── ...(次回の記事で説明します)</span><br></pre></td></tr></table></figure><h2 id="Backendの指定"><a href="#Backendの指定" class="headerlink" title="Backendの指定"></a>Backendの指定</h2><p>tfstateファイルをS3 バケットで管理するため、Backend用のtfファイルを作成します。<br>先ほどAWS CLIで作成したバケットを指定します。</p><figure class="highlight bash"><figcaption><span>backend.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend <span class="string">"s3"</span> &#123;</span><br><span class="line">    bucket = <span class="string">"example-bucket"</span></span><br><span class="line">    key    = <span class="string">"state/service"</span></span><br><span class="line">    region = <span class="string">"ap-southeast-2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Providerの指定"><a href="#Providerの指定" class="headerlink" title="Providerの指定"></a>Providerの指定</h2><p>Terraformは、AWSだけでなく、GCP、Alibaba Cloudなど様々なプロバイダに対応しています。<br>今回は、AWSを利用するための定義をします。<br>また、リージョンを指定します。</p><figure class="highlight bash"><figcaption><span>provider.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">provider <span class="string">"aws"</span> &#123;</span><br><span class="line">  region = <span class="string">"ap-southeast-2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Versions"><a href="#Versions" class="headerlink" title="Versions"></a>Versions</h3><p>このファイルはなくても問題ないのですが、Terraform 0.12から構文が変わっているため、明示的に記述します。<br>以下により<code>0.12</code>以上のバージョンでないと実行できないようになっています。<br>（Terraformのアップグレードコマンドで0.12にした場合は、自動で作成されます）</p><figure class="highlight bash"><figcaption><span>versions.tf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_version = <span class="string">"&gt;= 0.12"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Terraform-init"><a href="#Terraform-init" class="headerlink" title="Terraform init"></a>Terraform init</h2><p>準備が整ったので、Terraformを実行します。<br>まず、Terraformのワークスペースの初期化や、プラグインをダウンロードするために<code>terraform init</code>を実行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init</span><br></pre></td></tr></table></figure><p>問題がなければ以下のようなメッセージが出力されます。</p><blockquote><p>Terraform has been successfully initialized!</p></blockquote><p>仮に<code>0.11.14</code>で<code>terraform init</code>を実行すると以下の結果になります。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> terraform init</span></span><br><span class="line"></span><br><span class="line">Initializing the backend...</span><br><span class="line">Backend configuration changed!</span><br><span class="line"></span><br><span class="line">Terraform has detected that the configuration specified for the backend</span><br><span class="line">has changed. Terraform will now check for existing state in the backends.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Successfully configured the backend "s3"! Terraform will automatically</span><br><span class="line">use this backend unless the backend configuration changes.</span><br><span class="line"></span><br><span class="line">Error: The currently running version of Terraform doesn't meet the</span><br><span class="line">version requirements explicitly specified by the configuration.</span><br><span class="line">Please use the required version or update the configuration.</span><br><span class="line">Note that version requirements are usually set for a reason, so</span><br><span class="line">we recommend verifying with whoever set the version requirements</span><br><span class="line">prior to making any manual changes.</span><br><span class="line"></span><br><span class="line">  Module: root</span><br><span class="line">  Required version: &gt;= 0.12</span><br><span class="line">  Current version: 0.11.14</span><br></pre></td></tr></table></figure><h2 id="Workspaces-の準備"><a href="#Workspaces-の準備" class="headerlink" title="Workspaces の準備"></a>Workspaces の準備</h2><p>本構成は、<code>stg</code>と<code>prd</code> の二つの環境を構築します。<br>stgはStaging(検証環境)、prdはProduction(本番環境)の略です。</p><p>Terraformでは、複数の環境を構築するにあたって便利な<code>Workkspace</code>があります。<br>Workspaceを使うことで、ディレクトリで環境を分けることなく、コード内で識別することが可能となります。</p><p>それでは、Workspaceコマンドで<code>stg</code>と<code>prd</code>を作成します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new stg</span><br><span class="line">Created and switched to workspace <span class="string">"stg"</span>!</span><br><span class="line">$ terraform workspace new prd</span><br><span class="line">Created and switched to workspace <span class="string">"prd"</span>!</span><br></pre></td></tr></table></figure><p>現在のWorkspaceを確認します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace show</span><br><span class="line">prd</span><br></pre></td></tr></table></figure><p>最後に作成した<code>prd</code>が対象になっているため、変更します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace select stg</span><br><span class="line">Switched to workspace <span class="string">"stg"</span>.</span><br><span class="line">$ terraform workspace show</span><br><span class="line">stg</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>これで、いよいよTerraformで環境構築できる準備が整いました。<br>次回の記事では実際のAWSリソースのTerraform定義から、VPCを作成する手順を説明していきますのでお楽しみに！</p><ul><li><a href="https://future-architect.github.io/articles/20190819/">はじめてのTerraform 0.12 ～実践編～</a><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちはー&lt;br&gt;TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;foot
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
      <category term="Terraform" scheme="https://future-architect.github.io/tags/Terraform/"/>
    
  </entry>
  
  <entry>
    <title>WAFとして go-swagger を選択してみた</title>
    <link href="https://future-architect.github.io/articles/20190814/"/>
    <id>https://future-architect.github.io/articles/20190814/</id>
    <published>2019-08-14T01:30:07.000Z</published>
    <updated>2019-08-14T01:18:37.523Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の多賀です。<br>2019年7月にキャリア入社しました。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Go のWebアプリケーションフレームワークを検討した際に、 <code>go-swagger</code> が良いのではと思い、比較調査してみました。</p><p>その結果、実際にPJへ導入しています。</p><h2 id="バージョン"><a href="#バージョン" class="headerlink" title="バージョン"></a>バージョン</h2><table><thead><tr><th align="left">名称</th><th align="left">バージョン</th></tr></thead><tbody><tr><td align="left">Go</td><td align="left">1.12.7</td></tr><tr><td align="left"><a href="https://github.com/go-swagger/go-swagger" target="_blank" rel="noopener">go-swagger</a></td><td align="left">v0.19.0</td></tr><tr><td align="left"><a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">swaggo/swag</a></td><td align="left">v1.6.2</td></tr><tr><td align="left"><a href="https://github.com/OpenAPITools/openapi-generator" target="_blank" rel="noopener">openapi-generator</a></td><td align="left">4.0.3</td></tr><tr><td align="left"><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a></td><td align="left">v1.4.0</td></tr></tbody></table><h2 id="開発物"><a href="#開発物" class="headerlink" title="開発物"></a>開発物</h2><p>以下の実装を行うとします。<br>Web API を作成して、Swagger でドキュメントを管理しましょうというよくある構成かと思います。</p><table><thead><tr><th>項目</th><th>内容</th></tr></thead><tbody><tr><td>作成物</td><td>Web API</td></tr><tr><td>仕様定義</td><td>Swagger</td></tr><tr><td>言語</td><td>Go</td></tr><tr><td>仕様変更</td><td>高頻度</td></tr></tbody></table><h2 id="Go-のフレームワークに求めるもの"><a href="#Go-のフレームワークに求めるもの" class="headerlink" title="Go のフレームワークに求めるもの"></a>Go のフレームワークに求めるもの</h2><p>この場合、フレームワークに対して何を求めるでしょうか。<br>私は以下を重要視していました。</p><h3 id="重要視したこと"><a href="#重要視したこと" class="headerlink" title="重要視したこと"></a>重要視したこと</h3><p>ドキュメントと実装の乖離をなくすことで、認識齟齬なく開発を行うこと</p><h4 id="なぜ？"><a href="#なぜ？" class="headerlink" title="なぜ？"></a>なぜ？</h4><ol><li>ドキュメントと実装のズレを解消するコストが高いため<ul><li>Web API 開発をする中で最も困ることは <strong>ドキュメントと実装がかけ離れること</strong> です。ドキュメントととのずれによる、コミュニケーションを極力減らしたいと考えました</li></ul></li><li>インターフェイスが頻繁に変わることが想定されたため<ul><li>データ定義の部分が固く決まっていなかったため、データに引きずられて API 仕様の変更も頻繁に起きるだろうと思いました</li></ul></li><li>インターフェイスのやり取りの物理的な距離が遠いため<ul><li>同一の会社内だけでなく会社間をまたいだ開発も想定されたため、コミュニケーションコストがより高くなると想定しました</li></ul></li></ol><h2 id="フレームワーク比較"><a href="#フレームワーク比較" class="headerlink" title="フレームワーク比較"></a>フレームワーク比較</h2><p>ドキュメントと実装の整合性を重要視する考えのもと、下記 2 パターンの方式を検討しました。</p><ol><li>ドキュメントからコードを生成</li><li>コードからドキュメントを生成</li></ol><p>それぞれの方式についてサンプルを作りながら検討しました。<br>結果としては、<strong>1 のパターンのほうが重要視した要件を満たす</strong> と考えました。</p><h3 id="1-ドキュメントからコードを生成"><a href="#1-ドキュメントからコードを生成" class="headerlink" title="1. ドキュメントからコードを生成"></a>1. ドキュメントからコードを生成</h3><p>Swagger ファイルから Go のソースコードが生成できないかを考えました。<br>ライブラリとして、 <a href="https://github.com/go-swagger/go-swagger" target="_blank" rel="noopener">go-swagger</a> をあげています。</p><h4 id="go-swagger"><a href="#go-swagger" class="headerlink" title="go-swagger"></a><a href="https://github.com/go-swagger/go-swagger" target="_blank" rel="noopener">go-swagger</a></h4><p>Swaggerファイルを入力にGoのコードを生成することができるツールです。<br>生成されるコードは、<a href="https://github.com/go-openapi" target="_blank" rel="noopener">go-openapi</a> で管理されているモジュールが利用されています。</p><h4 id="サンプル"><a href="#サンプル" class="headerlink" title="サンプル"></a>サンプル</h4><p>swagger.yml (一部抜粋)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/data/&#123;name&#125;:</span></span><br><span class="line"><span class="attr">    post:</span></span><br><span class="line"><span class="attr">      operationId:</span> <span class="string">dataId</span></span><br><span class="line"><span class="attr">      consumes:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">      produces:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">      parameters:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">name</span></span><br><span class="line"><span class="attr">          in:</span> <span class="string">path</span></span><br><span class="line"><span class="attr">          required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">データ名</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">body</span></span><br><span class="line"><span class="attr">          in:</span> <span class="string">body</span></span><br><span class="line"><span class="attr">          schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/Sample"</span></span><br><span class="line"><span class="attr">      responses:</span></span><br><span class="line">        <span class="string">"200"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">          schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/ApiResponse"</span></span><br><span class="line">        <span class="string">"404"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Data</span> <span class="string">Not</span> <span class="string">Found</span></span><br><span class="line">        <span class="string">"500"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Internal</span> <span class="string">Server</span> <span class="string">Error</span></span><br></pre></td></tr></table></figure><p>生成コードを利用した handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataHandler</span><span class="params">(params operations.DataIDParams)</span> <span class="title">middleware</span>.<span class="title">Responder</span></span> &#123;</span><br><span class="line"><span class="comment">// リクエスト</span></span><br><span class="line"><span class="comment">// params にすべての情報が含まれている</span></span><br><span class="line">log.Println(params)</span><br><span class="line">log.Println(*params.Body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ビジネスロジック層にリクエスト情報を渡す</span></span><br><span class="line">service := service.New()</span><br><span class="line"><span class="keyword">if</span> err := service.Save(params.Body); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーの場合</span></span><br><span class="line"><span class="comment">// 500エラー返せる</span></span><br><span class="line"><span class="keyword">return</span> operations.NewDataIDInternalServerError()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// レスポンス</span></span><br><span class="line">dummyResponse := &amp;models.APIResponse&#123;</span><br><span class="line">Message: <span class="string">"OK"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 200 レスポンス</span></span><br><span class="line"><span class="keyword">return</span> operations.NewDataIDOK().WithPayload(dummyResponse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="メリット"><a href="#メリット" class="headerlink" title="メリット"></a>メリット</h4><ol><li>Swagger と実装が乖離することはない<ul><li>Swagger から自動生成でリクエスト/レスポンスの struct を吐き出します。自動生成部分も CI で必ず生成して build するようにすれば、漏れることはないです。</li></ul></li><li>go-swagger でリクエスト/レスポンスのオブジェクト型を 生成してくれるためロジックに集中できる<ul><li>リクエスト/レスポンスの型だけでなく、リクエストを受ける/レスポンスを返す実装も合わせて生成されます。そのため、実装者は生成されたコードから リクエストパラメータ struct を受け取る → レスポンス struct を生成 までを実装すればよいです</li></ul></li></ol><h4 id="デメリット"><a href="#デメリット" class="headerlink" title="デメリット"></a>デメリット</h4><ol><li>Swagger の定義を手で書く必要がある<ul><li>Swagger の yml 定義を手でメンテする必要がある点は、デメリットになるかと思います。</li></ul></li></ol><h3 id="2-コードからドキュメントを生成"><a href="#2-コードからドキュメントを生成" class="headerlink" title="2. コードからドキュメントを生成"></a>2. コードからドキュメントを生成</h3><p>実装コードを正として、ドキュメント(Swagger ファイル)を出せないかを考えました。<br>現状対応しているライブラリとしては、<a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">swaggo/swag</a> があげられました。</p><h4 id="swaggo-swag"><a href="#swaggo-swag" class="headerlink" title="swaggo/swag"></a><a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">swaggo/swag</a></h4><p>Go のソースコードを静的解析して、Swagger ドキュメントを生成してくれるツールです。<br>以下のフレームワークとの連携をサポートしています。</p><ul><li><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a></li><li><a href="https://github.com/labstack/echo" target="_blank" rel="noopener">echo</a></li><li><a href="https://github.com/gobuffalo/buffalo" target="_blank" rel="noopener">buffalo</a></li><li><a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener">net/http</a></li></ul><h4 id="サンプル-1"><a href="#サンプル-1" class="headerlink" title="サンプル"></a>サンプル</h4><p>gin を利用したパターンの handler サンプルコードです。<br>Swagger ファイルは自動生成されるため割愛します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataHandler godoc</span></span><br><span class="line"><span class="comment">// @Summary Show a account</span></span><br><span class="line"><span class="comment">// @Description get string by ID</span></span><br><span class="line"><span class="comment">// @ID dataId</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Produce  json</span></span><br><span class="line"><span class="comment">// @Param name path string true "data name"</span></span><br><span class="line"><span class="comment">// @Param id body int true "id"</span></span><br><span class="line"><span class="comment">// @Param info body string false "info"</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; APIResponse</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; APIResponse</span></span><br><span class="line"><span class="comment">// @Failure 500 &#123;object&#125; APIResponse</span></span><br><span class="line"><span class="comment">// @Router /data/&#123;name&#125; [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DataHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> params DataRequestParams</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;params); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(http.StatusBadRequest, &amp;APIResponse&#123;Message: <span class="string">"Error"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">service := service.New()</span><br><span class="line"><span class="keyword">if</span> err := service.Save(params.Body); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(http.StatusInternalServerError, &amp;APIResponse&#123;Message: <span class="string">"Error"</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">res := APIResponse&#123;Message: <span class="string">"OK"</span>&#125;</span><br><span class="line">c.JSON(http.StatusOK, &amp;res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="メリット-1"><a href="#メリット-1" class="headerlink" title="メリット"></a>メリット</h4><ol><li>コードが正になり、コードの修正がドキュメントに反映される</li><li>コードのコメントで Swagger の仕様定義を実施できる</li><li>Swagger ファイル生成時に、コードのコメントのバリデーションを一部実行してくれる</li><li>有力フレームワークの機能をそのまま活用できる</li></ol><h4 id="デメリット-1"><a href="#デメリット-1" class="headerlink" title="デメリット"></a>デメリット</h4><ol><li>仕様定義漏れを目見でチェックする必要がある<ul><li>コメントの解析をベースに、Swagger 生成をしていますが、定義が漏れている場合にエラーになりませんでした。(パラメータの記載漏れ、レスポンスのステータスコード漏れ 等確認しました。) そのため、実装とコメントが乖離していないかは目見で確認しないといけませんでした。コメントの量も多く、目見での確認には漏れが出ることが想像されました。</li></ul></li><li>コメント+実装ベースのため Swagger との連携度が低い</li></ol><h3 id="補足-コード生成系フレームワーク比較"><a href="#補足-コード生成系フレームワーク比較" class="headerlink" title="補足: コード生成系フレームワーク比較"></a>補足: コード生成系フレームワーク比較</h3><p>実際、go-swagger 以外にも Swagger -&gt; コード生成ツールは存在します。<br>ですが、<a href="https://github.com/OpenAPITools/openapi-generator" target="_blank" rel="noopener">openapi-generator</a> での生成コードは現状はまだ、運用に耐えるレベルではない考えます。</p><p>特に、Handlerとリクエスト/レスポンスの型定義がマッチされたコードが生成されない点が辛いです。<br>せっかくコード生成したのに、各 API ごとにドキュメントと見比べながらモデルを紐付けるのはいまいちだと思いました。<br>(生成コードが薄いことは良かったですが、紐付けを固くする選択をしました。)</p><p>比較表</p><table><thead><tr><th align="left">対象</th><th align="left">評価</th><th align="left">メリット</th><th align="left">デメリット</th></tr></thead><tbody><tr><td align="left">go-swagger</td><td align="left">o</td><td align="left">- リクエスト/レスポンスの型が定まる <br><br>- リクエストを受け取る/レスポンスを返す 部分を意識しなくて良い <br><br> - リクエストパラメータのバリデーションを自動で実行 <br><br>- 編集不要ファイルは DO NOT EDIT コメントがついている<br><br> - デフォルトで未実装エラーが出る Handler が登録される</td><td align="left">- 自動生成だけでは API 受け付けられない (configure_xxx.go 内の修正が必須) <br><br>- Router 周りのコードが長い</td></tr><tr><td align="left">openapi generator (net/http)</td><td align="left">x</td><td align="left">- 生成コード量が少なく明瞭</td><td align="left">- 非編集ファイルが明確にされていない <br><br>- リクエスト/レスポンスの型定義が Handler に紐付いていない</td></tr><tr><td align="left">openapi generator (gin)</td><td align="left">x</td><td align="left">- 生成コード量が少なく明瞭</td><td align="left">- 非編集ファイルが明確にされていない <br><br>- リクエスト/レスポンスの型定義が Handler に紐付いていない</td></tr></tbody></table><h4 id="openapi-generator-サンプル-gin-version"><a href="#openapi-generator-サンプル-gin-version" class="headerlink" title="openapi-generator サンプル (gin version)"></a>openapi-generator サンプル (gin version)</h4><details><summary>サンプルコード</summary><div>swagger.yml (一部抜粋)<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">"/data/&#123;name&#125;"</span><span class="string">:</span></span><br><span class="line"><span class="attr">    post:</span></span><br><span class="line"><span class="attr">      operationId:</span> <span class="string">dataId</span></span><br><span class="line"><span class="attr">      parameters:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">name</span></span><br><span class="line"><span class="attr">          in:</span> <span class="string">path</span></span><br><span class="line"><span class="attr">          required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">データ名</span></span><br><span class="line"><span class="attr">          schema:</span></span><br><span class="line"><span class="attr">            type:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      requestBody:</span></span><br><span class="line"><span class="attr">        content:</span></span><br><span class="line">          <span class="string">application/json:</span></span><br><span class="line"><span class="attr">            schema:</span></span><br><span class="line">              <span class="string">$ref:</span> <span class="string">"#/components/schemas/Sample"</span></span><br><span class="line"><span class="attr">      responses:</span></span><br><span class="line">        <span class="string">"200"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">          content:</span></span><br><span class="line">            <span class="string">application/json:</span></span><br><span class="line"><span class="attr">              schema:</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">"#/components/schemas/ApiResponse"</span></span><br><span class="line">        <span class="string">"404"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Data</span> <span class="string">Not</span> <span class="string">Found</span></span><br><span class="line">        <span class="string">"500"</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Internal</span> <span class="string">Server</span> <span class="string">Error</span></span><br></pre></td></tr></table></figure><p>handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataId -</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DataId</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.JSON(http.StatusOK, gin.H&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>model</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ApiResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Message <span class="keyword">string</span> <span class="string">`json:"message,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(handler に model が紐付いていないことが伝わればよいかと思います)</p></div></details><h2 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h2><p>複数のフレームワークを比較検討してみました。</p><p>ドキュメントベースで開発して、コミュニケーションコストを下げたい目的があれば、<code>go-swagger</code> の利用はおすすめできると思います。<br>開発進めてみて知見が溜まってきたら、また公開していきます。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは、TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;の多賀です。&lt;br&gt;2019年7月にキャリア入社しました。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; cl
      
    
    </summary>
    
      <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
      <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Google Cloud Next &#39;19 in Tokyo Day3 セッションレポート</title>
    <link href="https://future-architect.github.io/articles/20190809/"/>
    <id>https://future-architect.github.io/articles/20190809/</id>
    <published>2019-08-08T23:29:54.000Z</published>
    <updated>2019-08-08T23:54:38.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG DXチームの統合思念体です。<a href="https://cloud.withgoogle.com/next/tokyo/" target="_blank" rel="noopener">Google Cloud Next ’19 in Tokyo Day3</a>に少し顔を出していたので参加レポートをお送りします。</p><ul><li><a href="https://future-architect.github.io/articles/20190804/">Day2 の参加レポート</a>はこちらです。</li></ul><h1 id="Google-Cloud-Next-’19-in-Tokyoとは"><a href="#Google-Cloud-Next-’19-in-Tokyoとは" class="headerlink" title="Google Cloud Next ’19 in Tokyoとは"></a>Google Cloud Next ’19 in Tokyoとは</h1><p>「かつてないクラウドを体験しよう」をテーマに、📍東京プリンスホテル, 📍ザ・プリンス パークタワー東京の2ヶ所で 7/30~8/1の3日間に渡ってクラウドの最新動向や、採用事例を学べるセッションが開催されるカンファレンスです。ハッシュタグは<code>#GoogleNext2019</code>。2019年は160ものセッションが開催され年々熱気が増しているように感じます。</p><h1 id="会場への道のり-amp-会場の様子"><a href="#会場への道のり-amp-会場の様子" class="headerlink" title="会場への道のり &amp; 会場の様子"></a>会場への道のり &amp; 会場の様子</h1><p>Day2に参加した私はすでに会場への道をマスターしており、道中で「これブログに使えるかな？」などと考えながら写真を撮る余裕がありました。<br><img src="/images/20190809/photo_20190809_01.jpeg"><br>↑行きしなに東京タワーをパシャリ。変わらずの炎天下でしたが会場着後は快適な空調のおかげで穏やかな気持ちでセッション聴講できました！<br><img src="/images/20190809/photo_20190809_02.jpeg"><br>↑こちらはEXPO会場のとある一角。バーコーナー的な感じでしょうか。写真ではお水のみですが、時間帯によってはお菓子も並んでいました。個人的には<code>揚一番</code>を陳列してくれていた点に全力で称賛を送りたいと思います!!（何個も食べてすいません…揚一番大好きです！！）</p><h1 id="セッションレポート"><a href="#セッションレポート" class="headerlink" title="セッションレポート"></a>セッションレポート</h1><p>さて、本題に入っていきましょう。Day3もコンテナオーケストレーションネタを主軸にいくつかのセッションに参加したのでレポートを書いていきます！</p><h2 id="☁ハイブリッド-マルチクラウド環境下における-Kubernetes-デザインの勘所-データ管理の視点から"><a href="#☁ハイブリッド-マルチクラウド環境下における-Kubernetes-デザインの勘所-データ管理の視点から" class="headerlink" title="☁ハイブリッド マルチクラウド環境下における Kubernetes デザインの勘所 - データ管理の視点から"></a>☁ハイブリッド マルチクラウド環境下における Kubernetes デザインの勘所 - データ管理の視点から</h2><blockquote><p>本セッションでは、なぜ Kubernetes クラスタがステートレスである必要があるか、アプリケーションから生成されるデータを保管する Kubernetes ストレージのデザインについて、ネットアップのソリューションを使用するとどのような課題を解決できるかをお話します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=327831-143299" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=327831-143299</a></p></blockquote><p>k8s、ハイブリッド・マルチクラウド、という単語に惹かれる形で参加を決定しました。コンテナを使うときに悩みどころのひとつとなる「ステートフルデータの取り扱い方法」について詳しく解説してくれたセッションでした。本セッションはランチセッションだったみたいなのですが、知らずにギリギリで会場イン。係員の方に「お弁当はもう無いです。」と言われ、「ああーー勿体ないことしたぁぁーー」と思いながら着席しました笑</p><p>セッションを通じて、k8sひいてはコンテナアプリケーションを扱う際に必ずつきまとう「ステートフルデータどうする問題」に詳しくなりました！クラウドであれば、コンテナはステートレスな状態としステートフルなものはマネージドサービスをフル活用する、というのがコンテナアプリケーション運用時のベストプラクティスと考えていましたが、アプリケーションレベルでの管理に私の意識が寄っていた気がします。ハイブリッド・マルチクラウドが進む世界においては、etcd含め、クラスタレベルでのステートという考えも大事であり、「コンテナを破棄可能な状態に保つ」だけでなく「クラスタを破棄可能な状態に保つ」ことも重要だなと改めて考えさせられました！</p><p>以下セッションメモです。</p><h3 id="複数のk8sクラスタを運用する際の課題"><a href="#複数のk8sクラスタを運用する際の課題" class="headerlink" title="複数のk8sクラスタを運用する際の課題"></a>複数のk8sクラスタを運用する際の課題</h3><ul><li>クラウドごと、あるいはオンプレでクラスタのオペレーションが微妙に異なる</li><li>複数クラスタをどうやって接続するか</li><li>ステートフルなデータをどういったストレージで管理するか（本日のメイントピック）</li></ul><h3 id="ハイブリッドクラウドの実現に向けて"><a href="#ハイブリッドクラウドの実現に向けて" class="headerlink" title="ハイブリッドクラウドの実現に向けて"></a>ハイブリッドクラウドの実現に向けて</h3><h4 id="オペレーションの統合"><a href="#オペレーションの統合" class="headerlink" title="オペレーションの統合"></a>オペレーションの統合</h4><ul><li>環境ごとにマネージド範囲が異なるので差異を吸収するレイヤが必要</li><li>統一的に操作できるAPIなどを定義した管理レイヤを設けるのが好ましい</li></ul><h4 id="k8sクラスタを破棄可能な状態にしておき、クラスタ移動に備える"><a href="#k8sクラスタを破棄可能な状態にしておき、クラスタ移動に備える" class="headerlink" title="k8sクラスタを破棄可能な状態にしておき、クラスタ移動に備える"></a>k8sクラスタを破棄可能な状態にしておき、クラスタ移動に備える</h4><ul><li>ワークロードにはステートフルとステートレスの2種類あるが、ステートフルワークロードの扱い方が重要</li><li>ステートフルデータがあると、クラスタの移動が容易にできなくなってしまうため</li><li>保存の仕方は主に以下3種<ul><li>マネージドのデータサービス</li><li>ユーザ管理データサービス</li><li>ブロック・ファイルストレージ</li></ul></li></ul><h3 id="コンテナにおけるステートとは？"><a href="#コンテナにおけるステートとは？" class="headerlink" title="コンテナにおけるステートとは？"></a>コンテナにおけるステートとは？</h3><p>システム稼働時に必要なデータあるいはコンテナ起動時に必要なデータがそれにあたる</p><h4 id="k8sにおけるステート"><a href="#k8sにおけるステート" class="headerlink" title="k8sにおけるステート"></a>k8sにおけるステート</h4><ul><li>ステートフルなものは、Podのライフサイクルとは異なるライフサイクルのもので、<code>PVC</code>や<code>PV</code>など</li><li>現実的にマニフェスト化できないもの（コードで管理が難しいもの）はSecretなど</li><li>ステートレスなものは、k8sのオブジェクトは基本ステートレス</li></ul><h4 id="k8sがステートを持たない利点"><a href="#k8sがステートを持たない利点" class="headerlink" title="k8sがステートを持たない利点"></a>k8sがステートを持たない利点</h4><ul><li>ステートを持つ場合は、有事の際に直す必要がでてくる<ul><li>アドホックだし時間がかかる</li></ul></li><li>ステートを持たなければ、再作成で復旧可能<ul><li>壊れても良い</li></ul></li></ul><h3 id="ではそのステートをどうやって管理するか？"><a href="#ではそのステートをどうやって管理するか？" class="headerlink" title="ではそのステートをどうやって管理するか？"></a>ではそのステートをどうやって管理するか？</h3><h4 id="データ永続化の領域"><a href="#データ永続化の領域" class="headerlink" title="データ永続化の領域"></a>データ永続化の領域</h4><ul><li>マネージドデータサービスとユーザ管理データサービス<ul><li>ベンダーロックイン的な話も出るが、大事なのはデータサービスの抽象化レイヤを配置し、入れ替え可能にしておくこと</li></ul></li><li>ブロック・ファイルストレージ<ul><li><code>Storage in k8s</code>と<code>Storage for k8s</code>。クラスタ上にデータを置くと、再作成など難しい</li></ul></li></ul><h4 id="CSIとは-Container-Storage-Interface-？"><a href="#CSIとは-Container-Storage-Interface-？" class="headerlink" title="CSIとは(Container Storage Interface)？"></a>CSIとは(Container Storage Interface)？</h4><ul><li>コンテナストレージの共通仕様</li><li>APIは共通化されているため、バックエンドを置き換え可能になる</li><li>ただし、CSI対応を謳っていても実装状況は違うので注意</li></ul><h3 id="ステートフルなデータの取り扱い"><a href="#ステートフルなデータの取り扱い" class="headerlink" title="ステートフルなデータの取り扱い"></a>ステートフルなデータの取り扱い</h3><p>Podが動いている間にうまれるデータ、およびetcdのデータがある</p><h4 id="etcdを保護するために"><a href="#etcdを保護するために" class="headerlink" title="etcdを保護するために"></a>etcdを保護するために</h4><ul><li>etcdは<code>クラスタのステート</code>と捉える場合と<code>クラスタのコンフィグレーション</code>と捉える場合でアプローチが異なる</li><li>クラスタのステートとして考える場合<ul><li>マネージドなクラスタの場合は、サービス提供側に任せるか、3rdパーティ製ツールを用いる</li><li>マネージドではないクラスタの場合は、自身で必ず保護し、バックアップのみならずそこからのリストアフローまでしっかり考えておく</li></ul></li><li>クラスタのコンフィグレーションとして考える場合<ul><li>GitOpsのような状態が理想</li><li>管理しているマニフェストを再実行で復旧状態にしておく</li><li>Secretをどのように考えるかが大事だが、例えばHashicorp Vaultを使うのは1つの解決策となりうる</li></ul></li></ul><h3 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h3><ul><li>微妙に違うk8sたちを統一的に管理することが必要</li><li>重要なのはクラスタを破棄可能にするためのステート管理方式の決定</li></ul><h2 id="☁Kubernetes-ソフトウェア-サプライチェーンにおけるエンドツーエンドのセキュリティ＆コンプライアンス"><a href="#☁Kubernetes-ソフトウェア-サプライチェーンにおけるエンドツーエンドのセキュリティ＆コンプライアンス" class="headerlink" title="☁Kubernetes ソフトウェア サプライチェーンにおけるエンドツーエンドのセキュリティ＆コンプライアンス"></a>☁Kubernetes ソフトウェア サプライチェーンにおけるエンドツーエンドのセキュリティ＆コンプライアンス</h2><blockquote><p>このセッションでは、コンテナがもたらす課題とメリットについて、ANZ のメンバーも参加して意見を交わします。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=302742-140857" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=302742-140857</a></p></blockquote><p>k8sにおけるセキュリティに興味があり参加を決めました！スピーカーの方が英語で話されるとのことで入り口では通訳レシーバーが配布されていましたが、良い機会だと思い私はレシーバーを受け取らずにセッション会場へ突入していきました。(わりとなんとかなります。みなさんもぜひチャレンジを！)</p><p>ANZ(オーストラリア・ニュージーランド銀行)さんの事例に合わせ、いかにセキュリティを高めるかがテーマのセッションでした。コンテナセキュリティという観点で登場したサービス・ソリューション群はDay2で聞いたものと一緒でしたが、その分洗練されたセキュリティサービスが提供されていると理解しました。緻密なセキュリティ対策が求められる銀行ビジネスの中で、セキュリティを高めつつクラウド・コンテナアプリケーションを導入していくかという話が興味深く、技術ネタそのものよりもそちらに耳を傾けてしまいました。</p><p>講演中に手元の端末を使ってDEMOを行う際は、スイッチャーの方に「画面切り替えお願いします」といった形でお願いするのですが、うまく切り替わった後に講演者の方がスマートに発した「Perfect」の一言が最高にCoolでかっこいいなとテンション上がってました！笑</p><p>以下、セッションメモです。</p><h3 id="Supply-Chain-Security"><a href="#Supply-Chain-Security" class="headerlink" title="Supply Chain Security"></a>Supply Chain Security</h3><ul><li>VM時代のサプライチェーンはToo Human Baseでした</li><li>マイクロサービスであるということは大量のデプロイを何度も行うということである</li><li>人力ではとても回らないので、CI/CDを適切に整えることが大切</li></ul><h3 id="ANZにおける事例"><a href="#ANZにおける事例" class="headerlink" title="ANZにおける事例"></a>ANZにおける事例</h3><ul><li>ANZ = オーストラリア・ニュージーランド銀行<ul><li>50thousand employees</li><li>10million customers</li></ul></li><li>New ways of workingを考えている</li><li>Fintechの流れもあり、techにも力を入れている<ul><li>Quick change &amp; Quick feedback</li></ul></li><li>素晴らしいエクスペリエンスは顧客の信頼の中で生まれる<ul><li>「Security is key to gain customers trust.」</li></ul></li></ul><h3 id="まとめ-1"><a href="#まとめ-1" class="headerlink" title="まとめ"></a>まとめ</h3><ul><li>Base image、Image scan、Binary AuthorizationなどのGCPセキュリティサービスを活用してコンテナアプリをセキュアに保つことが大事</li></ul><h2 id="☁Anthos-が変えるハイブリッドクラウドの形"><a href="#☁Anthos-が変えるハイブリッドクラウドの形" class="headerlink" title="☁Anthos が変えるハイブリッドクラウドの形"></a>☁Anthos が変えるハイブリッドクラウドの形</h2><blockquote><p>本セッションでは、Anthos が何を目指しているのか、何が実現できるのかというようなコンセプトから、Kubernetes、Istio などのコンポーネントに触れながら、これを利用することで何が変わるのか、技術者、ビジネス担当者それぞれの立場から見たメリットを合わせ、ご説明します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=297710-140796" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=297710-140796</a></p></blockquote><p>話題のAnthosのセッションなのでぜひ聞きたいと真っ先に参加申し込みをしたのがこのセッションです！やる気出しすぎて最前ど真ん中というベスポジ中のベスポジをゲットしつつ臨みました。</p><p>Anthosの具体的なアーキテクチャについての話というよりも、Anthosがどこに向かっているのかを聞けるセッションでした。本セッションで話していたことは、Anthosに閉じず、GCPがどこに向かおうとしているのか、も多分に含んでいるんだろうなーと感じています。OSSに対する強い思いも随所にあふれており、私の大好きなIstioの話も登場し、Google Cloud ソリューションアーキテクト長谷部さんの熱意あふれる大満足な40分間でした！</p><p>以下、セッションメモです。</p><h3 id="日本のエンタープライズITは変革が求められている"><a href="#日本のエンタープライズITは変革が求められている" class="headerlink" title="日本のエンタープライズITは変革が求められている"></a>日本のエンタープライズITは変革が求められている</h3><ul><li>開発手法・スキル・リソース配分・市場など様々な観点で変化があり、それに追従するためにも変革が求められている</li><li>その一つの解がAnthosであり、本セッションでは技術よりも、Anthosが向かう先を話す</li></ul><h3 id="Anthosが目指すもの"><a href="#Anthosが目指すもの" class="headerlink" title="Anthosが目指すもの"></a>Anthosが目指すもの</h3><h4 id="ハイブリッド＆マルチクラウド"><a href="#ハイブリッド＆マルチクラウド" class="headerlink" title="ハイブリッド＆マルチクラウド"></a>ハイブリッド＆マルチクラウド</h4><ul><li>既存リソースの有効活用<ul><li>すべてクラウドに移行しているのは稀。最近の調査では、クラウドからオンプレに戻そうとする動きもある</li></ul></li><li>レギュレーション・社内ポリシーの対応<ul><li>クラウドに置けないデータはオンプレにおくしかない</li></ul></li><li>マルチクラウド<ul><li>他社クラウドもサポート</li></ul></li></ul><h4 id="フルマネージド指向"><a href="#フルマネージド指向" class="headerlink" title="フルマネージド指向"></a>フルマネージド指向</h4><ul><li>デファクトとなりつつある3つのOSS、それらをマネージドサービスで提供する<ul><li>k8s –&gt; GKE</li><li>Istio –&gt; Istio on GKE</li><li>Knative –&gt; Cloud Run</li></ul></li><li>価値のある業務に集中する。プラットフォーム管理はGoogleが、開発者は価値のあるところにフォーカスしてほしい</li><li>マネージドサービスの提供領域についてはGoogleがテスト、監査を行う</li><li>あくまで元々のOSSに準拠し、魔改造はしない</li></ul><h4 id="オープンテクノロジー-with-Google"><a href="#オープンテクノロジー-with-Google" class="headerlink" title="オープンテクノロジー with Google"></a>オープンテクノロジー with Google</h4><ul><li>Goolgeはk8s・Knative・Istio・Tensorflowをはじめ2000を超えるOSSプロジェクトへ貢献してきた</li><li>昨今のクラウドベンダーとOSSベンダーとの衝突は悲しいものであり、GoogleはOSSを育ててきた企業だからこそ、OSS企業を大事にしたい</li><li>OSS各社と戦略的パートナーシップを結んだ</li></ul><h4 id="Anthosが支えたい世界"><a href="#Anthosが支えたい世界" class="headerlink" title="Anthosが支えたい世界"></a>Anthosが支えたい世界</h4><p>CEOの方々と話す機会があるが、「3年後のIT投資戦略をたてなきゃいけないがそれは可能か？」とよく聞かれる。変化が早く、見通せないのは前提。であれば、変化したらそれに柔軟に合わせられる状態になるような選択をするのが大事。しかし保守的すぎてもだめで、競争力をつけるためにk8sやIstioなどの最新のテクノロジーは使える状態であるべき。それらをマネージドサービスにて利用することで開発者は価値のある箇所に注力することができる。</p><h3 id="Anthosの構成要素"><a href="#Anthosの構成要素" class="headerlink" title="Anthosの構成要素"></a>Anthosの構成要素</h3><ul><li>Anthosはコンテナを基礎としている</li><li>コンテナの特徴は3点<ul><li>「ファイルサイズが小さい」・「アプリに必要なものがひとまとめ」・「(仮想マシンに比べ）負荷が低い」</li></ul></li></ul><h4 id="なぜGoogleがコンテナを使うのか？"><a href="#なぜGoogleがコンテナを使うのか？" class="headerlink" title="なぜGoogleがコンテナを使うのか？"></a>なぜGoogleがコンテナを使うのか？</h4><ul><li>開発速度をあげて、早くリリースしたい</li><li>サーバリソースを有効活用したい</li><li>開発者は開発に集中したい</li></ul><h4 id="コンテナオーケストレーションの重要性"><a href="#コンテナオーケストレーションの重要性" class="headerlink" title="コンテナオーケストレーションの重要性"></a>コンテナオーケストレーションの重要性</h4><ul><li>どのサーバ上につくる？ = スケジューリング</li><li>サーバが落ちたらどうする？ = セルフヒーリング</li><li>負荷が高くなったらどうする？ = オートスケーリング</li></ul><h4 id="Anthosのテクノロジースタック"><a href="#Anthosのテクノロジースタック" class="headerlink" title="Anthosのテクノロジースタック"></a>Anthosのテクノロジースタック</h4><img src="/images/20190809/photo_20190809_03.jpeg"><ul><li>ベースにGKEとIstioがいて、その上にControl Planeがある</li></ul><h3 id="Anthosのもたらす価値・提供機能"><a href="#Anthosのもたらす価値・提供機能" class="headerlink" title="Anthosのもたらす価値・提供機能"></a>Anthosのもたらす価値・提供機能</h3><img src="/images/20190809/photo_20190809_04.jpeg"><h5 id="コンテナオーケストレーション-GKE-GKE-On-prem"><a href="#コンテナオーケストレーション-GKE-GKE-On-prem" class="headerlink" title="コンテナオーケストレーション - GKE/GKE On-prem"></a>コンテナオーケストレーション - GKE/GKE On-prem</h5><ul><li>k8sは宣言型APIで設定する</li><li>宣言型API = あるべき状態を記述する。手順ではなく、最後の状態を定義する</li><li>k8sは宣言された状態をkeepするように動く</li></ul><h4 id="サービスメッシュ-の前に…"><a href="#サービスメッシュ-の前に…" class="headerlink" title="サービスメッシュ(の前に…)"></a>サービスメッシュ(の前に…)</h4><p>なぜマイクロサービス？</p><ul><li>1つ1つのサービスが小さくシンプル</li><li>機動的な機能追加</li><li>個別集中的なセキュリティ</li><li>個別のテクノロジー採用」</li></ul><p>しかし…連携が増え管理が大変</p><ul><li>どのように連携するか？</li><li>どのサービスがどのサービスと連携しているのか？</li><li>サービス間のセキュリティ、認証認可の担保は？</li></ul><h4 id="サービスメッシュ-Istio-on-GKE-CSM"><a href="#サービスメッシュ-Istio-on-GKE-CSM" class="headerlink" title="サービスメッシュ - Istio on GKE/CSM"></a>サービスメッシュ - Istio on GKE/CSM</h4><ul><li>Istioという解決策。間に入り、サービス間の連携を取り持つ<ul><li>つなげる、セキュアに保つ、見える化する</li></ul></li></ul><h4 id="設定、ポリシーの一元管理-Anthos-Config-Management"><a href="#設定、ポリシーの一元管理-Anthos-Config-Management" class="headerlink" title="設定、ポリシーの一元管理 - Anthos Config Management"></a>設定、ポリシーの一元管理 - Anthos Config Management</h4><ul><li>マルチ、ハイブリッドクラスタの一元管理</li><li>宣言型モデルと継続的なモニタリング</li><li>シンプルなマイグレーション</li></ul><h4 id="コンテナへのマイグレーション-Migrate-for-Anthos"><a href="#コンテナへのマイグレーション-Migrate-for-Anthos" class="headerlink" title="コンテナへのマイグレーション - Migrate for Anthos"></a>コンテナへのマイグレーション - Migrate for Anthos</h4><ul><li>仮想マシンで動いているものを簡単にコンテナ化できる</li></ul><h3 id="ユースケース"><a href="#ユースケース" class="headerlink" title="ユースケース"></a>ユースケース</h3><h4 id="Anthos-on-Edges"><a href="#Anthos-on-Edges" class="headerlink" title="Anthos on Edges"></a>Anthos on Edges</h4><ul><li>エッジロケーション(工場など)にAnthosを導入し、集中管理を行う</li><li>GKE On-premはインターネットへの疎通ができれば導入可能</li></ul><h4 id="Anthos-for-Hybrid-Cloud"><a href="#Anthos-for-Hybrid-Cloud" class="headerlink" title="Anthos for Hybrid Cloud"></a>Anthos for Hybrid Cloud</h4><ul><li>クラウドにおけないものはOn-prem、おけるものはクラウドに</li></ul><h4 id="Anthos-for-Multi-Cloud"><a href="#Anthos-for-Multi-Cloud" class="headerlink" title="Anthos for Multi Cloud"></a>Anthos for Multi Cloud</h4><ul><li>複数のクラウドを組み合わせたサービス構成</li><li>複数クラウドでDRを組むなども可能になる</li></ul><h3 id="まとめ-2"><a href="#まとめ-2" class="headerlink" title="まとめ"></a>まとめ</h3><img src="/images/20190809/photo_20190809_05.jpeg"><ul><li>2019/09/03にGoogle Cloud Kubernetes Dayやります(私も楽しみです！)</li></ul><h2 id="☁Istio-Kubernetes-Spinnaker-を使ったカナリア-デプロイメント"><a href="#☁Istio-Kubernetes-Spinnaker-を使ったカナリア-デプロイメント" class="headerlink" title="☁Istio, Kubernetes, Spinnaker を使ったカナリア デプロイメント"></a>☁Istio, Kubernetes, Spinnaker を使ったカナリア デプロイメント</h2><blockquote><p>Istio, Kubernetes, Spinnaker を使うことで、カナリアデプロイメントなど高度なロールアウトパターンをサポートし、アプリケーションを安全かつ簡単にデプロイすることが可能です。本セッションではこれらを如何に GCP 上で実現するか、最新のプロダクト情報も交えながら説明します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=299647-140817" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=299647-140817</a></p></blockquote><p>Istioが好きで最近仕事でCI/CDを設計している私にとってまたとない機会だったので、意気揚々と参加登録しました。本セッションもスピーカーの方が英語ネイティブな方だったのですが、2つ前のセッションを通訳レシーバーなしで過ごした私は、これまた意気揚々と「レシーバー要らないです」と言いながら会場へ足を踏み入れました。</p><p>k8sとIstioを使っていかにカナリアデプロイを実現するか、デモを交えて詳しく説明してくれるセッションでした。講演者の方の朗らかな人柄もあいまって、幸せな笑いに満ちたセッションだなーと思いつつ聴講していました！ちなみにセッションタイトルには「Spinnaker」とありますが、本セッションでは代わりに「TEKTON」を利用したカナリアデプロイメントの説明をしてくださっています。「Spinnaker」を利用したのはGoogle Cloud Next ‘19 in San Franciscoだったようです。(セッションの模様はYouTubeで見られるとのこと！)</p><p><a href="https://youtu.be/CmZWau04ZS4" target="_blank" rel="noopener">Canary Deployments With Istio and Kubernetes Using Spinnaker (Cloud Next ‘19)</a></p><p>デモアプリで登場した猫のアプリがとても印象的でした！猫！かわいい！！</p><p>以下、セッションのメモです。</p><h3 id="k8sにおけるコンテナデプロイ"><a href="#k8sにおけるコンテナデプロイ" class="headerlink" title="k8sにおけるコンテナデプロイ"></a>k8sにおけるコンテナデプロイ</h3><ul><li>課題は、どうやって安全かつ簡単にコンテナアプリケーションのバージョンを切り替えるか</li><li>ケースとして、アプリバージョンをOldからNewへ切り替えたい時</li><li>k8sではすでに下記に対応可能<ul><li>Rollingアップデート</li><li>Blue/Greenデプロイ</li><li>オーバープロビジョニング</li></ul></li></ul><h3 id="カナリアデプロイメント"><a href="#カナリアデプロイメント" class="headerlink" title="カナリアデプロイメント"></a>カナリアデプロイメント</h3><p>徐々に新しいバージョンにアプリケーションを切り替えていく。</p><ul><li>k8sでやるには、Deployment objectを利用する</li><li>よりアドバンスにやるには、Istioを利用してTrafficの分配を行う<ul><li><code>Destination Rule</code>と<code>Virtual Service</code>の設定によって実現可能</li></ul></li></ul><h3 id="TEKTONについて"><a href="#TEKTONについて" class="headerlink" title="TEKTONについて"></a>TEKTONについて</h3><ul><li>カナリアデプロイメントに際し、フェーズごとに設定変更しなければならない箇所がたくさんある</li><li>でも手で全部やるのは大変！！→自動化しよう！！</li><li>TEKTONはIstioを利用してカナリアデプロイメントを自動化してくれるツール</li><li>TEKTONはk8sのCRD(Custom Resource Definition)をラップしており、PipelineとTasksを定義することで動作する​​</li></ul><h3 id="まとめ-3"><a href="#まとめ-3" class="headerlink" title="まとめ"></a>まとめ</h3><ul><li>k8sを利用したカナリアデプロイメントにはIstioは絡めてTrafficコントロールを任せよう</li><li>TEKTONやSpinnakerを使って自動化することはとても重要</li><li>Spinnakerを使ったDEMOを行った<a href="https://youtu.be/CmZWau04ZS4" target="_blank" rel="noopener">サンフランシスコでのセッション動画</a>をぜひみてください！</li></ul><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p><a href="https://future-architect.github.io/articles/20190804/">Day2のレポート</a>でも書きましたが、Anthos含めKubernetesに関連するセッションが非常に充実していました。AnthosのセッションはまさにGoogle Cloudがどこに向かっていくかをありのまま伝えてくれたように思います。</p><p>Anthosのセッションを担当されていた長谷部さんが「実はGoogleは数年前からコンテナを使っているが、昨今いろいろな所でコンテナという言葉を耳にする。コンテナ技術は今流行っていると言える。」と発言されていました。Kubernetes・Istio・Knativeなどをはじめ、いまデファクトスタンダードになりつつある様々なOSSは例えばBorgなど元々Googleの社内システムにて利用されていたシステムが起源となっています。彼らは数年かけてブラッシュアップさせてきたものをOSSとして公開し、そしてそれを今GCPにてマネージドサービスとして提供しています。</p><p>変化の早いテクノロジーの世界において、知見は隠すものではなく皆で共有し・皆で育てていくものとなってきています。GCPを活用するということは言い換えればGoogleが長年培ってきた知見の集大成を一気に享受できるということであり、そのメリットは計り知れないはずです。我々も受け取るだけでなく広く世に発信し続けなければならないなと改めて考えさせられる良い機会にもなりました。</p><p>Day2・Day3の2日間だけの参加でしたが、非常に有意義な時間を過ごすことができました！GCPについての学びを惜しみなく発信する機運がマックスに高まってますので本ブログにも引き続きご注目ください！</p><p>我ら統合思念体の起源であるDXユニットに興味を持っていただけたら、 <a href="https://jobs.qiita.com/employers/future/development_teams/109" target="_blank" rel="noopener">Qiita Jobs</a>や<a href="https://progres12.jposting.net/pgfuture/u/job.phtml?job_code=344" target="_blank" rel="noopener">このあたりの職種</a> もぜひご覧いただけると幸いです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG DXチームの統合思念体です。&lt;a href=&quot;https://cloud.withgoogle.com/
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>Google Cloud Next ’19 in Tokyo Day2 セッションレポート</title>
    <link href="https://future-architect.github.io/articles/20190804/"/>
    <id>https://future-architect.github.io/articles/20190804/</id>
    <published>2019-08-04T00:00:00.000Z</published>
    <updated>2019-08-03T15:22:13.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、TIG DXチーム<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の統合思念体です。<a href="https://cloud.withgoogle.com/next/tokyo/" target="_blank" rel="noopener">Google Cloud Next ’19 in Tokyo</a> Day2 にチームメンバーで参加しましたので参加レポートをお送りします。</p><p>チームでの参加に至った理由ですが、社内の中でも特にDXチームではGCPの活用事例が非常に増えており、著しい変化を見せるGCPの最新動向を知ること、またGCPサービスの深い理解すること、他社事例などに刺激を貰うことで、自社のFuture IoTサービス<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>をさらに成長させたい、という思いがあったことが背景にあります。</p><p>…という建付けで、実際にはチームメンバーの村田さんによる「みんなで行こうよ」発言ですぐに決まりました。</p><h2 id="Google-Cloud-Next-’19-in-Tokyoとは"><a href="#Google-Cloud-Next-’19-in-Tokyoとは" class="headerlink" title="Google Cloud Next ’19 in Tokyoとは"></a>Google Cloud Next ’19 in Tokyoとは</h2><p>「かつてないクラウドを体験しよう」をテーマに、📍東京プリンスホテル, 📍ザ・プリンス パークタワー東京の2ヶ所で 7/30~8/1の3日間に渡ってクラウドの最新動向や、採用事例を学べるセッションが開催されるカンファレンスです。ハッシュタグは <code>#GoogleNext2019</code> です<br>2019年は160ものセッションが開催され年々熱気が増しているように感じます<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><p><a href="https://cloud.withgoogle.com/next/tokyo/" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/</a></p><h2 id="会場の様子"><a href="#会場の様子" class="headerlink" title="会場の様子"></a>会場の様子</h2><p>当日は気候的に猛暑であったという点で物理的な熱気が凄まじく、会場へ向かうだけでかなり試されました。2ヶ所の会場それぞれでセッションが存在するため、シャトルバスで15minかけて移動するか、徒歩8分程で移動するかの選択肢でした。思念体を構成する一部のメンバーは両会場のセッションを交互に予約したため4往復するハメになり詰んでました。会場を一つにまとめるようなセッションの選び方もイベントを楽しむためには重要かもしれません。</p><p>ちなみに、移動途中には増上寺の敷居を通らせていただくのですが、歴史ある寺院の建造物とバックにある東京タワーを一緒に見ることができて、いかにも東京らしい絶景を味わえます。</p><p>会場では弊社の代表取締役社長の神宮さんパネルがお出迎え。知らなかったので一同でビビりました。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">フューチャーもGoogle Cloud<br>Next ’19 in Tokyoを応援しています！実は会場内のパネルに代表取締役社長の神宮さんが登場してます✨<a href="https://twitter.com/hashtag/GoogleNext19?src=hash&amp;ref_src=twsrc%5Etfw" target="_blank" rel="noopener">#GoogleNext19</a> <a href="https://t.co/maaknVdD0p" target="_blank" rel="noopener">pic.twitter.com/maaknVdD0p</a></p>&mdash; フューチャー技術ブログ (@future_techblog) <a href="https://twitter.com/future_techblog/status/1156409806606888961?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">July 31, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><h2 id="セッションレポート"><a href="#セッションレポート" class="headerlink" title="セッションレポート"></a>セッションレポート</h2><p>まずは、Day2について、私たちが聴講したセッションについて報告します。Day3の午後のセッションもいくつか参加したので、別の記事で公開予定です。</p><p>本来は3日間フル参戦したかったのですが、業務調整が大変すぎるという判断でDay1参加は見送っています。全体を期待した方、すいません。</p><h2 id="☁基調講演"><a href="#☁基調講演" class="headerlink" title="☁基調講演"></a>☁基調講演</h2><p><a href="https://cloud.withgoogle.com/next/tokyo/next-onair" target="_blank" rel="noopener">こちら</a>から講演の様子をオンデマンドで視聴できます。</p><p>内容は、様々なGCPを利用しているユーザ企業の方々がビジョンや戦略を中心に説明。統一しているのは、多くの企業も「ユーザーファースト」を謳っており、デジタルシフトがますます進んでいると感じました。技術的には、「BigQuery」や「Cloud Spanner」が多く利用されているようでした。</p><h2 id="☁Cloud-Code-とコンテナツールで-Kubernetes-を使った開発を徹底効率化"><a href="#☁Cloud-Code-とコンテナツールで-Kubernetes-を使った開発を徹底効率化" class="headerlink" title="☁Cloud Code とコンテナツールで Kubernetes を使った開発を徹底効率化"></a>☁Cloud Code とコンテナツールで Kubernetes を使った開発を徹底効率化</h2><blockquote><p>本セッションでは、Cloud Code、skaffold、Tekton などを使って、Kubernetes 開発をどのように効率化するか、デモを中心にご紹介します。Kubernetes は怖くない！<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=297697-140795" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=297697-140795</a></p></blockquote><p>わたしは普段、helmを利用したk8sアプリケーションのデプロイを行っているのですが、<code>コーディング</code>→<code>GCR push</code>→<code>kubectl apply</code>の流れを効率化できる手法を知りたいと思い参加しました。ただし、今回はCI/CDではなくローカル環境での開発をCloud Codeを利用して効率化するという話でした。</p><h3 id="k8sを用いたローカル開発の課題"><a href="#k8sを用いたローカル開発の課題" class="headerlink" title="k8sを用いたローカル開発の課題"></a>k8sを用いたローカル開発の課題</h3><p>k8sをつかうとコード開発以外に細かい作業がたくさんあります。</p><ul><li>ソースコードを変更するたびに、YAMLなどの設定の変更を始めとした様々な繰り返し作業が発生</li><li>ターミナル、ブラウザなど切り替えが多いため、コンテキストスイッチにより生産性が低下</li><li>関連ツールを全て覚えるのが困難</li></ul><h3 id="Cloud-Code-for-IDEs"><a href="#Cloud-Code-for-IDEs" class="headerlink" title="Cloud Code for IDEs"></a>Cloud Code for IDEs</h3><ul><li>エンジニアがコードにフォーカスすることを支援してくれるツールで、k8sの開発サイクルに対応し、デバッグ機能・クラスタ管理・テンプレートと編集支援をしてくれる</li><li>Kubernetesアプリケーションの継続的デプロイメントをサポートするCLIであるSkaffoldを利用している</li><li>Build push deployを指定して自動化してくれる</li></ul><h3 id="Cloud-Code-for-IDEの主な特徴"><a href="#Cloud-Code-for-IDEの主な特徴" class="headerlink" title="Cloud Code for IDEの主な特徴"></a>Cloud Code for IDEの主な特徴</h3><p>1．Kubernetesの開発サイクルを短く<br>2．デバッグ<br>3．クラスタ管理<br>4．テンプレートと編集支援<br>5．エコシステムとの統合<br>6．GCPとの統合</p><h3 id="セッションの感想"><a href="#セッションの感想" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>Kubernetesは柔軟でスケーラブルではあるが学習コストが高いというのは今身をもって体感しています。ローカルで簡単に試す環境を作りたい、勉強したいという初心者にもかなり使えるツールなのではないかなと感じました。</p><p>個人的には帰宅してすぐにVSCodeにCloud Codeプラグインを入れちゃいました。仕事ではそこそこの規模なGKEを運用しており、この場合はhelm等使うことが良いと思いますが、小規模でk8s使って開発したい時に活躍しそうです。</p><p>kubectlでのクラスタ切り替えや、gcloudでのクラスタ情報を取得など、多くのコマンドがあり覚えきれないですよね泣。そういった部分が隠蔽化されて、ワンポチでできちゃうってのはすごく使いやすいですね。</p><h2 id="☁Cloud-Run-〜Knative-を使った新しいサーバーレス"><a href="#☁Cloud-Run-〜Knative-を使った新しいサーバーレス" class="headerlink" title="☁Cloud Run 〜Knative を使った新しいサーバーレス"></a>☁Cloud Run 〜Knative を使った新しいサーバーレス</h2><blockquote><p>本セッションでは Cloud Run を使って具体的にどういったことが出来るのかデモを交えながら説明します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=297911-140799" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=297911-140799</a></p></blockquote><p>コンテナアプリケーションのデプロイ先として、Cloud Runを使うか・GKEを使うか、を迷う機会があり、Cloud Runの特徴についてより深く学びたいと考え参加を決めました！Cloud Run・Knativeについて、サーバーレスとは？という話題から実際に使うときのプロダクト選定基準まで幅広く解説してくれたセッションでした。</p><h3 id="サーバーレスとこれまでの課題"><a href="#サーバーレスとこれまでの課題" class="headerlink" title="サーバーレスとこれまでの課題"></a>サーバーレスとこれまでの課題</h3><ul><li>サーバーレスとは？<ul><li>No infra management、Fully managed security、Pay only for usage の3点</li></ul></li><li>GCPのサーバーレス<ul><li>Functions(Cloud Functions)、Apps(App Engine)、Containers(Cloud Run)</li></ul></li><li>これまでの課題<ul><li>対応言語や対応ライブラリに依存すること、ベンダーロックイン、GPU/TPUなどの特定リソースにアクセスできないことの3点</li></ul></li></ul><h3 id="Knativeが登場"><a href="#Knativeが登場" class="headerlink" title="Knativeが登場"></a>Knativeが登場</h3><ul><li>k8sクラスタ上にFaaS/PaaS実行環境を構築できる</li><li>特徴は、「OSS」「コンテナをサーバーレスライクに使える」「k8sクラスタのHWリソースが使える（GPUなどもOK）」</li></ul><h3 id="Cloud-Run"><a href="#Cloud-Run" class="headerlink" title="Cloud Run"></a>Cloud Run</h3><ul><li>Cloud Runの主な特徴が3つある<ol><li>高速なデプロイと、リクエストがなければコンテナ数は0になる = 課金されない</li><li>サーバーレスネイティブ</li><li>高いポータビリティ</li></ol></li><li>2種類のCloud Run実行パターンが有る<ul><li>Cloud Run (以下、無印)と、Cloud Run on GKEがある</li></ul></li><li>2つのCloud Runの違い<ul><li>インフラ面で違いはあるが、「Same API, Same CLI, Same App」である</li><li>ユーザ目線では、無印はマシンスペックについていじれる項目が少ない。VPCへのアクセスが無印ではまだできず、on GKEは可能という違いがある</li></ul></li><li>Cloud Runのリソースモデル<ul><li>「Service」カスタムドメインも選択可能</li><li>「Revision」splittingはApp Engineで既にできるが、Cloud Runでもそのうち可能になる（これは期待！）</li><li>「Container Instance」</li></ul></li><li>Cloud Runのその他の特徴<ul><li>エンドポイントはインターネットFacing</li><li>Cloud PubSub、Cloud Tasks、Cloud Schedulerトリガーで起動ができる</li></ul></li><li>高速なデプロイとスケールをセキュアに実現する技術<ul><li>gVisorという、ホストとコンテナの間に入るレイヤーがある</li></ul></li></ul><h3 id="Concurrencyについて"><a href="#Concurrencyについて" class="headerlink" title="Concurrencyについて"></a>Concurrencyについて</h3><p>1つのコンテナに投げられるリクエストの最大数。<br>Concurrencyの設定を変えて、コンテナ数がどのように変化するか見てみました。</p><ul><li>Concurrency = 1、1400TPSで負荷をかけると、Containerは500個へスケール</li><li>Concurrency = 80、1400TPSで負荷をかけると、Containerは100個へスケール</li></ul><p>Concurrencyの値を大きくした時に注意すべきことは、コールドスタートが少なくなることと、スレッドセーフにする必要がある点です。</p><h3 id="GCPのサーバーレスどう使い分けるか？"><a href="#GCPのサーバーレスどう使い分けるか？" class="headerlink" title="GCPのサーバーレスどう使い分けるか？"></a>GCPのサーバーレスどう使い分けるか？</h3><ul><li>Functionsは「コードベース」で「イベントドリブン」</li><li>Appsは「コードベース」で「10年の歴史があるので知見が転がっている」</li><li>Containersは「コンテナベース」、「ランタイム制約・ロックインなし」、「まだベータ版」</li><li><a href="https://cloud.google.com/serverless-options/" target="_blank" rel="noopener">公式の使い分けチャート</a>もあります！</li></ul><h3 id="セッションの感想-1"><a href="#セッションの感想-1" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>これからはコンテナベースなサーバーレスが主流になっていくのかなーと感じられるセッションでした！いまはFunctionsめちゃくちゃ使ってるけど、徐々にCloud Runに移行しようかなと思いました。</p><p>あと、Cloud Run東京リージョン来てくれてうれしい！（VPC Accessも期待しています！）</p><h2 id="☁データウェアハウスのあるべき姿とBigQueryの新機能"><a href="#☁データウェアハウスのあるべき姿とBigQueryの新機能" class="headerlink" title="☁データウェアハウスのあるべき姿とBigQueryの新機能"></a>☁データウェアハウスのあるべき姿とBigQueryの新機能</h2><blockquote><p>今日、企業はデータを活用するにあたって、<br>データ ウェアハウスに求められる役割についてあらためて考えます。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-3-S01" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-3-S01</a></p></blockquote><p>もともとデータベースを主軸に仕事をしてきたこともあり参加しました。内容としては主にBigQueryの概要と性能アップ、そして新機能の紹介でした。</p><h3 id="BigQuery特徴"><a href="#BigQuery特徴" class="headerlink" title="BigQuery特徴"></a>BigQuery特徴</h3><ul><li>性能<ul><li>ある事例では250ペタバイトの保存データや5ペタバイトのクエリの実行記録もある</li><li>昨年まで400MBのクエリが24.5secで処理されていたが、現在は4.2secで処理された記録がある</li></ul></li><li>Serverless<ul><li>upgradeやセキュリティアップデートをシームレスに実施することができる</li><li>カスタマーが一切気にすることがない世界唯一のデータウェアハウスである</li><li>自動再クラスタリングがバックグラウンドで実行される</li></ul></li><li>Open<ul><li>BigQueryをどのPFでもどのようなインプットからも利用することができる</li></ul></li></ul><h3 id="新機能"><a href="#新機能" class="headerlink" title="新機能"></a>新機能</h3><ul><li>Parquet &amp; ORC Federation Beta<ul><li>Parquet/ORCを使ったBigQueryテーブルが作成できる</li><li>列ファイル形式と論理区画により高速に</li><li>Hiveパーティションで、クエリとロードをサポートしている</li></ul></li><li>Cloud Sql Federation Beta<ul><li>BigQuery＋PostgresQL、MySQL、CloudCqlの組み合わせで使う場面が多い</li><li>External query functionを利用してBigQueryからCloudCqlへクエリを投げることができる。Joinも可能。</li></ul></li><li>BigQueryStorage APIs<ul><li>BigQueryからデータを取り出すための新しいAPIです。 </li><li>BigQueryのストレージ層に対してgRPCでクエリを投げることによって、従来のAPIと比較して高速かつリアルタイムにデータを取得できる。</li></ul></li><li>BigQueryBI Engine<ul><li>レポートで頻繁に必要とされるデータをインメモリ処理にしてくれることで、パフォーマンスを向上させる</li><li>BigQueyとBIツールの間にデータを蓄積するメモリを加えることで実現している</li></ul></li></ul><h3 id="セッションの感想-2"><a href="#セッションの感想-2" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>DWHやそれを取り巻くBIの大きな課題である性能問題に注力するだけでなく、RDBとの連携やAPIの提供などユーザがさらに使いやすく他システムと連携できるような機能を提供していますね。</p><p>今後のDWHの選定では性能だけでなくどれだけ他システムとの連携が取れるかが大事な軸になりそうと思わせるセッションでした。</p><h2 id="☁オブザーバビリティを加速させる-Stackdriver"><a href="#☁オブザーバビリティを加速させる-Stackdriver" class="headerlink" title="☁オブザーバビリティを加速させる Stackdriver"></a>☁オブザーバビリティを加速させる Stackdriver</h2><blockquote><p>本セッションでは「オブザーバビリティ」とは何かを紹介し、従来の監視との差異、そして Stackdriver がどのようにオブザーバビリティを確保する支えになるかを解説します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=295818-140777" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=295818-140777</a></p></blockquote><p>最近DevOpsという単語を意識する機会が多く、GCPにおいてDevOpsを支えるStackdriverについて詳しくなりたいと思い参加しました！SREにおけるStackdriverの活用方法について、運用におけるフェーズごとに適切なプロダクトとその利用方法を解説してくれるセッションでした</p><h3 id="DevOpsとSRE"><a href="#DevOpsとSRE" class="headerlink" title="DevOpsとSRE"></a>DevOpsとSRE</h3><ul><li>DevOpsからSREへ。SREはDevOpsの実践方法である</li><li>SREとは、意思決定にデータを用い、人間の主観で判断しない。また、運用の課題(スケーラビリティ、信頼性、効率)をソフトウェア・エンジニアリングで解決する</li><li>オブザーバビリティ（可観測性）とは、システムを運用する上で判断に必要な情報が取得可能な状態であること</li></ul><h3 id="SREにおけるStackdriverについて"><a href="#SREにおけるStackdriverについて" class="headerlink" title="SREにおけるStackdriverについて"></a>SREにおけるStackdriverについて</h3><p>各運用プロセスで必要なデータは異なります。</p><ul><li>通常運用<ul><li>全体感のわかる統計データを取得</li><li>SLO違反が発生した際にアラートが飛ぶよう設定する</li><li>Istioを使ってるのであれば、Cloud Service Meshも有益</li></ul></li><li>高負荷時・調査<ul><li>パフォーマンスモニタリングにはAPMなど専用のメトリクスが容易されているのでそれらを活用する</li><li>Stackdriver Profiler</li><li>Stackdriver Trace</li></ul></li><li>その他障害対応<ul><li>Stackdriver Error Reporting</li></ul></li></ul><h3 id="セッションの感想-3"><a href="#セッションの感想-3" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>アプリのパフォーマンス検証において有用なサービスを知ることができたので、プロジェクトでもどしどし使っていきたいなと思いました。あと、IstioはStackdriverへの詳細メトリクス連携を目的としたモニタリングの観点のみだけだとしてもぜひ導入したいと思います。</p><h2 id="☁デモで魅せます！GCP-で生産ラインにおける検査工程の効率化"><a href="#☁デモで魅せます！GCP-で生産ラインにおける検査工程の効率化" class="headerlink" title="☁デモで魅せます！GCP で生産ラインにおける検査工程の効率化"></a>☁デモで魅せます！GCP で生産ラインにおける検査工程の効率化</h2><blockquote><p>GCP のデータ関連サービスを利用したスピード開発により、<br>生産ラインにおける製品の品質チェックを、どのように実現するか解説します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-8-OS2" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-8-OS2</a></p></blockquote><p>7月から工場系の案件に携わることになったため参加しました。工場の品質管理という課題をGCPでデータ分析や機械学習を用いて解決する方法について、デモを交え解説していました。</p><h3 id="製造業の課題"><a href="#製造業の課題" class="headerlink" title="製造業の課題"></a>製造業の課題</h3><ul><li>製造業では人不足が深刻になっている</li><li>人不足のため品質管理に注力したくてもできていない</li><li>欠陥品が見つかっても何が原因であるかを分析することに時間がかかる</li><li>ラインセンサーを使用してもその場限りのデータになっていて、分析目的に利用できていない</li></ul><h3 id="どのようにデータを分析すべきか"><a href="#どのようにデータを分析すべきか" class="headerlink" title="どのようにデータを分析すべきか"></a>どのようにデータを分析すべきか</h3><ul><li>欠陥品ができた時の工場各センサーのデータをもとに原因分析する</li><li>例1<ul><li>事象：欠陥品が出た時に振動センサーが異常値を示していた</li><li>原因：地震が発生していた</li></ul></li><li>例2<ul><li>事象：欠陥品がでたときに温度変化の線サーバ異常値を示していた</li><li>原因：電気線がショートしていた</li></ul></li></ul><h3 id="GCPが提供する欠陥品の発見方法"><a href="#GCPが提供する欠陥品の発見方法" class="headerlink" title="GCPが提供する欠陥品の発見方法"></a>GCPが提供する欠陥品の発見方法</h3><ul><li>Auto MLを使って画像認識で欠陥を発見<ul><li>Googleの学習済みモデルを活用</li><li>すべての開発者が使用可能</li><li>フルカスタムモデルよりトレーニングデータ量、トレーニング時間、リソースを削減することが可能</li><li>クラウドでもオンプレでもモデル活用が可能</li></ul></li></ul><h3 id="GCPが提供する大量データ収集、分析"><a href="#GCPが提供する大量データ収集、分析" class="headerlink" title="GCPが提供する大量データ収集、分析"></a>GCPが提供する大量データ収集、分析</h3><ul><li>ペタバイトスケールのフルマネージドサービス</li><li>SQL2011またはJDBC対応</li><li>BigQueryMLで機械学習モデル作成が簡単に実現可能</li><li>位置情報のサポート</li><li>Json形式、ネストされたデータの対応</li></ul><h3 id="デモ"><a href="#デモ" class="headerlink" title="デモ"></a>デモ</h3><ul><li>小さなベルトコンベアと車のラジコンを使って工場のラインを再現</li><li>部品(車体)に傷がついたという想定でマジックで線を書き、画像認識で検知</li></ul><h2 id="☁Transform-your-work-culture-テクノロジーが可能にするイノベーションと-Diversity-amp-Inclusion"><a href="#☁Transform-your-work-culture-テクノロジーが可能にするイノベーションと-Diversity-amp-Inclusion" class="headerlink" title="☁Transform your work culture テクノロジーが可能にするイノベーションと Diversity &amp; Inclusion"></a>☁Transform your work culture テクノロジーが可能にするイノベーションと Diversity &amp; Inclusion</h2><blockquote><p>Google re:work の実践的なプログラムをもとに、どのようにテクノロジーで働き方を変え、<br>Diversity &amp; Inclusion を実現する具体的なヒントをご紹介していきます<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-6-OS2" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-6-OS2</a></p></blockquote><p>働き方改革に興味があったため参加させていただきました。</p><h3 id="働き方改革の導入手法としての鍵"><a href="#働き方改革の導入手法としての鍵" class="headerlink" title="働き方改革の導入手法としての鍵"></a>働き方改革の導入手法としての鍵</h3><ol><li>Anywhere（在宅勤務）</li><li>Simply（業務効率化）</li><li>Shorter（退社時間の計画）</li></ol><h3 id="Anywhere"><a href="#Anywhere" class="headerlink" title="Anywhere"></a>Anywhere</h3><p>実現のためには、まずテーマを1つに定め、モデル部署を選択し、期間を1ヶ月などと定め、トライアルをすることが重要だそう。効果は事後アンケートで効果測定するのが良いとのことです。まずは1回で良いので実施してみると効果が見えるそうです。</p><h3 id="Simply"><a href="#Simply" class="headerlink" title="Simply"></a>Simply</h3><p>主に会議の効率化について説明されていました。<strong>グランドルール</strong> と呼ばれるシンプルなルールを徹底し、会議時間を短縮、参加メンバーを厳選することが良いとのことです。</p><ul><li>最初にアジェンダを会議前に上げる</li><li>議事録をみんなで会議中に作る</li><li>会議中に次のTODO、決定事項が決まっている</li></ul><h3 id="Shorter"><a href="#Shorter" class="headerlink" title="Shorter"></a>Shorter</h3><p>個人的に興味深かったのですが、いわゆるノー残業デーにするのではなく、個々人で自分が帰る時間を宣言するモデルが有効だそうです。この「自分」で「自分の勤務時間」を「決める」ということの方が、一斉なノー残業デーより効果があったそうです。結果として、平均勤務時間が8-9h –&gt; 7-8h に減ったとのこと。</p><h3 id="全体を通して特に記憶に残ったこと"><a href="#全体を通して特に記憶に残ったこと" class="headerlink" title="全体を通して特に記憶に残ったこと"></a>全体を通して特に記憶に残ったこと</h3><ul><li><a href="https://www.womenwill.com/japan/" target="_blank" rel="noopener">Woman Will</a>に、Playbookがあるのでご参考に。調査結果もここに記載されている</li><li>トップダウンだけではなく、ボトムアップの動きも重要。トライアルなど実施の前にメンバーへのヒアリングをすること。納得しないと人間は動かない、変わらない</li><li>「育児・介護」など事情がある人だけのものではなく、みんなのもの</li></ul><p>とても参考になりました。スピーカーの山本 裕介さん、ありがとうございました！</p><h2 id="☁Google-Kubernetes-Engine-によるコンテナ-セキュリティの道"><a href="#☁Google-Kubernetes-Engine-によるコンテナ-セキュリティの道" class="headerlink" title="☁Google Kubernetes Engine によるコンテナ セキュリティの道"></a>☁Google Kubernetes Engine によるコンテナ セキュリティの道</h2><blockquote><p>このセッションでは Binary Auth、Container Analysis、GKE Sandbox など、GKE のコンテナ セキュリティの機能を紹介します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=320063-141088" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=320063-141088</a></p></blockquote><p>DXチームは日頃からGKEをバリバリ使っているので、GKE×セキュリティ、を考えようと参加しました。コンテナのリリースフローに合わせて、各フェーズで利用すべきセキュリティサービスを紹介してくれるセッションでした</p><h3 id="コンテナの導入による新しいセキュリティの課題"><a href="#コンテナの導入による新しいセキュリティの課題" class="headerlink" title="コンテナの導入による新しいセキュリティの課題"></a>コンテナの導入による新しいセキュリティの課題</h3><ul><li>アプリリリースの手順をおさらい<ul><li>コンテナ導入前は、「ほとんどが手動」で「サーバに直接モジュールをデプロイ」</li><li>アプリは1つのマシン上に置かれて動いているので、他のシステムアプリケーションやOSへもアクセスできてしまう</li></ul></li><li>セキュリティ上の課題<ul><li>k8sへのアクセス権限の管理が煩雑</li><li>より複雑なFW設定やネットワークポリシー</li></ul></li></ul><h3 id="コンテナによる新しいセキュリティの可能性"><a href="#コンテナによる新しいセキュリティの可能性" class="headerlink" title="コンテナによる新しいセキュリティの可能性"></a>コンテナによる新しいセキュリティの可能性</h3><ul><li>統一したモニタリング<ul><li>コンテナに不正侵入されてないか</li></ul></li><li>イメージスキャン<ul><li>脆弱性のあるモジュールを含んでいないか</li></ul></li><li>イメージ署名<ul><li>署名済みイメージから変更はないか</li></ul></li><li>サービスメッシュ<ul><li>コンテナ間のアクセス権限は正しいか、不正アクセスはないか</li></ul></li></ul><h3 id="CI-CD・ビルド"><a href="#CI-CD・ビルド" class="headerlink" title="CI/CD・ビルド"></a>CI/CD・ビルド</h3><ul><li>GCR: Container Analysis<ul><li>検出した脆弱性の内容と重要度を表示</li></ul></li><li>GKE: Binary Authorization<ul><li>信頼できるコンテナのみをGKEにデプロイ</li><li>信頼チェック済みのイメージと異なるイメージがデプロイされようとすることを防ぐ</li></ul></li></ul><h3 id="アプリケーション運用"><a href="#アプリケーション運用" class="headerlink" title="アプリケーション運用"></a>アプリケーション運用</h3><ul><li>GKE Sandbox<ul><li>GKEコンテナのセキュリティを更に強化</li><li>他人の書いたコードを自分の環境で実行するとして、信頼性のチェックは必要</li><li>パフォーマンスをすこし落としてでもセキュリティを高める思想</li></ul></li><li>gVisor<ul><li>ホストとコンテナ間に1枚かますことで脅威の影響範囲を狭めセキュアに保つ</li></ul></li><li>Event Threat Detection<ul><li>GCP環境に存在する脅威を検出</li><li>クラウドベースの脅威を迅速に検出</li></ul></li></ul><h3 id="ユーザ管理"><a href="#ユーザ管理" class="headerlink" title="ユーザ管理"></a>ユーザ管理</h3><ul><li>Cloud Identity &amp; Access Management<ul><li>きめ細かいアクセス制御</li></ul></li><li>Cloud Security Command Center<ul><li>複数PJの包括的な脅威検出情報を一元管理できる</li></ul></li></ul><h3 id="セッションの感想-4"><a href="#セッションの感想-4" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>以前参加したGoogle Kubernetes Dayでも、GCPはセキュリティ的にむしろ安全である、という主張がありましたが、まさにそれが体現されていることを実サービスの紹介によって理解できました！<br>ただやはりコンテナのランタイムポリシーチェックなどをしてくれるGCPサービスはまだ登場してこないですね…(あるいはコンテナランタイムチェックは必要ない、というGCPからのメッセージなのだろうか)</p><h2 id="☁TwitterでのGCP事例"><a href="#☁TwitterでのGCP事例" class="headerlink" title="☁TwitterでのGCP事例"></a>☁TwitterでのGCP事例</h2><blockquote><p>Twitter のデータアーキテクチャを、GCP に焦点を当てて解説します。<br><a href="https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-4-S08" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/sessions?session=D1-4-S08</a></p></blockquote><p>Twitter好きなので参加しました。このセッションのハッシュタグは <code>#GoogleNext19Twitter</code> だそうです。</p><h3 id="Twitterの規模"><a href="#Twitterの規模" class="headerlink" title="Twitterの規模"></a>Twitterの規模</h3><p>とても大きいということが数値ベースで実感としてよくわかりました。</p><ul><li>2013年天空の城ラピュタで “14万TPS”のツイート。50万コア、12万ノード、1日平均5億ツイート</li><li>Webページにembedされていたりするので、1日1兆を超えるメッセージが飛ぶ</li></ul><h3 id="オンプレミスからGCPへの移行"><a href="#オンプレミスからGCPへの移行" class="headerlink" title="オンプレミスからGCPへの移行"></a>オンプレミスからGCPへの移行</h3><p><strong>Partly Cloudy</strong> というPJ名が指す通り、まずはHadoopクラスタから段階的なクラウドリフトをしたそうです。</p><ul><li>Twitterにとって戦略的な決断で、Googleであればずっと一緒に成長し続けられると信じた</li><li>GCP移行でHadoopのクラスタの、ストレージとコンピュートを分離できた</li><li>オンプレミスとGCPの接続のため、1.6Tbpsのネットワーク帯域幅が必要！</li><li>クラスタの規模をどうするか。10ノードだと細かすぎるし、1000ノードだと大きすぎる</li><li><a href="https://cloud.google.com/twitter/" target="_blank" rel="noopener">cloud.google.com/twitter</a> にも移行について記載しているよ</li></ul><h3 id="セッションの感想-5"><a href="#セッションの感想-5" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>システム規模が私にとって異次元過ぎてクラクラしちゃいましたが、この規模のクラウドマイグレーションを成功させることができたということは、素晴らしい事例だと感じました。</p><h2 id="☁Google-Cloud-Platform-でゲノム解析"><a href="#☁Google-Cloud-Platform-でゲノム解析" class="headerlink" title="☁Google Cloud Platform でゲノム解析"></a>☁Google Cloud Platform でゲノム解析</h2><blockquote><p>GCP上で、GATK や DeepVariant、ワークフローエンジン などのオープンソースを使用し、ゲノムデータをエンドツーエンドで解析する方法を学びます<br><a href="https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-5-S03" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-5-S03</a></p></blockquote><p>畑違いなのですが、好奇心を刺激され参加させていただきました。</p><h3 id="公開データセット"><a href="#公開データセット" class="headerlink" title="公開データセット"></a>公開データセット</h3><p>バイオメディカルリサーチのためのゲノム関連の公開データセットがあります。</p><ul><li>未アノテーション系（1000人ゲノムなど）</li><li>アノテーション済みの（CinVarアノテーションなど）</li></ul><h3 id="ゲノム解析の手法"><a href="#ゲノム解析の手法" class="headerlink" title="ゲノム解析の手法"></a>ゲノム解析の手法</h3><ol><li>一時解析（サンプル、シーケンサ、生データ）<ul><li>物理的な解析</li></ul></li><li>二次解析（FASTQ, BAM, VCF）<ul><li>Pipelines APIを用いて業界標準のツールやフレームワークを利用可能</li><li>GATK, dsub/SAMtools, DeepVariant, NextflowをCloudShellから簡単に実行していました</li></ul></li><li>三次解析（解釈、アノテーション）<ul><li>アノテーション処理はBigQuery, Dataprep, AI Platform Notebooksがオススメ</li><li><a href="https://github.com/googlegenomics/gcp-variant-transforms" target="_blank" rel="noopener">Variant Transforms</a>をGCP上で動かせば、 8000万行というそこそこ大きなデータ量も、並列処理を行うことで2hで完了できる</li><li>BigQueryを用いたTi/Tv比（ゲノムの品質を見るための指標らしい）のクエリでは、1万人サンプルだと、23TB、行数が3.6億レコードになるが、BigQueryだと1SQLで計算できる。チューニングしなくても8minほどで終わるが、さらにクラスタ化と不要データを削除することで、1min以内に処理が完了</li><li>DataprocはSpark/Hadoopのマネージドサービスだが、ゲノム解析ツールのHailも実行可能</li><li>ParabricksでGPUを用いたディープバリアントでき、マーケットプレースから簡単に実行可能</li></ul></li></ol><h3 id="セッションの感想-6"><a href="#セッションの感想-6" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>ゲノム領域は文字通り何も知識がありませんでしたが、単語レベルで知らないことばかりで楽しかったです。<br>ゲノム解析の仕事をしている人は？という質問で手を上げた人が少なかったので、日本でこの領域を攻めると先駆者になれそうだと思いました。</p><h2 id="☁マイクロサービス、サービスメッシュ（Istio）導入により迅速な開発を実現"><a href="#☁マイクロサービス、サービスメッシュ（Istio）導入により迅速な開発を実現" class="headerlink" title="☁マイクロサービス、サービスメッシュ（Istio）導入により迅速な開発を実現"></a>☁マイクロサービス、サービスメッシュ（Istio）導入により迅速な開発を実現</h2><blockquote><p>マイクロサービス、サービスメッシュ（Istio）導入により、開発、運用の方法が変わります。<br>このセッションでは、アプリケーション開発の効率を高めるために Istio がどのように既存のネットワークやセキュリティを変えるかについて解説します。<br><a href="https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-6-S11" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-6-S11</a></p></blockquote><p>Istioの機能説明というよりは、なぜそれが必要になったかといった背景などを詳しく説明していただけました。サービスメッシュという考えをより深く理解できると思います。</p><h3 id="サービスメッシュの背景"><a href="#サービスメッシュの背景" class="headerlink" title="サービスメッシュの背景"></a>サービスメッシュの背景</h3><ul><li>MicroServiceが犠牲にしている部分に、オペレーションの負荷増大がある<ul><li>Service as a Serviceを実現するために、サービスのオペレーション部分を同じ形式にする</li></ul></li><li>よくあるシステムの課題として「脆弱である」・「透明性の低い」・「成長への足かせになる」といったことがある<ul><li>IPベースのFirewallルールはどのシステムがどのシステムにアクセスしているか分からない</li><li>複数のシステムを経由する時に本当の送信元が分からない</li><li>サービスの追加に、NW（Firewall）、認証、認可、モニタリングが追加で時間がかかる</li></ul></li><li>k8sを使っているからと言って解決されない領域<ul><li>通信時の暗号化が義務付けられていますか？鍵変更の頻度は？</li></ul></li><li>これからは、<em>サービスメッシュ</em><ul><li>これを管理するためのもの、全てのサービスを同じにする、認証、認可、モニタリングも同じにする</li><li>透明性が高く、言語非依存、柔軟かつ簡単にNW機能を自動化する仕組み</li></ul></li></ul><h3 id="サービスメッシュの効果"><a href="#サービスメッシュの効果" class="headerlink" title="サービスメッシュの効果"></a>サービスメッシュの効果</h3><ul><li>観測性やアジリティが高くなる。ゴールデンシグナル（全サービス共通的なエラーレート、レイテンシ、APIコール数などの指標）が見れる。ロールアウト時に徐々に新サービスにリクエストを転送し、エラーバジェットを使い潰さないようにする</li><li>サービスメッシュの重要な点は、<em>統一性の獲得</em> できること</li><li>アプリケーションからインフラから切り離すことができる。例えば、リトライのロジックを書く時、アプリ開発者はインフラのコードを書くことが無くなる。リトライ回数、バックオフ、ジッター追加などの運用が、サービスメッシュにしておけば操作できる</li><li>k8sを導入していてもほとんどのサービスVM上で動いているのでは？ VMにサービスメッシュを入れて、k8sにサービスメッシュを入れて、通信させることで柔軟性が増し、モダナイゼーションを迅速に行える</li></ul><h3 id="セッションの感想-7"><a href="#セッションの感想-7" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>Kubernetesを導入するだけでは解決しない点は、「確かに..」と納得でした。<br>既存のVMにサービスメッシュを導入しモダナイゼーションへ繋げる点は興味深いと思いました。</p><h2 id="☁GCP-で稼働する-Go-アプリケーションのパフォーマンスチューニング"><a href="#☁GCP-で稼働する-Go-アプリケーションのパフォーマンスチューニング" class="headerlink" title="☁GCP で稼働する Go アプリケーションのパフォーマンスチューニング"></a>☁GCP で稼働する Go アプリケーションのパフォーマンスチューニング</h2><blockquote><p>このセッションではレイテンシに問題がある Go 言語のアプリを例にあげて、App Engine と Kubernetes Engine といったクラウドコンポーネントを最適化していく手法を詳細にご紹介します<br><a href="https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-7-S03" target="_blank" rel="noopener">https://cloud.withgoogle.com/next/tokyo/my-schedule?session=D1-7-S03</a></p></blockquote><p>最適化の中でも、レイテンシ（応答性能）を小さくすることにフォーカスするセッションでした。<br>「機械より人間の時間のほうが大事だからね」というイケメン発言が素敵でした。</p><h3 id="計測"><a href="#計測" class="headerlink" title="計測"></a>計測</h3><ul><li><strong>「計測」は 直感に反する！</strong></li><li>Goのコードは通常はサーバコンポーネントなので、その部分だけ高速化しても効果薄の場合があるので注意。<strong>ユーザーファースト</strong>を掲げ、サーバメトリクスだけに依存せず、ブラウザ中のJS、キャッシュ、レンダリングも測定すること。</li><li>Stackdriverのでウォーターフォールトレースが可能。どのようなAPIコールをどのような順番で出力されるのか。シーケンシャルか、コンカレントかが分かる</li></ul><h3 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h3><ul><li>RDBが支配的な場合インデックスを貼るなどで対応しよう</li><li>サービスがバッチコールを受け入れる場合ば、NWレイテンシや認証が短縮できるのでバッチ実行しよう</li><li>関連しないやつはコンカレントに実行しよう</li><li>メールの送信を、CloudTaskを用いて非同期化しよう</li></ul><h3 id="Go-Tooling"><a href="#Go-Tooling" class="headerlink" title="Go Tooling"></a>Go Tooling</h3><ul><li>性能計測はベンチマークのテストコードを書き、 <code>go test -bench=.</code> で取得できる</li><li>逐次処理のトレースは、<code>go test -bench=. -trace a.trace</code> と <code>go tool trace --http :6060 a.trace</code> で可視化できる</li><li>CPUプロファイリングは、比較的ランタイム負荷が小さい処理で、実行中のgorutineのコールトレースを収集する。<code>go test -bench=. -cpuprofile a.prof</code> や<code>go tool pprof -http :6060 a.prof</code></li></ul><h3 id="セッションの感想-8"><a href="#セッションの感想-8" class="headerlink" title="セッションの感想"></a>セッションの感想</h3><p>ユーザファーストという言葉は何度強調しても足りない！とか、ボトルネックになっていない箇所を最適化しようとするのは自転車置き場議論だ！といったワードがとても面白かったセッションでした。また、go toolを活用して解析した結果、ボトルネックが標準ライブラリにあるという事がわかり、だったら出力のバッファリングをあえてなくしたほうがユーザ体験が良くなるよといった流れが、実に直感に反した最適化で学びでした。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>前回のGoogle Next in Tokyoにも増してKubernetesとそのエコシステムについてのセッションが増えてきたように思います。Kubernetes, Istio, Knativeなどデファクトスタンダートになりつつある、これらOSS群をフルマネージドで利用できる環境を整えるんだ、というクラウドプラットフォーマーとしての強い意志を感じました。</p><p>ちょうどDXチーム内でもKubernetesについて持ち回りで5分話す会というのを先月から始めたのですが、直近学んだことがセッションの中でも多数登場し、予習復習の意を含めとても有意義なイベントなったのは非常に良い収穫でした。</p><p>今後は9/3に開催されるGoogle Kubernetes Dayが控えており、これからの動向がより一層楽しみです！</p><p>ぜひDXユニットに興味を持っていただけたら、 <a href="https://jobs.qiita.com/employers/future/development_teams/109" target="_blank" rel="noopener">Qiita Jobs</a>や<a href="https://progres12.jposting.net/pgfuture/u/job.phtml?job_code=344" target="_blank" rel="noopener">このあたりの職種</a> もご覧いただけると幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。その中でもDXチームは特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://future-architect.github.io/articles/20190723/ あたりを参考ください</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">ちなみに2018年は2日間開催で130セッションでした。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、TIG DXチーム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>俺のインフラデザインパターン　～過去の失敗に学ぶニッチなインフラの話～</title>
    <link href="https://future-architect.github.io/articles/20190731/"/>
    <id>https://future-architect.github.io/articles/20190731/</id>
    <published>2019-07-31T00:47:37.000Z</published>
    <updated>2019-07-31T04:04:31.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="１．自己紹介"><a href="#１．自己紹介" class="headerlink" title="１．自己紹介"></a>１．自己紹介</h1><p>2014年キャリア入社、TIG<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属の二木です。読み方は「フタキ」ではなく「ニキ」と読みます。メンバーからは「N i K i」といった雰囲気で呼ばれています。入社後は、流通・小売業界の案件にて、インフラ全体を設計/構築/運用するチームに所属し、日々成長を実感しながら過ごしています。</p><p>本記事では、フューチャーにおける <strong>インフラ設計技法の知財化</strong> を進める活動について報告します。</p><p>ちなみに、タイトルの「俺の～」は、二木が整理した内容を中心にまとめるよという意思表示と、目を惹くようなタイトルにしたかったための命名です。</p><h1 id="２．はじめに"><a href="#２．はじめに" class="headerlink" title="２．はじめに"></a>２．はじめに</h1><p>早速ですが、システム構築におけるインフラとは何を指すでしょうか？<br>色々な解釈が可能かと思いますが、フューチャーにおけるインフラとは、以下のように定義されています。</p><ul><li><strong>『!!!!!! ソースコード以外は全てインフラ領域である !!!!!!』</strong> <ul><li>※詳細は<a href="https://future-architect.github.io/articles/20170109/">こちらの記事</a>をどうぞ</li></ul></li></ul><p>もう一度いいます。「ソースコード以外は全てインフラ領域である」です。<br>この無限大にスコープが広がりそうな定義のため、私の入社当初は、カバー範囲の広さ・その影響力の大きさに振り回され、プロジェクト規模の大きさもあいまって、うまく立ち回れない日々もありました。</p><p>もちろん、フューチャーではこのカバー範囲の広さに対抗するため、多くのシステム開発PJで培った設計成果物が、テンプレートのような形で、だれでも利用可能な形で存在します。</p><p>では、すでに過去の成果物が存在するにも関わらず、なぜインフラ設計技法の知財化を進めるかについては、次章で説明します。</p><h1 id="３．インフラ知財の整備に取り組むきっかけ"><a href="#３．インフラ知財の整備に取り組むきっかけ" class="headerlink" title="３．インフラ知財の整備に取り組むきっかけ"></a>３．インフラ知財の整備に取り組むきっかけ</h1><p>2019年8月時点で、私が対応中のプロジェクトは2019年秋にリリースです。</p><p>日々品質向上に取り組んでいますが、その中で反省すべきことがありました。</p><p>過去プロジェクトのインフラ知財（設計書、ツールなど）を活用して、高品質なシステムを短納期で構築する予定でしたが、その設計背景・意図を読み解くことをしなかったため、後々の工程で手戻りが発生してしまいました。</p><h2 id="３－１．あるべきディレクトリ設計"><a href="#３－１．あるべきディレクトリ設計" class="headerlink" title="３－１．あるべきディレクトリ設計"></a>３－１．あるべきディレクトリ設計</h2><p>一例として、オンプレミス環境のディレクトリ設計構築で発生した問題を簡単に説明します。<br>インフラ知財では、Tomcatディレクトリ配下に、環境・システム種別のディレクトリを作成しています。</p><p><strong>図1:インフラ知財のディレクトリ構成</strong><br><img src="/images/20190731/photo_20190731_01.png"></p><p>プロジェクト過渡期の環境維持や、運用・保守まで見据えたホスピタリティのある設計になっていました。</p><h2 id="３－２．手戻りが発生したディレクトリ設計"><a href="#３－２．手戻りが発生したディレクトリ設計" class="headerlink" title="３－２．手戻りが発生したディレクトリ設計"></a>３－２．手戻りが発生したディレクトリ設計</h2><p>インフラ知財をプロジェクトで利用する際、構成をシンプルにしようと、不要と思った環境・システム種別のディレクトリを削除しました。</p><p><strong>図2:プロジェクトで設計構築したディレクトリ構成</strong><br><img src="/images/20190731/photo_20190731_02.png"></p><p>Tomcatディレクトリ配下に、環境・システム種別のディレクトリがないため、環境維持を行うには非常に分かりづらい設計となっていました。</p><p>プロジェクト過渡期にテスト環境が複数面必要となり、現行のディレクトリ構成では環境維持が困難になりました。<br>結果、本来あるべきディレクトリ構成に変更が必要と気付き、以下のような手戻りが発生しました。</p><ul><li>ローカルディレクトリの再作成</li><li>NFS領域のディレクトリの再作成</li><li>アプリケーションのデプロイ先変更</li><li>アプリケーション、ミドルウェア、スクリプトのログ出力先変更</li><li>アプリケーション、ミドルウェア、スクリプトの環境変数の設定変更</li><li>アプリケーション、ミドルウェア、スクリプトのリリース処理の変更</li><li>ジョブ定義の設定変更</li><li>監視定義の設定変更</li><li>ログ収集の設定変更</li><li>ログ参照の設定変更</li></ul><p>さくっと書きましたが、それぞれがそこそこ時間が掛かる作業だったので大変な思いをしました。</p><h1 id="４．本活動のゴール"><a href="#４．本活動のゴール" class="headerlink" title="４．本活動のゴール"></a>４．本活動のゴール</h1><p>現在、同じ失敗繰り返さないために、 <strong>利用者が設計背景・意図をしっかりと理解できる</strong> よう、インフラ知財の整備を進めています。</p><p>タイトルにあるようにインフラデザインパターンのパターンとは、「状況」「問題」「解決」「名前」の4要素で構成されているかと思います<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。ここでいう「解決」「名前」の部分は過去資産でまとまっていましたが、「状況」「問題」の部分も、その設計背景や意図をキチンと明文化することで整理していきます。</p><p>この活動により、インフラ知財を誰がどのプロジェクトで利用しても、一定の品質を担保し、かつ、設計・構築やレビューの工数を削減することを実現します。</p><h2 id="４－１．対象技術要素"><a href="#４－１．対象技術要素" class="headerlink" title="４－１．対象技術要素"></a>４－１．対象技術要素</h2><p>フューチャーでは、オープンな技術を要素別に整理した技術マップがあり、Winners‘ Circleと呼んでいます。</p><p><strong>図3:Winners‘ Circle</strong><br><img src="/images/20190731/photo_20190731_03.png" style="border:solid 1px #000000"><br>※全く見せられなくてすいません…</p><p>ボカシが強めですが、Winners‘ Circleは以下のような構成になっています。</p><ul><li>内側ほどプロジェクトでの利用実績が多数ある<strong>Mainカテゴリ</strong><ul><li>現時点で顧客への導入実績・ノウハウともに充実しているフューチャーにおける主要技術です</li></ul></li><li>外側ほど今後の利用を前提に技術検証を進めていく<strong>Watchカテゴリ</strong><ul><li>導入実績がなく、品質担保の手法や非機能要件がまだ把握できていない技術要素です</li></ul></li></ul><p>Watchカテゴリにあるような、新技術の検証ってわくわくしますし、最先端の技術導入をするような取り組みは、時代を切り開いているようでドヤ顔したくなりますよね。</p><p>しかし、本活動ではプロジェクトで利用することを想定しているので、Winners‘ CircleにおけるMainカテゴリを対象としています。</p><p>まずは、直近のプロジェクトで扱った技術要素からスタートします。</p><h2 id="４－２．実施計画"><a href="#４－２．実施計画" class="headerlink" title="４－２．実施計画"></a>４－２．実施計画</h2><p>Winners‘ CircleのMainカテゴリにはまだまだ多数の技術要素が存在するので、以下のようなサイクルを通して、インフラ知財のカバー範囲を拡大していき、全社で利用できるインフラ知財へと発展させて行きたいと考えています。</p><p><strong>図4:インフラ知財整備活動の計画</strong><br><img src="/images/20190731/photo_20190731_04.png"></p><ol><li>インフラ知財の整備を行う（β版）</li><li>インフラエンジニアの興味を引きそうな内容をフューチャー技術ブログに投稿する（仲間を見つける）</li><li>2019年を目途にインフラ知財β版を完成させ、正式版ver1.0にする</li><li>各プロジェクトにインフラ知財を展開し一緒に育てる</li><li>各プロジェクトで育ったインフラ知財をmasterにマージし、バージョンアップしていく</li></ol><p>社員の皆さまも、興味がある方はぜひ声をかけてください！一緒にやりましょう。</p><h1 id="５．記事掲載予定"><a href="#５．記事掲載予定" class="headerlink" title="５．記事掲載予定"></a>５．記事掲載予定</h1><p>本活動を通して、フューチャーのインフラエンジニアがどう品質を高めているか、ニッチな領域を題材として記事を書いていこうと思います。</p><ul><li>俺の『ユーザ管理・ディレクトリ管理』</li><li>俺の『スクリプト設計・ジョブ管理』</li><li>俺の『ログ管理』</li><li>俺の『運用監視』</li></ul><h1 id="６．おわりに"><a href="#６．おわりに" class="headerlink" title="６．おわりに"></a>６．おわりに</h1><p>最後まで読んでいただきありがとうございます。<br>インフラエンジニアとして頑張っている方に共感いただければ幸いです。<br>そして、俺のシリーズの記事を見て、一緒に働いてみたいと思っていただければ、是非<a href="https://progres12.jposting.net/pgfuture/u/job.phtml?job_code=187" target="_blank" rel="noopener">このあたりの職種でエントリー</a>お願いします！</p><p>ご意見、ご感想を頂戴できますと、執筆者のモチベーションが上がります。（褒めてください笑）<br>また、こんな内容を記事に取り上げてほしいなどあればお気軽にご連絡お願いします。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略です</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">http://creativeshift.co.jp/pattern-lang/</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;１．自己紹介&quot;&gt;&lt;a href=&quot;#１．自己紹介&quot; class=&quot;headerlink&quot; title=&quot;１．自己紹介&quot;&gt;&lt;/a&gt;１．自己紹介&lt;/h1&gt;&lt;p&gt;2014年キャリア入社、TIG&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/tags/Infrastructure/"/>
    
  </entry>
  
  <entry>
    <title>社内技術書輪読会とSite Reliability Engineering</title>
    <link href="https://future-architect.github.io/articles/20190729/"/>
    <id>https://future-architect.github.io/articles/20190729/</id>
    <published>2019-07-28T23:08:56.000Z</published>
    <updated>2019-07-28T23:12:35.625Z</updated>
    
    <content type="html"><![CDATA[<p>TIG/DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所属のLEEです。</p><p>2019年より社内で輪読会を企画運営し、このたび初回の課題図書になってた<a href="https://www.oreilly.co.jp/books/9784873117911/" target="_blank" rel="noopener">Site Reliability Engineering</a> を全10回で無事読破できました。</p><p>これを記念に実施概況をまとめさせていただきます。</p><h1 id="Who-am-I"><a href="#Who-am-I" class="headerlink" title="Who am I"></a>Who am I</h1><p>名前から分かる通り韓国出身で、入社してちょうど1年くらいになりました。前職がWeb系の会社のエンジニアだったのでITコンサルティングを生業とするフューチャーに入社したのは、ある意味エンジニア界隈のトレンドに逆走した感じかもしれませんが、外には出せない情報ばかりの貴重な経験をさせてもらえているので良い決断だったと思っています。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>入社して今までの会社と違う環境で戸惑いながらも、自分が慣れているWeb系のテイストを取り入れようとしました。</p><p>その一つが社内勉強会の企画でしたが、すでにいくつか定期開催済みということもあり、もう少しひねりを加えてと始めたのが輪読会でした。</p><p>輪読会は登壇スタイルの勉強会と比べて以下の特徴があると思います。</p><ul><li>毎回のテーマは本の内容に限定され特別に悩む必要がなく</li><li>忙しい業務の中の準備の手間が発表者一人に集中させない</li><li>勉強パーティー的なイベント性を排除しやすい</li></ul><p>参加型でライトでありながらみんなの成長に繋がるような勉強会になれたらと思ってました。</p><h1 id="書籍の選定"><a href="#書籍の選定" class="headerlink" title="書籍の選定"></a>書籍の選定</h1><p>まず初回にどの本にするかと、これからの書籍選定ポリシーを決めました。<br>経験者などに話を聞きながら以下のように決めました。</p><ul><li>古すぎなく、最新のトレンドが取り入れられ<ul><li>過去の名著はすでに読破したヒトがいる</li></ul></li><li>一人で読むには負担が多く分厚い本<ul><li>簡単な本は一人で読めば良い</li></ul></li><li>明日業務に役立つことは無いけど、将来的に地力を伸ばせること<ul><li>ちょっと背伸びした内容で、達成感も得やすい</li></ul></li></ul><p>他には、別のエンジニアコミュニティのオンライン読書会の経験から、<em>数式や図式が重要なファクターじゃない読み物</em> を条件に加えました。</p><p>初回としては人を可能な限り呼び寄せるべく、エンジニア界隈のビッグウェーブに乗り、Googleの<a href="https://landing.google.com/sre/books/" target="_blank" rel="noopener">Site Reliability Engineering</a>を選びました。これに関しては後で詳しく話します。</p><h1 id="運営ポリシー"><a href="#運営ポリシー" class="headerlink" title="運営ポリシー"></a>運営ポリシー</h1><p>輪読会をやるとしたら自然に思い浮かぶ要素を決めるだけでした。</p><ul><li>開催頻度<ul><li>週1</li></ul></li><li>1回にかける時間<ul><li>集中力が必要になるので1時間以下にした</li></ul></li><li>1回でどれくらいの量・ページを消化するか<ul><li>その分量の担当者の人数</li></ul></li><li>1冊の本を何回に分けて終わらせるか<ul><li>長すぎると消化しきれず飽きられてしまう</li></ul></li></ul><p>あと一つ、自分は一応社歴が浅かったため、以下の根回しをしておきました。</p><ul><li>ユニット内のサクラ募集</li><li>社内に顔が利く真野<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>さんを利用して開催の告知</li></ul><h1 id="当日の運用"><a href="#当日の運用" class="headerlink" title="当日の運用"></a>当日の運用</h1><p>進行としてはSRE本の場合は全34章だったので一人当たり1章ずつ担当、1回に2〜3章を1時間する計画で10週〜3ヶ月で終わらせる目標で勧めました。実際の輪読会は以下のような感じに進めました。</p><ul><li>前回の終わり頃に担当者を募集</li><li>担当者はみんなが見れる章の要約資料を事前に用意</li><li>皆に本を片手に内容を噛み砕いて説明する</li><li>理解できなかった部分をみんなに質問を投げかける</li><li>関連する自分の経験を共有する</li><li><strong>やらなくてもいいと思った章は飛ばす</strong><ul><li>一部のケーススタディなど</li><li>自分でざっくり読んで5分以内にまとめるなど</li></ul></li></ul><p>「輪読会はこれが初めて！」というメンバーが多かったですが、第1回目から予め決めておいたルールに従い運営したため、特に問題が発生しなかったので良かったです。</p><h1 id="輪読会の雰囲気"><a href="#輪読会の雰囲気" class="headerlink" title="輪読会の雰囲気"></a>輪読会の雰囲気</h1><p>あれこれの根回しのおかげて、ユニットメンバー含め、あらゆるところのプロジェクトから参加してくれました。弊社AIグループの方や同じTIGではないインフラに興味のある若手の方、他にも10年以上なるベテランまで、あらゆる客層から輪を広げることができたのは嬉しかったです。</p><p>ということで、参加者はバラエティ豊かでした。</p><p>1年目の新人さんから、オンプレミス～クラウドまで構築し続けたインフラスペシャリスト、Oracleの全てを知り尽くすDBスペシャリスト、データ解析プラットフォームの構築エンジニアや、Webフロントエンドのスペシャリストまで様々。</p><p>彼らが輪読会中のちょっと専門用語に反応して、自らの経験を話してくれたのは非常に勉強になりました。</p><p>ここだけの話、1番盛り上がったのは「11章のオンコール対応」や「13章　緊急対応」です。<br>みなさん、システムのグランドデザインから保守運用まで対応されているメンバーが多かったので、実感が伴った「わかるわかる」とか、「あるよねー」と同意が連発していました。</p><p>他にも、リスクの管理手法として「エラーバジェット」という概念は、全てにおいて数値というファクトベースに改善サイクルを回るGoogleらしいなとみんなで感心していました。</p><p>また、輪読会の中では、こういったGoogleの物語を聞いて「さすがぐーぐる、言ってることが違うな」とか「それぐーぐるだからできるもんっしょ」といった雰囲気でところどころ茶々を入れながら進められたので和気あいあいです。</p><h1 id="効果"><a href="#効果" class="headerlink" title="効果"></a>効果</h1><p>輪読会の効果として<strong>積読の解消</strong>は言うこともないでしょう。</p><p>興味があって買ったはいいものの、手をつけるにはあまりにも分厚い技術書が本棚に溜まっていく経験が多くのエンジニアにはあるはずです。その中の一冊をみんなと協力して分担して読み終えていくのは、勉強会的な要素も含めると、シナジー効果があり効率的だと思います。</p><p>実際こういった輪読会の読書法は、ある程度ざっくりした内容を頭の中に掴んでおいて、必要になった時に必要な部分を思い出して熟読するスタイルの<em>カタログのような技術書</em>にはぴったりだなと思っているところです。</p><p>その他にも、勉強会でも得られる以下のような効果がありました。</p><ul><li>関連経験・知見の共有</li><li>人脈を広げる</li><li>内容の批評</li><li>コミュニケーションコストを節約できるコンテキストの共有<ul><li>本に出ているコンセプトと用語(バジェット・トイル・ポストモーテムなど)</li></ul></li></ul><p>週1ペースで1時間にも満たない時間でこれだけの効果があるということで、これからも継続しようと話しています。</p><h1 id="個人の所感"><a href="#個人の所感" class="headerlink" title="個人の所感"></a>個人の所感</h1><p>1冊の本で数回を繰り返す輪読会というのは<em>「本の読解」「要約」「プレゼンテーション」</em>というフローなのですが、完全に国語能力が要求されると感じました。回を繰り返すにつれ、斜め読みなどで読書の効率を上げたり、聞く人のコンテキストに合わせてうまく説明するなど工夫をこらしましたが、慣れるまでは冗長な説明をしてしまうなど大変でした。</p><h1 id="Site-Reliability-Engineeringについて"><a href="#Site-Reliability-Engineeringについて" class="headerlink" title="Site Reliability Engineeringについて"></a>Site Reliability Engineeringについて</h1><p>Googleが提唱したSREとはどういったもので、どういう道のりをたどって現在に至ったのかを記した知人曰く<em>インフラエンジニアのバイブル</em>のような内容です。</p><p>インプラエンジニア、もしくは運用エンジニアの要素として自動化・モニタリング・SLO・オンコール対応・リリースなどに加えマネジメント・ポストモーテム・教育などにも触れています。</p><p>感想としては、なんというかイマドキのインフラエンジニアならばこういったものは当たり前だろといった感じでした。</p><p>しかし、実際こういった当たり前のことを当たり前のようにやることも大変難しいものですし、Googleの場合、それをはるか以前から研究・実践し、当たり前というトレンドを自ら先導し、エンジニア界隈に拡散させたと考えることもできるではないでしょうか。</p><p>あと、これは弊社<a href="https://twitter.com/shibu_jp" target="_blank" rel="noopener">渋川さん</a>からの引用で、会のみんなも同意した話ですが<strong>Google SREのみんなが書きあげた同人誌の総集編</strong>と一言で言えるものでした。各章はまるである勉強会の一つのセッションのような感覚で読めると思います。</p><h1 id="System-Performance、それから…"><a href="#System-Performance、それから…" class="headerlink" title="System Performance、それから…"></a>System Performance、それから…</h1><p>SRE本を無事終えて、2冊目は<a href="https://www.oreilly.co.jp/books/9784873117904/" target="_blank" rel="noopener">詳解 システム・パフォーマンス</a>が選ばれ絶賛輪読中です。次の本はもう少し軽いものがいいなと願ってましたがSRE本より厚くなるとは皮肉なものですね。</p><img src="/images/20190729/photo_20190729_01.png"><p>今後はConnpassなどで外部の人を招待し、もっと輪を広げていこうと考えています。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>TIG/DXユニットでは社外の勉強会への参加以外にも、様々な社内勉強会を企画運営しています。</p><p>ぜひDXユニットに興味を持っていただけたら、 Qiita Jobsもご覧いただけると幸いです。<br><a href="https://jobs.qiita.com/employers/future/development_teams/109" target="_blank" rel="noopener">https://jobs.qiita.com/employers/future/development_teams/109</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。DXユニットはTIGの中でも特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">フューチャー技術ブログの運営をしていたり、過去には新人研修に関わっていたため、比較的顔が広いと思われたようです。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TIG/DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;所属のLEEです。&lt;/p&gt;
&lt;p&gt;2019年より社内で輪読会を企画運営し、このたび初回の課題図書になってた&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="Culture" scheme="https://future-architect.github.io/categories/Culture/"/>
    
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/tags/Infrastructure/"/>
    
  </entry>
  
  <entry>
    <title>Future IoTのstackshareを公開しました</title>
    <link href="https://future-architect.github.io/articles/20190723/"/>
    <id>https://future-architect.github.io/articles/20190723/</id>
    <published>2019-07-22T23:35:13.000Z</published>
    <updated>2019-07-22T23:43:43.509Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIG<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> DXユニット<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> の武田です。</p><p>先日「Future IoT」のstackshareを公開しました。<br><a href="https://stackshare.io/future-corporation/futureiot" target="_blank" rel="noopener">https://stackshare.io/future-corporation/futureiot</a>  </p><img src="/images/20190723/photo_20190723_01.png" style="border:solid 1px #000000"><p>Futureとしてstackshareを活用するのは初めての試みとなりますが、本記事では公開に至った経緯や技術スタックの採用戦略について簡単にお伝えできればと思います。</p><h2 id="stackshareとは"><a href="#stackshareとは" class="headerlink" title="stackshareとは"></a>stackshareとは</h2><img src="/images/20190723/photo_20190723_02.png"><p><a href="https://stackshare.io" target="_blank" rel="noopener">https://stackshare.io</a><br>世界中のツールやサービスがどのような技術スタックを使っているかチェックできるサービスになります。FacebookやTwitterといった有名企業もstackshareで自社の技術スタックを公開しています。  </p><p>また「The Top 50 Developer Tools」という形で毎年、各企業が利用したツールのランキングも発表されています。<br><a href="https://stackshare.io/posts/top-developer-tools-2018" target="_blank" rel="noopener">https://stackshare.io/posts/top-developer-tools-2018</a><br>世の中の技術的なトレンドを掴むことが求められるエンジニアにとって非常に有用なサービスとなっています。</p><h2 id="Future-IoT-とは"><a href="#Future-IoT-とは" class="headerlink" title="Future IoT とは"></a>Future IoT とは</h2><p>Futureが提供するIoTの活用に特化したコンサルティングサービスです。<br>Future IoTは「トータルデザイン」をコンセプトにしており、ハードウェアデバイス、通信、データ解析などのアーキテクチャ全体のデザインから構築までを一貫して提供します。</p><p>詳細については次の記事で紹介されてますので、ぜひご覧ください。</p><blockquote><p>IoT/M2M展へ「Future IoT」出展してきました！<br><a href="https://future-architect.github.io/articles/20190509/">https://future-architect.github.io/articles/20190509/</a></p></blockquote><h2 id="なぜ公開に至ったか"><a href="#なぜ公開に至ったか" class="headerlink" title="なぜ公開に至ったか"></a>なぜ公開に至ったか</h2><p>昨今の技術トレンドとしてオープンな技術がますます主役になってきていますが、それはコンサルティングサービスとて例外ではありません。</p><p>DXユニットでは「オープンであること」を組織のテーマとしており、自分たちが採用している技術についても積極的に世の中に発信することで、技術力をアピールし、プレゼンスを向上させていきたいと考えています。<br>また、自分たちの採用技術に精通した世の中のエンジニアにアプローチし、積極的に採用につなげていくといった狙いもあります。</p><p>このような経緯からstackshareの公開に至りました。</p><h2 id="技術採用戦略について"><a href="#技術採用戦略について" class="headerlink" title="技術採用戦略について"></a>技術採用戦略について</h2><p>stackshareを見るとFuture IoTでは下記のようなプロダクト、サービスを採用しています。（抜粋）</p><table><thead><tr><th>分類</th><th>プロダクト、サービス</th></tr></thead><tbody><tr><td>Messaging</td><td>Apache Kafka, Mosquitto</td></tr><tr><td>Data Processing</td><td>Spark Streaming, Hadoop</td></tr><tr><td>Data Store</td><td>HBase, Google Big Query, Google Cloud SQL, Elasticsearch</td></tr><tr><td>Language</td><td>Golang, Java</td></tr><tr><td>Business Tools</td><td>Slack, Confluence, drawio</td></tr></tbody></table><p>ここで記載した技術スタックはあくまで実績に基づいた一例であり、この技術に縛られるということはありません。Future IoT、ひいてはDXユニットでは下記のコンセプトに基づいてお客様にとって最適な技術を選定しています。</p><h4 id="オープンであること"><a href="#オープンであること" class="headerlink" title="オープンであること"></a>オープンであること</h4><p>先にも述べましたがオープンな技術を積極的に採用します。<br>これはコスト面での優位性だけでなく、ベンダロックインを避けることなどを目的としています。</p><p>一方で各種クラウドベンダのフルマネージドサービスのようなものを選択しないということではありません。コスト面、拡張性、移植性、ロックインのリスクといったさまざまな要素を考慮し、OSSとマネージドサービスをフラットに比較し最適なものを選択しています。</p><h4 id="モダンかつ高度な技術であること"><a href="#モダンかつ高度な技術であること" class="headerlink" title="モダンかつ高度な技術であること"></a>モダンかつ高度な技術であること</h4><p>最新の技術スタックを積極的に採用し、常に最先端の技術にキャッチアップします。<br>これはお客さまに最先端のコンサルティングサービスを提供するということはもちろん、社内エンジニアの技術力やモチベーションを向上していくことも狙いとしています。<br>DXユニットは社内組織の中でも特に最先端の技術にチャレンジする文化を大切にしています。</p><h4 id="選択可能、交換可能であること"><a href="#選択可能、交換可能であること" class="headerlink" title="選択可能、交換可能であること"></a>選択可能、交換可能であること</h4><p>疎結合なアーキテクチャを尊重します。<br>これはシステム全体として特定のサービス、プロダクトに密に依存することを避け、特定の領域においてプロダクトやサービスを切り替え可能にすることを意味しています。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>stackshareについてはひとまず公開してみたというレベルですが、これから技術スタックの拡充や各プロダクトの選定理由の記載も進めていきたいと考えています。<br>選定理由の記載を進めると「Stack Profile Strength」というランクがアップしていくみたいですね。</p><p>ぜひDXユニットに興味を持っていただけたら、 Qiita Jobsもご覧いただけると幸いです。<br><a href="https://jobs.qiita.com/employers/future/development_teams/109" target="_blank" rel="noopener">https://jobs.qiita.com/employers/future/development_teams/109</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">TIGの中でも特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。TIG&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; DXユニット&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 
      
    
    </summary>
    
      <category term="IoT" scheme="https://future-architect.github.io/categories/IoT/"/>
    
    
      <category term="IoT" scheme="https://future-architect.github.io/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>― 脱RDB脳 ― Cassandraのデータモデルについて考えてみる</title>
    <link href="https://future-architect.github.io/articles/20190718/"/>
    <id>https://future-architect.github.io/articles/20190718/</id>
    <published>2019-07-18T00:11:12.000Z</published>
    <updated>2019-07-17T23:36:27.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Technology Innovation Group所属 DBチームの岩崎です。</p><p>私はDBチームとして様々なプロジェクトでOracleやPostgreSQLなどRDBの設計・構築に携わってきました。<br>現在は、Cassandraの導入とデータモデルを設計しています。</p><p>本稿ではDBネタとしてRDB脳から脱却して、KVSならではのテーブル設計の勘所をお伝えいたします。</p><h1 id="Cassandraはどのようなデータベースなのか"><a href="#Cassandraはどのようなデータベースなのか" class="headerlink" title="Cassandraはどのようなデータベースなのか"></a>Cassandraはどのようなデータベースなのか</h1><p>CassandraはKVS(Key-ValueStore）と呼ばれ、KeyとValueを組み合わせる単純な構造からなるDBです。<br>データアクセスはkeyに対して行い、Keyに関連付けられたValueが呼び出されます。</p><p>KVSは一般的にスキーマレスを採用することが多いと思いますが、Cassandraではアプリケーションの観点から見て、データは構造的に扱える方が開発・運用・管理していく上でメリットがあるとのスタンスを取っているため、スキーマレスではなくスキーマ定義を必要としています。</p><p>また、keyに対して複数のカラムを定義することが可能で、カラム型にはListやMapのようなコレクション型、いわゆるオブジェクト型のようなユーザ定義型（UDT:User Defined Type）の使用に対応しているため、JSONのような階層的なデータをスキーマ定義して柔軟に扱うことができるのが特徴です。</p><p>その他、本稿では触れませんが下記のような特徴を持っており、スケーラビリティ・アベイラビリティに重きを置いたデータベースと言えます。</p><ol><li>データをクラスタ内の複数ノードで分散保持しているため、性能・容量のリニアにスケール可能  </li><li>マスタレスアーキテクチャで、単一障害点がなくノード障害時のマスタ切り替え不要で可用性を厳格に保証  </li><li>データセンターを跨ぐクロスリージョン構成を取ることができ、広域災害時の高いBCP要求を満たすことが可能  </li></ol><h1 id="Cassandraのデータモデルを理解する"><a href="#Cassandraのデータモデルを理解する" class="headerlink" title="Cassandraのデータモデルを理解する"></a>Cassandraのデータモデルを理解する</h1><p>Cassandraにおいてデータをどのように定義して扱うことができるのかということを説明していきます。<br>CassandraはCQLというSQLライクなクエリ言語を用いて記述できるためRDB脳でも直感的に扱えます。<br>なお、本項ではCassandraのバージョンは3.11.4を利用します。</p><h2 id="テーブル作成"><a href="#テーブル作成" class="headerlink" title="テーブル作成"></a>テーブル作成</h2><p>CassandraではRDBと同様にデータをテーブルという単位で管理を行います。<br>KVSではデータの管理、アクセスはkeyに対して行うため、PRIMARY KEYとして定義する必要があります。<br>Valueに相当するカラムは複数定義可能で配列やMapなどのコレクション型もデータ型として定義することが可能です。</p><h3 id="テーブル定義"><a href="#テーブル定義" class="headerlink" title="テーブル定義"></a>テーブル定義</h3><p>PRIMARY KEYに指定したカラムがKVSにおけるkey項目です。</p><figure class="highlight sql"><figcaption><span>テーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_table (</span><br><span class="line">   <span class="keyword">id</span>      <span class="built_in">text</span></span><br><span class="line"> , <span class="keyword">body</span>    <span class="built_in">text</span></span><br><span class="line"> , tag     <span class="keyword">list</span>&lt;<span class="built_in">text</span>&gt;</span><br><span class="line"> , keyword <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;</span><br><span class="line"> , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="レコード作成"><a href="#レコード作成" class="headerlink" title="レコード作成"></a>レコード作成</h3><figure class="highlight sql"><figcaption><span>レコード作成</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_table (</span><br><span class="line">   <span class="keyword">id</span></span><br><span class="line"> , <span class="keyword">body</span></span><br><span class="line"> , tag</span><br><span class="line"> , keyword</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">   <span class="string">'01'</span></span><br><span class="line"> , <span class="string">'Cassandraデータモデリングの紹介'</span></span><br><span class="line"> , [<span class="string">'Future'</span>,<span class="string">'Tech Blog'</span>]</span><br><span class="line"> , &#123;<span class="string">'author'</span>: <span class="string">'Iwasaki'</span>, <span class="string">'nosql'</span>:<span class="string">'cassandra'</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>このようにCassandraでは扱うデータをテーブルとしてスキーマ定義して管理します。<br>次にデータアクセス方法について見ていきましょう。</p><h2 id="データアクセス-PRIMARY-KEY"><a href="#データアクセス-PRIMARY-KEY" class="headerlink" title="データアクセス(PRIMARY KEY)"></a>データアクセス(PRIMARY KEY)</h2><p>データベース内に作成したテーブルにアクセスするにはkeyをWHERE句に指定してアクセスを行います。<br>KVSの特徴は基本的にはkey以外をWHERE句の絞り込み条件に指定できないという点です。</p><h3 id="keyを指定してデータアクセス"><a href="#keyを指定してデータアクセス" class="headerlink" title="keyを指定してデータアクセス"></a>keyを指定してデータアクセス</h3><figure class="highlight"><figcaption><span>Key指定のデータアクセス</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"> id | body                            | keyword                                     | tag</span><br><span class="line"><span class="comment">----+---------------------------------+---------------------------------------------+-------------------------</span></span><br><span class="line"> 01 | Cassandraデータモデリングの紹介 | &#123;'author': 'Iwasaki', 'nosql': 'cassandra'&#125; | ['Future', 'Tech Blog']</span><br></pre></td></tr></table></figure><h3 id="key以外を指定してデータアクセス"><a href="#key以外を指定してデータアクセス" class="headerlink" title="key以外を指定してデータアクセス"></a>key以外を指定してデータアクセス</h3><figure class="highlight"><figcaption><span>Key以外を指定した場合のデータアクセス</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">body</span> = <span class="string">'Cassandraデータモデリングの紹介'</span>;</span><br><span class="line"></span><br><span class="line">-&gt; key以外をWHERE句に指定したためクエリの実行に失敗する</span><br></pre></td></tr></table></figure><p>このようにRDBでは当たり前のようにできたWHERE句による絞り込みが、KVSではできないということを念頭にデータモデルを設計する必要があります。</p><p>実際は全くできないというわけではないものの制限があるため、できないというスタンスにたって設計したほうが無難と考えられます。</p><h2 id="データアクセス-PARTITION-KEY"><a href="#データアクセス-PARTITION-KEY" class="headerlink" title="データアクセス(PARTITION KEY)"></a>データアクセス(PARTITION KEY)</h2><p>CassandraはKVSのため基本的には上記のPRIMARY KEYによるデータアクセスになりますが、もう一つの特徴としてPARTITION KEYによるデータアクセスが可能です。</p><p>PARTITION KEYとはレコードをカラム単位で集約するキーのことを意味します。</p><p>先ほど作成したtest_tableに対して日付単位で集約できるようにPARTITION KEYを追加してみましょう。</p><h3 id="テーブル定義-1"><a href="#テーブル定義-1" class="headerlink" title="テーブル定義"></a>テーブル定義</h3><p>PRIMARY KEYの先頭項目がPARTITION KEYと認識されます。<br>下記の例ではPARTITION KEYがdate、PRIMARY KEYはdateとidの複合になります。  </p><figure class="highlight sql"><figcaption><span>パーティションキー付きのテーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_part_table (</span><br><span class="line">   <span class="built_in">date</span>    <span class="built_in">text</span></span><br><span class="line"> , <span class="keyword">id</span>      <span class="built_in">text</span></span><br><span class="line"> , <span class="keyword">body</span>    <span class="built_in">text</span></span><br><span class="line"> , tag     <span class="keyword">list</span>&lt;<span class="built_in">text</span>&gt;</span><br><span class="line"> , keyword <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;</span><br><span class="line"> , PRIMARY <span class="keyword">KEY</span>((<span class="built_in">date</span>), <span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="レコード作成-1"><a href="#レコード作成-1" class="headerlink" title="レコード作成"></a>レコード作成</h3><figure class="highlight sql"><figcaption><span>レコード作成</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_part_table (</span><br><span class="line">   <span class="built_in">date</span></span><br><span class="line"> , <span class="keyword">id</span></span><br><span class="line"> , <span class="keyword">body</span></span><br><span class="line"> , tag</span><br><span class="line"> , keyword</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">   <span class="string">'2019-07-01'</span></span><br><span class="line"> , <span class="string">'01'</span></span><br><span class="line"> , <span class="string">'パーティションキーテスト1'</span></span><br><span class="line"> , [<span class="string">'Future'</span>,<span class="string">'Tech Blog'</span>]</span><br><span class="line"> , &#123;<span class="string">'author'</span>: <span class="string">'Iwasaki'</span>, <span class="string">'nosql'</span>:<span class="string">'cassandra'</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_part_table (</span><br><span class="line">   <span class="built_in">date</span></span><br><span class="line"> , <span class="keyword">id</span></span><br><span class="line"> , <span class="keyword">body</span></span><br><span class="line"> , tag</span><br><span class="line"> , keyword</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">   <span class="string">'2019-07-01'</span></span><br><span class="line"> , <span class="string">'02'</span></span><br><span class="line"> , <span class="string">'パーティションキーテスト2'</span></span><br><span class="line"> , [<span class="string">'Future'</span>,<span class="string">'Tech Blog'</span>]</span><br><span class="line"> , &#123;<span class="string">'author'</span>: <span class="string">'Iwasaki'</span>, <span class="string">'nosql'</span>:<span class="string">'cassandra'</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_part_table (</span><br><span class="line">   <span class="built_in">date</span></span><br><span class="line"> , <span class="keyword">id</span></span><br><span class="line"> , <span class="keyword">body</span></span><br><span class="line"> , tag</span><br><span class="line"> , keyword</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">   <span class="string">'2019-07-02'</span></span><br><span class="line"> , <span class="string">'01'</span></span><br><span class="line"> , <span class="string">'パーティションキーテスト3'</span></span><br><span class="line"> , [<span class="string">'Future'</span>,<span class="string">'Tech Blog'</span>]</span><br><span class="line"> , &#123;<span class="string">'author'</span>: <span class="string">'Iwasaki'</span>, <span class="string">'nosql'</span>:<span class="string">'cassandra'</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="PARTITION-KEYを指定してデータアクセス"><a href="#PARTITION-KEYを指定してデータアクセス" class="headerlink" title="PARTITION KEYを指定してデータアクセス"></a>PARTITION KEYを指定してデータアクセス</h3><p>PARTITION KEYのdateをWHERE句の条件に指定してデータアクセスしてみると、PARTITION KEY単位で集約されたデータを取得することができます。</p><figure class="highlight"><figcaption><span>パーティションキーを指定してのデータアクセス</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_part_table <span class="keyword">where</span> <span class="built_in">date</span> = <span class="string">'2019-07-01'</span>;</span><br><span class="line"></span><br><span class="line"> date       | id | body                      | keyword                                     | tag</span><br><span class="line"><span class="comment">------------+----+---------------------------+---------------------------------------------+-------------------------</span></span><br><span class="line"> 2019-07-01 | 01 | パーティションキーテスト1 | &#123;'author': 'Iwasaki', 'nosql': 'cassandra'&#125; | ['Future', 'Tech Blog']</span><br><span class="line"> 2019-07-01 | 02 | パーティションキーテスト2 | &#123;'author': 'Iwasaki', 'nosql': 'cassandra'&#125; | ['Future', 'Tech Blog']</span><br><span class="line"></span><br><span class="line">-&gt; 2019-07-01のレコード2件が取得可能</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_part_table <span class="keyword">where</span> <span class="built_in">date</span> = <span class="string">'2019-07-02'</span>;</span><br><span class="line"></span><br><span class="line"> date       | id | body                      | keyword                                     | tag</span><br><span class="line"><span class="comment">------------+----+---------------------------+---------------------------------------------+-------------------------</span></span><br><span class="line"> 2019-07-02 | 01 | パーティションキーテスト3 | &#123;'author': 'Iwasaki', 'nosql': 'cassandra'&#125; | ['Future', 'Tech Blog']</span><br><span class="line"></span><br><span class="line">-&gt; 2019-07-02のレコード1件が取得可能</span><br></pre></td></tr></table></figure><p>このようにCassandraではPARTITION KEY単位による列ごとに集約されたデータアクセスが可能なため、KVSの中でもワイドカラムストア(列指向型)と呼ばれることがあります。</p><p>CassandraではPARTITION KEYのハッシュ値を基に物理的なデータ配置箇所を決定しています。</p><p>Cassandraは複数ノードでクラスタ構成を取ることが一般的ですが、同一PARTITION KEYのデータは、（複数の）特定ノード内に集約されてデータが格納されます。</p><p>そのため、検索条件にPARTITION KEYを指定することで対象のキーのデータをどのノードが保持しているかということが分かるため、サーバーの並列数やデータ量が増えても高速にデータアクセスすることが可能になります。</p><p>言い換えれば、PARTITION KEYが無いと全ノードの全レコードを舐めないと条件に一致するかを評価することができないので、KVSはキーアクセスしか行えないということになります。</p><p>ちなみに複合PRIMARY KEYを定義する場合、特に指定がなければ先頭のキーがPARTITION KEYとなり、単一PRIMARY KEYの場合はPRIMARY KEY = PARTITION KEYとして認識されています。  </p><p>また、PARTITION KEY以外のPRIMARY KEYはCLUSTERING KEYと呼ばれ、パーティション内のデータのソートキーとなっています。</p><p>PARTITION KEYのみを指定してデータを取得する際の動作は、RDB脳にはなじみ深いB*TreeインデックスをRANGE SCANする動作と同様です。</p><p>本記事のなかではあまりふれませんが、CLUSTERING KEYによるソート順に従って先頭の〇〇件を取得する、といったことも可能です。</p><h2 id="データ更新"><a href="#データ更新" class="headerlink" title="データ更新"></a>データ更新</h2><p>Cassandraはテーブル構造を事前に定義しているため、RDB同様に特定のカラムに対する更新が可能です。<br>また、配列やMapで定義した項目に対しても要素の追加や削除など柔軟に更新を行うことができます。</p><h3 id="Map型のデータ更新"><a href="#Map型のデータ更新" class="headerlink" title="Map型のデータ更新"></a>Map型のデータ更新</h3><p>先ほど作成したtest_tableのMap型で定義したkeywordに対して要素の追加や更新を行ってみましょう。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> keyword <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"> keyword</span><br><span class="line"><span class="comment">---------------------------------------------</span></span><br><span class="line"> &#123;'author': 'Iwasaki', 'nosql': 'cassandra'&#125;</span><br></pre></td></tr></table></figure><p>Mapのkey要素であるauthorを指定してvalueを書き換えてみます。</p><figure class="highlight"><figcaption><span>Mapの要素を書き換え</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> test_table <span class="keyword">SET</span> keyword[<span class="string">'author'</span>] = <span class="string">'Yuta'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> keyword <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"> keyword</span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"> &#123;'author': 'Yuta', 'nosql': 'cassandra'&#125;</span><br></pre></td></tr></table></figure><p>Mapの要素を足してみます。</p><figure class="highlight"><figcaption><span>Mapの要素を追加</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> test_table <span class="keyword">SET</span> keyword = keyword + &#123;<span class="string">'category'</span>: <span class="string">'db'</span>&#125; <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> keyword <span class="keyword">from</span> test_table <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'01'</span>;</span><br><span class="line"></span><br><span class="line"> keyword</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"> &#123;'author': 'Yuta', 'category': 'db', 'nosql': 'cassandra'&#125;</span><br></pre></td></tr></table></figure><h1 id="Cassandraのデータモデリングについて考える"><a href="#Cassandraのデータモデリングについて考える" class="headerlink" title="Cassandraのデータモデリングについて考える"></a>Cassandraのデータモデリングについて考える</h1><p>なんとなくCassandraでデータをどのように扱うか理解できましたでしょうか。</p><p>ここからはどのようにデータモデルを考えていくべきかをチャットテーブルを例に説明していきます。</p><h2 id="チャットのデータモデル概要"><a href="#チャットのデータモデル概要" class="headerlink" title="チャットのデータモデル概要"></a>チャットのデータモデル概要</h2><p>チャット管理に関するリレーショナルモデルのテーブル設計を元に考えてみましょう。</p><ul><li>チャットルーム<ul><li>ユーザ、グループ毎にチャットを管理するテーブル。</li></ul></li><li>チャット<ul><li>チャットの投稿内容の詳細を管理するテーブル</li></ul></li><li>リアクション<ul><li>チャットの投稿に対するスタンプなどのリアクションを管理するテーブル</li></ul></li></ul><img src="/images/20190718/photo_20190718_01.png" class="img-middle-size"><p>例えばRDBであれば上記のままの3つのテーブルを作成することが考えられます。</p><p>しかし、KVSは単一テーブルに対するキーアクセスのみを可能にしたデータベースであるため、RDBのように複数テーブル間を結合することができないという点がKVSとRDBとの最大の違いです。</p><p>KVSにおけるテーブル設計では、ある機能を実現するためのテーブルは基本的に1つで足りる（であろう）というスタンスに立ち、まず上記のテーブルを1テーブルに集約できないかを考えます。</p><p>また、KVSでは結合だけでなくトランザクションも存在しないため(単一レコードに対する軽量トランザクションのみ)テーブルを分割すると、アプリケーションの作りが複雑化してしまうという問題もあります。</p><p>そのため、まずはテーブルを集約することを意識していきましょう。</p><h2 id="テーブル集約のポイント"><a href="#テーブル集約のポイント" class="headerlink" title="テーブル集約のポイント"></a>テーブル集約のポイント</h2><p>RDBのようにフラットな階層でデータモデルを表現するためには結合が必須です。<br>しかし、KVSは配列やMapのようなコレクション型を扱えるという点が集約のポイントになります。</p><p>例えばチャットとリアクションの関係をコレクション型を利用して１つのテーブルとして表現してみましょう。<br>チャットに対してリアクションをコレクション型で定義することで1チャットに対してN数のリアクションを表現できます。</p><h3 id="Map型を利用した集約"><a href="#Map型を利用した集約" class="headerlink" title="Map型を利用した集約"></a>Map型を利用した集約</h3><p>reactionをMap型で定義することでユーザ別のリアクションを表現できるようになりました。<br>更新時もMap要素を指定して行えるため追加や削除を柔軟に行えます。</p><figure class="highlight sql"><figcaption><span>Map型を利用したチャットテーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chat (</span><br><span class="line">    <span class="keyword">id</span>        <span class="built_in">text</span>              <span class="comment">-- チャットID</span></span><br><span class="line">  , <span class="keyword">body</span>      <span class="built_in">text</span>              <span class="comment">-- チャット本文</span></span><br><span class="line">  , <span class="keyword">user</span>      <span class="built_in">text</span>              <span class="comment">-- 投稿者</span></span><br><span class="line">  , send_date <span class="built_in">text</span>              <span class="comment">-- 投稿日付</span></span><br><span class="line">  , reaction  <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;   <span class="comment">-- リアクション</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>次にチャットルームとチャットの関係を1つのテーブルとして表現してみましょう。</p><p>チャットルームには最終投稿日付やチャットルーム参加者などチャットにとっての付随情報を管理をするため、RDBではチャットルームIDをFKとしてチャット側に持たせるという考え方になると思います。</p><p>ここもコレクションを利用してチャットルームにチャット情報を集約してみましょう。</p><p>chatをMap型で定義することでチャットテーブルにチャットの情報を持たせることができます。</p><figure class="highlight sql"><figcaption><span>Map型を利用したチャットルームテーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chatroom (</span><br><span class="line">    <span class="keyword">id</span>            <span class="built_in">text</span>              <span class="comment">-- チャットルームID</span></span><br><span class="line">  , last_update   <span class="built_in">text</span>              <span class="comment">-- 最終更新日付</span></span><br><span class="line">  , <span class="keyword">member</span>        <span class="keyword">set</span>&lt;<span class="built_in">text</span>&gt;         <span class="comment">-- 参加者</span></span><br><span class="line">  , chat          <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;   <span class="comment">-- チャット情報</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>しかし、上記のようなMap型（map&lt;text, text&gt;）では単一項目のvalueしか持てないためチャットの情報を表現しきることができません。</p><p>そこでユーザ定義型(UDT)という複数のフィールドと型を定義して利用します。</p><h3 id="UDT型を利用した集約"><a href="#UDT型を利用した集約" class="headerlink" title="UDT型を利用した集約"></a>UDT型を利用した集約</h3><p>chatの情報をUDTとして定義してみましょう。</p><p>UDTはテーブルではなくタイプとして定義（CREATE）されます。タイプにはPKを指定する必要はありません。</p><p>UDTのフィールドにMapなどのコレクション型を定義することもできます。</p><figure class="highlight sql"><figcaption><span>UDT型の定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> chat_type (</span><br><span class="line">    <span class="keyword">body</span>      <span class="built_in">text</span>              <span class="comment">-- チャット本文</span></span><br><span class="line">  , <span class="keyword">user</span>      <span class="built_in">text</span>              <span class="comment">-- 投稿者</span></span><br><span class="line">  , send_date <span class="built_in">text</span>              <span class="comment">-- 投稿日付</span></span><br><span class="line">  , reaction  <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;   <span class="comment">-- リアクション</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上記で作ったUDTを利用してチャットルームとチャットを集約してみましょう。<br>先ほどの作ったUDTをデータ型として指定することができます。</p><p>ただし注意しなければならない点は、コレクション型の中でUDTを定義する場合、frozenという指定が必要になります。frozenの制約事項は後述します。</p><figure class="highlight sql"><figcaption><span>UDT型を利用したチャットルーム定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chatroom (</span><br><span class="line">    <span class="keyword">id</span>            <span class="built_in">text</span></span><br><span class="line">  , chatroom_name <span class="built_in">text</span></span><br><span class="line">  , last_update   <span class="built_in">text</span></span><br><span class="line">  , <span class="keyword">member</span>        <span class="keyword">set</span>&lt;<span class="built_in">text</span>&gt;</span><br><span class="line">  , chat          <span class="keyword">map</span>&lt;<span class="built_in">text</span>, frozen&lt;chat_type&gt;&gt;</span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> chatroom <span class="keyword">JSON</span></span><br><span class="line">  <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "id": "1",</span></span><br><span class="line"><span class="string">    "chatroom_name": "DB Tech Blog",</span></span><br><span class="line"><span class="string">    "last_update": "2019-07-01:12:00",</span></span><br><span class="line"><span class="string">    "member": ["iwasaki","sugiyama","mano"],</span></span><br><span class="line"><span class="string">    "chat": &#123;</span></span><br><span class="line"><span class="string">        "01": &#123;</span></span><br><span class="line"><span class="string">          "body" : "chat message 1",</span></span><br><span class="line"><span class="string">          "user" : "iwasaki",</span></span><br><span class="line"><span class="string">          "send_date" : "2019-07-01:10:00",</span></span><br><span class="line"><span class="string">          "reaction" : &#123; "sugiyama" : "reaction 1"&#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "02": &#123;</span></span><br><span class="line"><span class="string">          "body" : "chat message 2",</span></span><br><span class="line"><span class="string">          "user" : "iwasaki",</span></span><br><span class="line"><span class="string">          "send_date" : "2019-07-01:11:00"</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "03": &#123;</span></span><br><span class="line"><span class="string">          "body" : "chat message 3",</span></span><br><span class="line"><span class="string">          "user" : "sugiyama",</span></span><br><span class="line"><span class="string">          "send_date" : "2019-07-01:12:00",</span></span><br><span class="line"><span class="string">          "reaction" : &#123; "iwasaki" : "reaction 1"&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;'</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> chat <span class="keyword">from</span> chatroom <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line"> chat</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> &#123;'01': &#123;body: 'chat message 1', user: 'iwasaki', send_date: '2019-07-01:10:00', reaction: &#123;'sugiyama': 'reaction 1'&#125;&#125;, '02': &#123;body: 'chat message 2', user: 'iwasaki', send_date: '2019-07-01:11:00', reaction: null&#125;, '03': &#123;body: 'chat message 3', user: 'sugiyama', send_date: '2019-07-01:12:00', reaction: &#123;'iwasaki': 'reaction 1'&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>UDTを利用することでチャットルームとチャットを集約することができました。</p><p>しかし、上記の集約例だと2つの問題点が存在します。</p><h3 id="問題点1-投稿数-要素数となるためコレクションサイズが肥大化し過ぎる"><a href="#問題点1-投稿数-要素数となるためコレクションサイズが肥大化し過ぎる" class="headerlink" title="問題点1. 投稿数 = 要素数となるためコレクションサイズが肥大化し過ぎる"></a>問題点1. 投稿数 = 要素数となるためコレクションサイズが肥大化し過ぎる</h3><p>Cassandraのドキュメントによると、mapコレクションのキーの最大数は65,535しか持てないと記述されています。</p><p>また、コレクション要素全てを読み込んでしまうのでアクセス効率も悪くなります。</p><p>つまり、チャットルームにチャットの情報をコレクション型で集約してしまうと1チャットルーム内で投稿できるチャット数が制限されてしまい、要件を満たせなくなる可能性があります。</p><p>チャットとリアクションのようにそこまでコレクションの要素が肥大化しない関係であれば積極的に集約していく価値がありますが、上記のパターンには注意が必要です。</p><h3 id="問題点2-chatの情報をfrozenで定義しているため柔軟な更新が行えなくなる"><a href="#問題点2-chatの情報をfrozenで定義しているため柔軟な更新が行えなくなる" class="headerlink" title="問題点2. chatの情報をfrozenで定義しているため柔軟な更新が行えなくなる"></a>問題点2. chatの情報をfrozenで定義しているため柔軟な更新が行えなくなる</h3><p>Cassandraではコレクション型の中でさらにコレクション型を定義するようなネスト構造を表現する際にfrozenを利用して定義します。</p><p>frozenを利用することで深い階層のデータを定義していくことができますが、frozenされた項目の値はBLOBと同様に処理されるようになるため、frozenされた項目に対して部分更新ができなくなります。</p><p>つまり先ほどのchatroomの例だと、chatがfrozenで定義されているためchatの項目を更新するためには、下記のようにchatの全項目を指定して更新する必要があります。</p><h3 id="frozen項目の更新"><a href="#frozen項目の更新" class="headerlink" title="frozen項目の更新"></a>frozen項目の更新</h3><p>chatのbodyだけ更新するとbody以外の項目は全てnullとして扱われるのでデータロストしてしまいます。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> chatroom <span class="keyword">SET</span> chat[<span class="string">'01'</span>] = fromJson(</span><br><span class="line"><span class="string">'&#123; "body" : "chat message update 1"&#125;'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">cqlsh:<span class="keyword">test</span>&gt; <span class="keyword">select</span> chat <span class="keyword">from</span> chatroom <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line"> chat</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> &#123;'01': &#123;body: 'chat message update 1', user: null, send_date: null, reaction: null&#125;, '02': &#123;body: 'chat message 2', user: 'iwasaki', send_date: '2019-07-01:11:00', reaction: null&#125;, '03': &#123;body: 'chat message 3', user: 'sugiyama', send_date: '2019-07-01:12:00', reaction: &#123;'iwasaki': 'reaction 1'&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>下記のようにfrozen項目全体を含めて更新する必要があります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> chatroom <span class="keyword">SET</span> chat[<span class="string">'01'</span>] = fromJson(</span><br><span class="line"><span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "body" : "chat message update 1",</span></span><br><span class="line"><span class="string">  "user" : "iwasaki",</span></span><br><span class="line"><span class="string">  "send_date" : "2019-07-01:13:00",</span></span><br><span class="line"><span class="string">  "reaction" : &#123; "sugiyama" : "reaction 1"&#125;</span></span><br><span class="line"><span class="string">  &#125;'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>このように一見便利なfrozenですが安易に利用してネストを深くすると更新要件を満たすことができなくなる可能性があるので、注意が必要です。</p><h3 id="staticカラムを利用してテーブルを集約する"><a href="#staticカラムを利用してテーブルを集約する" class="headerlink" title="staticカラムを利用してテーブルを集約する"></a>staticカラムを利用してテーブルを集約する</h3><p>コレクション型を利用してチャットルームとチャットを集約するのは制約事項があることがわかりました。</p><p>Cassandraにおいてテーブル集約を考える際にもう一つ有効な手法としてstaticカラムというものがあります。</p><p>staticカラムとして定義することで対象のカラムはパーティション単位で同じデータが保持されるようになります。</p><figure class="highlight sql"><figcaption><span>staticカラムを利用したテーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> static_test(</span><br><span class="line">  <span class="keyword">id</span>                <span class="built_in">text</span>,</span><br><span class="line">  <span class="keyword">no</span>                <span class="built_in">text</span>,</span><br><span class="line">  static_data       <span class="built_in">text</span> <span class="keyword">static</span>,</span><br><span class="line">  non_static_data   <span class="built_in">text</span>,</span><br><span class="line">  primary <span class="keyword">key</span>((<span class="keyword">id</span>),<span class="keyword">no</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> static_test <span class="keyword">json</span> <span class="string">'&#123;"id":"1","no":"1","static_data":"static_1","non_static_data":"non_static_1"&#125;'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> static_test <span class="keyword">json</span> <span class="string">'&#123;"id":"1","no":"2","static_data":"static_1","non_static_data":"non_static_1"&#125;'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> static_test <span class="keyword">json</span> <span class="string">'&#123;"id":"2","no":"1","static_data":"static_2","non_static_data":"non_static_2"&#125;'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> static_test <span class="keyword">json</span> <span class="string">'&#123;"id":"2","no":"2","static_data":"static_2","non_static_data":"non_static_2"&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> static_test ;</span><br><span class="line"></span><br><span class="line"> id | no | static_data | non_static_data</span><br><span class="line"><span class="comment">----+----+-------------+-----------------</span></span><br><span class="line">  1 |  1 |    static_1 |    non_static_1</span><br><span class="line">  1 |  2 |    static_1 |    non_static_1</span><br><span class="line">  2 |  1 |    static_2 |    non_static_2</span><br><span class="line">  2 |  2 |    static_2 |    non_static_2</span><br></pre></td></tr></table></figure><h3 id="staticカラムを更新する"><a href="#staticカラムを更新する" class="headerlink" title="staticカラムを更新する"></a>staticカラムを更新する</h3><p>staticとして定義したstatic_dataを更新すると同一パーティション内のstatic_dataも更新されます。</p><figure class="highlight"><figcaption><span>staticカラムの更新</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> static_test <span class="keyword">set</span> static_data = <span class="string">'static_test_1'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> static_test;</span><br><span class="line"></span><br><span class="line"> id | no | static_data   | non_static_data</span><br><span class="line"><span class="comment">----+----+---------------+-----------------</span></span><br><span class="line">  1 |  1 | static_test_1 |    non_static_1</span><br><span class="line">  1 |  2 | static_test_1 |    non_static_1</span><br><span class="line">  2 |  1 |      static_2 |    non_static_2</span><br><span class="line">  2 |  2 |      static_2 |    non_static_2</span><br><span class="line"></span><br><span class="line">-&gt; PARTITION KEY = '01'に対する更新だが、同パーティション内のstatic_dataも更新される</span><br></pre></td></tr></table></figure><p>staticで定義すると下記のように同一パーティション内のデータはstaticカラムを参照するようなデータ構造になるため、static項目を更新すると同一パーティション内のデータは全て更新されたように見えていたわけです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"id"</span> : <span class="number">1</span>, <span class="attr">"static_data"</span> : <span class="string">"static_test_1"</span>  &#123; </span><br><span class="line">        <span class="attr">"no"</span> : <span class="number">1</span>  &#123; <span class="attr">"non_static_data"</span> : <span class="string">"non_static_1"</span>&#125;,</span><br><span class="line">        <span class="attr">"no"</span> : <span class="number">2</span>  &#123; <span class="attr">"non_static_data"</span> : <span class="string">"non_static_1"</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123; <span class="attr">"id"</span> : <span class="number">2</span>, <span class="attr">"static_data"</span> : <span class="string">"static_2"</span>  &#123; </span><br><span class="line">        <span class="attr">"no"</span> : <span class="number">1</span>  &#123; <span class="attr">"non_static_data"</span> : <span class="string">"non_static_2"</span>&#125;,</span><br><span class="line">        <span class="attr">"no"</span> : <span class="number">2</span>  &#123; <span class="attr">"non_static_data"</span> : <span class="string">"non_static_2"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このstaticカラムを利用することで同一パーティションキー間でテーブル結合することなく共有することができます。</p><p>チャットとチャットルームにおける関係にも利用できそうです。</p><h3 id="staticカラムを利用してテーブルを集約する-1"><a href="#staticカラムを利用してテーブルを集約する-1" class="headerlink" title="staticカラムを利用してテーブルを集約する"></a>staticカラムを利用してテーブルを集約する</h3><p>チャットにチャットルームIDをFKとして持たせてチャットルームの情報を引っ張ってくるRDB的な結合を、チャットテーブルにstatcカラムとしてチャットルームの情報を定義することでテーブル集約を実現することができます。</p><figure class="highlight sql"><figcaption><span>staticカラムを利用したチャットテーブル定義</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chat (</span><br><span class="line">    chatroom_id         <span class="built_in">text</span>               <span class="comment">-- チャットルームID</span></span><br><span class="line">  , chat_id             <span class="built_in">text</span>               <span class="comment">-- チャットID</span></span><br><span class="line">  , chatroom_name       <span class="built_in">text</span> <span class="keyword">static</span>        <span class="comment">-- チャットルーム名</span></span><br><span class="line">  , last_update         <span class="built_in">text</span> <span class="keyword">static</span>        <span class="comment">-- 最終更新日付</span></span><br><span class="line">  , <span class="keyword">member</span>              <span class="keyword">set</span>&lt;<span class="built_in">text</span>&gt; <span class="keyword">static</span>   <span class="comment">-- チャット参加者</span></span><br><span class="line">  , <span class="keyword">body</span>                <span class="built_in">text</span>               <span class="comment">-- チャット本文</span></span><br><span class="line">  , <span class="keyword">user</span>                <span class="built_in">text</span>               <span class="comment">-- 投稿者</span></span><br><span class="line">  , send_date           <span class="built_in">text</span>               <span class="comment">-- 投稿日付</span></span><br><span class="line">  , reaction            <span class="keyword">map</span>&lt;<span class="built_in">text</span>, <span class="built_in">text</span>&gt;    <span class="comment">-- リアクション</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>((chatroom_id), chat_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>staticカラムでテーブル集約したことにより、コレクション型で集約した時に比べて、投稿数 = レコード数となるため、投稿数の制約が無くなります。</p><p>また、レコード更新時もネストが1段階浅くなりfrozenを利用せずチャットの情報を保持することができるため、個別更新にも対応できる柔軟なデータモデルになったと言えます。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Cassandraのデータモデルを考える際にはついついRDB的な思考で結合ありきのデータモデルでテーブル設計を行ってしまいますが、まずはテーブルを集約できるかを念頭に見つめ直してみましょう。</p><p>最後にデータモデルを考える上での考慮点をまとめてみました。</p><ul><li>結合ありきのテーブル設計になっていないか</li><li>コレクション型を利用してテーブル間の関係を集約できるか</li><li>集約時にネストが深くなりすぎないか、また更新要件を満たすことができるか</li><li>staticカラムを利用してパーティション単位の情報を共有させることで集約できるか</li></ul><p>他にもデータモデル設計時に検討した項目はありますが、それはまた別の機会に紹介できれば幸いです。<br>ぜひ皆さんもRDB脳から脱却してKVSを使いこなしてみましょう！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、Technology Innovation Group所属 DBチームの岩崎です。&lt;/p&gt;
&lt;p&gt;私はDBチーム
      
    
    </summary>
    
      <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
      <category term="DB" scheme="https://future-architect.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>GCPインスタンスを自動で停止させるツールの公開</title>
    <link href="https://future-architect.github.io/articles/20190716/"/>
    <id>https://future-architect.github.io/articles/20190716/</id>
    <published>2019-07-16T00:12:58.000Z</published>
    <updated>2019-07-16T00:20:09.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG DXユニットの真野です。2019年時点ではフューチャーに入社して9年目、主にバックエンド側の設計や開発をしています。</p><blockquote><p>TIG: Technology Innovation Groupの略で、フューチャーの中でも特にIT技術に特化した部隊です。<br>DXユニット: TIGの中でも特にデジタルトランスフォーメーションに関わる仕事を推進していくチームです。</p></blockquote><p>GCPのインスタンス（GCE, SQL, GKE）を自動で停止させるGoで書かれたツールをGitHubに公開しました。<br><a href="https://github.com/future-architect/gcp-instance-scheduler" target="_blank" rel="noopener">https://github.com/future-architect/gcp-instance-scheduler</a></p><p>このツールの実装はアルバイト社員の<a href="https://qiita.com/donkomura" target="_blank" rel="noopener">donkomura</a>さんが主体的に開発を進めていただいました。<br>別の機会にdonkomuraさんにはアルバイトブログを書いてもらおうと思うので、工夫した点などはそこで述べてもらおうと思います。</p><p>このツールを用いてGCPを利用しない時間帯を上手く指定することで、クラウドの運用費用を節約できます。</p><h1 id="ツールの概要"><a href="#ツールの概要" class="headerlink" title="ツールの概要"></a>ツールの概要</h1><p><code>state-scheduler:true</code> というラベルがついた、GCE, SQL, GKEなどのインスタンスを停止します。<br>GKEの場合は、ノードプールを構成するインスタンスグループのサイズを0にすることで実現します。</p><p>定期的なシャットダウンを避けたい場合は、<code>state-scheduler:false</code>と指定すれば、対象から除外させることもできます。</p><p>構成は下図の通り、Pub/SubトリガーのCloud Functionとして動作します。</p><img src="/images/20190713/photo_20190713_01.png"><p>起動タイミングはCloud Schedulerで制御する構成です。<br>そのため、「0 21 * * *」のようにCRON形式でスケジュールを定義すれば、毎日21時に停止させることができます。</p><p>ちなみに、Cloud FunctionをHTTPトリガーにせずPub/Subを挟んでいる理由は、認証を挟みたかったためです。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><h1 id="デプロイ方法"><a href="#デプロイ方法" class="headerlink" title="デプロイ方法"></a>デプロイ方法</h1><p>ツールのデプロイ手順を1~3の順に説明します。</p><h2 id="1-ラベルの設定"><a href="#1-ラベルの設定" class="headerlink" title="1. ラベルの設定"></a>1. ラベルの設定</h2><p>停止したいインスタンスのラベルに <code>state-scheduler:true</code> を設定する必要があります。<br>ラベルの設定はもちろん管理コンソールから手動で行っても良いですし、下記のようなgcloudコマンドでも設定できます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GCE</span></span><br><span class="line">gcloud compute instances update &lt;insntance-name&gt; \</span><br><span class="line">  --project &lt;project-id&gt; \</span><br><span class="line">  --update-labels state-scheduler=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cloud SQL (master must be running)</span></span><br><span class="line">gcloud beta sql instances patch &lt;insntance-name&gt; \</span><br><span class="line">  --project &lt;project-id&gt; \</span><br><span class="line">  --update-labels state-scheduler=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GKE</span></span><br><span class="line">gcloud container clusters update &lt;cluster-name&gt; \</span><br><span class="line">  --project &lt;project-id&gt; \</span><br><span class="line">  --zone &lt;cluster-master-node-zone&gt; \</span><br><span class="line">  --update-labels state-scheduler=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2-Cloud-Functionのデプロイ"><a href="#2-Cloud-Functionのデプロイ" class="headerlink" title="2. Cloud Functionのデプロイ"></a>2. Cloud Functionのデプロイ</h2><p>デプロイには <a href="https://cloud.google.com/sdk/gcloud/" target="_blank" rel="noopener">gcloud</a> が必要ですのでインストールしておきます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/future-architect/gcp-instance-scheduler.git</span><br><span class="line"><span class="built_in">cd</span> gcp-instance-scheduler</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploy Cloud Function</span></span><br><span class="line">gcloud <span class="built_in">functions</span> deploy ReceiveEvent --project &lt;project-id&gt; \</span><br><span class="line">  --runtime go111 \</span><br><span class="line">  --trigger-topic instance-scheduler-event</span><br></pre></td></tr></table></figure><h2 id="3-Cloud-Schedulerの設定"><a href="#3-Cloud-Schedulerの設定" class="headerlink" title="3. Cloud Schedulerの設定"></a>3. Cloud Schedulerの設定</h2><p>最後にスケジューラの設定を行います。</p><p>今回は仮に、「毎日21時」に停止することにします。タイムゾーンをUTCにしたい場合は適時書き換えください。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create Cloud Scheduler Job</span></span><br><span class="line">gcloud beta scheduler <span class="built_in">jobs</span> create pubsub shutdown-workday \</span><br><span class="line">  --project &lt;project-id&gt; \</span><br><span class="line">  --schedule <span class="string">'0 21 * * *'</span> \</span><br><span class="line">  --topic instance-scheduler-event \</span><br><span class="line">  --message-body <span class="string">'&#123;"command":"stop"&#125;'</span> \</span><br><span class="line">  --time-zone <span class="string">'Asia/Tokyo'</span> \</span><br><span class="line">  --description <span class="string">'automatically stop instances'</span></span><br></pre></td></tr></table></figure><p>以上で適用できました。<br>これで、毎日21時に指定したインスタンスのシャットダウンが行われます。</p><p>テキストでは長いですが、コマンド数として少ないので簡単に適用できると思います。</p><h1 id="こぼれ話（ツール設計について）"><a href="#こぼれ話（ツール設計について）" class="headerlink" title="こぼれ話（ツール設計について）"></a>こぼれ話（ツール設計について）</h1><p>このGCP停止ツールの特徴として、Goの<a href="https://godoc.org/cloud.google.com/go" target="_blank" rel="noopener">GCP SDK</a>経由でインスタンスの制御を行っています。</p><p>これには理由があって、当初は、インフラ構築をTerraformで行っていたため、インスタンスのステータスを<a href="https://www.terraform.io/docs/configuration/override.html" target="_blank" rel="noopener">override variables</a>で上書いた上で、terraform applyによって停止させる想定でした。<br>この方式だと、既存のTerraform資産を活かしつつ手堅く実装できるんじゃないかという目論見です。</p><p>しかし、実は費用がかかっていたのはTerraform管理対象外である、サンドボックス的なDevelopment環境であったことが判明。<br>そこで方向転換し、Terraform定義が無い環境においても稼働できるように、GCPのAPIを直接呼び出すことによってシャットダウンすることにしました。</p><p>通常だとgcloudコマンドでガンバリそうですが、レポーティング機能やSlack連携機能が将来的に求められそうだったので、Goで開発することにしました。</p><p>結果として、個人的なプライベートの小さなGCP環境にでも簡単に適用できるので、これはこれで良かったなと思っています。</p><h1 id="今後"><a href="#今後" class="headerlink" title="今後"></a>今後</h1><p>まだまだ、稼働し始めたところで作りが甘いところがあり、継続的に改善していきます。<br>例えば、2019年7月時点では以下のような面を機能拡張していこうとなっています。</p><ul><li>停止したインスタンスや、停止をスキップしたインスタンス数のSlackへの通知</li><li>停止処理の高速化（並列化）</li><li>インスタンスの再起動機能の追加</li></ul><p>今後も有益だと思われるツールはドンドン公開していこうと考えています。</p><p>この記事が少しでも皆さんの役にたてば幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">参考: https://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG DXユニットの真野です。2019年時点ではフューチャーに入社して9年目、主にバックエンド側の設計や開発を
      
    
    </summary>
    
      <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
      <category term="gcp" scheme="https://future-architect.github.io/tags/gcp/"/>
    
  </entry>
  
</feed>
