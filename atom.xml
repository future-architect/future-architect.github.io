<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2021-04-22T02:03:14.451Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CircleCIでMarkdownのリンク切れを自動検知する</title>
    <link href="https://future-architect.github.io/articles/20210422b/"/>
    <id>https://future-architect.github.io/articles/20210422b/</id>
    <published>2021-04-21T15:00:01.000Z</published>
    <updated>2021-04-22T02:03:14.451Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210422b/chain-312403_640.png" class="img-small-size"><blockquote><p><a href="https://pixabay.com/ja/users/clker-free-vector-images-3736/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=312403">Clker-Free-Vector-Images</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=312403">Pixabay</a>から</p></blockquote><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャー棚井龍之介です。</p><p>私のチームでは、「システムの設計情報」や「実装に関わる業務知識」などを、<code>README.md</code> に整理して GitHub 管理しています。</p><p>設計資料や業務系のドキュメントが蓄積され、何度も更新され続けることに伴い、「あれ、この資料のリンクが切れてる。オリジナルのファイルはどこだっけ？」と探す機会が増えてきました。</p><p>本来ならば PullRequest のレビュー時に気付くべきですが、ファイル名のちょっとしたスペルミスや資料パスの変更などだと、目視でのチェックには限界があります。</p><p>こういった状況への対応として「<strong>リンク切れを自動検知する</strong>」ために、CircleCI で Markdown ファイルのリンク切れを検知できるようにしました。</p><h2 id="完成版コード"><a href="#完成版コード" class="headerlink" title="完成版コード"></a>完成版コード</h2><p><a href="https://github.com/r-ryu/markdown-link-checker"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/r-ryu/markdown-link-checker.png" width="460px"></a></p><p><a href="https://github.com/r-ryu/markdown-link-checker">https://github.com/r-ryu/markdown-link-checker</a></p><h1 id="使うツール"><a href="#使うツール" class="headerlink" title="使うツール"></a>使うツール</h1><p>Markdown チェックのために、<a href="https://github.com/tcort/markdown-link-check">markdown-link-check</a> を利用します。<br>Markdown テキストからリンクを抽出し、各リンクが生きている（200 OK）か死んでいるかをチェックします。</p><blockquote><p>markdown-link-check<br>Extracts links from markdown texts and checks whether each link is alive (200 OK) or dead.</p></blockquote><p>node のツールなので、<a href="https://github.com/tcort/markdown-link-check#installation">npm でインストール</a>すれば、任意の環境でリンクチェックできます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: markdown-link-check [options] [filenameOrUrl]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --progress         show progress bar</span><br><span class="line">  -c, --config [config]  apply a config file (JSON), holding e.g. url specific header configuration</span><br><span class="line">  -q, --quiet            displays errors only</span><br><span class="line">  -v, --verbose          displays detailed error information</span><br><span class="line">  -a, --alive &lt;code&gt;     comma separated list of HTTP code to be considered as alive</span><br><span class="line">  -r, --retry            retry after the duration indicated <span class="keyword">in</span> <span class="string">&#x27;retry-after&#x27;</span> header when HTTP code is 429</span><br><span class="line">  -h, --<span class="built_in">help</span>             display <span class="built_in">help</span> <span class="keyword">for</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h1 id="CircleCIへの記述"><a href="#CircleCIへの記述" class="headerlink" title="CircleCIへの記述"></a>CircleCIへの記述</h1><p>CircleCI の jobs 内で、markdown-link-check を呼び出します。</p><p><a href="https://github.com/tcort/markdown-link-check#check-links-from-a-local-markdown-folder-recursive">ツール本家の README</a> に記載された <code>$ find . -name \*.md -exec markdown-link-check &#123;&#125; \;</code> による実行方法は、CircleCI で実行した際に欲しい挙動が得られません。リンク切れが1つでも存在したら Task failed で落として欲しいのですが、<code>-exec</code> による方法では「最初にチェックされたファイルに、リンク切れがある場合のみ」Task failed で落ちます。2つ目以降のファイルにリンク切れが存在しても、CircleCI は検知してくれません。</p><p>CircleCI のチェックで、リンク切れファイルが<strong>1つでも</strong>存在する場合は Task failed で落としてもらうために、<code>xargs</code> を利用します。xargs を利用することで、対象ファイル全てに一括でリンターチェックが適用できます。（-exec の場合、1ファイルごとに処理されます。）</p><ul><li>引用: <a href="https://future-architect.github.io/articles/20210331/">今さらながらfindパイセンについてまとめてみた（‐execオプション）</a></li></ul><figure class="highlight bash"><figcaption><span>-execとxargsの違い</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -exex</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">echo</span> <span class="string">&quot;ファイル名: &#123;&#125;&quot;</span> \;</span><br><span class="line">ファイル名: ./test01.txt</span><br><span class="line">ファイル名: ./test02.txt</span><br><span class="line">ファイル名: ./test03.txt</span><br><span class="line">ファイル名: ./test04.txt</span><br><span class="line">ファイル名: ./test05.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># xargs</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs <span class="built_in">echo</span> <span class="string">&quot;ファイル名: &quot;</span></span><br><span class="line">ファイル名:  ./test01.txt ./test02.txt ./test03.txt ./test04.txt ./test05.txt</span><br></pre></td></tr></table></figure><p>CircleCI で markdown-link-check を xargs により実行させるコートはこちらです。<br>ツール自体が node 製なので、プライマリイメージには <code>cimg/node:15.11.0</code> を利用しています。</p><figure class="highlight yml"><figcaption><span>config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">markdown_link_check:</span></span><br><span class="line">    <span class="attr">docker:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cimg/node:15.11.0</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">checkout</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">markdown-link-check</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">find</span> <span class="string">.</span> <span class="string">-name</span> <span class="string">\*.md</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">--max-lines=1</span> <span class="string">markdown-link-check</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">workflow:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">markdown_link_check</span></span><br></pre></td></tr></table></figure><p>あとは CircleCI を回せば、リポジトリ内のリンク切れを全て検知してくれます。</p><h2 id="大量のリンク切れを検知したときは"><a href="#大量のリンク切れを検知したときは" class="headerlink" title="大量のリンク切れを検知したときは"></a>大量のリンク切れを検知したときは</h2><p>長期間メンテナンスされていないリポジトリの場合、markdown-link-check が大量のリンク切れを検知します。<br><code>.circleci/config.yml</code> に定義ファイルが追加された時点で、CircleCI が落ち続けてしまうので、まずはローカル実行でリンク切れ状況をチェックしましょう。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ circleci <span class="built_in">local</span> execute --job markdown_link_check</span><br><span class="line">（略）</span><br><span class="line"></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment"># リンク切れあり</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line">ERROR: 1 dead links found!</span><br><span class="line">[✖] ../docs/環境構築/README.md → Status: 400</span><br><span class="line"></span><br><span class="line">Task failed</span><br><span class="line">Error: task failed</span><br><span class="line"></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment"># リンク切れなし</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line">[✓] ../../docs/環境構築/README.md</span><br><span class="line"></span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><h2 id="特定のリンクは対象外にしたいとき"><a href="#特定のリンクは対象外にしたいとき" class="headerlink" title="特定のリンクは対象外にしたいとき"></a>特定のリンクは対象外にしたいとき</h2><p>正規表現で <code>ignorePatterns</code> を設定すれば、特定のリンクをチェック対象外に指定できます。</p><p>例えば、別サイトへのリンクをチェック対象外にしたい場合、<code>config.json</code> に以下設定を追加します。</p><figure class="highlight json"><figcaption><span>config.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ignorePatterns&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;^http&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-c</code> オプションで、config.jsonを渡します。</p><figure class="highlight yml"><figcaption><span>config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">find</span> <span class="string">.</span> <span class="string">-name</span> <span class="string">&#x27;*.md&#x27;</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">--max-lines=1</span> <span class="string">markdown-link-check</span> <span class="string">-c</span> <span class="string">config.json</span></span><br></pre></td></tr></table></figure><p>その他、config.json の設定次第で様々な動作調整が可能です。<br>詳細は <a href="https://github.com/tcort/markdown-link-check#config-file-format">Config file format</a> をご参照ください。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>ドキュメントの増加やメンバーの入れ替えなどにより、徐々に資料の陳腐化が進んでしまうのはあるあるだと思います。資料パスのリンク切れは自動検知可能なので、こういった作業は自動化・仕組み化して、エンジニアは開発に集中しましょう。</p><p>今回は「CircleCI で Markdown チェックを自動化する」方法でした。</p><p>この方法が、読んでいただいた方の役に立てたら幸いです。</p><h2 id="参照記事"><a href="#参照記事" class="headerlink" title="参照記事"></a>参照記事</h2><ul><li><a href="https://github.com/tcort/markdown-link-check#config-file-format">markdown-link-check</a></li><li><a href="https://future-architect.github.io/articles/20210331/">今さらながらfindパイセンについてまとめてみた</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210422b/chain-312403_640.png&quot; class=&quot;img-small-size&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pixabay.com/ja/users/clker-free-</summary>
      
    
    
    
    <category term="CI/CD" scheme="https://future-architect.github.io/categories/CI-CD/"/>
    
    
    <category term="Document" scheme="https://future-architect.github.io/tags/Document/"/>
    
    <category term="CircleCI" scheme="https://future-architect.github.io/tags/CircleCI/"/>
    
    <category term="Markdown" scheme="https://future-architect.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Technical Credibilityを築くということ</title>
    <link href="https://future-architect.github.io/articles/20210422a/"/>
    <id>https://future-architect.github.io/articles/20210422a/</id>
    <published>2021-04-21T15:00:00.000Z</published>
    <updated>2021-04-22T02:16:30.961Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/articles/20210414a/">春の入門連載2021</a>の7日目です。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、TIGの須田です。</p><p>私は新卒でフューチャーへ入社しITの世界でのキャリアが始まりました。その後、一度フューチャーを離れIoTプラットフォーマーのソリューションアーキテクトとして多くのお客様へ自社サービスの導入支援やIoTシステムの設計や構築の支援をしておりました。そうしたソリューションアーキテクトとしてのロールを通じて、多くの経験や学びを得ることができたのですが、その中でも特にTechnical Credibilityというキーワードについて自分の経験を交えて本ブログにて書いてみたいと思います。</p><p>本ブログのシリーズが、春の入門記事＆新人だった頃の自分に伝えたい内容を書こう、というテーマであったので迷わずこのテーマについて取り上げようと決めました。</p><h2 id="Technical-Credibilityとはなにか"><a href="#Technical-Credibilityとはなにか" class="headerlink" title="Technical Credibilityとはなにか"></a>Technical Credibilityとはなにか</h2><img src="/images/20210422a/climbing-4514507_640.jpg" class="img-middle-size"><blockquote><p><a href="https://pixabay.com/ja/users/rappellingusa-13786882/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4514507">Rappellingusa</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4514507">Pixabay</a>からの画像</p></blockquote><p>Technical Credibilityとは無理やり日本語に訳すと技術的信頼？信頼度？となります。Technical Credibilityの厳密な説明や定義が少ししにくいのですが、技術力やそのナレッジを通して信頼を得ていくこと、そのプロセス、と自分は解釈しています。</p><p>私はこの言葉をソリューションアーキテクトとして活動していた際に初めて知りました。ソリューションアーキテクトというロールはお客様の抱える課題や実現したいことに対して、主にテクニカルサイドからどのようにそれらを解決・実現できるかについて具体的なアドバイスやご支援するものです。そうしたロールであることからも、技術的なアドバイスを求められることが大きく期待されています。</p><p>こうした技術的なやり取りを通じてお客さんの信頼を得ていくプロセスをTechnical Credibilityを得る、とここでは表現したいと思います。</p><p>ソリューションアーキテクトの仕事そのものについてはこちらのエントリがとても参考になります。またこちらのエントリにもTechnical Credibilityの大切さについての言及があるのでこちらもぜひおすすめです。</p><iframe src="https://hatenablog-parts.com/embed?url=https%3A%2F%2Fimai-factory.hatenablog.com%2Fentry%2F2017%2F12%2F12%2F192439" style="border: 0; width: 100%; height: 190px;" allowfullscreen scrolling="no"></iframe><p>フューチャーは経営とITをデザインするという言葉が示す通り、ソフトウェアエンジニアであってもお客様の業務を理解し、一緒にシステムを作り上げていくことが求められます。そのためTechnical Credibilityの考え方が同じく重要だと考えています。</p><p>ここからはTechnical Credibilityを築くことの重要性や、その際にどのような考えやアクションが重要になってくるのか、またその中でのちょっとしたTipsなんかにふれていきたいと思います。</p><h2 id="Technical-Credibilityがなぜ大事なのか"><a href="#Technical-Credibilityがなぜ大事なのか" class="headerlink" title="Technical Credibilityがなぜ大事なのか"></a>Technical Credibilityがなぜ大事なのか</h2><p>ITの世界に限らずTechnical Credibilityは私たちの日常のいたるところで適用できる考え方だと思っています。例えば体調が優れないときは病院へ行き専門医に原因や対処法を診察してもらいますし、何か資産運用を始めたいとなった際にFPに相談される方もいらっしゃると思います。こうしたシーンにおいて、私たちが知らないことやより深く知りたいことを、その知識や経験を有している専門家に相談しアドバイスをもらうという観点では私たちITコンサルタントに期待される役割と同様です。</p><p>まず初めに、こうした特別な事情を有した相談は誰にでもできるものではありません。そうした経験を有している方へアドバイスを求めることが自然です。そうした際にまず大事になってくるのが、この人に相談ができる・したいと認知してもらえていることです。私たちも期待した答えが得られなさそうだったり、詳しくない人に専門的なアドバイスを求めようとはまず思わないですよね。（あえて専門家以外の方にフラットな意見を聞くことが重視されているようなシーンでは話は変わるかもしれません）</p><p>こうしたアドバイスをもらう際に、その一連のやり取りの中でこれぞまさに求めていたアドバイスだ！といった助言をいただけたとします。そうすると、また似たような悩みや関連する相談事があった際に、ぱっとその人の顔が思い浮かび、また相談してみようかしらと考えるのは自然なことではないでしょうか。そうした体験を繰り返すことで、最初はさしあたった相談や課題が主だったのが、より多くのことについてもまずこの人に相談にのってもらいたい、この人なら何かアイデアがあるんではないだろうかと大きな信頼へと変わっていきます。</p><p>このプロセスこそがTechnical Credibilityが築かれることでもたらされる好循環で、こうした信頼がうまれることでより多くの機会を創出することにつながります。特にビジネスの世界ではこうした些細な相談事から大きなプロジェクトへつながったり、はたまた一緒に大きな仕事をしていこうという機会にもつながってきます。</p><p>それではTechnical Credibilityを築くためにはどうしたらよいのでしょうか。このアプローチは人それぞれあると思いますが、私自身の経験や私自身がこの人はとてもTechnical Credibilityを築くのが上手だなと思える人たちの振る舞いを見て学んだポイントについてふれていきたいと思います。</p><h2 id="Technical-Credibilityを築くには"><a href="#Technical-Credibilityを築くには" class="headerlink" title="Technical Credibilityを築くには"></a>Technical Credibilityを築くには</h2><h3 id="自分の経験・知識を還元できそうな領域を見つける"><a href="#自分の経験・知識を還元できそうな領域を見つける" class="headerlink" title="自分の経験・知識を還元できそうな領域を見つける"></a>自分の経験・知識を還元できそうな領域を見つける</h3><p>まずは自分が提供できる専門性や得意な領域を見つけることがとても大事です。これについて、何かの専門家である必要はなく、自分の経験に裏付けされた何かアドバイスができる、といったそういったもので十分かと考えています。例えば、DynamoDBを使ったデータモデルの設計実装経験とその過程で得られた知見や、ライブラリの選定を通じて得た各プロダクトの特徴や適したユースケースを理解している、はたまた倉庫業務のアプリケーション開発を通じて得られた倉庫業務の知識そのもの、特定の産業用途に特化した独自プロトコルのフォーマットのパース処理を通じて得られプロトコル仕様、こうした人それぞれの経験がまさに価値を生んでいきます。こうしたナレッジは誰しも持っているものではありません。さらに、商用環境での導入などを通じてより実践に即したノウハウなどは、やってみたの域を超えた高い付加価値を有しています。</p><p>こうした経験はこれから同じチャレンジをする人たちや、今まさにはまっている人たちにとってはとても有益な情報となります。このように、まずは自分がこれまで経験をその中で培ったナレッジから何か貢献できることから始めていくことで、その人のTechnical Credibilityを築いていくことができるのではないでしょうか。こうした過程を重ねていくことで、○○のことなら前にｘｘさんが教えてくれたからまた相談してみよう、ぜひメンバとして一緒にやってもらいたいといったラベリングができあがり、より大きな相談事をもらえたり、チャンスへつながっていくのではないでしょうか。とにもかくにも、自分の経験や知識を惜しげもなくシェアしていくことが大事な一歩かと考えます。</p><p>例えばこのように普段使っている便利な小技だったり、やってみて分かったはまりどころ、がっつり業務導入した知見などを技術ブログとして共有することも社内、社外問わず自分のラベリングを作るのに効果的な手法ですね。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200116/index.html" data-iframely-url="//cdn.iframe.ly/AJ0a9bh?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200803/index.html" data-iframely-url="//cdn.iframe.ly/vWZNkTt?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20201013/index.html" data-iframely-url="//cdn.iframe.ly/SAxxrkF?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><h3 id="常に最新の情報をキャッチアップする"><a href="#常に最新の情報をキャッチアップする" class="headerlink" title="常に最新の情報をキャッチアップする"></a>常に最新の情報をキャッチアップする</h3><p>個別の技術要素を正しく理解することが全ての基本です。これがやりたかったらこのAPIを使えばよさそうですねとか、このクラウドサービスとこの機能を組みあわせれば実現できそうですね、など様々な技術要素を考慮しながら具体的な課題へのアプローチを提示できることがまずは重要です。特に、昨今のクラウドサービスの拡充やそれらのサービスの成長スピードなんかを考えると、つい昨日までしてた苦労が実はマネージドサービスやSaaSとして提供されていたり、新しい機能が使えることでよりシンプルな実装になったりというのはよくあることとなってきました。そのため、最新の情報を常にキャッチアップしておくことも、不要な苦労を避けてもらうためにも非常に重要となってきます。</p><p>こうした個別の技術要素を正しく理解しながら、自分の引き出しを増やして、いざという時にすっとアイデアや解決策そのものを引き出せるようにしておくこともとても大事なスキルとなってきます。</p><p>情報収集の仕方についてはみなさん好みのやり方があると思うのでここではふれませんが、すぐに試せる環境を手元に用意しておくことをおすすめします。最近ではDockerコンテナなどでたいていの実行環境はdocker pullで利用できますし、試すだけの環境構築の敷居はかなり下がっていると感じます。また様々な機能がクラウドサービスやSaaSとしても提供されるようになり、何かを確認したい・知りたい時は自分で手を動かして理解する方がよほど早くなってきているとも思います。前述したように、昨今における機能の充実速度はとても速いです。たくさんの利便性を享受できる一方で、理解しなくてはいけない事柄も同時に増えてきているとも言えます。こうした状況では実際に手を動かしてプロダクトを理解し、想定通りの挙動がとれた・できなかったという経験を通じたキャッチアップや理解の方が結果的に効率的なことが多いです。特に自分で手を動かすことで、ただ知っている状態より深みが増します。さきほど書いた通り、自分が実際に体験した事柄が価値を生んでいきます。そのため、手元ですぐに試して確認したり失敗したりできる環境をメンテナンスしておくが非常に大事です。さてやってみるか、となった際にその初速を高められる準備をしておくことをおすすめします。</p><p>また最近では<a href="https://www.oreilly.com/">O’Reilly Media</a>のように、書籍を横断したキーワード検索ができるものもあり、短期間でよりピンポイントでの深堀をしたい際はこうしたサービスを活用していくのもおすすめです。</p><h3 id="課題の本質を考える"><a href="#課題の本質を考える" class="headerlink" title="課題の本質を考える"></a>課題の本質を考える</h3><p>ある悩みや課題に対して、具体的な解決策を説得力をもってぱっと提示できることの重要性についてはさきほど記載した通りです。</p><p>一方で、その課題やゴールが果たして適切なものなのかを一歩立ち止まって考えられることも、相談相手のためにも重要なことが多いです。例えば、実はその課題の本質には別の根本的な課題があって、そちらにアプローチするのがより効果が高いといったシーンです。専門家へ相談するようなシーンにおいては、相談者自身も何が課題になっているかが分からない、把握が難しいケースも多いです。特に初めての取り組みや、ナレッジの取得が難しいような課題に取り組む際に私たちも何が分からないのか分からない、といった経験が一度はあるのではないでしょうか。こうした状況下で設定した課題やゴールについて、相談を受ける側はいい意味で第三者的な見方ができます。あれ、これって本当に実現したいことなのかな、という事が浮かんだら投げかけてみることで相談者にも新たな気付きをもらすことができますし、何よりもこれこそがアドバイスの神髄ではないのでしょうか。</p><p>またITの世界では、同じ課題感であっても属する業種業態などによってもとらえ方やアプローチが変わってくることもあります。そのため、技術要素しか興味がないので、、と食わず嫌いせずに、その課題が置かれている業界背景などにも目を向けてみることで得られるものもたくさんあります。</p><p>こうしたいわゆるドメインへの理解をどう行っていくかですが、一般的な知識であれば今では色んな情報が簡単に手に入るのではないでしょうか。私はよく就職活動なんかで使われるような業界本なんかも最初は読んだりします。よりテクニカルなトピックについては、最近だと動画コンテンツが充実してきています。例えば、既に活用されている方も多いかもしれませんが<a href="https://www.udemy.com/">Udemy</a>もおすすめで、ITコンテンツ以外の業界に特化した技術コンテンツなども充実しています。例として、製造業ですと様々なフィールドネットワークのためのプロトコル技術や、PLCといった機器操作方法などのコンテンツもたくさんあり、体系だった理解を効率的に進められます。またYouTubeにもこうした多くの動画が公開されており、短い時間で体系だったキャッチアップが必要な際にとても有用なコンテンツとなっています。まずは気になるワードなどで検索してみることをおすすめします。</p><p>例えば私はIoT関連のプロジェクトを担当することが多いのですが、その際に専門的な機器設備の仕組みなどをキャッチアップするのにこのYouTubeチャンネルにお世話になってます。</p><p><a href="https://www.youtube.com/c/Theengineeringmindset/featured">https://www.youtube.com/c/Theengineeringmindset/featured</a></p><p>ちなみに実機を使った何か確認がしたい！という場合はヤフオクだと専門的なデバイスも入手しやすいのでこちらもおすすめです。</p><h3 id="どうしてそうするのか・したのかを蓄積する"><a href="#どうしてそうするのか・したのかを蓄積する" class="headerlink" title="どうしてそうするのか・したのかを蓄積する"></a>どうしてそうするのか・したのかを蓄積する</h3><p>どんなシステムや技術課題、業種業態の話であっても、実現したいことやそのポイントには多くの共通点があることが多いです。そのため、どうしてそのような判断をしたのか、どのようなアドバイスのステップや検討を経由したのか、といったログを残しておくことも非常に重要です。これは前述した引き出しから適したアドバイスを素早く引き出せることにもつながります。</p><p>Architecture Decision Records(以下ADRs)をご存じでしょうか。私はロール上、システムアーキテクトとして実現したい仕組みや解決したい課題へのアプローチを立案することも多いのですが、ADRsのアプローチは非常に有用です。どういう過程を経由したのか、その各過程ではどういった考えあったのか、を形として残すことでなぜそうするのかを第三者にもステップを追ってシェアすることができます。どんなに解決策やアプローチが優れていたとしても、そこに納得感が伴わないとなかなか行動に移しにくのも確かです。そういった観点でもこういったログを一緒に作る、というアクションもこれまでの考えをより納得感をもった理解を促すためにも非常に大事なのではないでしょうか。</p><p>具体的なADRの例ですがADRの具体的な作り方はこちらがとても分かりやすく整理されていておすすめです。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://scrapbox.io/kawasima/%25E5%25AE%259F%25E8%25B7%25B5ADR" data-iframely-url="//cdn.iframe.ly/ca2LjZK"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>新卒でフューチャーへ入社した際はいわゆるIT未経験だったこともあり、テクニカルな側面でのキャッチアップや研磨にとにかくがむしゃらだったことを今でも覚えています。</p><p>それを正しく人に伝え、そこからさらなる価値を生み出していくこと、そのためにより広い視野で食わず嫌いせずにキャッチアップを続けることの大事さを新人だったころに自分に伝えてあげたい、、、ぜひ自分の得意な領域に磨きをかけつつも、色々な技術に実際に触れてみて、みなさんしか作れないTechnical Credibilityの源泉を蓄えていってください！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の7日目です。&lt;/p&gt;
&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こん</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
    <category term="技術的信頼" scheme="https://future-architect.github.io/tags/%E6%8A%80%E8%A1%93%E7%9A%84%E4%BF%A1%E9%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>The Apache Wayのお話</title>
    <link href="https://future-architect.github.io/articles/20210421b/"/>
    <id>https://future-architect.github.io/articles/20210421b/</id>
    <published>2021-04-20T15:00:01.000Z</published>
    <updated>2021-04-21T03:54:26.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、<a href="/articles/20201107/">フューチャーOSS推進タスクフォース</a>の藤野です。</p><p>私が現在参加している<a href="https://www.apache.org/">The Apache Software Foundation（ASF）</a>の基本理念の一つである<a href="https://www.apache.org/theapacheway/">The Apache Way</a>について紹介します。</p><p>The Apache Wayを通して、ASFのことを少しでも知ってもらえたらと思います。</p><h2 id="The-Apache-Wayとは？"><a href="#The-Apache-Wayとは？" class="headerlink" title="The Apache Wayとは？"></a>The Apache Wayとは？</h2><p>この記事を読んでいる多くの方は、開発者や利用者等、様々な立場でOSSに何らかの形で関わりを持っていると思いますので、The Apache Software Foundationやそこで開発されているのOSSについていくつか程度の差はあれどご存知かと思われます。</p><p>The Apache Software Foundation とは、HTTPDやTomcat等、数多くのOSSプロジェクトの開発を支援している非営利団体で、世界で成功しているOSSコミュニティの一つです。</p><p>The Apache Wayとは、このThe Apache Software Foundationがどのようにプロジェクトを統治するのか、コミュニティ運営の基本指針のようなもので、ASFプロジェクトで長年にわたって使用されているコミュニティの振る舞いや運用方法のガバナンスモデルを提供します。</p><p>そしてこのThe Apache Wayは、コミュニティメンバによって其々捉え方が異なり、多くの解釈があります。<br>今日は、このThe Apache Wayの（私的な）解釈をまとめてみました。</p><h2 id="The-Apache-Wayの主要コンセプト"><a href="#The-Apache-Wayの主要コンセプト" class="headerlink" title="The Apache Wayの主要コンセプト"></a>The Apache Wayの主要コンセプト</h2><p>The Apache Wayを紐解くと4つに分割できます。そしてそのコンセプトは其々次の通りです。</p><ul><li><strong>MERITOCRACY（成果・実績主義）</strong><br>成果・実績によって評価され、統治され、その影響力は、公的に獲得したMerit、つまりコミュニティに貢献することに基づいています。</li><li><strong>Community</strong><br>組織ではなく、個人がASFに参加します。<br>相互に信頼し、互いに尊敬します。<br>BDFL（Benevolent Dictators For Life）は許可されません。</li><li><strong>Collaborative Development</strong><br>ASFのProjectは共同開発によって行われます。<br>コミュニティはコラボレーションなしでは成長できません。<br>コミュニティ全体で技術的な方向性を決定します。</li><li><strong>Open Communications</strong><br>Codeと意思決定に関連するすべての議論はPublicにアクセス可能でなければなりません。</li></ul><p>この4つの主要コンセプトをそれぞれ深堀りしてみましょう。</p><h2 id="MERITOCRACY"><a href="#MERITOCRACY" class="headerlink" title="MERITOCRACY"></a>MERITOCRACY</h2><p>まずは、MERITOCRACY（成果・実績主義）です。</p><p>ASFでは、すべての個人に対して参加する機会が与えられますが、その影響力は、公的に得られたMerit、つまりコミュニティに貢献した実績に基づいています。</p><p>では、そのMeritとは何でしょうか？Meritとは、コミュニティにとって有用な目に見える作業の実績です。そして、そのMeritはコード実績だけではありません。ほとんどのコミュニティは、ドキュメント、Webサイト、インフラストラクチャ、メーリングリストのヘルプ、およびバグレポートの等の貢献も高く評価しています。つまり、様々なロールのユーザがコミュニティに貢献することが出来ます。</p><p>また、Meritには様々な側面があります。</p><ul><li><strong>Meritは所属に関係なく個人にあります</strong><br>重要なのは、「あなたが誰であるかではなく、あなたが何をするか」です。<br>Meritは貢献者の所属する組織や企業には全く影響を受けません。</li><li><strong>Meritには有効期限がありません</strong><br>貢献者が、コミュニティへの参加をしばらくの間やめていたとしても、そのMeritは消えることはありません。後でコミュニティに戻ってきても、通常はコミュニティ内でのMeritを維持します。</li><li><strong>Meritは譲渡できません</strong><br>あるコミュニティで得られたMeritは、必ずしも別のコミュニティで評価されるとは限りません。Meritの認識は、コミュニティによって大きく異なります。</li><li><strong>より多くMeritを持っている人は、より多くの責任を得ます</strong><br>これはMeritの最も重要な側面のひとつです。貢献者のMeritに対する最も明白な報酬は、そのコミュニティ内のコミッターになることです。また、コミッターは、プロジェクトのリポジトリへの書き込みアクセス権を持っているので、コード、Webサイト等に直接貢献することが出来ます。 Meritを提供し続けているコミッターは、PMCになれる場合があります。<br>つまり、誰でもコミュニティに貢献することは出来ますが、全ての貢献者がコミッタになれるわけではありません。私自身もコミッタになる前は3桁以上のパッチを提出しています。コミッタからPMCになるにも2年以上活動を継続しました。<br>今コミュニティにいるコミッタやPMCは皆それぞれコミュニティへの大きな貢献によって、その地位にいます。</li></ul><h2 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h2><p>次は、Communityです。ASFでは、Communityの定義について厳格に定められています。</p><p>ASFでは、取締役会、他の役員、コミッター、およびメンバーを含むすべての参加者は、個人として参加しています。決して、企業からの参加であってはなりません。</p><p>これは、ASFの強みの1つであり、完全なベンダーの中立性を保障します。しかしながら、実際、一部の企業には雇われコミッタのような方もいますが、そうったコミッタに関しても企業として参加しているのではなく、あくまで個人参加となります。その貢献実績は個人にのみあります。前述したMERITOCRACYにあるように、個人の貢献実績によってコミュニティ内の役割が決まるので、一部の企業が自由にそのプロジェクトのコミッタを追加することはできません。</p><p>では、あるOSSプロダクトをASFに寄与する場合（Apache Incubator）はどうでしょうか？この場合、開発者が特定の企業から構成されていることは良くあることです。そのような場合においても、Apache Incubatorの卒業要件（TLPへの昇格要件）としてコミッタの多様性、つまり、コミッタが様々な企業からであることを示さなければなりません。</p><p>また、コミュニティ内では参加者全員が相互に信頼し、互いに尊敬することを期待します。そして、<a href="http://apache.org/foundation/policies/conduct.html">その行動規範</a>も明確に定義しています。</p><p>ASFのフラットな構造は、役職に関係なく参加者は同じ発言力を持ち、平等であるべきとされています。専門知識は高く評価されている一方で、BDFL（Benevolent Dictators For Life）は許可されていません。</p><p>そして、このCommunityにおいて、もっとも重要なコンセプトは「Community over Code」です。「Community over Code」とは、ASF内で非常に良く引用される格言で、健全なコミュニティが優れたコードよりもはるかに重要であることを明言しています。</p><p>優れたソフトウェアを創造することを目的とするASFが、その作り出されたプログラムコードそのものよりも、コミュニティ自体を大事にするASFの最も重要な特徴として強調されています。</p><h2 id="Collaborative-Development"><a href="#Collaborative-Development" class="headerlink" title="Collaborative Development"></a>Collaborative Development</h2><p>ASFの各プロジェクトは共同開発によって行われています。</p><p>コミュニティ全体によって方向性を決定しするため、主要な決定事項については、コンセンサスを得ようと努めています。この際に行われる意思決定は怠惰なコンセンサスアプローチ（lazy consensus approach）で行われます。これは以下のような数字による投票で行います。</p><ul><li>+1　賛成票</li><li> 0　棄権、意見なし</li><li>-1　反対票</li></ul><p>コンセンサスは100％の合意を意味するものではなく、 コミュニティの合意には、-1の投票が無く、いくつかの+1の投票を獲得するだけで十分です。反対票には代替案または反対票の理由の詳細な説明を含める必要があります。また、投票は通常72時間(3日)ルールで行われます。</p><p>これはさまざまなタイムゾーンのプロジェクト参加者が意思決定に参加できるように、十分な時間（少なくとも72時間）の投票が可能であることを保障します。</p><h2 id="Open-Communications"><a href="#Open-Communications" class="headerlink" title="Open Communications"></a>Open Communications</h2><p>ASFでは、その技術的な仕事はオープンに行われなければなりません。つまり、コードや技術的決定に関連するすべてのコミュニケーションが公開メーリングリストで行われる必要があります。メーリングリスト外の対談や会議でのディスカッションはすべての参加者がディスカッションして決定できるように、適切なメーリングリストに戻す必要があります。</p><p>コードや技術的決定に関連するプライベートな決定は許可されていません。私自身もApacheCon（ASF主催の国際カンファレンス）で他のコミッタ達とF2Fで議論することがあるのですが、そこで決めたことは、必ずその後開発用のメーリングリストに共有することを行っています。</p><p>もちろん、プロジェクトに非公開なメーリングリストはあります。しかしながら、ASFのすべての非公開メーリングリストには、セキュリティ問題など非公開にする特定の理由があります。</p><p>パブリックの場でできるだけ多くの仕事をするという概念は、The Apache Wayの基本であり、 オープンコミュニケーションは、誰もが自由にコミュニティに参加することを保障します。技術的な議論、コンセンサス、コードとドキュメントの作業をすべてオープンに行うことで、新しいユーザはメーリングリスト、アーカイブからプロジェクトの過去、現在、そして未来の方向性を知ることが出来ます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>The Apache Wayの主要なコンセプトを述べました。</p><p>これまでをまとめると、The Apache Wayとは、</p><p>「ASFの各プロジェクトでは、個人参加の原則により、ベンダーの中立性を促進し、特定の企業からの過度の影響を防ぎます。メンバーはその貢献実績により評価され、影響力は完全に平等です。プログラムコードや技術的な意思決定等の議論は全てのオープンで透過的でコンセンサスベースで行われます。」</p><p>と言い表せます。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>今回は私の解釈によるThe Apache Wayを述べました。</p><p>The Apache Wayは常に変化しフレキシブルで成長しています。</p><p>「There is no “one way” to The Apache Way. 」という言葉があります。</p><p>The Apache Wayは基本的な原則ではありますが、どう解釈するかは人それぞれです。このThe Apache Wayからも分かるように、ASFはコミュニティのガバナンスがしっかりしています。</p><p>そのため、これからコミュニティに参加しようと思っている人にとっては入り易いコミュニティだと思います。</p><p>ぜひ、参加してみてはいかがでしょう。</p><ul><li><a href="https://community.apache.org/gettingStarted/101.html">入門ページへ</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、&lt;a href=&quot;/articles/20201107/&quot;&gt;フューチャーOSS推進タスクフォース&lt;/a&gt;の藤野で</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="OSS推進タスクフォース" scheme="https://future-architect.github.io/tags/OSS%E6%8E%A8%E9%80%B2%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%95%E3%82%A9%E3%83%BC%E3%82%B9/"/>
    
    <category term="ApacheWay" scheme="https://future-architect.github.io/tags/ApacheWay/"/>
    
  </entry>
  
  <entry>
    <title>情報の民主化のために発信しましょう</title>
    <link href="https://future-architect.github.io/articles/20210421a/"/>
    <id>https://future-architect.github.io/articles/20210421a/</id>
    <published>2021-04-20T15:00:00.000Z</published>
    <updated>2021-04-21T01:08:15.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、<a href="https://www.inspace.co.jp/">フューチャーインスペース株式会社</a>の柴尾です。<a href="/articles/20210414a/">春の入門連載2021</a>の6日目です。</p><p>複数のプロジェクトでルーターやスイッチといった物理的な装置の設定から、パブリッククラウド（主にAWS, GCP）まで設計、構築、保守運用、それらのクラウド業務の請求が複雑なのでバックオフィス部門との調整を行っています。</p><h1 id="新人のころを思い出してみて"><a href="#新人のころを思い出してみて" class="headerlink" title="新人のころを思い出してみて"></a>新人のころを思い出してみて</h1><p>私は2010年4月にフューチャーインスペース株式会社の前身である株式会社アセンディアへ大学卒業後入社しました。</p><p>忘れもしない出来事として当時東京採用・大阪採用・福岡採用・大分採用が定期的にWeb会議で会話していたものの、私も出身の地元である大分から3月31日に東京本社で初めて一同に介して、「明日からこのメンバーで研修か、こなせるのかな？」などと不安と期待と感情が混ざっている中で、研修の受け入れ担当から「明日から研修はフューチャーグループ合同でやるから」と衝撃の一言がありました（笑）</p><p>青天の霹靂とはまさにこのことで当時は誰も予想していなかった、</p><ul><li>フューチャーアーキテクト株式会社</li><li>フューチャーワン株式会社（当時は株式会社エルム）</li><li>フューチャーインスペース株式会社（当時は株式会社アセンディア）</li></ul><p>合同研修を初めて行いました。</p><p>研修の内容はこのブログ趣旨とは外れるので割愛しますが、この研修の体験は色々な意味でよかったと思います。</p><h1 id="新人の時に知りたかったあの知識"><a href="#新人の時に知りたかったあの知識" class="headerlink" title="新人の時に知りたかったあの知識"></a>新人の時に知りたかったあの知識</h1><p>さて、ブログの主題としては今の私が思うのはズバリ「 <strong>情報の発信による効果</strong> 」です。</p><p>私はAWSを触れるようになったのは最近なのですが、公式のドキュメントや他の企業ブログ、個人ブログを見るだけで自分の中に落とし込むことができませんでした。</p><p>そのような中で、JapanAWS-UserGroupこと<a href="https://jaws-ug.jp/">JAWS-UG</a> に出会い、衝撃を受けました。</p><p>利用者側が主導してコミュニティの運営、イベントの運営含め自主的に動いていることだけではなく、参加者側がただただ参加してハイ終わりではなく、参加して聞いた内容をブログにまとめ上げる、それも早い人はイベント終わった瞬間に、そういったインプットからアウトプットまでのスピード感に驚かされました。</p><p>AWS公式漫画でも紹介されていますので、引用させていただきます。</p><p><a href="https://aws.amazon.com/jp/campaigns/manga/vol11-2/">https://aws.amazon.com/jp/campaigns/manga/vol11-2/</a></p><p>COVID19によりオンライン会議が以前に比べて活発になった昨今では、AWS、JAWS-UGだけではなく様々な企業、コミュニティによるオンラインイベントが行われています。もしこの記事を見ていただいている方の同時刻にもイベントが行われているかもしれません。</p><p>話を戻して、そういった中で個人的に感じた、 <strong>発信すること</strong> については、一般的なPDCAに当てはめることができて以下のような効果があると思っています。</p><table><thead><tr><th>Step</th><th>想定される効果</th></tr></thead><tbody><tr><td>Plan</td><td>発信する内容の整理する過程で知識を落とし込める、自分の理解が曖昧な部分を洗い出せる</td></tr><tr><td>Do</td><td>実際に発信する</td></tr><tr><td>Check</td><td>目に触れた人から反応がある（コメント、あるいはフィードバック）</td></tr><tr><td>Action</td><td>自分だけではカバーできなかった範囲でさらに視野が広がる</td></tr></tbody></table><p>例えば、以前私が参加したとある講座があり参加してきました。正直私自身、データベースをそこまで詳しいエンジニアではなかったものの、必死になってリアルタイムでまとめて即公開をチャレンジしてみました。<br>（それも分からないところを書いて丸投げする形で）</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3.png"></p><p>すると、以下のように偶然時間が空いた人や少し経ってからポツポツとコメントを頂くようになって、</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3_2.png"></p><p>自分の足りなかった範囲を補うコメントであったり、タイプミス部分含めて指摘が貰えて、結果的に理解がより深まるようになりました。</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3_3.png"></p><h1 id="なぜ、そう思ったのか（思うようになったか）"><a href="#なぜ、そう思ったのか（思うようになったか）" class="headerlink" title="なぜ、そう思ったのか（思うようになったか）"></a>なぜ、そう思ったのか（思うようになったか）</h1><p>正直、私は積極的に情報公開するタイプではありませんでした。</p><p>ただ私が研修後に入った始めてのプロジェクトで積極的に内部に情報を展開する文化があり、その展開された情報に対して、誰かが反応するという様子を見ていたことから、自然と敷居が低くなっていったのかもしれません。</p><p>2010年当時は今ほどチャットツールが活発ではなくメールベースでしたが、そのような行為があったことを忘れないように今でもメールを保存しています。<br><img src="/images/20210421a/sample.jpg"></p><p>また、それほど瞬発的に情報を整理できるタイプでもなかったため、相手に伝える情報を整理してから、伝えることを繰り返して訓練を積みました。</p><p>自分の幅を広げようと技術系のセミナーに行くと知らないことばかりで衝撃を受けて、それらをメモして調べていく中でまとめるといった行為に繋がり、繰り返していくことでそれまで散り散りになっていた知識が紐付いてきて、結果として身に着けてきたかなと思います。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>私の新人の時に知りたかったあの知識「 <strong>情報を発信すること</strong> 」でした。</p><p>直接、知識というものではなく意識に近いものですが、結果的に知識へ繋がるものだと思います。</p><ul><li>情報の発信することは怖いですよね？</li><li>出す情報が間違っていない？</li><li>この情報を出しても意味ある？</li></ul><p>…と考えるより、とりあえず発信しましょう。<br>発信することから得られることのほうが結果的に大きいです。</p><p>間違えていれば、誰かが指摘してくれます。素直に受け止めて次につなげましょう。ただただダメじゃんというFBしてくる一定の層がいますが、批判することに価値を見出している勢は、そういった視点があるという新しい学びと考えることにしましょう。</p><p>出している情報に価値を見出すのは自分ではなく他の人です。出さない情報には価値が付けられません。実は他にも同じことを知りたくて困っている人がいるかもしれないと考えることにしましょう。</p><p>エンジニアの知識は教科書どおり前から順に定着することが難しいものです。でも、きっと繰り返し継続して行っていくことで、ある日弾けるようにそれまでの知識が繋がっていくでしょう。</p><p>ぜひ今を楽しんでください。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、&lt;a href=&quot;https://www.inspace.co.jp/&quot;&gt;フューチャーインスペース株式会社&lt;/a</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
    <category term="情報発信" scheme="https://future-architect.github.io/tags/%E6%83%85%E5%A0%B1%E7%99%BA%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>議事メモ作成の心得</title>
    <link href="https://future-architect.github.io/articles/20210420a/"/>
    <id>https://future-architect.github.io/articles/20210420a/</id>
    <published>2021-04-19T15:00:00.000Z</published>
    <updated>2021-04-22T01:42:42.186Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。2020年10月入社の江口小夏です。<a href="/articles/20210414a/">春の入門連載2021</a>の5日目です。</p><p>新入社員の皆様、入社おめでとうございます！🌸</p><p>私は入社して約半年が経ちましたが、配属当初最も大変だと感じたのは議事メモ作成でした。この記事を読んでくださっている新入社員の方でも、議事録／議事メモ作成に時間を割いている方は多いのではないでしょうか？</p><p>私もまだまだ勉強途中ですが、少しでも議事録／議事メモを取る方の参考になればと思い筆を執りました。<br>ひとつの参考にしていただければ嬉しいです！</p><p>↓その他の議事メモ関連の記事はこちらから！↓</p><ul><li><a href="https://qiita.com/RuyPKG/items/abf72dde739e52364bcf">新人でも、楽がしたい！ ～議事録の準備～</a></li><li><a href="https://future-architect.github.io/articles/20210327/">議事録をサッと準備する</a></li></ul><h2 id="議事録-vs-議事メモ"><a href="#議事録-vs-議事メモ" class="headerlink" title="議事録 vs 議事メモ"></a>議事録 vs 議事メモ</h2><p><img src="/images/20210420a/writing.jpg"></p><p><a href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962">Free-Photos</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962">Pixabay</a>からの画像</p><p>企業やプロジェクトによって「議事録」をとるか、「議事メモ」をとるか変わると思います。<br>本ブログで扱う言葉を定義するためにも、議事録と議事メモの違いを確認しておきます。</p><p>議事録は、</p><blockquote><p>会議の内容や発言者を正確に記録し、会議の進行に沿って記載する。品質が重要で表現なども正確に記録する。</p></blockquote><p>一方で、議事メモは、</p><blockquote><p>会議の内容や発言者を正確に記録することはもちろんだが、サマリや決定事項、ToDoを明確にすることが最も重要。品質よりもスピード優先。</p></blockquote><p>自分自身の経験を踏まえて、本ブログでは<strong>議事メモ</strong>を取る場合を想定して書いていきます！</p><h2 id="議事メモ作成の目的"><a href="#議事メモ作成の目的" class="headerlink" title="議事メモ作成の目的"></a>議事メモ作成の目的</h2><p>皆さまご存知かと思いますが、念のため議事メモをとる目的を確認します。<br>（目的は、議事録でも同じ。）</p><p>主な目的は、</p><ul><li><strong>決定事項とToDoの確認と承認を得る → 認識齟齬防止</strong></li><li><strong>会議不参加者が会議内容を理解できるようにする</strong></li></ul><p>です。</p><p>特に一つ目は非常に重要なため、発言者や決定事項に対して承認を得たかはしっかり記載しておく必要があります。</p><hr><p>さてここまでで議事メモとは何か？をおさらいしました。<br>ここからは、議事メモをとる際の私なりのマインド面についてお話していきます。</p><h2 id="議事メモ作成を楽しむために"><a href="#議事メモ作成を楽しむために" class="headerlink" title="議事メモ作成を楽しむために"></a>議事メモ作成を楽しむために</h2><p>最初は「大変だな…」と感じていた議事メモ作成でしたが、徐々に議事メモを作成するのが楽しくなってきました。<br>その理由は以下のとおりです。</p><p><strong>1.議事メモとることで会議の内容を自然とおさらいできる</strong><br><strong>2.重要書類を作成するという責任感を感じる</strong></p><p>それぞれ説明していきます。</p><hr><p><strong>1. 会議の内容を自然とおさらいできる</strong></p><p>新入社員の頃は「会議の内容がさっぱり分からない…」なんてこともあるかもしれません。<br>そんな状態で会議中に議事メモ作成は大変かもしれませんが、以下のような良いこともあるかと思います。</p><ul><li><strong>議事メモ作成過程において、分からない内容や単語を再度復習・確認できる</strong></li><li><strong>発言の背景から、発言者の意図を読み取ることができる</strong></li></ul><p>結果として、会議をおさらいして自分の糧にできます。<br>キャッチアップ方法の一つとして是非議事メモを活用してみてください！</p><p><strong>2. 重要書類をつくっている責任感を感じる</strong></p><p>（「責任感＝楽しい」かどうかは人それぞれかもしれませんが…）</p><p>先ほど<a href="#%E8%AD%B0%E4%BA%8B%E3%83%A1%E3%83%A2%E4%BD%9C%E6%88%90%E3%81%AE%E7%9B%AE%E7%9A%84">議事メモ作成の目的</a>でも述べた通り、議事メモは<strong>「内容の承認を得て、認識齟齬を防止する」</strong>役割があります。これは議事メモが会議において非常に重要な書類である、ということです。</p><p>例えばスポーツでも、責任感のあるエースポジションを任されたらプレッシャーもありますが、終えたときの達成感や喜びもひとしおですよね。議事メモに対してそのようなイメージを持って、自分は楽しんでいます。</p><hr><p>これまで私なりの議事メモの楽しみ方をご紹介しました。</p><p>次に、議事メモをとる場合のコツやポイントをお伝えします。</p><p>意識するポイントなどは人それぞれですので、参考になる部分をご覧になっていただければと思います。</p><h2 id="コツ・手法"><a href="#コツ・手法" class="headerlink" title="コツ・手法"></a>コツ・手法</h2><h3 id="議事メモ作成ではここを意識しよう"><a href="#議事メモ作成ではここを意識しよう" class="headerlink" title="議事メモ作成ではここを意識しよう"></a>議事メモ作成ではここを意識しよう</h3><p>議事メモを作成するときに意識しているポイントを書いていきます。</p><hr><ul><li><strong>最低限、発言者と大まかな発言内容は確実に記録する</strong></li></ul><p>会議が進行する中で発言を一言一句漏らさずに書こうとすると、記載が間に合わないこともあります。<br>そんな時は、少なくとも<strong>発言者</strong>と<strong>何についてどんな意見を</strong>言っているのかに集中して書くと、議事メモに記載すべき最低限の内容をおさえることができます。</p><ul><li><strong>「～ため」「～ので」を聞き逃さない</strong></li></ul><p>ほとんどの発言には背景や意図、目的があります。なぜその発言があったかを、会議に出席していない人が理解するためにも重要なため、意識して聞きましょう。</p><ul><li><strong>ToDoを明確にする</strong></li></ul><p>会議で挙がったタスクやToDo事項は正確に記載する必要があります。期限やアウトプットの方法など不明点があれば、先輩など会議参加者に確認するのがベターです。</p><ul><li><strong>論点を意識して会議に臨む</strong></li></ul><p>議事メモ作成者だけに限りませんが、「この会議では何を決めなければいけないのか」を意識しておくことが大切です。</p><p>特に新入社員の頃は、会議が進行するにつれて、会議の内容に頭が追いついていけなくなることもあるかと思います。<br>しかし、会議で決めなければいけないことを頭に置いておけば、迷子になってしまったときも立ち返る基準になるはずです。</p><ul><li><strong>決定事項の合意がとれているかを確認する</strong></li></ul><p>決めなければならないことに対して顧客の合意がとれているかは非常に重要です。認識齟齬を防止するためにも、議事メモを記載するときは合意が取れているかを意識しておくと良いかと思います。</p><ul><li><strong>議事メモへの記載は時系列に沿うことよりも分かりやすさが重要</strong></li></ul><p>会議では議論が行ったり来たりすることも多々あります。</p><p>そのとき時系列順にすべて記載していると、見返したときに議事メモの内容が分かりづらくなることがあります。議論が進む中で、同じトピックに戻ったときは、時系列が違っていても同じ章に記載すると分かりやすくなります。</p><h3 id="議事メモチェックポイント"><a href="#議事メモチェックポイント" class="headerlink" title="議事メモチェックポイント"></a>議事メモチェックポイント</h3><p>会議終了後に議事メモを修正・清書するときのチェックポイントをいくつか挙げてみます。</p><hr><ul><li><strong>文章に主語があるか？</strong></li></ul><p>日本語は主語が省略されがちです。何／誰についての発言かを明確にするためにも、主語がない場合は補填しましょう。</p><ul><li><strong>分かりやすい日本語／シンプルな文章になっているか？</strong></li></ul><p>議事メモを読んで、すんなりと内容を理解できる状態にする必要があります。修正し終わった後に、顧客の会議不参加者になったつもりで議事メモを読み返してみると修正箇所が見えてきます。</p><ul><li><strong>誤字脱字、表記ゆれがないか？</strong></li></ul><p>誤字・脱字や同じ単語を別表現にしない、用語は正式名称で記載できている（略語を使っていない）かは最終チェックとして確認しましょう。</p><blockquote><p>例：プロジェクト／PJ</p></blockquote><ul><li><strong>名称は正式なものになっているか？</strong></li></ul><p>企業名や用語は略語などを使わず正式に書きましょう。</p><blockquote><p>NG:　フューチャー<br>OK： フューチャー株式会社</p></blockquote><ul><li><strong>口語が残っていないか？</strong></li></ul><p>口語体や崩れた日本語表現は適当な文章に直しましょう。</p><blockquote><p>NG:　XXXって思ってるんですよね<br>OK:　XXXと考えている。</p></blockquote><blockquote><p>NG:　XXXみたいな感じかな<br>OK:　XXXのようなイメージをしている。</p></blockquote><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>私もまだまだ勉強中の身ですが、教わったこと・学んだことをまとめてみました。<br>気を付けるべき点は会社やプロジェクトによって異なると思いますので、ひとつの参考にしていただければ幸いです。</p><p>最後まで読んでいただきありがとうございました！</p><h1 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h1><p><a href="https://qiita.com/RuyPKG/items/abf72dde739e52364bcf">新人でも、楽がしたい！ ～議事録の準備～</a><br><a href="https://future-architect.github.io/articles/20210327/">議事録をサッと準備する</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。2020年10月入社の江口小夏です。&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の5日目です。&lt;/p&gt;
&lt;p&gt;新入社員の皆様、入社おめでとうございます！🌸&lt;/p&gt;
&lt;p&gt;私は入社して約半年が経ちましたが、配属当初最</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="議事録" scheme="https://future-architect.github.io/tags/%E8%AD%B0%E4%BA%8B%E9%8C%B2/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
  </entry>
  
  <entry>
    <title>GUI GitツールのRebase, Cherry pick</title>
    <link href="https://future-architect.github.io/articles/20210420b/"/>
    <id>https://future-architect.github.io/articles/20210420b/</id>
    <published>2021-04-19T15:00:00.000Z</published>
    <updated>2021-04-20T01:28:50.505Z</updated>
    
    <content type="html"><![CDATA[<p>Gitを使っての開発で、指定のツールや好みのGitクライアントを使っていると思います。</p><p>ターミナルの黒画面でGitコマンドを使うのはちょっと不安、GUI画面から画面を確認しながらGitを操作したい方向けの記事です。</p><p>GitのBranch作成やCheckout, Commit, Pushまで使えた方向けに、次の段階としてRebase, Cherry Pickなどの実行方法を説明します。</p><h2 id="紹介するツール"><a href="#紹介するツール" class="headerlink" title="紹介するツール"></a>紹介するツール</h2><ul><li><a href="https://www.sourcetreeapp.com/">Sourcetree</a></li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a> with <a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">Git Graphプラグイン</a></li><li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></li></ul><h2 id="Git操作イメージ"><a href="#Git操作イメージ" class="headerlink" title="Git操作イメージ"></a>Git操作イメージ</h2><p>説明にあたりGitツリーが以下の状態であることを前提としています。<br><code>feature</code> ブランチは個人の開発ブランチです。<code>master</code> ブランチは状況により <code>develop</code> ブランチなどに適宜読みかえください。</p><h3 id="初期状態"><a href="#初期状態" class="headerlink" title="初期状態"></a>初期状態</h3><p><img src="/images/20210420b/commit_base.png"></p><h3 id="masterブランチへRebase"><a href="#masterブランチへRebase" class="headerlink" title="masterブランチへRebase"></a>masterブランチへRebase</h3><p><code>git rebase master</code> に相当<br><img src="/images/20210420b/commit_rebase_master.png"></p><h3 id="コミットをまとめる-Squash"><a href="#コミットをまとめる-Squash" class="headerlink" title="コミットをまとめる(Squash)"></a>コミットをまとめる(Squash)</h3><p><code>git rebase -i</code> に相当<br><img src="/images/20210420b/commit_rebase_squash.png"></p><h3 id="別ブランチのコミットを持ってくる-Cherry-pick"><a href="#別ブランチのコミットを持ってくる-Cherry-pick" class="headerlink" title="別ブランチのコミットを持ってくる(Cherry-pick)"></a>別ブランチのコミットを持ってくる(Cherry-pick)</h3><p><code>git cherry-pick</code> に相当<br><img src="/images/20210420b/2021-03-26-16-34-37.png"></p><h2 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h2><h3 id="masterブランチへRebase-1"><a href="#masterブランチへRebase-1" class="headerlink" title="masterブランチへRebase"></a>masterブランチへRebase</h3><ol><li>リベースしたい元(featureブランチ)をチェックアウト</li><li>リベースしたい先(masterブランチ)で右クリックし、「リベース…」を選択</li><li>「リベースの確認」ダイアログが立ち上がり、「OK」をクリック</li><li>featureブランチがmasterブランチから生えていることを確認<br><img src="/images/20210420b/sourcetree_rebase_master.gif"></li></ol><h3 id="コミットをまとめる-Squash-1"><a href="#コミットをまとめる-Squash-1" class="headerlink" title="コミットをまとめる(Squash)"></a>コミットをまとめる(Squash)</h3><ol><li>リベースしたいブランチ(featureブランチ)をチェックアウト</li><li>まとめたいコミットの1つ前のコミット(今回はmaster Bコミット)を右クリック</li><li>右クリックメニューから「xxxxの子とインタラクティブなりベースを行う…」を選択、</li><li>リベースダイアログが立ち上がる。1つ目のコミット(feature E)を選択し、「前のコミットとスカッシュ」を選択</li><li>コミットがまとまったことを確認し「メッセージを編集」ボタンをクリック</li><li>コミットメッセージを編集し「OK」ボタンを押し、メッセージが変更されたことを確認</li><li>「OK」ボタンを押してリベースを確定する</li><li>Sourcetree画面に反映されない場合には「F5」を押し更新<br><img src="/images/20210420b/sourcetree_rebase_squash.gif"></li></ol><h3 id="別ブランチのコミットを持ってくる-Cherry-pick-1"><a href="#別ブランチのコミットを持ってくる-Cherry-pick-1" class="headerlink" title="別ブランチのコミットを持ってくる(Cherry-pick)"></a>別ブランチのコミットを持ってくる(Cherry-pick)</h3><ol><li>チェリーピックしたい先(featureブランチ)をチェックアウト</li><li>持ってきたいコミット(今回はmaster Dコミット)を右クリック</li><li>「チェリーピック」を選択</li><li>チェリーピックダイアログが立ち上がる。「OK」を選択</li><li>featureブランチに持ってきたコミットが追加されてることを確認<br><img src="/images/20210420b/sourcetree_cherrypick.gif"></li></ol><h2 id="Visual-Studio-Code-with-Git-Graphプラグイン"><a href="#Visual-Studio-Code-with-Git-Graphプラグイン" class="headerlink" title="Visual Studio Code with Git Graphプラグイン"></a>Visual Studio Code with Git Graphプラグイン</h2><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><ol><li>以下のプラグインをインストール<br> <a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">Git Graph - Visual Studio Marketplace</a></li><li>Git Graph画面を開く<br><img src="/images/20210420b/gitgraph_open.gif"></li></ol><h3 id="masterブランチへRebase-2"><a href="#masterブランチへRebase-2" class="headerlink" title="masterブランチへRebase"></a>masterブランチへRebase</h3><ol><li>リベースしたい元(featureブランチ)をチェックアウト</li><li>リベースしたい先(masterブランチ)で右クリックし、「Rebase current branch on this Commit…」を選択</li><li>ダイアログが立ち上がり、「Yes, rebase」をクリック</li><li>featureブランチがmasterブランチから生えていることを確認<br><img src="/images/20210420b/gitgraph_rebase_master.gif"></li></ol><h3 id="コミットをまとめる-Squash-2"><a href="#コミットをまとめる-Squash-2" class="headerlink" title="コミットをまとめる(Squash)"></a>コミットをまとめる(Squash)</h3><p><a href="https://github.com/mhutchie/vscode-git-graph/issues/410">Issue</a>が上がっているが、GUI単独では現時点でできない。<br>リベース選択時に「Launch Interactive Rebase in new Terminal」を選択することにより一部CUIを併用することで実現可能。</p><h3 id="別ブランチのコミットを持ってくる-Cherry-pick-2"><a href="#別ブランチのコミットを持ってくる-Cherry-pick-2" class="headerlink" title="別ブランチのコミットを持ってくる(Cherry-pick)"></a>別ブランチのコミットを持ってくる(Cherry-pick)</h3><ol><li>チェリーピックしたい先(featureブランチ)をチェックアウト</li><li>持ってきたいコミット(今回はmaster Dコミット)を右クリック</li><li>「Cherry Pick…」を選択</li><li>ダイアログが立ち上がり、「Yes, cherry pick」を選択</li><li>featureブランチに持ってきたコミットが追加されてることを確認<br><img src="/images/20210420b/gitgraph_cherrypick.gif"></li></ol><h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><h3 id="事前準備-1"><a href="#事前準備-1" class="headerlink" title="事前準備"></a>事前準備</h3><p>「View」メニューから「Tool Windows」⇒「Git」と選択しGitの画面を表示する<br><img src="/images/20210420b/intellij_open.gif"></p><h3 id="masterブランチへRebase-3"><a href="#masterブランチへRebase-3" class="headerlink" title="masterブランチへRebase"></a>masterブランチへRebase</h3><ol><li>リベースしたい元(featureブランチ)をチェックアウト</li><li>左のブランチ一覧からリベースしたい先(masterブランチ)で右クリックし、「Rebase Current onto Selected」を選択</li><li>featureブランチがmasterブランチから生えていることを確認<br><img src="/images/20210420b/intellij_rebase_master.gif"></li></ol><h3 id="コミットをまとめる-Squash-3"><a href="#コミットをまとめる-Squash-3" class="headerlink" title="コミットをまとめる(Squash)"></a>コミットをまとめる(Squash)</h3><ol><li>リベースしたいブランチ(featureブランチ)をチェックアウト</li><li>まとめたいコミットの最初(今回はmaster Cコミット)を右クリック</li><li>右クリックメニューから「Interactively Rebase from Here…」を選択、</li><li>リベースダイアログが立ち上がる。1つ目のコミット(feature E)を選択し、「Squash」を選択</li><li>コミットメッセージを編集しエディタ外をクリックし、メッセージが変更されたことを確認</li><li>「Start Rebasing」ボタンを押してリベースを確定する</li><li>コミットがまとまったことを確認<br><img src="/images/20210420b/intellij_rebase_squash.gif"></li></ol><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>私は普段IntelliJのGo言語特化版のGolandで開発をメインに行ってます。</p><p>本記事は、開発メンバがGitの使い方に苦労しているのを見たり、相談が来て生まれました。できるだけ視覚的に理解できるよう、記事を書いたつもりです。</p><p>本記事を通し、少しでもGitの操作の苦手意識を減らし、理解を深めることができたら幸いです。(この記事を書くにあたり<code>git reflog</code>コマンドが非常に役立ちました。)</p><p>紹介したツールや実行方法は一例です。</p><p>自分にあったツールやコマンドを使い、良いGitライフを！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gitを使っての開発で、指定のツールや好みのGitクライアントを使っていると思います。&lt;/p&gt;
&lt;p&gt;ターミナルの黒画面でGitコマンドを使うのはちょっと不安、GUI画面から画面を確認しながらGitを操作したい方向けの記事です。&lt;/p&gt;
&lt;p&gt;GitのBranch作成やCh</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="VSCode" scheme="https://future-architect.github.io/tags/VSCode/"/>
    
    <category term="Git" scheme="https://future-architect.github.io/tags/Git/"/>
    
    <category term="IntelliJ" scheme="https://future-architect.github.io/tags/IntelliJ/"/>
    
    <category term="SourceTree" scheme="https://future-architect.github.io/tags/SourceTree/"/>
    
  </entry>
  
  <entry>
    <title>IT初学者がカラムナデータベースを勉強してみた</title>
    <link href="https://future-architect.github.io/articles/20210419b/"/>
    <id>https://future-architect.github.io/articles/20210419b/</id>
    <published>2021-04-18T15:00:01.000Z</published>
    <updated>2021-04-18T06:23:02.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。2020年4月に入社した牛尾です。<a href="/articles/20210414a/">春の入門連載2021</a>の4日目です。</p><p>私はITについては初学者の状態で入社しました。フューチャーの同期社員や、OJTでご指導くださった先輩社員の技術への知見の深さや広さ、また社会人としての諸々の能力の高さにただただ尊敬する毎日です。</p><p>IT初学者の私が入社してから1年間学んできたIT分野のなかで、特に楽しかった技術を抜粋してご紹介します。</p><p>私のようにIT初学者で、エンジニア、ITコンサルタントを志望している皆さんの楽しい社会人生活のキャリアを描く一助となれたら嬉しく思います！</p><h1 id="紹介するトピック"><a href="#紹介するトピック" class="headerlink" title="紹介するトピック"></a>紹介するトピック</h1><p>本記事では <strong>カラムナデータベース</strong> を紹介いたします。</p><p>私は入社してから初めてデータベースを学び、研修当初は一般的な <strong>リレーショナルデータベース</strong> を学んできましたが、今は <strong>カラムナデータベース</strong> やKVSデータベースなど勉強しています。</p><p>IT初学者の自分が学んで楽しかった内容の紹介です。もし、技術への知見の深い方はこちらの記事などを参照してもらえればです。</p><blockquote><ul><li><a href="/articles/20190821/">システム開発で得たRedis利用ノウハウ</a></li><li><a href="/articles/20190718/">— 脱RDB脳 — Cassandraのデータモデルについて考えてみる</a></li><li><a href="/articles/20210412a/">KVSと二年間向き合って得たナレッジを還元する時がきた</a></li><li><a href="/articles/20190625/">Amazon Redshiftの仕様を調べてみた</a></li></ul></blockquote><h2 id="データベースとは"><a href="#データベースとは" class="headerlink" title="データベースとは"></a>データベースとは</h2><p>定義づけを確認すると、Oracleのサイトでは以下のように書かれています。</p><blockquote><p><strong>「データベースとは、構造化した情報またはデータの組織的な集合」</strong><br><a href="https://www.oracle.com/jp/database/what-is-database/">https://www.oracle.com/jp/database/what-is-database/</a></p></blockquote><p>前述したとおり自分が入社して初めて学んだのはリレーショナルデータベースでした。ここでは細かい部分のリレーショナルデータベースの説明を省略させていただきます。SQLやデータ設計については、当ブログでも参考になる記事がありますので参考ください。</p><blockquote><ul><li><a href="/articles/20210416b/">(新卒で役にたつ！)SQL小技集</a></li><li><a href="/articles/20210215/">登が教えるSQL基礎</a></li><li><a href="/articles/20200616/">レシートで学ぶデータモデリング入門</a></li></ul></blockquote><h2 id="カラムナデータベース"><a href="#カラムナデータベース" class="headerlink" title="カラムナデータベース"></a>カラムナデータベース</h2><p>通常のOracle、Postgre、MySQLなどの<strong>リレーショナルデータベースでは、データを 行(レコード)単位で扱っているのに対して、カラムナデータベースではデータを列(カラム)方向</strong>で扱います。</p><p>例えば、とあるアパレル店での日付ごとに営業担当者の販売実績などを管理していたとして、列方向と行方向でのデータの扱い方は以下のようになります。</p><p><img src="/images/20210419b/%E8%A1%8C%E3%81%A8%E5%88%97%E3%83%87%E3%83%BC%E3%82%BF.jpg"></p><ul><li><strong>行方向</strong> : 日付、支店、営業担当者等をセットとして、 <strong>1行でデータを扱う</strong></li><li><strong>列方向</strong> : 日付データ、支店データなどの項目ごとに、 <strong>1列でデータを扱う</strong></li></ul><h2 id="カラムナデータベースのメリット①"><a href="#カラムナデータベースのメリット①" class="headerlink" title="カラムナデータベースのメリット①"></a>カラムナデータベースのメリット①</h2><p>カラムナデータベースの1つ目のメリットは <strong>データの圧縮効率がよくなる</strong> ことです。</p><p>データの圧縮効率がよくなるというのはデータを列方向に保持していると<strong>データの定義情報や、値が同一のデータを格納しているので圧縮効率をあげやすいため</strong>です。</p><p>先ほどのアパレル店での表データの例を見ていきましょう。</p><h3 id="a-行方向-リレーショナルデータベース"><a href="#a-行方向-リレーショナルデータベース" class="headerlink" title="a) 行方向(リレーショナルデータベース)"></a>a) 行方向(リレーショナルデータベース)</h3><p>データは全て一意になるように格納されています。(一意にデータを格納することでデータ整合性を保証できるなどは大きなメリットです。)</p><p>日付、支店、担当者などをキーとして1行のデータが <strong>完全一致していない別々のデータ</strong>なので、カラムナデータベースと比較したときに、<strong>データの圧縮はしづらい</strong>という特徴があるのです 。</p><p><strong>リレーショナルデータベースの場合でも</strong>ストレージコストの削減やディスクI/Oを減らすことによるパフォーマンスの向上を目的として<strong>データの圧縮を実施する場合は多々あります</strong>。OracleではOLTP表圧縮などの圧縮機能が用意されているので、興味のある方は<a href="https://www.oracle.com/jp/a/tech/docs/technical-resources/0315-1100-compression.pdf">こちら</a>を参照してみてください。</p><p><img src="/images/20210419b/%E8%A1%8C%E6%96%B9%E5%90%91%E3%83%87%E3%83%BC%E3%82%BF.jpg"></p><h3 id="b-列方向-カラムナデータベース"><a href="#b-列方向-カラムナデータベース" class="headerlink" title="b) 列方向(カラムナデータベース)"></a>b) 列方向(カラムナデータベース)</h3><p>列データの値を見てみると、<strong>「支店」は全て大阪の値</strong>、<strong>「商品カテゴリ」は紳士服と婦人服</strong>であったりと<strong>重複</strong> が見られます。</p><p>データを圧縮するときに「大阪5」などで表せば <strong>効率的にデータを圧縮</strong> できる気が直感的にするのではないでしょうか。(実際の圧縮はそのように単純にはおこなっていませんが、今回は分かりやすくするために、そのような表現をしました)</p><p><img src="/images/20210419b/%E3%82%AB%E3%83%A9%E3%83%A0%E6%96%B9%E5%90%91%E3%83%87%E3%83%BC%E3%82%BF.jpg"></p><h2 id="カラムナデータベースのメリット②"><a href="#カラムナデータベースのメリット②" class="headerlink" title="カラムナデータベースのメリット②"></a>カラムナデータベースのメリット②</h2><p>2つ目のメリットは <strong>大量のデータに対してのアドホックな分析処理が高速になる</strong> (OLAP実装を得意とする)ことです。</p><p>先ほどの表データを例に行方向と列方向のデータベースの場合を見ていきましょう。</p><p>例えば、支店が「大阪」の販売金額の合計を集計したいとします。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(販売金額) <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 支店 = <span class="string">&#x27;大阪&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="a-行方向-リレーショナルデータベース-1"><a href="#a-行方向-リレーショナルデータベース-1" class="headerlink" title="a) 行方向(リレーショナルデータベース)"></a>a) 行方向(リレーショナルデータベース)</h3><p>行方向のデータベースでは行全体にアクセスをして、「支店」項目が大阪かを判別した後に「販売金額」の列データを抜き出してきます。先頭の行から順にアクセスをしているので、その分　<strong>「日付」や「営業担当者」等の必要のない項目にもアクセス</strong>　をしています。</p><p><img src="/images/20210419b/%E8%A1%8C%E6%96%B9%E5%90%91%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9.jpg"></p><h3 id="b-列方向-カラムナデータベース-1"><a href="#b-列方向-カラムナデータベース-1" class="headerlink" title="b) 列方向(カラムナデータベース)"></a>b) 列方向(カラムナデータベース)</h3><p>列方向では、 <strong>必要のある「支店」「販売金額」の項目のみにアクセスをする</strong> ことで、必要最小限のディスクI/Oが実現できます。</p><p>データベースの処理速度が遅くなる原因は <strong>ディスクI/O</strong> が増加することなので(ディスクの処理速度が遅いため)不要なアクセスを避けることで <strong>処理が高速</strong> になります。</p><p><img src="/images/20210419b/%E5%88%97%E6%96%B9%E5%90%91%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9.jpg"></p><h2 id="カラムナデータベースのデメリット"><a href="#カラムナデータベースのデメリット" class="headerlink" title="カラムナデータベースのデメリット"></a>カラムナデータベースのデメリット</h2><p>今までカラムナデータベースのメリットをみてきましたが、<strong>OLTPの実装には向かない</strong> という特徴が存在します。<br>データの圧縮、展開で <strong>オーバーヘッドが発生</strong> するので、データの新規追加、更新、削除などの<strong>トランザクション処理は苦手</strong> です。</p><p>例えば、先ほどの表データに1行データを追加したいとします。行方向のデータベースでは、行データをまとめて追加すればよいですが、列方向の場合は、圧縮したデータを一度展開して、各列項目を読み込んで追加したうえで、再度圧縮してあげるという処理が発生します。</p><p><img src="/images/20210419b/%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%B1%95%E9%96%8B%E5%9C%A7%E7%B8%AE.jpg"></p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>ここでは紹介しきれませんでしたが、データベースにはまだまだKVS型やXML型、JSON型、NoSQLなど色々な種類があります。データベース以外にも機会学習でCNNを簡易ながらも作ってみたり、暗号技術を勉強したりする日々はとても楽しいです。</p><p>これからも多くの技術書を業務内外で読みふけり、全力でITを楽しもうと思います。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>以下他サイトでの参照記事です。興味のある方は参照してみてください。</p><ul><li><a href="https://www.techcrowd.jp/nosql/column/">https://www.techcrowd.jp/nosql/column/</a></li><li><a href="https://www.slideshare.net/InsightTechnology/c31hirama">https://www.slideshare.net/InsightTechnology/c31hirama</a></li><li><a href="https://www.publickey1.jp/blog/11/post_175.html">https://www.publickey1.jp/blog/11/post_175.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。2020年4月に入社した牛尾です。&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載20</summary>
      
    
    
    
    <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
    <category term="DB" scheme="https://future-architect.github.io/tags/DB/"/>
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
    <category term="カラムナ型DB" scheme="https://future-architect.github.io/tags/%E3%82%AB%E3%83%A9%E3%83%A0%E3%83%8A%E5%9E%8BDB/"/>
    
  </entry>
  
  <entry>
    <title>ブラサカ活動報告~ストーンフリープロジェクト編~</title>
    <link href="https://future-architect.github.io/articles/20210419a/"/>
    <id>https://future-architect.github.io/articles/20210419a/</id>
    <published>2021-04-18T15:00:00.000Z</published>
    <updated>2021-04-18T05:43:38.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。ブラサカチームの中井です。</p><p>Tokyo2020のブラインドサッカーチームでVRを駆使したフィットネスアプリを制作しました。活動・成果を報告します。</p><h2 id="フューチャーのTokyo2020チームとは？"><a href="#フューチャーのTokyo2020チームとは？" class="headerlink" title="フューチャーのTokyo2020チームとは？"></a>フューチャーのTokyo2020チームとは？</h2><p>「東京2020大会に向けてテクノロジーとアイデアでFuture Group発の価値を作る」という目的のもと、若手メンバが中心となり主に以下４つの非営利活動を行っている有志です。</p><blockquote><ol><li>ブラインドサッカーVR体験</li><li>晴海選手村地区開発</li><li>キッズ企画（アイデアソン・ハッカソン）</li><li>ラグビー観戦</li></ol></blockquote><p>私たちブラインドサッカーチームは、①の<a href="https://www.fif.jp/kidsyouth/report/olypara2019.html">ブラインドサッカーVR体験</a>を行っています。</p><p>主な活動として…</p><blockquote><ul><li>ブラインドサッカーを疑似体験できるアプリの開発・提供</li><li>ブラインドサッカーの認知度を上げるためのIT施策の検討・立案</li><li>小学校に向けたスポ育事業</li></ul></blockquote><p>を行っています。</p><p>Tokyo2020の過去の活動を以下記事で紹介しています。興味のある方はぜひご覧ください。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="/articles/20190925/index.html" data-iframely-url="//cdn.iframe.ly/KtSwerZ?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><p>また、昨年は小学生向けのスポーツ教育の推進も行い、品川区立日野学園にて実施したブラインドサッカーの体験授業が、文部科学省「青少年の体験活動推進企業表彰」奨励賞を受賞しました！</p><ul><li><a href="https://www.fif.jp/MEXTCSRaward_release_210312.pdf">フューチャーのＣＳＲ事業 フューチャー イノベーション フォーラム（ＦＩＦ） 文部科学省 「青少年の体験活動推進企業表彰」 ２年連続受賞</a></li></ul><p>このように日々活動領域を広げながら活動をしています。</p><h2 id="ストーンフリープロジェクトの発足"><a href="#ストーンフリープロジェクトの発足" class="headerlink" title="ストーンフリープロジェクトの発足"></a>ストーンフリープロジェクトの発足</h2><p>2020年までは上述の通り盛んに活動していました。しかし、新型コロナウイルスの影響で今まで通り活動ができない状況。コロナ渦で何かできることはないか、VRを活かして状況を少しでも変えることができないか、チーム内で議論を重ねました。</p><p>「以前よりもジムに行きづらくなった」、「リモートワークにより通勤が無くなり、運動不足となっている」という意見が多数でたことから、 <strong>VR×フィットネス</strong> というテーマでアプリを制作することにしました。</p><br><p>題して、『<strong>ストーンフリープロジェクト</strong>』。</p><br><p>このプロジェクトの行く末はどうなるのか、果たしてチームメンバの運動不足は解消されるのでしょうか….</p><p>（※ストーンフリーは『ジョジョの奇妙な冒険』第6部に出てくるスタンド名が由来となっています。第6部の刑務所から脱獄するストーリーから、コロナの困難な状況から脱出することを祈り、命名しました。）</p><h2 id="VR×フィットネス"><a href="#VR×フィットネス" class="headerlink" title="VR×フィットネス"></a>VR×フィットネス</h2><p>ブラサカチームの渡辺です。VRフィットネスの現状と、私たちのチームの『ストーンフリープロジェクト』での取り組みを紹介します。</p><h2 id="VRフィットネスの現状"><a href="#VRフィットネスの現状" class="headerlink" title="VRフィットネスの現状"></a>VRフィットネスの現状</h2><p>近年一般に普及したVRシステムが有する、ヘッドマウントディスプレイ：HMD（頭部）やコントローラー・トラッカー（手）の位置・姿勢計測を利用して、リズムゲームやスポーツなど体全体を動かすタイトルが多数リリースされています。その運動量の大きさから、VRゲームはしばしばフィットネス効果が注目され、さらにVRとゲームの親和性から、遊びながら体を動かせるという有効性を生み出しています。</p><p>Oculus Questでは、各タイトル毎に消費カロリーなどが可視化されるOculus Move<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>がリリースされ、プラットフォームの開発も進んでいます。一方、主にトレーニングジムでの利用を意識して、本格的なフィットネスマシンと組み合わせたVRシステムも開発されています<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><p>ICAROSでは、四つん這いでマシンに乗り、体感トレーニングを行いながら鳥のように空を飛ぶ体験ができます。またVRボートトレーニングでは、ローイング（ボート漕ぎ運動）マシンを用いて、様々な環境でのボート漕ぎが体験できます。</p><p>これらのフィットネス器具を用いたシステムは、フィットネス効率向上だけでなく、ICAROSの乗り物（モーションプラットフォーム）による移動感覚提示や、ローイングマシンによるハプティック（力触覚）フィードバックといった、VR体験としての臨場感向上というメリットがあります。</p><p>しかし、大型マシンであるが故に設置面積が大きく、一般的に高価なため、家庭で楽しむハードルは高いと言わざるを得ません。また、ジムで使用されるフィットネスマシンは、特定のフィットネス用途に特化されており、これ一つで様々な種類の運動ができないという点で、汎用性の無さがデメリットであると考えられます。</p><p><img src="/images/20210419a/img2.jpg"><br> ICAROS　　　　　　　　　　　　　　　VRボートトレーニング</p><h2 id="VRTuber"><a href="#VRTuber" class="headerlink" title="VRTuber"></a>VRTuber</h2><p>そこで私たちのチームは、</p><blockquote><ul><li>遊びながら、フィットネス効果を生み出す</li><li>家庭でも、気軽に運動を楽しめる</li><li>フィットネス器具により、効率的でまた汎用的な運動を可能とする</li><li>フィットネス器具によるハプティックフィードバックなどを生かし、VRフィットネスゲームとしての体験をより楽しいものとする</li></ul></blockquote><p>…というポイントを満たすVR×フィットネスとして、 <strong>VRTuber（VR×Tube）</strong> の開発を行いました。</p><p><img src="/images/20210419a/img3.jpg"></p><p>チューブを用いたトレーニング方法は多岐にわたり、かつ安価で収納も容易です。今回はVRTuberの第一弾として、ローイングをトリガーにしたシューティングゲームの開発を行いました。</p><p>使用した機材はOculus Quest<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>、手首に装着できるリストバンド付きチューブ<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>です。チューブを装着しながらOculus Touch（コントローラー）を持てるようにすることで、Oculus Touchの位置計測を利用して、ユーザが行うローイングを検出します。</p><p>HMDに表示する映像はUnityで作成しました。弾を打つ方向はOculus Touchのスティックで変更可能で、ローイングにより放った弾によりボクセルアニマルを倒す事ができます。ユーザのHPや、ボクセルアニマルの出現頻度・速度といったパラメータは変更可能です。</p><p><img src="/images/20210419a/VRTuber2.gif"></p><p>このゲームを体験した主観的感想としては、ゲームとしてはそれなりに楽しめましたが、ローイングで弾を打つことについては、コントローラーのボタン同様ある種の約束事（例：×ボタンを押すと銃を打つ）の存在は拭えませんでした。</p><p>この点からも、チューブによるハプティックフィードバックを、Virtual Worldからの自然なフィードバックとして利用できているとは言い難いです。</p><p>今回はチューブトレーニングによる動きをトリガーにして、まずゲームを作ってみようということで作成しましたが、正しいコンテンツ選択と作りこみをすることで、チューブによるハプティックフィードバックも十分に生かし、よりリアルな体験が可能と考えています。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>このようにブラサカチームでは、2020年を過ぎた現在も活動を行っています。</p><p>少しでも私たちの活動を面白いと思っていただけた方は、<a href="https://www.future.co.jp/contact_us/">お問い合わせ</a> か<a href="https://twitter.com/future_techblog">Twitter</a>にて、ぜひご連絡ください。</p><p>お待ちしています！！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Oculus Move: <a href="https://www.youtube.com/watch?v=qiL4HvldAec">Oculus Move: VR Fitness Tracking | Oculus - Youtube</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">funandbody: <a href="http://www.funandbody.com/">http://www.funandbody.com/</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Oculus Quest2: <a href="https://www.oculus.com/quest-2/">https://www.oculus.com/quest-2/</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">チューブ: <a href="https://www.amazon.co.jp/-/en/Training-Fitness-Exercise-Dieting-Strength/dp/B01EYFSNLE">https://www.amazon.co.jp/-/en/Training-Fitness-Exercise-Dieting-Strength/dp/B01EYFSNLE</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは。ブラサカチームの中井です。&lt;/p&gt;
&lt;p&gt;Tokyo2020のブラインドサッカーチームでVRを駆使したフィットネ</summary>
      
    
    
    
    <category term="VR" scheme="https://future-architect.github.io/categories/VR/"/>
    
    
    <category term="Unity" scheme="https://future-architect.github.io/tags/Unity/"/>
    
    <category term="活動報告" scheme="https://future-architect.github.io/tags/%E6%B4%BB%E5%8B%95%E5%A0%B1%E5%91%8A/"/>
    
    <category term="スポーツ×IT" scheme="https://future-architect.github.io/tags/%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%84%C3%97IT/"/>
    
    <category term="VR" scheme="https://future-architect.github.io/tags/VR/"/>
    
    <category term="フィットネス" scheme="https://future-architect.github.io/tags/%E3%83%95%E3%82%A3%E3%83%83%E3%83%88%E3%83%8D%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>(新卒で役にたつ！)SQL小技集</title>
    <link href="https://future-architect.github.io/articles/20210416b/"/>
    <id>https://future-architect.github.io/articles/20210416b/</id>
    <published>2021-04-15T15:00:01.000Z</published>
    <updated>2021-04-16T02:54:29.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><img src="/images/20210416b/top.jpg"><p>Photo taken by <a href="https://twitter.com/kaedemalu">@kaedemalu</a></p><p><a href="/articles/20210414a/">春の入門連載2021</a>の3日目です。</p><p>今回は業界歴の比較的浅い方々をターゲットに、覚えておくと現場で役立ちそうなSQLの小技をいくつか紹介したいと思います。</p><p>知らなくても困らないけど、知っているとちょっと仕事を効率化できそうなもの、考え方に触れれば比較的簡単に応用ができそうなものをピックアップしてみました。</p><p>紹介しているサンプルはPostgreSQLを前提とした記述しています。多少構文が異なるケースはあるものの、どのプロダクトでも同様の事ができます。</p><h2 id="メタデータの利用"><a href="#メタデータの利用" class="headerlink" title="メタデータの利用"></a>メタデータの利用</h2><p>一般的にデータベースは、内部でオブジェクト(テーブル、インデックス、ストアドプログラムなど)をはじめとしたデータベース構成要素の定義情報を持っており、それらは「メタデータ」や「ディクショナリ」と呼ばれています。条件付きではありますが、データベース内で発生した「出来事」の情報も保持しています。</p><p>メタデータを上手くを活用すると、例えば簡単なケースでは、後述するような環境のクリーニング(全テーブルのデータを一括削除)であったり、テーブルのレコード件数の確認だったりといった、日常のちょっとした機械的な作業の手数を減らす事ができます。</p><p>その他にも、「〇〇カラムってどのテーブルで持ってたんだっけ」といった、設計ドキュメントを見れば分かるけれど、それを探して開くのが面倒くさいような、ちょっとした調べ事をSQLの発行で代替できます。</p><p>応用性が非常に高い領域ですので、まずは簡単な事から初めつつ、引き出しを増やしていってみてください。</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><strong>特定環境の全テーブルを削除するSQLをSQLで作成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">&#x27;TRUNCATE TABLE &#x27;</span> || table_schema || <span class="string">&#x27;.&#x27;</span> || table_name || <span class="string">&#x27;;&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.tables   <span class="comment">/* Oracleの場合はDBA_TABLES、USER_TABLESなど、プロダクトに応じて変えてください */</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_schema = <span class="string">&#x27;sample&#x27;</span> <span class="comment">/* 対象スキーマを限定するなど、状況に応じて指定してください */</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><strong>特定文字を含むカラム名を持つテーブルの調査</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    table_name,</span><br><span class="line">    column_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.columns</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%uriage%&#x27;</span> <span class="comment">/* 「uriage(売上)」という文字が含まれる */</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="SELECT句のみSQL"><a href="#SELECT句のみSQL" class="headerlink" title="SELECT句のみSQL"></a>SELECT句のみSQL</h2><p>一般的にSELECT文はFROM句とセットで記述すると習うのではないかと思います。<br>しかしながら、PostgreSQLなどのDBプロダクトではFROM句のないSELECT文が構文として許容されています(OracleなどはNGです)。</p><p>「FROM句のないSELECT文を書くケースなんてあるのか？」という疑問を抱かれるでしょうが、初めて利用する関数の挙動確認などを行う場合など、デバッグやカジュアルな検証を行う際に便利です。わざわざテストテーブルを作成し、テスト用ダミーデータを入れてといった手間を省く事ができます。</p><h3 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h3><p><strong>SQL版Hello World!</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Oracleの場合はFROM句省略は不可ですが、DUAL表(1カラムだけ定義され、1レコードだけ入っているビルドインのテーブル)</span></span><br><span class="line"><span class="comment"> を利用すれば同様の事が実施可能 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Hello World!&#x27;</span> <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p><strong>組み込み関数の挙動確認</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 「 UPPER(小文字を大文字に変換して返す))」なる関数が便利そうだが、想定する結果を返してくれるか？ */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UPPER</span>(<span class="string">&#x27;AbCdE&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文字列型 → 日付型への型変換で指定するフォーマットは合っているだろうか？ */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TO_DATE</span>(<span class="string">&#x27;2021/04/16&#x27;</span>, <span class="string">&#x27;YYYY/MM/DD&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JOINのコーディング量削減-※限定利用推奨"><a href="#JOINのコーディング量削減-※限定利用推奨" class="headerlink" title="JOINのコーディング量削減 ※限定利用推奨"></a>JOINのコーディング量削減 ※限定利用推奨</h2><p>新人研修などでも「内部結合と外部結合の理解は必須」などと言われるかと思いますが、データベース(RDBMS)を利用する場合、JOINは日常的に書く事になります。</p><p>コピー &amp; ペーストである程度楽できるとはいえ、結合する両テーブルのカラムを指定したり、「=」や「AND」、半角スペースを入れたりと、キーボードを叩く手数は少なくありません。</p><p>システム内でのコーディングスタイルの一貫性が損なわれる可能性がある(ONとUSINGが混在すると)といったような理由のため、アプリケーションに組み込むSQLで利用する事は推奨しませんが、結合するテーブル間で結合キーの物理名が同じ場合には(条件が整っていれば)「USING」句を利用する記述方法で、コーディング量を1/2以下に減らす事ができます。</p><h3 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a><strong>Sample</strong></h3><p><strong>USINGとONの比較</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USING */</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_1</span><br><span class="line">        <span class="keyword">JOIN</span> table_2    <span class="comment">/* 内部結合の場合は「INNER」も省略してしましょう */</span></span><br><span class="line">            <span class="keyword">USING</span> (join_key1, join_key2)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ON */</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_1</span><br><span class="line">        <span class="keyword">JOIN</span> table_2</span><br><span class="line">            <span class="keyword">ON</span>      table_1.join_key1 = table_2.join_key1</span><br><span class="line">                <span class="keyword">AND</span> table_1.join_key2 = table_2.join_key2</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="コメント化-解除ショートカットキー"><a href="#コメント化-解除ショートカットキー" class="headerlink" title="コメント化/解除ショートカットキー"></a>コメント化/解除ショートカットキー</h2><p>SQLに限った話ではないですが、普段利用するツールのショートカットキーを把握しておく事は作業の効率化に繋がります。SQLの場合、ショートカットキーの中でも特に利用頻度が多いのが行単位でコメント化/解除(行の先頭に「– 」を挿入する/消す)を行うものです。</p><p>ツールによって異なりますが、私の知る限りは「Ctrl + /」が割り当てられているケースが多いです。<br>本当によく利用するので知っていると便利です。</p><h3 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a><strong>Sample</strong></h3><p><strong>WHERE句の条件指定を色々と変えながらデータを探す</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">        xxx_month = <span class="string">&#x27;202104&#x27;</span></span><br><span class="line"> <span class="comment">--   AND yyyy_code = &#x27;0001&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>研修や入門書では触れられなさそうな、地味な「小技」を紹介してみました。</p><p>SQLに限らず実施頻度が多い作業はなるべく効率化を検討し、生産性を上げていきましょう。</p><h2 id="関連記事"><a href="#関連記事" class="headerlink" title="関連記事"></a>関連記事</h2><ul><li><a href="/articles/20191121/">「脱Oracle」の背景にある、Oracle Databaseの価値を改めて考える</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;img src=&quot;/images/20210416b/top.jpg&quot;&gt;

&lt;p&gt;Photo taken by &lt;a href=</summary>
      
    
    
    
    <category term="DB" scheme="https://future-architect.github.io/categories/DB/"/>
    
    
    <category term="SQL" scheme="https://future-architect.github.io/tags/SQL/"/>
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>リモートワーク連載：社用機と私用機に同じモニタ3台を使う話</title>
    <link href="https://future-architect.github.io/articles/20210416a/"/>
    <id>https://future-architect.github.io/articles/20210416a/</id>
    <published>2021-04-15T15:00:00.000Z</published>
    <updated>2021-04-16T01:45:26.610Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="/articles/20210118/">リモートワーク連載</a> の第 5 弾です。</p><hr><p>20 年 4 月新卒入社から 1 年が経った SAIG 佐藤です。</p><p>私は入社前後からコロナ禍に襲われ、入社後ずっと自宅から勤務を行っています。</p><p>……これは大学院時代、特に家から一歩も出ずに修論を書いていた頃と何も変わりません。</p><p>就職以来社会人としてのマネーが加わり最近ではどんどん環境が整ってきました。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>私用 PC が置いてある自室で勤務する</li><li>勤務でもプライベートでもモニタを 3 枚使う</li><li>可能な限り配線を <del>減らす</del> <strong>見えなくする</strong></li></ul><h2 id="デスク環境"><a href="#デスク環境" class="headerlink" title="デスク環境"></a>デスク環境</h2><p><img src="/images/20210416a/DSC_0283.JPG"></p><h3 id="配線図"><a href="#配線図" class="headerlink" title="配線図"></a>配線図</h3><p><img src="/images/20210416a/%E3%83%91%E3%83%AF%E3%83%9D%E6%9C%BA%E7%B5%B5_0326.png"></p><h3 id="メインモニタ-LG-24GL600F-B"><a href="#メインモニタ-LG-24GL600F-B" class="headerlink" title="メインモニタ ( LG 24GL600F-B )"></a>メインモニタ ( LG 24GL600F-B )</h3><p>昨今モニタと言えば高解像度よりも高リフレッシュレートが求められています <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.283ex" xmlns="http://www.w3.org/2000/svg" width="4.023ex" height="1.131ex" role="img" focusable="false" viewBox="0 -375 1778 500" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path><path id="MJX-3-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mstyle" transform="scale(0.5)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><use xlink:href="#MJX-3-TEX-N-5B"></use></g><g data-mml-node="mo" transform="translate(278, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="773.5px" font-family="serif">要</text><text data-variant="normal" transform="translate(600, 0) matrix(1 0 0 -1 0 0)" font-size="773.5px" font-family="serif">　</text><text data-variant="normal" transform="translate(1200, 0) matrix(1 0 0 -1 0 0)" font-size="773.5px" font-family="serif">出</text><text data-variant="normal" transform="translate(1800, 0) matrix(1 0 0 -1 0 0)" font-size="773.5px" font-family="serif">　</text><text data-variant="normal" transform="translate(2400, 0) matrix(1 0 0 -1 0 0)" font-size="773.5px" font-family="serif">典</text></g><g data-mml-node="mo" transform="translate(3278, 0)"><use xlink:href="#MJX-3-TEX-N-5D"></use></g></g></g></g></g></svg></mjx-container>。<br>訳：ゲームをするので高リフレッシュレートのモニタを買いました。</p><p>仕事ではただの 24’ モニタです。</p><h3 id="サブモニタ1-HP-E243d"><a href="#サブモニタ1-HP-E243d" class="headerlink" title="サブモニタ1 ( HP E243d )"></a>サブモニタ1 ( HP E243d )</h3><p>モニタとは名ばかり、カメラ内蔵 Thunderbolt3 ドックとしての役割が強いです。</p><p>社用マシンに対して 60 W 給電を行うことで電源ケーブルを一本減らすことができます。代わりに巨大な AC アダプタが足元に置かれることとなりましたが、机の上からはケーブルが減ったので良しとします。<br>このモニタに RJ45 を繋ぐこともできますが、たまに瞬断するのでマシンに直接つないでいます。</p><p>プライベートではただの 24’ モニタです。<br>内臓カメラの映像も USB-C 経由でないと受け取れず、私用マシン用に別のwebカメラを設置しています。</p><h3 id="サブモニタ2-Dell-P2317H-amp-ergotron-LX-45-241-224"><a href="#サブモニタ2-Dell-P2317H-amp-ergotron-LX-45-241-224" class="headerlink" title="サブモニタ2 (Dell P2317H &amp; ergotron LX 45-241-224 )"></a>サブモニタ2 (Dell P2317H &amp; ergotron LX 45-241-224 )</h3><p>視界の端にあるモニタで、凝視はしないが常時表示しておきたいターミナルや pdf の書類を置いておくのに丁度よいです。<br>縦にもできるので、pdfの1ページを丸ごと無駄なく表示することができます。</p><p>プライベートでは tweetdeck が常駐しています。<del>勤務中も特に開くものが無いときは私用マシンから deck が表示されています</del></p><h3 id="KVMスイッチ-サンワサプライ-400-sw032"><a href="#KVMスイッチ-サンワサプライ-400-sw032" class="headerlink" title="KVMスイッチ ( サンワサプライ 400-sw032 )"></a>KVMスイッチ ( サンワサプライ 400-sw032 )</h3><p>V を共有しないので KM スイッチ<br>物理キーではなくてキーボード操作でスイッチできる素晴らしいスイッチです。操作部を手元に置く必要がないので、スイッチ本体ごと配線をモニタの裏に隠すことができます。</p><p>デフォルトで「左 ctrl 2 連打」でスイッチします。頻繁に誤爆するので「ScrLck 2 連打」の方がよいです。<br>ScrLck は ScrLck で、Excel が変な挙動をすると思えば ScrollLock がオンになっていがち。</p><h2 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h2><h3 id="キーボード-Logicool-K740"><a href="#キーボード-Logicool-K740" class="headerlink" title="キーボード ( Logicool K740 )"></a>キーボード ( Logicool K740 )</h3><p>まだ 1 年強ですが既に Enter キーにガタが来ていて、いつひしゃげてもおかしくありません。保証書をどこかへ失くしたため 3 年保証はなかったことになりました。</p><p>そのうち買い替えます。</p><h3 id="マウス-BUFFALO-BSMBU19"><a href="#マウス-BUFFALO-BSMBU19" class="headerlink" title="マウス ( BUFFALO BSMBU19 )"></a>マウス ( BUFFALO BSMBU19 )</h3><p>5 ボタンマウスはいいぞ。</p><p>マウスは消耗品と割り切っているのですが思ったより長持ちしています。</p><h3 id="ゲーミングオフィスチェア-AKRacing-Premium"><a href="#ゲーミングオフィスチェア-AKRacing-Premium" class="headerlink" title="ゲーミングオフィスチェア ( AKRacing Premium )"></a>ゲーミングオフィスチェア ( AKRacing Premium )</h3><p><img src="/images/20210416a/61iHLVP0bKL._AC_SX425_.jpg"></p><p>ゲーミングチェアブランドの最上位機種がオフィスチェアなのでゲーミングオフィスチェア</p><p>リモートが長引く読みで初任給を費やして買いました。大正解です。</p><h2 id="他にほしいもの"><a href="#他にほしいもの" class="headerlink" title="他にほしいもの"></a>他にほしいもの</h2><h3 id="オーディオインターフェース"><a href="#オーディオインターフェース" class="headerlink" title="オーディオインターフェース"></a>オーディオインターフェース</h3><p>私用マシンには Steinberg CI1 を繋いでいますが、社用マシンはうまく繋げられず、未だに内蔵スピーカ（秘匿性の高い会議のときは有線イヤホン）から音声を出しています。<br>うまくミックスして同じヘッドホンから音を出せるようにしたい……。</p><h3 id="マイク"><a href="#マイク" class="headerlink" title="マイク"></a>マイク</h3><p>今使っている Sony ECM-PCV80U はいい加減古い &amp; 入力音量が小さい (らしい) ので、↑と合わせて新調したい</p><h3 id="ホワイトボード"><a href="#ホワイトボード" class="headerlink" title="ホワイトボード"></a>ホワイトボード</h3><p>ほしいけど部屋に置く場所がない</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>いつでも快適な仕事ができるので、デスク周りへの投資は投資対効果がかなり高いです。<br><del>いつでも快適な昼寝ができるよう、</del>次は机の後ろにあるベッドをグレードアップしようと思います。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210118/index.html" data-iframely-url="//cdn.iframe.ly/I5k143p"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;/articles/20210118/&quot;&gt;リモートワーク連載&lt;/a&gt; の第 5 弾です。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;20 年 4 月新卒入社から 1 年が経った SAIG 佐藤です。&lt;/p&gt;
&lt;p&gt;私は入社前後からコロナ禍に襲われ、入社後ずっと自</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>Web会議で意識したい「コミュニケーション環境」をリモート環境アップデートで向上させた話</title>
    <link href="https://future-architect.github.io/articles/20210415b/"/>
    <id>https://future-architect.github.io/articles/20210415b/</id>
    <published>2021-04-14T15:00:01.000Z</published>
    <updated>2021-04-15T04:18:07.968Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIG（テクノロジーイノベーショングループ）の久保です。採用活動などの社外イベントなどでは <strong>#技術も好きだけど業務の方が好き</strong> と掲げているTIGでは珍しいITコンサルタントです。<br><code>注：弊社はITコンサルタント集団なので、IT面でも業務面でもプロのコンサルタント集団ですが「どちらかといえば」業務の方が好きという話です。</code></p><p>本題ですが、2020年、コロナの影響によりリモートワークが推奨され、弊社も第一回目の緊急事態宣言前には完全リモートワークとなっていました。同じように完全リモートワーク。あるいは週の半分以上はリモートワークの方も多いのではないでしょうか。</p><p><a href="/articles/20210118/">リモートワーク連載</a>の4本目は、ワークスタイルがリモートワークとなりデスク周りの環境も変わる中で、 <strong>#技術も好きだけど業務の方が好き</strong> な私が揃えていった設備を本記事で紹介していきます（特別業務特化というわけではないので、技術・業務のどちらが好きでも参考になるかと思います）</p><h1 id="この記事を読んで得られること"><a href="#この記事を読んで得られること" class="headerlink" title="この記事を読んで得られること"></a>この記事を読んで得られること</h1><ul><li>ITコンサルタントのリモートデスク環境例を知ることができる。</li><li>リモート会議をする時に相手が気になるポイントを知ることができる。</li></ul><h1 id="リモートデスク環境を整える上で意識したこと"><a href="#リモートデスク環境を整える上で意識したこと" class="headerlink" title="リモートデスク環境を整える上で意識したこと"></a>リモートデスク環境を整える上で意識したこと</h1><p>リモートワークとなり、私が１番変わったと感じたのはコミュニケーション方法でした。<br>日々の小さな情報共有が「相手の隣に行って声をかける」から「チャットツール」に変わり、チームの意思決定や業務連絡が「会議室」から「Web会議」に変わりました。</p><p>↓イメージ図↓<br><img src="/images/20210415b/image.png"></p><p>この変化の大きな特徴は、相手の顔やリアクションから感情を感じにくくなったことではないでしょうか。</p><p>コロナ前は、相手の表情から言葉の裏ではどんなことを考えているのか想像したり、雰囲気から意思を理解したりすることができました。また、聞きたい・伝えたいことがあればすぐに伝えることもできました。</p><p>しかし、リモートになったことで以前までは当たり前だった「相手の表情や雰囲気を読み取ること」「問い合わせに対する回答の迅速さ」が難しくなりました。</p><p>リモートワークが当たり前になるにつれ、私がそう思うのであれば相手も同じことを思っているのではないか。という私の中での懸念が日々大きくなり、私は相手に<strong>自身の表情や機微が見えるようにしよう</strong>また<strong>できるだけオフラインと同じ状況を作ろう</strong>意識してデスク周りを整えて行きました。</p><h1 id="構築したリモートデスク環境の説明"><a href="#構築したリモートデスク環境の説明" class="headerlink" title="構築したリモートデスク環境の説明"></a>構築したリモートデスク環境の説明</h1><p>「<strong>自身の表情や機微が見えるようにしよう</strong>」「<strong>できるだけオフラインと同じ状況を作ろう</strong>」の考えから、具体的には以下のポイントでデスク周りを整えて行きました。</p><ul><li>私自身の表情や感情が伝わる・見える環境</li><li>コミュニケーションを取りやすくする</li></ul><p>上記２点を意識して整えたデスク環境を説明していきます。</p><h2 id="環境概要"><a href="#環境概要" class="headerlink" title="環境概要"></a>環境概要</h2><p>下の写真は、私のデスクトップ周りになります。<br><img src="/images/20210415b/image_2.png"></p><p>デスクに置いていある機材（PCは除く）</p><ul><li>ディスプレイ</li><li>ディスプレイアーム</li><li>ウェブカメラ</li><li>リングライト</li><li>タブレットアーム</li><li>タブレット（iPad）</li><li>PCスタンド【番外編】</li><li>アーモンド【番外編】</li></ul><h2 id="機材とアップデート順番"><a href="#機材とアップデート順番" class="headerlink" title="機材とアップデート順番"></a>機材とアップデート順番</h2><p>デスク周りに追加していった機材を購入順に紹介していきます。</p><h3 id="【購入順１】ディスプレイ（本記事の議題「意識したこと」とは関係ないです）"><a href="#【購入順１】ディスプレイ（本記事の議題「意識したこと」とは関係ないです）" class="headerlink" title="【購入順１】ディスプレイ（本記事の議題「意識したこと」とは関係ないです）"></a>【購入順１】ディスプレイ（本記事の議題「意識したこと」とは関係ないです）</h3><p>最初から申し訳ないのですが、「意識したこと」とは関係ないですがリモート環境下になり一番最初に購入しました。ディスプレイがあると作業と参照が同時にできる（厳密には１画面内でウィンドウ分割するので3~4ワークできる）ので、会社では使っていたけど家には無い人はぜひ購入を検討してみてください。Macの場合は画面切り替え・ウィンドウ切り替えが高性能ですが、やはり素のディスプレイ利用には敵わないと個人的には思っています。</p><h3 id="【購入順2-3】ディスプレイアーム＆ウェブカメラ"><a href="#【購入順2-3】ディスプレイアーム＆ウェブカメラ" class="headerlink" title="【購入順2,3】ディスプレイアーム＆ウェブカメラ"></a>【購入順2,3】ディスプレイアーム＆ウェブカメラ</h3><p><img src="/images/20210415b/image_3.png"><br><strong>購入目的</strong></p><ul><li>Web会議で相手と目を合わせたい。<ul><li>Web会議中はディスプレイを見て会話することが多いため、PCの純正カメラだと相手と目が合わない。ウェブカメラとディスプレイの位置を高くするディスプレイアームで視点の高さを実現。</li></ul></li><li>Web会議で自分の顔だけでなく広く見せたい。<ul><li>PCの純正カメラだと画角が狭いので、ほとんど顔しか写らない。雰囲気も感じて欲しいので画角の広いカメラにした。</li></ul></li></ul><p>PC内蔵カメラとウェブカメラの見え方の違いをイメージにしました。<br><img src="/images/20210415b/image_4.png"><br>PC内蔵カメラの場合、ディスプレイに資料を投影している方は会議の相手に目線が合いません。一方でウェブカメラの場合は目線を合わせることができる上に、見える範囲が大きく違うことがわかります。</p><h3 id="【購入順4】リングライト"><a href="#【購入順4】リングライト" class="headerlink" title="【購入順4】リングライト"></a>【購入順4】リングライト</h3><p><img src="/images/20210415b/image_5.png"><br><strong>購入目的</strong></p><ul><li>顔の表情を明るく見せたい。<ul><li>日中はPC裏の窓から明かりが入るが、夜間は逆光で顔が暗くなってしまうため正面から顔を照らす。</li></ul></li></ul><h3 id="【購入順5】タブレットアーム＆iPad（iPadは元々持っていた）"><a href="#【購入順5】タブレットアーム＆iPad（iPadは元々持っていた）" class="headerlink" title="【購入順5】タブレットアーム＆iPad（iPadは元々持っていた）"></a>【購入順5】タブレットアーム＆iPad（iPadは元々持っていた）</h3><p><img src="/images/20210415b/image_6.png"><br><strong>購入目的</strong></p><ul><li>通知に即レスしたい。<ul><li>顧客環境によってはチャットツールを複数使いこなすこともあり（現在はSlackとGoogleChat）、ワーク用の画面とは別で用意したかった。基本的には通知を見る用で、レス自体は手元のPCで返します。Excelなど集中して作り込んでいるとPCだけではなかなか気づけないです。</li></ul></li><li>（iPadですが）ホワイトボードを使いたい。<ul><li>オフラインではディスカッション時にアイデアを列挙する際やイメージを絵で表したい時にホワイトボードを使っていたため、オンラインでイメージを伝えるのにiPad（zoomのホワイトボード機能やJamboardなど）を利用しています。</li></ul></li></ul><h1 id="整えたリモートデスク環境でできるようになったこと"><a href="#整えたリモートデスク環境でできるようになったこと" class="headerlink" title="整えたリモートデスク環境でできるようになったこと"></a>整えたリモートデスク環境でできるようになったこと</h1><p>上記の機材を揃えることによって、以下が改善されました。</p><ul><li>Web会議中、相手は久保の目を見て会話することができる。</li><li>Web会議中、相手は久保の表情やリアクションを感じることができる。</li><li>Web会議中、ホワイトボードを用いてイメージを伝えることができる。</li><li>業務時、問い合わせに対する反応をすぐに返せる。</li></ul><h1 id="整えたリモートデスク環境の評価"><a href="#整えたリモートデスク環境の評価" class="headerlink" title="整えたリモートデスク環境の評価"></a>整えたリモートデスク環境の評価</h1><p>上で述べた環境を整えた後に、同僚とウェブ会議を実施し感想を聞いたことがあります。</p><ul><li>表情や身振り手振りが見えるので安心する。</li><li>いつでも表情が明るくハキハキしているように見える。</li></ul><p>この２点は、ウェブカメラやでディスプレイアーム、リングライトを設置することで、得られた結果だと思っています。</p><p>また、昨年推進したプロジェクトのパートナー様からは、プロジェクト完了時に<strong>「質問に対する返信が早く安心できた。会議では我々の心配を払拭してくれるような話し方で信頼できた。」</strong>と言葉をいただきました。<br>この言葉は、上記であげた機材やリモートワーク下でのコミュニケーション方法に不安を感じ、相手の気持ちになって整備した結果だと思っています。</p><p>しかし、同僚からは他にも「たまに電車の音がする」などの声もあるため、現状に満足せず相手がマイナス方面に気になってしまうことは、できるだけ取り除いていきたいと思います。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>私は<strong>自身の表情や機微が見えるようにする</strong>、<strong>できるだけオフラインと同じ状況を作る</strong>を意識してデスク周りを整えました。<br>購入した機材を効果別にまとめると以下になります。</p><table><thead><tr><th>購入機材</th><th>カテゴリ</th><th>成果</th></tr></thead><tbody><tr><td>ディスプレイアーム＆ウェブカメラ</td><td>会議中の意思疎通</td><td>・相手から自身の表情が見えるようになった</td></tr><tr><td>リングライト</td><td>会議中の意思疎通</td><td>・相手から自身の表情が見えるようになった</td></tr><tr><td>タブレットアーム＆iPad</td><td>コミュニケーション改善</td><td>・自身に対する問い合わせへの反応が早くなった <br> ・イメージを伝えやすくなった</td></tr></tbody></table><p>リモートワークになり、コミュニケーションについて不満に思ったり心配になったことは、皆さんも一度はあると思います。</p><p>ITコンサルタントのデスクとなると、プログラムが書きやすいように画面が複数あったり、縦長だったりを思い浮かべる思いますが、私はリモート環境下でまず初めに他者とコミュニケーションを円滑にすることを目的にデスク周りを整えました。</p><p>ぜひ、この記事を読まれた方は自分の作業のしやすさだけではなく、一緒に仕事をする仲間とのコミュニケーションが上手にとれる環境になっているか、もう一度見直してみてください。</p><h1 id="番外編"><a href="#番外編" class="headerlink" title="番外編"></a>番外編</h1><h2 id="デスクに置いてあるその他①：PCスタンド"><a href="#デスクに置いてあるその他①：PCスタンド" class="headerlink" title="デスクに置いてあるその他①：PCスタンド"></a>デスクに置いてあるその他①：PCスタンド</h2><p>画像では見難かったですが、MacbookはPCスタンドの上に置いて画面をできるだけ高い位置に置いています。</p><p>理由は２つあり、１つ目はWeb会議中の手元のPCを見る際の目線の位置があまり下がらないようにすること。<br>そして、２つ目が最大の理由なのですが、PCを１日触っていると肩こりになりやすいことです。</p><p>誰もが抱えていると思われるこの肩こりの原因は、PCの画面が低いことで頭の方向が下方になり、スマホ首と同じような状態になるからだそうです。スマホ首を維持し続けると、頭の重量の傾きで首から肩にかけて必要以上に筋肉が硬直し血流が悪くなることから発生します。</p><p>そのため、できるだけ画面の位置を高くすることで、スマホ首にならない良い姿勢を保つようにしています。</p><h2 id="デスクに置いてあるその他②：アーモンド"><a href="#デスクに置いてあるその他②：アーモンド" class="headerlink" title="デスクに置いてあるその他②：アーモンド"></a>デスクに置いてあるその他②：アーモンド</h2><p>アーモンドが健康に良いとされている理由は様々な記事に書いてあります。</p><p>説明するにはかなりマニアックになるので、気になる方は別途調べてみてください。</p><p>私はふるさと納税で１年分まとめ買いをしました。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。TIG（テクノロジーイノベーショングループ）の久保です。採用活動などの社外イベントなどでは &lt;strong&gt;#技術も好きだけど業務の方が好き&lt;/strong&gt; と掲げているTIGでは珍しいITコンサルタントです。&lt;br&gt;&lt;code&gt;注：弊社はITコンサルタント集</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="会議" scheme="https://future-architect.github.io/tags/%E4%BC%9A%E8%AD%B0/"/>
    
    <category term="リモートワーク" scheme="https://future-architect.github.io/tags/%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"/>
    
  </entry>
  
  <entry>
    <title>実務で扱う未経験技術を効率良く習得するために考えたこと／経験別入社前にやっておくといいこと</title>
    <link href="https://future-architect.github.io/articles/20210415a/"/>
    <id>https://future-architect.github.io/articles/20210415a/</id>
    <published>2021-04-14T15:00:00.000Z</published>
    <updated>2021-04-16T02:48:22.591Z</updated>
    
    <content type="html"><![CDATA[<p>2020年の４月に新卒入社した２年目の仁木です。<a href="/articles/20210414a/">春の入門連載2021</a>の2日目です。</p><p>実務でいきなり新しい技術に触る機会が増え、うまくキャッチアップしたり、実務で使うもの以外でも今後使える技術を増やしていくにはどうしたらいいかなと考えていて、３パターンにわけて実践していることをまとめてみました。</p><p>抽象的な内容となりますが、入社を考えている方や、これから入社される方に入社２年目の人はこんなこと考えているのかと参考になればと思います。</p><h1 id="実務で扱う未経験技術3パターン"><a href="#実務で扱う未経験技術3パターン" class="headerlink" title="実務で扱う未経験技術3パターン"></a>実務で扱う未経験技術3パターン</h1><img src="/images/20210415a/top.jpg"><p>Photo taken by <a href="https://twitter.com/kaedemalu">@kaedemalu</a></p><ol><li><strong>1ヶ月以上前から扱うことが分かっているパターン</strong><br>研修後のOJT直後でプロジェクトにアサインされてまもない頃や、次フェーズで使う技術と設計がだいたい固まってきた時などにこのパターンでした。実務で使うまで１ヶ月以上の学習時間があります。分野を広く、興味があるところまで広げて好きに勉強できるので個人的に一番好きなパターンです。この時期はプロトタイプを作ってみるだけでなく、関連する言語やサービスの記事をなるべく広くインプットして、興味があるものや先輩社員やTwitterなどで流行りそうな技術はアプリ化したり、資格取得に繋げたりしています。この時期は視野が広くなるので次に来そうな技術を予想するのが楽しいです。</li><li><strong>直前に分かるパターン</strong><br>言語変更や仕様がより固まって予想してなかった技術が必要となったパターンです。あまりインプットの時間がないので短期的に見て必要な知識だけを効率よく身につけなければならない状態です。実装に必要な最低限の知識だけを効率よくキャッチアップするために小さいプロトタイプを素早く組み立てます。慣れるまで短い時間でたくさん立ち止まって調べなければならないので、最初はしんどいです。技術選択などは視野が狭くならないように知っている人に聞いた方がいい場合もあり、自力と他力のバランスを取るのが難しいです。現実を見ずに広めの好きなキャッチアップをしないように「時間がない」ことを忘れないように気をつけています。</li><li><strong>自力で間に合わなかったパターン</strong><br>インプットの時間が足りなくて、よくわからないうちにほぼレビューの力やアドバイスを借りて遂行したパターンです。1,2で時間不足、準備不足のものの一部がこれになります。時間がないので自力でできることが限られていて早めに諦めて人を頼る必要があります。人に教えてもらってコードが完成した後も次またすぐ使う技術かどうかでどこまで深追いするかは見極めが必要と思っています。理解が浅いと何回も同じ質問をしてしまいかねないので何度も出て来そうなものは汎化できるまで深掘りできるのが理想です。<br>とはいえ質問の共通部分まで辿るのは経験上難しくて、同じ質問をしてから気づくことが多いです。聞いている方は細かく見過ぎていて（聞かれている方から見て）同じ質問か分かってない時があるので、先輩社員になって同じ質問をしてくる後輩がいたら、共通部分の指摘ができるようになろうと思っています。</li></ol><h1 id="プログラミング経験者・未経験者別。入社前にやっておくといいこと"><a href="#プログラミング経験者・未経験者別。入社前にやっておくといいこと" class="headerlink" title="プログラミング経験者・未経験者別。入社前にやっておくといいこと"></a>プログラミング経験者・未経験者別。入社前にやっておくといいこと</h1><ul><li><strong>プログラミング経験者</strong><br>１言語以上ある程度すらすらかける人は入社後に興味のある技術を希望できる機会があるのでそれに向けてどんどん手を動かして見るといいと思います。何をやろうか思い浮かばないという人はTechBlogで興味のある技術を見つけてそれをやってみるとか、なんとなく怖くて手が出せなかった技術について調べてみるでもいいと思います。</li><li><strong>プログラミング未経験者</strong><br>未経験者に限らず、自分にも言い聞かせていることなのですが、本を読むだけ、コードを見るだけで理解しようとしたり、写経してやった気にならないようにしようと心がけていて、まず、自分で考える時間を作って、自分で書いてコードがどういう意味をしているかを考えるような時間があるといいと思います。<br>興味のある技術についても広めに勉強をしてもいいのかと思いますが、インプットが多くなりがちになってしまうので、まずは１つの言語をしっかり身につけて応用していくまたは、小さくてもアウトプットをたくさんしていくほうが実践力は付くと思います。</li></ul><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>いかがでしたでしょうか。パターン別に未経験技術のキャッチアップ方法で考えていることをまとめてみました。実務が一番技術力がつくと思っているので、それに合わせて目の前のことだけでなく、長期的に広く、新しい技術を身につけたいと考えながら仕事や勉強をしています。入社ちょうど1年経過した人はこんなこと考えているのかと参考になれば嬉しいです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020年の４月に新卒入社した２年目の仁木です。&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の2日目です。&lt;/p&gt;
&lt;p&gt;実務でいきなり新しい技術に触る機会が増え、うまくキャッチアップしたり、実務で使うもの以外でも今後使える技術</summary>
      
    
    
    
    <category term="Culture" scheme="https://future-architect.github.io/categories/Culture/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>春だから学ぶシステム連携</title>
    <link href="https://future-architect.github.io/articles/20210414b/"/>
    <id>https://future-architect.github.io/articles/20210414b/</id>
    <published>2021-04-13T15:00:01.000Z</published>
    <updated>2021-04-14T03:06:28.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIG真野です。<a href="/articles/20210414a/">春の入門連載2021</a>の1日目です。</p><p>システム間のデータ連携は業務システムでは不可欠な要素ですが、初心者にはとっつきにくい概念です。けれどシステムとしての付加価値はデータを繋げることで生まれることが多く、非常に重要です。</p><p>本記事ではそんなデータ連携について、具体的なパターンを例に上げて説明します。</p><p><img src="/images/20210414b/flamingos-1835649_1280.jpg"></p><blockquote><p><a href="https://pixabay.com/ja/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1835649">Pexels</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1835649">Pixabay</a>からの画像</p></blockquote><h2 id="システム間のデータ連携とは"><a href="#システム間のデータ連携とは" class="headerlink" title="システム間のデータ連携とは"></a>システム間のデータ連携とは</h2><p>システム間のデータ連携とは、システム間である共有したいデータの受け渡しを行うことです。データ交換と言うこともありますし、システムI/F（システムアイエフ）と呼ぶことも多いです。</p><p><img src="/images/20210414b/image.png"></p><p>この共有データのやり取りのために幾つかの取り決めが必要です。<strong>いつ</strong>・<strong>どのような項目</strong>を、<strong>どのようなプロトコル</strong>で渡すかといったことを両者で合意する必要があります。一般的にはデータを渡す側を配信（送信）、受け取る側を集信（受信、Import）と呼びます。配信と集信を合わせて集配信と呼ぶこともあります。</p><p>共有データのよく利用される形式の一つは、<strong>ファイル</strong> 形式や、何かしらの<strong>WebAPI</strong>や<strong>RPC</strong>で提供される事が多いです。</p><p>データ連携の分野では、<a href="https://www.amazon.co.jp/Enterprise-Integration-Patterns-Designing-Addison-Wesley/dp/0321200683">Enterprise Integration Patterns</a>という名著があり、共有データといった呼び方はそちらに揃えていますので、少しお高いですが興味がある人は読んで見ると一段上に上がれるかもしれません。</p><h2 id="システムI-Fはなぜ必要か？"><a href="#システムI-Fはなぜ必要か？" class="headerlink" title="システムI/Fはなぜ必要か？"></a>システムI/Fはなぜ必要か？</h2><p>システム連携がなぜ必要か、ここにピンと来ない人も以外と多いです。簡単に説明します。</p><p>例えば、システムAをA社、システムBをB社の業務システムとします。</p><p>A 社と B 社は業務上取引があり、もともとは「TEL で注文を行い、請求書を郵送でやり取りすること」で取引を行っていましたが、これでは取引回数が増える度に人員を増やさないと業務が継続できそうにありません。なんせ一回で 15 分程度は、お互いの事務処理を動かす必要があります。しかも TEL なので、TEL が集中する時間とそうでない時間があり需要の見極めには長年の経験と勘が求められました</p><p><img src="/images/20210414b/image_2.png"></p><p>電話だと大変なので、やり取りをメールに寄せ請求書や帳票をPDF添付するといったこともあるでしょう。これでもTELで同期的に処理するより属人性が減りかなり楽になりました。</p><p><img src="/images/20210414b/image_3.png"></p><p>しかし、システムからPDFを出力しメール添付で送信したり、メールからPDFを取り出しシステムに入力したりといった業務はなくなりません。PDFに記載されている項目のチェック作業や、万が一取引ができない場合にお断りを入れたりする業務も作業負荷としてはかなりのものです。</p><p>そのため人間を介在させること無く、システム同士でデータをやり取りさせたいという要求が生まれるわけです。どうせシステムからデータを抽出して、相手方に渡して、<br>相手方はそれをシステムに入力するのであれば直接システム同士でデータ連係させた方が間違いもなく確実じゃないかということです。</p><p><img src="/images/20210414b/image_4.png"></p><p>システム A に入力したデータは、B 社のシステム B に自動で連携されるので、もはや B 側ではデータの受付処理を人間が行う必要がなくなります。現実的には何か人間の意志入れが必要な場面は残るかと思いますが、大部分の業務は簡略化できました。</p><p>やや極端な例を示しましたが、なるべく人が考えなくても済む部分はシステムに任せたいという背景は理解できたと思います。</p><p>また、今回はシステムA、システムBで事業会社が異なりましたが、社内システムであっても同じような要求がでてくるので考え方は同じです。</p><h2 id="連携パターン"><a href="#連携パターン" class="headerlink" title="連携パターン"></a>連携パターン</h2><p>さて共有データ（先程の例だと注文データ）はどのような形式で連携されるかです。</p><p>Enterprise Integration Patterns本では、ファイル・DB・RPC（Remote Procedure CAll）・メッセージングの4つで分類分けされています。大別するとシステム連携はこの4パターンのいずれかで行われているということです。それぞれの特徴を説明します。</p><h3 id="ファイル"><a href="#ファイル" class="headerlink" title="ファイル"></a>ファイル</h3><p><img src="/images/20210414b/image_5.png"></p><p>ファイル連係はその名の通り、やりとりしたい共有データをファイルによって行う方式です。</p><p>ファイル連係は見方を変えればストレージを共有するとも言い換えられます。そのため、共有するストレージが単一障害点にならないように設計する必要があります</p><p>ストレージは、AWSだとS3といったオブジェクトストレージが利用されることが多いでしょう。SFTPなども依然としてよく使われるプロトコルです。</p><p>仮にS3を利用する場合は、利用するS3バケットはどちらの所有であるべきか、などはよく議論になるポイントです。</p><p>また、処理済みの場合はオブジェクトのタグ付けで <code>status:complete</code> を付与してステータス管理したり、二重取り込みを禁止するために最初にリネームするなどの工夫がよく見られます。</p><p>ある程度のデータ規模になるとファイル形式が採用される事が多く、1日分の処理データや、ある断面でのマスタデータなどを連携したいときによく用いられます。</p><h3 id="API-RPC"><a href="#API-RPC" class="headerlink" title="API/RPC"></a>API/RPC</h3><p><img src="/images/20210414b/image_6.png"></p><p>RPC のプロトコルとしてよく使われるのが REST-API（JSON Over HTTP）です。最近であればgRPC（Protocol Buffers over HTTP/2）も採用実績が増えています。どちらもマイクロサービシーなシステムを構築する際にもよく使われる技術でもあります。</p><p>ファイル連係に比べてよりリアルタイムな連係が可能ですが、比較的大量データの連係には不得意です。システム間連係ではある程度上限が決まっているデータの連係に用いましょう。</p><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p><img src="/images/20210414b/image_7.png"></p><p>DB連携は、データベースを共有しあるテーブルに書き込まれているデータを共有する方法です。抽出条件は日付カラムやらステータスカラムやらを用意することが多いでしょう。<br>こちらもファイル連携と同じく、配信・集信のどちらかのデータベースを利用するかでパターンが分かれます。</p><p>DB連携はデータ反映の鮮度が早く確実、大量データの連携も可能ですが、依存関係が密結合になってしまうのが難点です。<br>昨今はマイクロサービスなど疎結合なアーキテクチャを採用することが多く、DBを共有してしまうと自システムの都合でインフラのメンテナンスを行いにくくなったり、データ連携で負荷が生じ、予期せぬ障害連鎖にも繋がりかねません。また、一度密結合になった連携を、疎結合に戻すのは一般的に難しいためできるなら避けたい法式です。</p><h3 id="メッセージング"><a href="#メッセージング" class="headerlink" title="メッセージング"></a>メッセージング</h3><p><img src="/images/20210414b/image_8.png"></p><p>RPC と異なり、配信側はメッセージを送信した後、集信側の処理結果を待たずに配信を完了とする方式です。パブリッシュ・サブスクライブ（Publish-Subscribe）方式が代表的で、配信：集信＝１：N の場合には有効な手法です。プロダクトとしては、Apache Active MQ や ZeroMQ、Apache Kafka などが有名です</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><ul><li>システムのデータ連携は、糊付けの部分でかなり地味。されどできる便利だしユーザ目線からすると超重要です</li><li>連携法式は大分類で捉えると理解しやすい<ul><li>静止点がとれ、ある一定のデータ量になるデータ交換を目的とするシステム I/F ではまずファイル連携の利用を検討しましょう</li><li>リアルタイム性を求められるなど要件が出てきた段階で RPC やメッセージングの利用を検討しましょう</li><li>逆に、イベントの通知を目的とする場合はファイル連携ではなく、RPC やメッセージングの利用を検討しましょう</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIG真野です。&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の1日</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="入門" scheme="https://future-architect.github.io/tags/%E5%85%A5%E9%96%80/"/>
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="システム連携" scheme="https://future-architect.github.io/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%80%A3%E6%90%BA/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>春の入門連載2021を始めます</title>
    <link href="https://future-architect.github.io/articles/20210414a/"/>
    <id>https://future-architect.github.io/articles/20210414a/</id>
    <published>2021-04-13T15:00:00.000Z</published>
    <updated>2021-04-22T01:45:41.903Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。技術ブログ運営の<a href="https://twitter.com/kaedemalu">伊藤太斉</a>です。2021年も春の入門連載を開催します。</p><p><img src="/images/20210414a/IMG_0722.JPG"><br>Photo taken by <a href="https://twitter.com/kaedemalu">@kaedemalu</a></p><h2 id="春の入門連載について"><a href="#春の入門連載について" class="headerlink" title="春の入門連載について"></a>春の入門連載について</h2><p>4月になり、どの会社も新卒社員を迎え活気がましていると思います。フューチャーも多くの新卒を迎え、日々研修に励んでいます。また、節目ということもあり、新しいことを始め流きっかけにもなりやすいのではないでしょうか？</p><p>この春の入門連載は今年で2年目の企画となりますが、今回は参加者を募集するにあたり</p><ul><li>新人が参画にする時に知っておいて欲しいこと</li><li>自分が新人の時に知っておきたかったこと</li></ul><p>をテーマとして組みました。フューチャーでも新人研修を卒業したら、様々な案件に参画しますが、その時の一助となるような記事が集まっています。</p><h2 id="投稿スケジュール・タイトル"><a href="#投稿スケジュール・タイトル" class="headerlink" title="投稿スケジュール・タイトル"></a>投稿スケジュール・タイトル</h2><p>本連載は以下のスケジュールで進みます。気になる記事、読んでみたい記事はぜひ読んでいただいたりシェアしていただけると嬉しいです。</p><table><thead><tr><th>日付</th><th>執筆者</th><th>タイトル</th></tr></thead><tbody><tr><td>4/14</td><td>真野隼記</td><td><a href="/articles/20210414b/">春だから学ぶシステム連携</a></td></tr><tr><td>4/15</td><td>仁木美来</td><td><a href="/articles/20210415a/">実務で扱う未経験技術を効率良く習得するために考えたこと／経験別入社前にやっておくといいこと</a></td></tr><tr><td>4/16</td><td>中山祐一</td><td><a href="/articles/20210416b/">(新卒で役にたつ！)SQL小技集</a></td></tr><tr><td>4/19</td><td>牛尾夏輝</td><td><a href="/articles/20210419b/">IT初学者がカラムナデータベースを勉強してみた</a></td></tr><tr><td>4/20</td><td>江口小夏</td><td><a href="/articles/20210420a/">議事メモ作成の心得</a></td></tr><tr><td>4/21</td><td>柴尾哲也</td><td><a href="/articles/20210421a/">情報の民主化のために発信しましょう</a></td></tr><tr><td>4/22</td><td>須田桂伍</td><td><a href="/articles/20210422a/">Technical Credibilityを築くということ</a></td></tr></tbody></table><p>※公開日、タイトルなどは変更になる可能性があります。ご了承ください。</p><h2 id="2021の連載について"><a href="#2021の連載について" class="headerlink" title="2021の連載について"></a>2021の連載について</h2><p><a href="/articles/20210112/">技術ブログの年間連載予定を発表します</a>で紹介しているように複数の連載企画が立ち上がっています。すでにGo1.16連載、GCP連載、シェルスクリプト連載などを実施済みです。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今回の連載の記事も力作揃いですので楽しみにお待ちください！</p><p>2020年の入門連載も合わせて読んでみてください。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200529/index.html" data-iframely-url="//cdn.iframe.ly/api/iframe?url=https%3A%2F%2Ffuture-architect.github.io%2Farticles%2F20200529%2F&key=42622142e53a4cc5ab36703bcee5415f"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。技術ブログ運営の&lt;a href=&quot;https://twitter.com/kaedemalu&quot;&gt;伊藤太斉&lt;/a&gt;です。2021年も春の入門連載を開催します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210414a/IMG_0722.JPG&quot;&gt;&lt;br</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>KMSで暗号化してLambdaで復号化する</title>
    <link href="https://future-architect.github.io/articles/20210413a/"/>
    <id>https://future-architect.github.io/articles/20210413a/</id>
    <published>2021-04-12T15:00:00.000Z</published>
    <updated>2021-04-15T01:32:44.958Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20210413a/Screen_Shot_2021-03-24_at_2.18.57.png"></p><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャーの棚井龍之介です。</p><p>認証情報を Lambda の環境変数に渡す要件が発生し、</p><ul><li>Lambda は環境変数を含めて Terraform 管理配下にある</li><li>コードは全て GitHub で履歴管理している</li><li>生の認証情報はリポジトリに Push すべきでない</li></ul><p>となったため、認証情報を KMS で暗号化して、リポジトリには暗号化した値を登録し、Lambda 内で復号化する構成を取りました。</p><p>認証情報のコード管理について、Terraform 作業とローカル作業を組み合わせて対応できたため、備忘録も兼ねて手順をブログ化しました。</p><h2 id="KMS-とは"><a href="#KMS-とは" class="headerlink" title="KMS とは"></a>KMS とは</h2><p>公式: <a href="https://aws.amazon.com/jp/kms/">AWS Key Management Service (KMS)</a></p><p>AWS の提供する、データの暗号化・復号化サービスです。共通鍵暗号の仕組みを使い、データベースの接続キーや認証情報の暗号化・復号化機能を提供します。他サービスと組み合わせることにより、KMS でアクセスキーで暗号化して、EC2 から RDS への接続時にのみ復号化する、といった柔軟な対応も可能です。</p><p>KMS の仕組み自体は、Classmethod さんの書かれた「<a href="https://dev.classmethod.jp/articles/10minutes-kms/">10分でわかる！Key Management Serviceの仕組み</a>」が詳しいのです。</p><h2 id="Terraform-とは"><a href="#Terraform-とは" class="headerlink" title="Terraform とは"></a>Terraform とは</h2><p>公式: <a href="https://www.terraform.io/">Terraform</a></p><p>HashiCorp 社により開発されている、OSS のクラウド管理ツールです。AWS や GCP などのクラウドサービスに対して、リソースの作成・削除や、各種パラメータの調整機能をコードベースで提供します。オペレーターになどよる GUI 操作や AWS CLI コマンド操作を排除し、インフラリソース管理を Terraform に一本集中することで、煩雑なリソース管理作業を簡略化することができます。</p><p>Future の技術ブログでは、<a href="/tags/Terraform/">Terraform 関連の投稿</a>がありますので、こちらも合わせてご覧ください。</p><p>Terraform やってみたいという方は、以下の記事がオススメです。</p><ul><li><a href="/articles/20190816/">はじめてのTerraform 0.12 ～環境構築～</a></li><li><a href="/articles/20200624/">春の入門祭り🌸 #18 Terraform 101</a></li></ul><h1 id="本記事の流れ"><a href="#本記事の流れ" class="headerlink" title="本記事の流れ"></a>本記事の流れ</h1><p>KMS の暗号化・復号化操作を、以下の流れで説明します。</p><ul><li>Terraform で KMS マスターキーの生成</li><li>AWS CLI で暗号化・復号化</li><li>Lambda で KMS 操作</li></ul><p>また、本記事では一部 Terraform による操作を前提としていますが、基本的な Terraform 操作の説明は省略しています。</p><h1 id="Terraform-で-KMS-マスターキーの生成"><a href="#Terraform-で-KMS-マスターキーの生成" class="headerlink" title="Terraform で KMS マスターキーの生成"></a>Terraform で KMS マスターキーの生成</h1><p>Terraform で KMS リソースを作成します。</p><p>KMS マスターキーの定義だけでなく、エイリアスも同時に定義します。</p><p>マスターキーの値は <code>1234abcd-12ab-34cd-56ef-1234567890ab</code> のような値であり非常に判別しづらいため、別名（エイリアス）として <code>alias/demo-alias</code> のように任意の識別名を付与します。</p><p>マスターキーの値と Alias の関係は <strong>マスターキー : Alias = 1 : n</strong> なので、1つのマスターキーには複数の Alias が設定可能です。逆に、1つの Alias を複数のマスターキーに紐づけることはできません。</p><p>公式: <a href="https://docs.aws.amazon.com/ja_jp/kms/latest/developerguide/kms-alias.html">エイリアスの使用</a></p><figure class="highlight go"><figcaption><span>kms</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_kms_key&quot;</span> <span class="string">&quot;demo&quot;</span> &#123;</span><br><span class="line">  description             = <span class="string">&quot;for demo&quot;</span></span><br><span class="line">  key_usage               = <span class="string">&quot;ENCRYPT_DECRYPT&quot;</span></span><br><span class="line">  enable_key_rotation     = <span class="literal">true</span></span><br><span class="line">  deletion_window_in_days = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">&quot;aws_kms_alias&quot;</span> <span class="string">&quot;demo&quot;</span> &#123;</span><br><span class="line">  name          = <span class="string">&quot;alias/demo-alias&quot;</span></span><br><span class="line">  target_key_id = aws_kms_key.demo.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Terraform 定義パラメータ</p><ul><li><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kms_key">aws_kms_key</a></li><li><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kms_alias">aws_kms_alias</a></li></ul><p>リソース定義を追加後、<code>$ terraform plan/apply</code> により KMS マスターキーと Alias を作成します。</p><h1 id="AWS-CLI-で暗号化・復号化"><a href="#AWS-CLI-で暗号化・復号化" class="headerlink" title="AWS CLI で暗号化・復号化"></a>AWS CLI で暗号化・復号化</h1><p>作成した Alias を用いて、テキスト情報の暗号化・復号化作業を実施してみます。</p><p>暗号化作業で <code>AliasArn</code> の値を使うため、環境変数 <strong>$KEYID</strong> に登録します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KEYID に登録</span></span><br><span class="line">$ <span class="built_in">export</span> KEYID=$(aws kms list-aliases \</span><br><span class="line">--query <span class="string">&#x27;Aliases[?AliasName==`alias/demo-alias`]&#x27;</span> | jq -r <span class="string">&#x27;.[].AliasArn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$KEYID</span></span><br><span class="line">arn:aws:kms:ap-northeast-1:&#123;aws-account&#125;:<span class="built_in">alias</span>/demo-alias</span><br></pre></td></tr></table></figure><h2 id="暗号化"><a href="#暗号化" class="headerlink" title="暗号化"></a>暗号化</h2><p>ローカルに <code>PlaintextFile</code> の名前でファイルを生成して、認証情報の平文を保存します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim PlaintextFile</span><br><span class="line"></span><br><span class="line">$ cat PlaintextFile</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>続いて、AWS CLI コマンドにより <code>PlaintextFileの中身（=平文）</code> を暗号化します。</p><p>コマンド実行後、KMS により暗号化された認証情報が <code>CiphertextBlob</code> として取得できます。CiphertextBlob の実態は、認証情報を暗号化して Base64 エンコードした値です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ aws kms encrypt \</span><br><span class="line">  --key-id <span class="variable">$KEYID</span> \</span><br><span class="line">  --plaintext fileb://PlaintextFile</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;KeyId&quot;</span>: <span class="string">&quot;arn:aws:kms:ap-northeast-1:&#123;aws-account&#125;:key/&#123;key-id&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CiphertextBlob&quot;</span>: <span class="string">&quot;&#123;暗号文&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上で「平文を暗号化して、暗号文を取得するまで」が完了です。</p><h2 id="復号化"><a href="#復号化" class="headerlink" title="復号化"></a>復号化</h2><p>暗号文 <code>CiphertextBlob</code> の値を復号化してみましょう。</p><p>先ほどの操作で生成した暗号文 <code>CiphertextBlob</code> を、<code>CiphertextFile</code> に保存します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ aws kms encrypt \</span><br><span class="line">  --key-id <span class="variable">$KEYID</span> \</span><br><span class="line">  --plaintext fileb://PlaintextFile \</span><br><span class="line">  --query CiphertextBlob \</span><br><span class="line">  --output text | base64 --decode &gt; CiphertextFile</span><br></pre></td></tr></table></figure><p>復号化コマンドを実行すると、最初に暗号化した平文が取得できます。<br>暗号文自体に KEYID の情報が格納されているので、復号化のコマンドには <code>--key-id $KEYID</code> の指定が不要です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ aws kms decrypt \</span><br><span class="line">  --ciphertext-blob fileb://CiphertextFile \</span><br><span class="line">  --query Plaintext \</span><br><span class="line">  --output text | base64 --decode</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>以上で「暗号文の復号化」が完了しました。</p><h1 id="Lambda-で-KMS-操作"><a href="#Lambda-で-KMS-操作" class="headerlink" title="Lambda で KMS 操作"></a>Lambda で KMS 操作</h1><p>KMS で生成した暗号文を、Lambda の中で復号化します。</p><p>先ほどの暗号化作業で作成した <code>CiphertextBlob</code> の値を、Lambda 内で復号化します。</p><p>KMS の復号化には <code>kms:Decrypt</code> のポリシーが必須なので、demo 用の Lambda に以下のインラインポリシーを追加します。</p><figure class="highlight json"><figcaption><span>KMS復号化用のインラインポリシー</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span>: <span class="string">&quot;AllowDecryptKmsKey&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;kms:Decrypt&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:kms:ap-northeast-1:&#123;aws-account&#125;:key/&#123;key-id&#125;&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Terraformでのlambdaのリソース構築設定に<code>kms_key_arn</code>を追記することで、lambdaはデフォルトのAWS KMSキーではなく作成したKMSのキーを利用するようになります。</p><figure class="highlight go"><figcaption><span>lambda</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_lambda_function&quot;</span> <span class="string">&quot;kms_lambda&quot;</span> &#123;</span><br><span class="line">  filename      = <span class="string">&quot;lambda_initial_script.zip&quot;</span></span><br><span class="line">  function_name = <span class="string">&quot;kms-lambda&quot;</span></span><br><span class="line">  role          = aws_iam_role.lambdarole.arn</span><br><span class="line">  handler       = <span class="string">&quot;lambda&quot;</span></span><br><span class="line">  runtime       = <span class="string">&quot;go1.x&quot;</span></span><br><span class="line">  memory_size   = <span class="number">1024</span></span><br><span class="line">  timeout       = <span class="number">900</span></span><br><span class="line">  kms_key_arn   = aws_kms_key.demo.arn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手動で設定を行う場合は環境変数の設定から暗号化設定を有効化します。<br><img src="/images/20210413a/lambda.png"></p><h2 id="Lambda-で復号化"><a href="#Lambda-で復号化" class="headerlink" title="Lambda で復号化"></a>Lambda で復号化</h2><p>以下のコードを Lambda にデプロイして、復号化結果を取得してみます。<br><code>encryptedKey</code> には、<code>CiphertextBlob</code> の値を直接代入しています。</p><figure class="highlight go"><figcaption><span>kms-demo-lambda</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-sdk-go/aws/session&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-sdk-go/service/kms&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CiphertextBlob</span></span><br><span class="line"><span class="keyword">var</span> encryptedKey = <span class="string">&quot;(CiphertextBlobの値)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svc = kms.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleRequest</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">decryptedKey, err := decryptKey(encryptedKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Decrypted text is: %s&quot;</span>, decryptedKey), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">v, err := base64.StdEncoding.DecodeString(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in := kms.DecryptInput&#123;</span><br><span class="line">CiphertextBlob: v,</span><br><span class="line">&#125;</span><br><span class="line">out, err := svc.Decrypt(&amp;in)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> strings.Replace(<span class="keyword">string</span>(out.Plaintext), <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>コマンドで動作確認<br>invoke を実行して、関数のレスポンスを取得</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ aws lambda invoke \</span><br><span class="line">  --function-name kms-demo-lambda outfile.txt</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;StatusCode&quot;</span>: 200,</span><br><span class="line">    <span class="string">&quot;ExecutedVersion&quot;</span>: <span class="string">&quot;<span class="variable">$LATEST</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat outfile.txt</span><br><span class="line"><span class="string">&quot;Decrypted text is: Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p>暗号化されていた <code>CiphertextBlob</code> の値が、正しく復号化されたことを確認できました。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>本記事では、KMS のマスターキー生成を Terraform で行い、暗号化は AWS CLI で手動実施するというハイブリッド方式をご紹介しました。</p><p><code>CiphertextBlob</code> の値は KMS で暗号化済みのため、Terraform やアプリケーションコードに直接追記しても問題ありません（Lambdaで利用するならば、ハードコードではなく環境変数に追記すべきですが）。GitHub 管理するコード上には暗号文のまま登録して、呼び出し先で復号化する機能配置ならば、生の認証情報がリポジトリに残らないようにできます。</p><p>以上、長文にお付き合いいただき、ありがとうございました。</p><h2 id="参照記事"><a href="#参照記事" class="headerlink" title="参照記事"></a>参照記事</h2><ul><li><a href="https://dev.classmethod.jp/articles/decrypt-sensitive-data-with-kms-on-lambda-invocation/">KMSで認証情報を暗号化しLambda実行時に復号化する</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20210413a/Screen_Shot_2021-03-24_at_2.18.57.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Terraform" scheme="https://future-architect.github.io/tags/Terraform/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="KMS" scheme="https://future-architect.github.io/tags/KMS/"/>
    
  </entry>
  
  <entry>
    <title>チケットごとにSlackスレッドを分けて通知するRedmineプラグインを作成しました！</title>
    <link href="https://future-architect.github.io/articles/20210413b/"/>
    <id>https://future-architect.github.io/articles/20210413b/</id>
    <published>2021-04-12T15:00:00.000Z</published>
    <updated>2021-04-13T04:51:56.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><ul><li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li><li><a href="#%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AE%E6%A6%82%E8%A6%81">プラグイン概要</a></li><li><a href="#%E5%AE%9F%E8%A3%85%E3%81%AE%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">実装のポイント</a></li><li><a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%A8%E8%A8%AD%E5%AE%9A">インストールと設定</a></li><li><a href="#%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D">動作確認</a></li><li><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB">おわりに</a></li></ul><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>​<br>こんにちは、TIGコアテクノロジーユニットの高橋・小松です。</p><p>皆さん、Slack使っていますか？<br>​<br>Futureでは約一年前にコミュニケーションツールとして採用され社内外のコミュニケーションにSlackを使うことも増えました。そしてプロジェクト管理で利用しているRedmineは相変わらず現役です。個人的にはRedmine4.2のリリースを心待ちにしています。</p><p>さて、そうなるとRedmineからSlackへ通知したくなりますね。</p><p>以前<a href="https://future-architect.github.io/articles/20190620/">RedmineからGoogle Hangouts Chatへ連携するプラグイン</a>を紹介しましたが今回そのSlack版を作成しましたので紹介します！</p><h3 id="既存redmine-slackプラグインとの違い"><a href="#既存redmine-slackプラグインとの違い" class="headerlink" title="既存redmine slackプラグインとの違い"></a>既存redmine slackプラグインとの違い</h3><p>Github上に<a href="https://github.com/sciyoshi/redmine-slack">redmine-slack</a>プラグインがすでに公開されていますが、題名にもある通り今回開発したRedmine Slack IntegrationプラグインはRedmineチケットごとにSlackスレッドを分けて通知してくれます。</p><p>これによりスレッド内で過去の更新を確認でき、議論しやすくなります。またプロジェクトやユーザごとに通知を無効化できる機能もつけています。<br>​<br>Redmineでチケット起票や更新のイベントが発生した際に、自動的にSlackチャンネルにメッセージが送信されます。</p><h3 id="主な機能"><a href="#主な機能" class="headerlink" title="主な機能"></a>主な機能</h3><ol><li>RedmineチケットごとにSlackスレッドを分けてチケットの内容/各ステータス更新を通知します。</li><li>プロジェクト単位で、Slack通知先チャンネルの設定ができます。</li><li>見落とし防止のため、Slackチャンネル通知(Also send to)も行います。</li><li>親子関係プロジェクトで、指定した子プロジェクトだけのチケット更新を通知対象外として設定できます。</li><li>指定したユーザのチケット更新を通知対象外として設定できます。</li></ol><h2 id="実装のポイント"><a href="#実装のポイント" class="headerlink" title="実装のポイント"></a>実装のポイント</h2><p>Google HangoutsとSlackではスレッドIDの管理方法が少々異なります。<br>Google Hangoutsは任意の値をスレッドIDとすることができるためRedmineチケットURLのハッシュ値をスレッドIDとしました。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Google Hangouts通知のスレッドIDの設定部分抜粋</span></span><br><span class="line">thread_key = Digest::MD5.hexdigest(issue_url)</span><br><span class="line">thread_url = webhook_url + <span class="string">&quot;&amp;thread_key=&quot;</span> + thread_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Hangouts通知部分抜粋</span></span><br><span class="line">client.post_async url, &#123;<span class="symbol">:body</span> =&gt; data.to_json, <span class="symbol">:header</span> =&gt; &#123;<span class="string">&#x27;Content-Type&#x27;</span> =&gt; <span class="string">&#x27;application/json&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>一方SlackはスレッドIDをRedmine側から指定することができずSlack側で生成されたスレッドIDを取得する必要があります。</p><p>そのためSlackApp(インストール方法は後述)からスレッドIDの戻り値を取得しRedmineチケットのカスタムフィールドでスレッドIDを管理することにしました。</p><p>これによりチケット新規作成時はスレッドIDを取得するため同期http通信となりますがチケット更新時は非同期http通信でSlackへ連携することでパフォーマンスが落ちにくくなります。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Slack通知部分抜粋</span></span><br><span class="line"><span class="keyword">if</span> thread_ts.blank?</span><br><span class="line">  res = client.post slack_api_url, &#123;<span class="symbol">:body</span> =&gt; data.to_json, <span class="symbol">:header</span> =&gt; header&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  client.post_async slack_api_url, &#123;<span class="symbol">:body</span> =&gt; data.to_json, <span class="symbol">:header</span> =&gt; header&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SlackスレッドID取得抜粋</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  res_body = JSON.parse(res.http_body.content)</span><br><span class="line"><span class="keyword">rescue</span> Exception =&gt; e</span><br><span class="line">  Rails.logger.warn(<span class="string">&quot;Cannot parse JSON string: <span class="subst">#&#123;res.http_body.content&#125;</span>&quot;</span>)</span><br><span class="line">  Rails.logger.warn(e)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> res_body.<span class="literal">nil</span>?</span><br><span class="line"><span class="keyword">return</span> res_body[<span class="string">&#x27;ts&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p><h2 id="インストールと設定"><a href="#インストールと設定" class="headerlink" title="インストールと設定"></a>インストールと設定</h2><h3 id="1-インストール"><a href="#1-インストール" class="headerlink" title="1. インストール"></a>1. インストール</h3><p>​<br><a href="https://github.com/future-architect/redmine_slack_integration/blob/master/README.md">README</a>を参照してください。</p><p>(フューチャー社内連絡)利用の際はコンシェルジュで依頼ください</p><h3 id="2-Slack-APP新規作成"><a href="#2-Slack-APP新規作成" class="headerlink" title="2. Slack APP新規作成"></a>2. Slack APP新規作成</h3><ol><li><p>前提条件</p><ul><li>Slack APP作成するユーザはSlackチャンネルに書き込みの権限が必要です。</li></ul></li><li><p>Slack URLを開く</p><ul><li><a href="https://api.slack.com/apps/">https://api.slack.com/apps/</a></li></ul></li><li><p>Slack App作成</p><ul><li>画面右上の「Create New App」をクリックしてください。<br><img src="/images/20210413b/20210302_050412_MUu9IrrIbg7w.png" alt="2021-03-02_17h02_40.png"></li></ul></li><li><p>Slack App基本情報の入力</p><ul><li>立ち上がったポップアップへ以下情報を入力して、「Create App」をクリックして、保存してください。<table><thead><tr><th align="left">項目名</th><th align="left">値</th><th align="left">説明</th></tr></thead><tbody><tr><td align="left">App Name</td><td align="left">Slack App名</td><td align="left"></td></tr><tr><td align="left">Development Slack Workspace</td><td align="left">連携するSlackチャンネルのワークスペース</td><td align="left"></td></tr></tbody></table></li></ul><p><img src="/images/20210413b/20210311_061735_szaJQUXknPxD.png" alt="2021-03-02_17h35_28.png"></p></li><li><p>「OAuth &amp; Permissions」画面を開く</p><ul><li>画面の左側メニューの「Features」-&gt;「OAuth &amp; Permissions」をクリックしてください。<br><img src="/images/20210413b/20210311_061919_Y8ExQo1I03HK.png" alt="2021-03-02_20h17_33.png"></li></ul></li><li><p>Scopes追加</p><ul><li>画面の中央に「Scopes」-&gt;「Bot Token Scopes」-&gt;「Add an OAuth Scope」をクリックして、chat:write、chat:write.customize、chat:write.publicのscopeを追加してください。<br><img src="/images/20210413b/20210302_083053_jNMHi35XtJ4D.png" alt="2021-03-02_20h30_16.png"></li></ul></li><li><p>Bot User OAuth Token作成</p><ul><li>画面の上に「OAuth Tokens &amp; Redirect URLs」-&gt;「Install to Workspace」をクリックしてください。<br><img src="/images/20210413b/20210302_084904_6h6zUh2LRNeE.png" alt="2021-03-02_20h39_02.png"><br>立ち上がったポップアップの「許可する」をクリックして、Bot User OAuth Tokenを作成します。<br><img src="/images/20210413b/20210311_062417_BXwWoDuY3G67.png" alt="2021-03-02_20h53_11.png"></li></ul></li><li><p>Bot User OAuth Tokenをコピー</p><ul><li>「OAuth Tokens for Your Team」-&gt; 「Bot User OAuth Token」のトークン内容をメモしてください。（「Copy」をクリック）<br><img src="/images/20210413b/20210302_090112_KthIlVZmu6RK.png" alt="2021-03-02_20h56_42.png"></li></ul></li></ol><p>​</p><h3 id="3-Redmine設定​"><a href="#3-Redmine設定​" class="headerlink" title="3. Redmine設定​"></a>3. Redmine設定​</h3><p>​</p><h4 id="3-1-Redmineプロジェクト設定"><a href="#3-1-Redmineプロジェクト設定" class="headerlink" title="3-1. Redmineプロジェクト設定"></a>3-1. Redmineプロジェクト設定</h4><ol><li>Redmineプロジェクト管理者権限があるアカウントでログインしてください。</li><li>プロジェクトの「設定」-&gt; 「情報」の画面を開いてください。</li><li>「Slack Channel」にSlack通知先チャンネル名を入力してください。</li><li>「Slack Token」にコピーしたトークン内容を貼り付けてください。</li><li>「Slack Disabled」を「いいえ」に選択してください。</li><li>「保存」をクリックして、設定内容を保存してくだくさい。</li></ol><p><img src="/images/20210413b/20210311_063301_O4jfcZ1FSAny.png" alt="2021-03-03_16h38_35.png"></p><h4 id="3-2-特定子プロジェクトだけ通知を無効"><a href="#3-2-特定子プロジェクトだけ通知を無効" class="headerlink" title="3-2. 特定子プロジェクトだけ通知を無効"></a>3-2. 特定子プロジェクトだけ通知を無効</h4><p>親子関係のRedmineプロジェクトで、子プロジェクトのSlack通知設定情報は親プロジェクトから継承できるため、親プロジェクトでの設定されたSlackチャンネルも通知できます。</p><p>一方、特定子プロジェクトだけ通知を無効にすることもできます。</p><ol><li>Redmineプロジェクト管理者権限があるアカウントでログインしてください。</li><li>プロジェクトの「設定」-&gt; 「情報」の画面を開いてください。</li><li>「Slack Disabled」を「はい」に選択してください。</li><li>「保存」をクリックして、設定内容を保存してください。</li></ol><p><img src="/images/20210413b/20210311_063536_RFkCB7QcO9e8.png" alt="2021-03-04_11h11_29.png"></p><h4 id="3-3-特定ユーザだけ通知を無効"><a href="#3-3-特定ユーザだけ通知を無効" class="headerlink" title="3-3. 特定ユーザだけ通知を無効"></a>3-3. 特定ユーザだけ通知を無効</h4><p>特定ユーザからのチケット更新の通知を無効にしたい場合は「個人設定」の「Slack Disabled」を「はい」にしてください。</p><p>例えば、ビルドユーザで大量のREST-APIを利用するシーンなどを想定しています。</p><p>設定はビルドユーザでログインしてビルドユーザの個人設定画面で行ってください。<br>​<br><img src="/images/20210413b/20210304_111712_yt9XAeY0BE7p.png" alt="2021-03-04_11h14_25.png"></p><h2 id="動作確認"><a href="#動作確認" class="headerlink" title="動作確認"></a>動作確認</h2><p>​</p><h3 id="チケット新規起票"><a href="#チケット新規起票" class="headerlink" title="チケット新規起票"></a>チケット新規起票</h3><p><img src="/images/20210413b/20210311_064251_fBozRNNlpJMZ.png" alt="2021-03-04_11h32_12.png"></p><h3 id="チケット更新"><a href="#チケット更新" class="headerlink" title="チケット更新"></a>チケット更新</h3><p><img src="/images/20210413b/20210311_064454_UEQgnwhbNw6p.png" alt="2021-03-04_11h48_25.png"></p><h3 id="Slackスレッドで議論"><a href="#Slackスレッドで議論" class="headerlink" title="Slackスレッドで議論"></a>Slackスレッドで議論</h3><p>​一例ですが、Redmineの更新を受けてSlackスレッドで議論することで対応をスムーズに進めることができます。</p><p><img src="/images/20210413b/20210316_034609_GO1fXyegzuce.png" alt="2021-03-16_15h18_43.png"></p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>我々のチームではRedmine Slack IntegrationプラグインでSlackのスレッドがとても管理しやすくなりました。</p><p>Githubからダウンロード可能ですのでぜひお試しください。Pull Requestもお待ちしております。</p><p>このプラグインがスムーズなプロジェクト運営の一助になれば幸いです。</p><hr><p><strong>TIGコアテクノロジーユニット</strong></p><p>TIGコアテクノロジーユニットでは、現在チームメンバーを募集しています。</p><p>私たちと一緒にテクノロジーで設計、開発、テストの高品質・高生産性を実現する仕組みづくりをしませんか？</p><p>興味がある方はお気軽に技術ブログTwitterや会社採用HPへ、連絡をお待ちしております。</p><p><a href="https://www.future.co.jp/recruit/">https://www.future.co.jp/recruit/</a></p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目次&quot;&gt;&lt;a href=&quot;#目次&quot; class=&quot;headerlink&quot; title=&quot;目次&quot;&gt;&lt;/a&gt;目次&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB&quot;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="Redmine" scheme="https://future-architect.github.io/tags/Redmine/"/>
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Slack" scheme="https://future-architect.github.io/tags/Slack/"/>
    
  </entry>
  
  <entry>
    <title>KVSと二年間向き合って得たナレッジを還元する時がきた</title>
    <link href="https://future-architect.github.io/articles/20210412a/"/>
    <id>https://future-architect.github.io/articles/20210412a/</id>
    <published>2021-04-11T15:00:00.000Z</published>
    <updated>2021-04-18T06:00:57.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、Technology Innovation Group所属 DBチームの岩崎です。</p><p>テックブログにて記事を書くのは1年半ぶりです。(反省)あれからずっと設計～開発まで推進し、無事アプリリリースが完了しました。</p><ul><li><a href="/articles/20190718/">— 脱RDB脳 — Cassandraのデータモデルについて考えてみる</a></li></ul><p>このタイミングで改めてKVS関連のナレッジを還元できたらと思い筆を執りました。</p><h2 id="1-データモデル設計の勘所"><a href="#1-データモデル設計の勘所" class="headerlink" title="1. データモデル設計の勘所"></a>1. データモデル設計の勘所</h2><p>前回の記事でも書かせていただきましたが、KVSを採用するにあたって一番ポイントになるのがデータモデル設計です。</p><p>ここを外すと、開発で大いに苦しみます。場合によっては要件を満たせず再設計ORノックアウトなんてことにも繋がりかねません。</p><h3 id="1-1-更新要件を中心に設計するのがベター"><a href="#1-1-更新要件を中心に設計するのがベター" class="headerlink" title="1-1. 更新要件を中心に設計するのがベター"></a>1-1. 更新要件を中心に設計するのがベター</h3><p>KVSはキーアクセスしかできないので<strong>データ参照にフォーカスしたモデルを設計しがち</strong>です。</p><p>もちろんこのアプローチは全然悪くないのですが、どのようにデータを取得するかに意識が偏り実は<strong>更新要件が満たせていない・・・</strong>なんてことにならないように気を付ける必要があります。</p><p>KVSは分散処理でハイパフォーマンスを実現する代わりにトランザクション管理を犠牲にしています。そのため、データの整合性を担保した更新は苦手なためデータモデルを工夫する必要があります。</p><h3 id="1-2-その更新は”部分更新”なのか？”全体更新”なのか？"><a href="#1-2-その更新は”部分更新”なのか？”全体更新”なのか？" class="headerlink" title="1-2. その更新は”部分更新”なのか？”全体更新”なのか？"></a>1-2. その更新は”部分更新”なのか？”全体更新”なのか？</h3><p>アプリケーションからKVSに対してReadだけでなくWriteも発生する際は対象データの更新範囲を意識する必要があります。例えば、ログデータのように一度書き込んで以後更新が発生しないようなデータ特性であればKVSは適しており、データ整合性の保証も容易で扱いやすいです。</p><p>ただし、トランザクションデータで更新が発生する際は、<strong>データ整合性をどこまで保証するか？</strong>というのがデータモデルを考える上で非常に重要なポイントとなります。</p><p>Cassandraではデータをスキーマ定義してテーブル管理しているため、データ更新時はレコード全体ではなく特定のカラムに対して、UPDATE(部分更新)をかけることができます。</p><p>そのため、複数ユーザーがそれぞれ別のカラムに対して部分更新をかけるのであれば、更新対象が分離しているため、同時更新時もデータ整合性は担保できます。またRDBのように行単位でロックを取得しないため、同一キーに対する更新であってもロック待ちが発生せず高速に書き込み処理を行うことができます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新対象が分離していれば同時更新もOK。行ロックも取得されない。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Aの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> title = <span class="string">&#x27;a-title&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="comment">-- Bの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">body</span> = <span class="string">&#x27;b-body&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新対象が重複していればあと勝ちになる</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Aの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> title = <span class="string">&#x27;a-title&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="comment">-- Bの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> title = <span class="string">&#x27;b-title&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br></pre></td></tr></table></figure><p>このように複数ユーザーから同時更新がかかる要件がある場合は、<strong>更新対象が分離できるか？</strong><br>また、<strong>更新対象が重複時はあと勝ちが許容できるか？</strong>というのを明確にする必要があります。</p><p>ただし、<strong>データモデルのネストが深くなるとUPDATE可能な範囲に制約が発生する</strong>点に注意です。<br>この制約を見落とした設計を行うと、部分更新できずに更新要件を満たせない！なんてことになります。</p><p>例えば、結合ができないという観点から親子関係を持ったデータモデルで考えてみます。<br>更新要件は同一カラムに対しての更新はあと勝ちで良いが、別カラムの更新は整合性を担保するとします。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ユーザー定義型(UDT)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> <span class="keyword">child</span>(</span><br><span class="line">    child_col_1      <span class="built_in">text</span></span><br><span class="line">    child_col_2      <span class="built_in">text</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- テーブル定義</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span>(</span><br><span class="line">    <span class="keyword">id</span>                <span class="built_in">text</span></span><br><span class="line">  , parent_col_1      <span class="built_in">text</span></span><br><span class="line">  , parent_col_2      <span class="built_in">text</span></span><br><span class="line">  , children      <span class="keyword">map</span>&lt;<span class="built_in">text</span>, frozen&lt;<span class="keyword">child</span>&gt;&gt; <span class="comment">-- valueの型に上記のUDTを利用</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Cassandraではネストが深くなると(第三階層移行)frozenを使用しないと定義できません。<br>親のカラム「parent_XXX」はfrozenされていないので、部分更新をかけることが可能です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- frozenされていないカラムの部分更新は可能</span></span><br><span class="line"><span class="comment">-- Aの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> parent_col_1 = <span class="string">&#x27;a&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="comment">-- Bの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> parent_col_2 = <span class="string">&#x27;b&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span></span><br></pre></td></tr></table></figure><p>親のカラム「children」の更新はMapのValueにあたるchild型がfrozenされているため、子のカラム「child_XXX」は部分更新ができず、子のモデル全体で更新を行う必要があります。<br>frozenされたカラムの部分更新をしようとすると、他の項目がnullになってしまいます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- frozenされたカラムの更新は全体更新になる</span></span><br><span class="line"><span class="comment">-- Aの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> children[<span class="number">01</span>] = &#123;<span class="string">&#x27;child_col_1&#x27;</span>: <span class="string">&#x27;a-1&#x27;</span>, <span class="string">&#x27;child_col_2&#x27;</span>: <span class="string">&#x27;a-2&#x27;</span>&#125; <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span>;</span><br><span class="line"><span class="comment">-- Bの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> children[<span class="number">01</span>] = &#123;<span class="string">&#x27;child_col_1&#x27;</span>: <span class="string">&#x27;b-1&#x27;</span>, <span class="string">&#x27;child_col_2&#x27;</span>: <span class="string">&#x27;b-2&#x27;</span>&#125; <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- frozenされたカラムの部分更新をしようとすると、他の項目がnullになってしまうので注意</span></span><br><span class="line"><span class="comment">-- Aの更新処理</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> children[<span class="number">01</span>] = &#123;<span class="string">&#x27;child_col_1&#x27;</span>: <span class="string">&#x27;a-1&#x27;</span>&#125; <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span>;</span><br><span class="line"><span class="comment">-- child_col_2の値はnullになる</span></span><br></pre></td></tr></table></figure><p>このように本来child_col_1だけ更新したいはずなのにchild_col_2のデータも含めた全体更新にせざるを得ないため、ネストの深い項目に対する同時更新時のデータ整合性を保証できずに更新要件が満たせなくて詰んでしまう・・・なんてことになりかねません。</p><p>そのため、更新要件次第ではあえて<strong>テーブルを分離させてfrozenを避ける</strong>というのも案の一つです。<br>もちろん子テーブル参照時は親からキーを手繰る必要があるので参照性にはデメリットもあります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">child</span>(</span><br><span class="line">    <span class="keyword">id</span></span><br><span class="line">  , child_col_1      <span class="built_in">text</span></span><br><span class="line">  , child_col_2      <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span>(</span><br><span class="line">    <span class="keyword">id</span>                <span class="built_in">text</span></span><br><span class="line">  , parent_col_1      <span class="built_in">text</span></span><br><span class="line">  , parent_col_2      <span class="built_in">text</span></span><br><span class="line">  , parent_col_3      <span class="built_in">text</span></span><br><span class="line">  , children_rel      <span class="keyword">set</span>&lt;<span class="built_in">text</span>&gt;</span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="1-3-パーティション検索も念頭に入れておく"><a href="#1-3-パーティション検索も念頭に入れておく" class="headerlink" title="1-3. パーティション検索も念頭に入れておく"></a>1-3. パーティション検索も念頭に入れておく</h3><p>一般的にKVSは単一キーによるプライマリーキーアクセスしかできないと思われがちです。</p><p>Cassandraではテーブル定義時にパーティションキーと呼ばれるデータの物理配置を管理するキーを定義します。このパーティションキー単位でデータをクラスタ化して管理しておりCQLではWHERE句にパーティションキーを指定してクラスタ単位でデータ操作を行うことができます。</p><p>例えば下記のように、パーティションキーを日付にしたテーブルを作成します。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- PTキーがdateのテーブル</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line">    <span class="built_in">date</span>             <span class="built_in">text</span></span><br><span class="line">  , <span class="keyword">id</span>               <span class="built_in">text</span></span><br><span class="line">  , <span class="keyword">body</span>             <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>((<span class="built_in">date</span>), <span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>このテーブルにデータを格納した時のイメージは下記になります。</p><table><thead><tr><th>date</th><th>id</th><th>body</th></tr></thead><tbody><tr><td>2021-03-20</td><td>01</td><td>01-hoge</td></tr><tr><td></td><td>02</td><td>02-hoge</td></tr><tr><td></td><td>03</td><td>03-hoge</td></tr><tr><td>2021-03-21</td><td>04</td><td>04-hoge</td></tr><tr><td></td><td>05</td><td>05-hoge</td></tr></tbody></table><p>このように日付をパーティションキーにすることで1クエリで日付単位のデータアクセスが可能になるため、キーアクセスの連射が不要になります。</p><p>また、日単位でデータ削除なども可能になるのでパーテイション設計は重要になります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="built_in">date</span> = <span class="string">&#x27;2021-03-20&#x27;</span> ;</span><br><span class="line"><span class="comment">-- &#x27;2021-03-20&#x27;の範囲のデータ3件を取得することができる</span></span><br></pre></td></tr></table></figure><p>先述の親子関係のテーブルを分離する際も子テーブルに親IDをパーティションキーに設定することで、親ID指定するだけでキーアクセスの連射することなく取得できるようになります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- parent_idをパーティションキーに設定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">child</span>(</span><br><span class="line">    parent_id        <span class="built_in">text</span></span><br><span class="line">  , child_id         <span class="built_in">text</span></span><br><span class="line">  , child_col_1      <span class="built_in">text</span></span><br><span class="line">  , child_col_2      <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>((parent_id), child_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span>(</span><br><span class="line">    parent_id         <span class="built_in">text</span></span><br><span class="line">  , parent_col_1      <span class="built_in">text</span></span><br><span class="line">  , parent_col_2      <span class="built_in">text</span></span><br><span class="line">  , parent_col_3      <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(parent_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>この時childは下記のようなイメージでデータが格納されます。</p><table><thead><tr><th>parent_id</th><th>child_id</th><th>child_col_1</th><th>child_col_2</th></tr></thead><tbody><tr><td>p-01</td><td>c-01</td><td>aaa</td><td>aaa</td></tr><tr><td></td><td>c-02</td><td>bbb</td><td>bbb</td></tr><tr><td></td><td>c-03</td><td>ccc</td><td>ccc</td></tr><tr><td>p-02</td><td>c-01</td><td>ddd</td><td>ddd</td></tr><tr><td></td><td>c-02</td><td>eee</td><td>eee</td></tr></tbody></table><p>親IDを指定するだけで子要素が一括で取得できるのでパーティションキーを適切に設計することで効率的なアクセスが可能になります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="string">&#x27;p_02&#x27;</span> ;</span><br><span class="line"><span class="comment">-- &#x27;p_02&#x27;の範囲のデータ2件を取得することができる</span></span><br></pre></td></tr></table></figure><p>ただし、パーティションキーを設計する際に気を付けるべき点があります。</p><p>理由は運用設計の勘所にて詳細説明しますが、<strong>1パーティションサイズが100MB以上にならないようにする</strong>というのが重要になります。<br>トランテーブルに対して年や月など粒度の大きな単位でパーティションキーを設計すると1パーテイションに大量のデータがクラスタ化されて100MBを超えてしまうということに陥りやすいので注意が必要です。</p><h3 id="1-4-クラスタリングキーを利用してデータ格納時のソート順を制御する"><a href="#1-4-クラスタリングキーを利用してデータ格納時のソート順を制御する" class="headerlink" title="1-4. クラスタリングキーを利用してデータ格納時のソート順を制御する"></a>1-4. クラスタリングキーを利用してデータ格納時のソート順を制御する</h3><p>先ほどパーテイションキー単位でクラスタ化するという話をしましたが、<strong>データ格納時にクラスタ化されたデータのソート順(ASC/DESC)を指定すること</strong>ができます。</p><p>通常、カラムはアルファベットの昇順でソートされますが例えばチャットのデータなどを一覧表示する際に最新日付順に表示したいなどソート条件が決まっている場合は、クラスタリングキーでソート順を指定することでデータ格納時に制御することができます。</p><p>こうすることで、アプリケーション上でCassandraから取得したデータをソートしなおすなどの無駄なフェーズを省くことができるため非常に重要な設計になります。</p><p>クラスタリングキーのソート順はあとから変更できないので注意です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> chat(</span><br><span class="line">    chatroom_id      <span class="built_in">text</span></span><br><span class="line">  , chat_post_date   <span class="built_in">text</span></span><br><span class="line">  , chat_id          <span class="built_in">text</span></span><br><span class="line">  , chat_body        <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>((chatroom_id), chat_post_date, chat_id)</span><br><span class="line">) <span class="keyword">WITH</span> <span class="keyword">CLUSTERING</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> (chat_post_date <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><h3 id="1-5-staticを利用したテーブル集約"><a href="#1-5-staticを利用したテーブル集約" class="headerlink" title="1-5. staticを利用したテーブル集約"></a>1-5. staticを利用したテーブル集約</h3><p>staticカラムを利用してテーブル集約ができるケースがあります。</p><p>これに関しては前回の記事で詳細を説明しているので下記ご参考ください。<br><a href="https://future-architect.github.io/articles/20190718/">https://future-architect.github.io/articles/20190718/</a></p><h2 id="2-トランザクション管理の勘所"><a href="#2-トランザクション管理の勘所" class="headerlink" title="2. トランザクション管理の勘所"></a>2. トランザクション管理の勘所</h2><p>一般的にKVSはトランザクション管理ができないと理解されていますが、Cassandraでは単一行に対しては<strong>Compare and Set（CAS）</strong>と呼ばれる軽量トランザクションを利用することでトランザクション管理を実現することができます。</p><h3 id="2-1-単一行に対してはトランザクション管理可能"><a href="#2-1-単一行に対してはトランザクション管理可能" class="headerlink" title="2-1. 単一行に対してはトランザクション管理可能"></a>2-1. 単一行に対してはトランザクション管理可能</h3><p>単一行に対してINSERT及びUPDATEクエリにIF句を利用することで、軽量トランザクションによる一意のデータ挿入や楽観ロック的な更新が可能になりデータ整合性を守るのに役立ちます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;01&#x27;</span>) <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">&#x27;iwasaki&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span> <span class="keyword">IF</span> lock_flg = <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>データ整合性を保証できるのでつい軽量トランザクションを多用したくなりますが、軽量トランザクションはPAXOS合意と呼ばれるアルゴリズムで下記の4フェーズで実装されておりCASコーディネーター間で往復が発生し、非軽量トランザクションに比べて操作のレイテンシーが4倍に増加するとドキュメントで明文されてます。</p><p><a href="https://docs.datastax.com/ja/dse/5.1/cql/cql/cql_using/useInsertLWT.html">https://docs.datastax.com/ja/dse/5.1/cql/cql/cql_using/useInsertLWT.html</a></p><blockquote><p>1.準備/約束<br>2.読み取り/結果<br>3.提案/受諾<br>4.コミット/確認</p></blockquote><p>また、行ロックを取得するということは同時更新時のパフォーマンスが著しく低下する可能性が高くなるので全ての処理を軽量トランザクションに寄せるのではなく、データ整合性を厳格に管理する必要がある処理に絞って利用するのがベターです。</p><p>ただし、私のプロジェクトでもID採番処理などでCASを採用するケースはあり、性能テストでは1CASあたり約50~100ms前後の処理時間をマークしていました。</p><p>アプリケーション特性にもよりますが、100ms台であれば許容される場面は多いと思うので多少の性能劣化はあれど、CASの利用を踏まえたモデル設計もありだと個人的には考えています。</p><h3 id="2-2-同一PTキーの更新であればバッチ処理時に原子性が保証される"><a href="#2-2-同一PTキーの更新であればバッチ処理時に原子性が保証される" class="headerlink" title="2-2. 同一PTキーの更新であればバッチ処理時に原子性が保証される"></a>2-2. 同一PTキーの更新であればバッチ処理時に原子性が保証される</h3><p>Cassandraでは複数のDML文(SELECTを除く)を組み合わせてバッチ処理でリクエストを集約できます。</p><p>バッチ処理を利用することでクライアント-サーバー間のトラフィックを削減できるというメリットがありますが、<strong>1つのパーティションをターゲットとするバッチ処理であればアトミック性(原子性)を担保することができる</strong>というメリットもあり非常に便利です。</p><p>また、同一パーティションであれば先述した軽量トランザクションも利用可能です。</p><p>ただし、<strong>実行の順序性は保証されない</strong>という点には注意が必要です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同一パーティションキーに対する更新であれば原子性が保証される</span></span><br><span class="line"><span class="keyword">BEGIN</span> BATCH</span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">&#x27;iwasaki&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span>;</span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> title = <span class="string">&#x27;hoge&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="string">&#x27;01&#x27;</span>;</span><br><span class="line">APPLY BATCH;</span><br></pre></td></tr></table></figure><p>このバッチ処理で便利な点は同一パーティションキーという点にあります。</p><p>実は同一テーブルという制約はなく、<strong>同一パーティションキー(キーの中身が同じ)であれば、別テーブルであってもバッチ処理で原子性を担保した更新処理を実行することができます。</strong></p><p>例えば最新断面のみを管理する記事テーブルと記事の全リビジョンを管理する記事リビジョンテーブルを用意し、両者のテーブル構造は同じでパーティションキーも揃えておきます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> art(</span><br><span class="line">    <span class="keyword">id</span>            <span class="built_in">text</span></span><br><span class="line">  , title         <span class="built_in">text</span></span><br><span class="line">  , <span class="keyword">body</span>          <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> art_revision(</span><br><span class="line">    <span class="keyword">id</span>            <span class="built_in">text</span></span><br><span class="line">  , revision      <span class="built_in">int</span></span><br><span class="line">  , title         <span class="built_in">text</span></span><br><span class="line">  , <span class="keyword">body</span>          <span class="built_in">text</span></span><br><span class="line">  , PRIMARY <span class="keyword">KEY</span>((<span class="keyword">id</span>), revision)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通常KVSでテーブル分離すると更新時のトランザクションが分かれるためエラー時に片方だけ更新されなかった、などのデータ不整合が発生する可能性が高くなります。</p><p>が、先述した同一パーティションキーに対するバッチ処理で更新を行えばテーブル分離しても両者のテーブルの原子性を担保した更新が可能になります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> BATCH</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span>(<span class="keyword">id</span>, <span class="keyword">body</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;test&#x27;</span>) <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>;</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_revision(<span class="keyword">id</span>, revision, <span class="keyword">body</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;01&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">APPLY BATCH;</span><br></pre></td></tr></table></figure><p>このようにリビジョンテーブルと分離ができると、アプリケーションからのデータアクセスが容易になる上にデータ整合性も担保しやすくなるので非常におすすめです。</p><p>また、バッチ処理の中に軽量トランザクション(CAS)を含めることもできます。</p><p>ただし、下記のように注意点もあります。</p><blockquote><ol><li>バッチ処理内に複数パーティションに対する更新が含まれる際は原子性は保証されない(リクエストの集約にはなり、実行エラーにはならない)</li><li>バッチ処理内のDMLの実行順序は保証されない(更新順序に依存させない。順不同で冪等にする必要がある)</li><li>バッチ処理内で軽量トランザクションを利用する際は単一パーテイションのみ可能(複数パーテイション更新になる場合は実行エラー発生)</li></ol></blockquote><p>基本的にはメリットが多く、バッチ処理をうまく利用することでデータ整合性を保証しつつ性能面の向上も見込めるためおすすめです。</p><h2 id="3-アプリケーション開発の勘所"><a href="#3-アプリケーション開発の勘所" class="headerlink" title="3. アプリケーション開発の勘所"></a>3. アプリケーション開発の勘所</h2><p>私のPJではデータストアとして業務データを管理するdatastax(KVS)、全文検索機能としてElasticsearch、オンプレ構成だったのでアーカイブ用にDynamoDBを採用しており、複数のデータストアが混在していました。</p><p>アプリ開発者にデータストア層を意識させるのは非常に困難かつ、データ整合性を担保できないと考え、<strong>業務ロジックを実装するHandlerとデータの整合性を保証したCRUD機能を提供するPersister層</strong>に分離しました。</p><p><img src="/images/20210412/datastore_api.png.jpg"></p><p>APIコールすると紐づくHandler(業務ロジック)が呼び出され、Handler内で発生するデータストアへのCRUDは全てPersisterクラスの共通メソッドを呼び出すことでデータストア層を隠蔽化しています。</p><h3 id="3-1-gRPCモデルを利用したCRUD機能を提供"><a href="#3-1-gRPCモデルを利用したCRUD機能を提供" class="headerlink" title="3-1. gRPCモデルを利用したCRUD機能を提供"></a>3-1. gRPCモデルを利用したCRUD機能を提供</h3><p>]<br>クライアント/サーバー間のAPI連携にはgRPCを採用しました。datastaxはCassandraベースの製品でデータアクセスはCassandraと同じCQLを利用します。</p><p>CQLはSQLライクで、従来のRDBアプリ開発者にも直感的に記述できるインターフェースです。とはいえ、コレクション型(Map,Set)の更新や軽量トランザクション(CAS)やバッチクエリなどCassandra特有のクエリもあり、少なからず学習コストがあります。</p><p>アプリ開発者がCQLを意識せずに実装できるようにするためPersisterレイヤーにCRUD及びCASなどの機能を持ったメソッドを共通実装して提供し、<strong>引数に対象エンティティに合わせたgRPCのモデルを渡せばモデルクラスから動的にCQLを組み立ててクエリ実行できる</strong>よう処理を隠蔽化しました。</p><p>Elasticserch、DynamoDBへのCRUDも同様にPersisterレイヤーで隠蔽化しています。私のqiitaでgRPCを用いた設計開発のノウハウを公開していますので是非参考頂けたらと思います。</p><p><a href="https://qiita.com/yatarou/items/5f49b91ebb5229e2f0c1">https://qiita.com/yatarou/items/5f49b91ebb5229e2f0c1</a></p><h3 id="3-2-処理ごとにCONSISTENCY-LEVELを意識する"><a href="#3-2-処理ごとにCONSISTENCY-LEVELを意識する" class="headerlink" title="3-2. 処理ごとにCONSISTENCY LEVELを意識する"></a>3-2. 処理ごとにCONSISTENCY LEVELを意識する</h3><p>CONSISTENCY LEVELとはCQLクエリ発行時の非軽量トランザクションを適切に処理するために</p><p>応答する必要があるレプリカ内のノードの数を決定します。</p><p>下記によく利用するCONSISTENCY LEVELとユースケースを整理してみました。</p><table><thead><tr><th>Level</th><th>範囲</th><th>ユースケース</th></tr></thead><tbody><tr><td>ALL</td><td>すべてのレプリカに問い合わせ、書き込みの完了をもって成功とする</td><td>CONCISTENCYレベルONEで読み取りを行ってもデータの整合性を担保したいとき。ALLは処理性能・可用性を犠牲にするため基本は推奨しない。</td></tr><tr><td>QUORUM</td><td>全てのデータセンターの全ノードの過半数の完了をもって成功とする。</td><td>過半数の成功で良いためALLに対して可用性は高い。が、「全てのデータセンター」の過半数なのでマルチセンターで両アクティブ構成でなければやりすぎ。</td></tr><tr><td>LOCAL_QUORUM</td><td>コーディネーター(処理要求を出すノード)と同じデータセンター内の過半数の完了を待って成功とする。</td><td>QUORUMに対してデータセンター間のレイテンシーを避けることができる。また、過半数の書き込みが整合性を保証するため、読み取り時も同一レベルを設定することで読み取り整合性も保証できる。基本的にはこのレベルで処理を行うことを推奨する。</td></tr><tr><td>ONE</td><td>コーディネータ－から最も近いノードに処理が成功した時点で完了とする。</td><td>1ノードにしか処理を行わないのでONEで書き込まれたデータを参照するときはデータ整合性が保証されない可能性があるため、データ登録後にUPDATEをかけないようなデータに向いている。また、レイテンシーが最も低いのでハイトランザクションのread/writeには強いため性能を最重視する際は検討しても良い。書き込まれたデータはノード間で非同期でレプリカコピーが行われる。(ALL以外はコピー実施される)</td></tr></tbody></table><h3 id="3-3-KVS-Elasticsearch間のデータ同期の考え方"><a href="#3-3-KVS-Elasticsearch間のデータ同期の考え方" class="headerlink" title="3-3. KVS-Elasticsearch間のデータ同期の考え方"></a>3-3. KVS-Elasticsearch間のデータ同期の考え方</h3><p>KVSだけでは満たせない全文検索などの機能を利用するためにElasticsearchを採用しました。Persisterの重要な役割の一つにdatastax(KVS)とElasticsearchのデータ同期がありました。</p><p>まず、<strong>Elasticsearchの検索インデックスはKVSのテーブルと1対1の関係</strong>にしました。これはKVSが結合できないため複合インデックスにするとデータ保証しきれないためです。</p><p>次にポイントとなるのがデータ連携のタイミングです。</p><p>Elasticsearch上のデータは主管データではなく、あくまで検索補完の位置づけなので更新フローは<strong>「KVS-&gt;Elasticsearch」として必ずKVS側から更新する</strong>ようにしました。KVSを更新せずにインデックスのみ更新するフローも原則禁止としています。更新順序に依存関係を持たせることでKVSの更新エラー時に検索インデックスだけ更新されてKVSにはデータがないのに検索はヒットするといった不整合を防ぐことができます。</p><p>また、KVSは1レコードサイズが肥大化しがちなので<strong>KVS更新時に検索項目が含まれている時のみElasticsearchへのインデックス同期すること</strong>を推奨します。こうすることでインデックスサイズの削減、同期不要時の処理性能向上が見込めます。更新順序制御や更新時のインデックス同期判定を業務ロジック上で判断させるのは困難なためPersisterのKVS更新メソッドの引数に渡すgRPCモデルのフィールドオプションにインデックス化する項目に対してカスタムオプション定義をしておき更新制御を行いました。</p><p>KVSからElasticsearchのデータ連携は基本的に同期処理で行っているのですが、Elasticsearchはインデクシングまでは同期処理で、連携されたデータを即時に検索できるようにするか、非同期で準リアルタイム(といっても数百msの世界)で検索できるようにするかをrefreshと呼ばれるオプションで制御することができます。</p><p><img src="/images/20210412/001_refresh_flush.png"></p><p>検索可能なSegment領域へのrefreshは基本的に非同期(false)を推奨します。</p><p><strong>refreshを同期的(true)に行うと、KVSへの連射更新時やSegmentのmerge処理が走るとパフォーマンスに大きな影響を与えかねません。</strong></p><p>Elasticsearchの公式ドキュメントでもrefresh同期は性能影響を与えると言及しています。refresh_intervalと呼ばれるパラメータでrefreshが定期実行されるのでそれに任せます。ただし、業務ロジック上でインデックス更新直後に即座に検索クエリを投げて対象の更新データを取得して後続処理を行うようなケースがある場合はrefresh_intervalで検索可能なインデックスへの書き出しが間に合わず検索にヒットしない、というケースが稀にあります。<br>そのため、refresh同期反映が必要な場合はPersisterから更新時にrefreshオプションを渡せるようにも工夫しました。</p><p>ちなみに更新時ではなくインデックスを指定して強制的にリフレッシュを実行するrefreshAPIがElasticsearchは提供していますが、このAPIはインデックス全体を対象としたrefresh処理を行うので性能影響があります。更新時のrefreshオプションなら対象レコードのみrefresh対象としてくれるのでこちらを利用することを強く勧めます。</p><h3 id="3-4-更新管理テーブルを用いたBCP同期"><a href="#3-4-更新管理テーブルを用いたBCP同期" class="headerlink" title="3-4. 更新管理テーブルを用いたBCP同期"></a>3-4. 更新管理テーブルを用いたBCP同期</h3><p>KVSはマルチデータセンターでクラスタ構成を容易にとることができるためKVSを採用する背景にBCP（事業継続計画：Business Continuity Plan）要件が含まれることが多々あると思われます。<br>しかし、Elasticsearchはマルチデータセンターでクラスタを組むことができず、KVSとのデータ整合性を担保したBCPデータ同期の仕組みを考える必要がありました。</p><p>現在では有償サブスクリプション(プラチナ)でクロスクラスタレプリケーション機能を提供しているそうですが、当時はベータ版の機能だったので採用を見送りました。<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/ccr-getting-started.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.7/ccr-getting-started.html</a></p><p>BCP要件上アクティブスタンバイ構成でリアルタイム同期の必要はなかったため、<strong>KVS側に更新管理テーブルを作成してスタンバイ側からPULL型の定期実行で同期対象の特定および対象レコードを抽出してElasticsearchに連携する仕組み</strong>を作りました。</p><p>更新管理テーブルはKVSにデータ登録・更新時に業務テーブルに書き込む前に対象レコードのPK、更新日付、BCP同期ステータスなどをまず更新管理テーブルに記録します。更新管理テーブルへの更新が完了したら、業務テーブル更新とインデックス同期を行います。</p><p>KVS上のデータはDRサイト側にもデータベースの機能で同期が図られているのでDRサイト側で定期的に更新管理テーブルをチェックしてBCP同期対象のPKを取得します。</p><p>更新管理テーブルはあくまでPKだけ管理しているので、仮にKVS側で更新管理テーブルの書き込みは成功して、業務テーブルへの書き込みが失敗していたとしても常に業務テーブルの最新データを取得してインデックスに連携するためデータ不整合は発生しません。<br><img src="/images/20210412/bcp.png.jpg"></p><h3 id="3-5-エラーハンドリング"><a href="#3-5-エラーハンドリング" class="headerlink" title="3-5. エラーハンドリング"></a>3-5. エラーハンドリング</h3><p>基本的にエラー時はアプリケーション上でリトライさせず、ユーザー画面にエラー通知を返して画面操作のリトライを促しました。</p><p>一部、軽量トランザクションを利用したロック制御を実装しており、ロックフラグをみてステータス更新をかけるような排他制御がありました。</p><p>この処理はロック取得の軽量トランザクションで更新がかけられない時はwaitを挟み、アプリケーション上でリトライをかけるように制御しました。また、DatastaxのDriver上でリトライポリシーを設定することが可能なためReadTimeoutException、WriteTimeoutExceptionに関してはリトライポリシーに従ってリトライをかけていました。リトライポリシー設定例は下記参照ください。</p><p><a href="https://docs.datastax.com/en/developer/java-driver/3.7/manual/retries/">https://docs.datastax.com/en/developer/java-driver/3.7/manual/retries/</a></p><h2 id="4-性能テスト-運用監視の勘所"><a href="#4-性能テスト-運用監視の勘所" class="headerlink" title="4. 性能テスト/運用監視の勘所"></a>4. 性能テスト/運用監視の勘所</h2><h3 id="4-1-Gatlingを利用した性能テスト"><a href="#4-1-Gatlingを利用した性能テスト" class="headerlink" title="4-1. Gatlingを利用した性能テスト"></a>4-1. Gatlingを利用した性能テスト</h3><p>性能テストは負荷テストツールのGatlingを利用しました。<br><a href="https://gatling.io/">https://gatling.io/</a><br>テストシナリオはscala言語で記述し、Gatlingテストレポートはhtml形式で出力されます<br>例えば下記のようなシナリオを想定したサンプルコードは下記になります。(環境構築は割愛)</p><blockquote><ol><li>100TPS相当の負荷をかける</li><li>負荷は一定時間同等量をかけ続ける</li><li>実行するAPIのURLは動的に変化させる</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> perf_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.gatling.core.Predef._</span><br><span class="line"><span class="keyword">import</span> io.gatling.http.Predef._</span><br><span class="line"><span class="keyword">import</span> io.gatling.jdbc.Predef._</span><br><span class="line"></span><br><span class="line">class getitemrandomtest extends Simulation &#123;</span><br><span class="line"></span><br><span class="line">    val httpProtocol = http</span><br><span class="line">        .baseUrl(<span class="string">&quot;http://localhost:1323&quot;</span>)</span><br><span class="line">        .inferHtmlResources()</span><br><span class="line">        .acceptHeader(<span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span>)</span><br><span class="line">        .acceptEncodingHeader(<span class="string">&quot;gzip, deflate&quot;</span>)</span><br><span class="line">        .acceptLanguageHeader(<span class="string">&quot;ja,en-US;q=0.9,en;q=0.8&quot;</span>)</span><br><span class="line">        .upgradeInsecureRequestsHeader(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .userAgentHeader(<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&quot;</span>)</span><br><span class="line"></span><br><span class="line">    val headers_0 = Map(<span class="string">&quot;Proxy-Connection&quot;</span> -&gt; <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line"></span><br><span class="line">    val feeder = csv(<span class="string">&quot;article_id.csv&quot;</span>).random -- 動的パラメータをファイルに切り出しておきます</span><br><span class="line"></span><br><span class="line">    val scn = scenario(<span class="string">&quot;getitemrandomtest&quot;</span>)</span><br><span class="line">        .feed(feeder)</span><br><span class="line">        .exec(http(<span class="string">&quot;request_0&quot;</span>)</span><br><span class="line">            .get(<span class="string">&quot;/test/$&#123;id&#125;&quot;</span>)</span><br><span class="line">            .headers(headers_0))</span><br><span class="line"></span><br><span class="line">    setUp(scn.inject(constantUsersPerSec(<span class="number">100</span>) during(<span class="number">60</span> seconds))).protocols(httpProtocol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constantUsersPerSecは指定時間・ユーザ数でリクエストを投げ続けてくれます。</p><p>他にも便利な機能があるので公式ドキュメントを参考にしながら実装してみてください。</p><h3 id="4-2-nodetoolコマンドでクラスタの性能を監視する"><a href="#4-2-nodetoolコマンドでクラスタの性能を監視する" class="headerlink" title="4-2. nodetoolコマンドでクラスタの性能を監視する"></a>4-2. nodetoolコマンドでクラスタの性能を監視する</h3><p>Cassandraではnodetoolユーティリティと呼ばれる、クラスタ操作/監視や性能レポート出力など運用機能を提供するコマンドラインがあります。<br><a href="https://docs.datastax.com/ja/dse/5.1/dse-admin/datastax_enterprise/tools/nodetool/toolsAboutNodetool.html">https://docs.datastax.com/ja/dse/5.1/dse-admin/datastax_enterprise/tools/nodetool/toolsAboutNodetool.html</a><br>色んな機能がありますが、運用でよく使うコマンドを中心に紹介していきます。</p><h4 id="GC監視"><a href="#GC監視" class="headerlink" title="GC監視"></a>GC監視</h4><p>gcstatsコマンドは、ガーベージ・コレクション統計を出力します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nodetool -u monitorRole gcstats</span><br><span class="line"></span><br><span class="line">       Interval (ms) Max GC Elapsed (ms)Total GC Elapsed (ms)Stdev GC Elapsed (ms)   GC Reclaimed (MB)         Collections      Direct Memory Bytes</span><br><span class="line">             1791392                  45                 296                   7               56561                   9                424631153</span><br></pre></td></tr></table></figure><p>Cassandraの性能劣化の原因でまず疑われるのがGCなので、上記コマンドの統計結果だけでなくjstatコマンドを利用して毎秒ファイル出力しログ監視を行うなどの仕組みも作って重点的に監視を行っていました。</p><h4 id="性能監視"><a href="#性能監視" class="headerlink" title="性能監視"></a>性能監視</h4><p>tablehistogramsコマンドで対象テーブルの過去15分間に発生したRead/Writeのレイテンシーに関する現在のパフォーマンス統計を表示します。<br>時間はマイクロ秒表記なので注意です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nodetool -u monitorRole tablehistograms [キースペース] [テーブル名]</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>/test_table histograms</span><br><span class="line">Percentile  SSTables     Write Latency      Read Latency    Partition Size        Cell Count</span><br><span class="line">                              (micros)          (micros)           (bytes)</span><br><span class="line">50%             0.00             57.34             57.34              1916                17</span><br><span class="line">75%             0.00             57.34             98.30              1916                17</span><br><span class="line">95%             0.00             65.54            163.84              1916                17</span><br><span class="line">98%             0.00             65.54            327.68              1916                17</span><br><span class="line">99%             0.00             65.54            458.75              1916                17</span><br><span class="line">Min             0.00              0.00              0.00              1598                15</span><br><span class="line">Max             1.00            163.84           5242.88              1916                17</span><br></pre></td></tr></table></figure><p>また、proxyhistogramsコマンドでノード単位のレイテンシーを出力することができます。<br>ノード間通信の読み取りと書き込みのレイテンシー値のパーセンタイル・ランクが含まれており、<br>このコマンドを使用して、処理の遅いノードに要求が届いているかどうかを確認します。<br><strong>CAS Read/Write Latencyで軽量トランザクションのパフォーマンスもみることができます。</strong><br>軽量トランザクションを利用する際に性能懸念がある際は確認することを推奨します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nodetool -u monitorRole proxyhistograms</span><br><span class="line"></span><br><span class="line">Percentile       Read Latency      Write Latency      Range Latency   CAS Read Latency  CAS Write Latency View Write Latency</span><br><span class="line">                     (micros)           (micros)           (micros)           (micros)           (micros)           (micros)</span><br><span class="line">50%                   1310.72             163.84           41943.04               0.00               0.00               0.00</span><br><span class="line">75%                  20971.52             393.22           58720.26               0.00               0.00               0.00</span><br><span class="line">95%                  67108.86           20971.52          100663.30               0.00               0.00               0.00</span><br><span class="line">98%                  67108.86           41943.04          100663.30               0.00               0.00               0.00</span><br><span class="line">99%                  83886.08           41943.04          100663.30               0.00               0.00               0.00</span><br><span class="line">Min                    114.69              49.15           20971.52               0.00               0.00               0.00</span><br><span class="line">Max                 100663.30           50331.65          117440.51               0.00               0.00               0.00</span><br></pre></td></tr></table></figure><h3 id="4-3-kibanaを利用して処理全体の性能監視の仕組みを作る"><a href="#4-3-kibanaを利用して処理全体の性能監視の仕組みを作る" class="headerlink" title="4-3. kibanaを利用して処理全体の性能監視の仕組みを作る"></a>4-3. kibanaを利用して処理全体の性能監視の仕組みを作る</h3><p>nodetoolコマンドなどでKVSレイヤーの統計情報を取得することができますが、KVSではRDBのように複雑なSQLが実行されるようなことがないため単一クエリの性能は基本的に問題ないというケースが多いです。</p><p>そのためKVSレイヤーのみに絞って性能監視してもボトルネックが掴めない場合が多いです。アプリ全体でどこがボトルネックになっているかを追えるようなロギングが重要になります。</p><p>私のPJではフロントでグローバルトランザクションIDを払い出してそれを取りまわしていたのでグローバルトランザクションID起点で性能監視が追えるように各レイヤーでロギングしました。各レイヤーのアプリログをElasticsearchに取り込み、kibanaでグローバルトランザクションIDで横断検索しボトルネック箇所を特定できるダッシュボードを作成してチューニングを実施しました。</p><p><img src="/images/20210412/gid.png.jpg"></p><p>業務ロジック上で時間がかかっているのか、データストアへのCRUDで時間がかかっているのかを切り分けることで、チューニング対象の特定がグッとしやすくなります。</p><h3 id="4-4-1パーティションサイズが100MB以上にならないようにする"><a href="#4-4-1パーティションサイズが100MB以上にならないようにする" class="headerlink" title="4-4. 1パーティションサイズが100MB以上にならないようにする"></a>4-4. 1パーティションサイズが100MB以上にならないようにする</h3><p>Cassandraはデータ書き込み時にCONCISTENCY LEVELに応じてノードの書き込み完了を保証します。</p><p>CONCISTENCY LEVELがALLでなければクラスタ内のノードがすべて書き込みが成功しているという保証ができないため、定期的にクラスタ内のノード間でデータの整合性を合わせるためにバリデーションとデータ同期が行われています。この仕組みを”nodetool repair”と呼びます。nodetool repairによる同期が完了しないと全ノードが同じデータを持つことが保証されませんがLOCAL_QUORUMで読み書きを行っていれば、仮に3ノード中1ノードが古いデータを持っていたとしてもデータ不整合は発生しないのでアプリケーション側に影響はありません。</p><p>しかし、<strong>削除データに関してはこの同期が完了していないと問題になるケースが存在します。</strong></p><p>Cassandraでは削除データに対し、”tombstone”とよばれる論理削除フラグで管理を行っておりnodetool repair実行時にこのtombstoneも併せて同期を取ります。実際に物理削除されるタイミングはコンパクションと呼ばれるタイミングで行われるのですが仮<strong>にコンパクション実行時にtombstoneが連携されていないノードがあった場合、そのノードでは本来削除するべきデータがゾンビとして残ってしまう</strong>可能性があります。</p><p>ゾンビ状態でnodetool repairでデータ同期が行われると、削除したはずのデータが再度他のノードにデータ同期されて復活するという事象が発生してしまいます。この事象を避けるためにtombstone削除の猶予期間として各テーブルごとに”gc_grace_seconds”と呼ばれるパラメータでデフォルト864000秒（10日間）経過したデータを対象に削除を行います。つまり<strong>10日以内にnodetool repairでデータ同期を終わらせる必要がある</strong>ということになります。</p><p>Datastaxではgc_grace_secondsで設定した値の期間内に同期が完了するようにrepaireタスクをスケジューリングして自動実行してくれる”nodesync”とよばれるサービスが動いています。</p><p>運用ではnodesyncによって10日以内にデータ同期が完了しているかを監視することが大切です。nodesyncによる同期状況はDatastaxが提供する専用のダッシュボードがあるのでそれを利用します。このnodesyncは自動でスケジュールしてくれるので非常に便利な機能ですが、データを積んでテストしていく中である日突然CPUが一定間隔で高騰し続ける事象が発生しました。その原因がパーティションサイズに大きく関係していたのです。</p><p>nodesyncの実行単位は200MBのセグメントと呼ばれる領域にパーティションデータを乗せてバリデーションを行うのですが<strong>1パーティションが1GBなど200MBを超えている場合はパーティション内のデータを分割できず、1GBそのままセグメント領域に展開してしまう</strong>ため1コアあたりの占有時間が顕著に長くなり、1GBを超えるような巨大パーティションが複数存在するとCPUリソースを全体を食いつぶすというのが原因でした。</p><p><img src="/images/20210412/nodesync_partition.png"></p><p>そのためパーティションサイズが1GBを超えるテーブルは100MBに収まるよう設計を見直しました。サイズが肥大化しがちなパーテイションの主は日付をキーにしている場合が多いです。定常業務の更新量では1GBを超えなくても、移行などでイレギュラー要素で想定以上の更新量が発生する可能性もあるため、月や日などの単位ではなく日時分などでパーティションの粒度を細かくするもしくは、日付＋分散キーにしてコンポジット化するなど検討しました。</p><p><strong>テーブル作成後のパーティションキー変更は出来ないのでデータモデル設計時には1パーティションサイズが100MBを越さないようなキー設計になっているかを意識してください。</strong>また、運用開始後もパーティションが想定外に肥大化していないかなどを監視すると事前に事故を防げる可能性が高くなるので重要です。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>KVSと二年間設計から開発まで携わる中で一番苦労したのは「情報収集」でした。</p><p>Cassandraをエンタープライズ領域で採用した事例は、日本ではまだ少なく参考文献やネット上の情報も少ないため設計の勘所や運用ノウハウがなくトライ＆エラーの連続でした。</p><p>私は「同じ山を同じ苦労で登る必要は絶対にない」という考えでナレッジは隠さずオープンにしていくべきと考え本稿の執筆に至りました。</p><p>伝えたいことを長々と書いてしまい、まとまりのない記事になってしまったかもですが、本稿がKVSを採用したいと思っている方に少しでも役立てば幸いです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、Technology Innovation Group所属 DBチームの岩崎です。&lt;/p&gt;
&lt;p&gt;テックブログに</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="KVS" scheme="https://future-architect.github.io/tags/KVS/"/>
    
    <category term="Cassandra" scheme="https://future-architect.github.io/tags/Cassandra/"/>
    
    <category term="NoSQL" scheme="https://future-architect.github.io/tags/NoSQL/"/>
    
    <category term="Database" scheme="https://future-architect.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>OpenAPIからモックサーバを建てられるPrismを実際のプロジェクトに導入してみた</title>
    <link href="https://future-architect.github.io/articles/20210410/"/>
    <id>https://future-architect.github.io/articles/20210410/</id>
    <published>2021-04-09T15:00:00.000Z</published>
    <updated>2021-04-12T01:43:54.391Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！フューチャー22卒内定者の大岩と申します。現在は、TIG DXユニットでアルバイトとして従事しています。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>私が参加しているプロジェクトで、<strong>OpenAPI定義ファイルからモックサーバを建てることができるOSSツール「Prism」</strong>を導入することになりました。この記事では、Prism導入の手順や、躓いた点などを紹介します。</p><h2 id="導入の背景"><a href="#導入の背景" class="headerlink" title="導入の背景"></a>導入の背景</h2><p>現プロジェクトでは、フロントエンドにVue.jsを採用し、バックエンドはGo言語で書かれたAPIサーバ2台で構成されています。これまでフロントエンドの開発を行う際には、ローカルでAPIサーバとDBを立ち上げる必要があり、フロントエンドを少しだけ変更したいという場合でもかなりの手間が掛かっていました。そこで<strong>モックサーバを構築し、画面の開発の際にはそこからデータを取得出来れば、フロントエンドの作業が格段に楽になる</strong>と考えました。</p><p>バックエンドのAPIドキュメントは、OpenAPI(Swagger)形式で整備されています。そこで、このOpenAPI形式のファイルからモックサーバを建てることができる、Stoplight社のOSSツール「Prism」を採用しました。</p><h2 id="OpenAPI-Swagger-について"><a href="#OpenAPI-Swagger-について" class="headerlink" title="OpenAPI(Swagger)について"></a>OpenAPI(Swagger)について</h2><p><strong>OpenAPI</strong>とは、API構造を記述する<strong>インターフェース記述言語</strong>です。yamlもしくはjsonで記述することで、綺麗なAPIドキュメントを作成することができたり、この記事で紹介するようにモックサーバを建てることができます。</p><p>OpenAPIは、もともとはSwaggerという名前で開発が進められていました。2015年に、もともとの開発元であったSmartBear Softwareから、OpenAPI Initiativeへ移されると同時に <code>Swagger Specification</code> から <code>OpenAPI Specification</code> (以下OASと記載) という名前に変わりました。なお、現在でも「Swagger UI」や「Swagger Editor」などのOpenAPIドキュメントを整備するツール群は <code>Swagger</code> の名前が使われています。</p><p>このFuture Tech Blogでも、OpenAPIに関する記事が多く公開されています。詳細は<a href="https://future-architect.github.io/tags/Swagger/">こちら</a>をご覧ください。</p><h3 id="Prismについて"><a href="#Prismについて" class="headerlink" title="Prismについて"></a>Prismについて</h3><p>Prismとは、API設計関係のツールを提供するStoplight社によって開発されている、<strong>OSSのHTTPモックツール</strong>です。OAS2.0およびOAS3.0に準拠したドキュメントから、自動的にモックサーバを構築することができます。</p><p>今回使用したバージョンは、v4.1.2です。</p><p><a href="https://github.com/stoplightio/prism">https://github.com/stoplightio/prism</a></p><h2 id="実際に導入してみる"><a href="#実際に導入してみる" class="headerlink" title="実際に導入してみる"></a>実際に導入してみる</h2><h3 id="インストール方法"><a href="#インストール方法" class="headerlink" title="インストール方法"></a>インストール方法</h3><p>まずはPrismのパッケージをnpm経由で、プロジェクトの <code>devDependencies</code> に追加します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -D prism</span><br></pre></td></tr></table></figure><p>あとは、<code>npx</code> で起動してみて、モックサーバが起動できていたら完了です。以下の例は、カレントディレクトリ内にある <code>swagger.yaml</code> ファイルを指定して、8080番ポートで起動する例です。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx prism mock ./swagger.yaml -p 8080</span><br></pre></td></tr></table></figure><p>これを実行すると、<strong>OpenAPIファイルに記載されている全てのエンドポイントのURLが一覧で表示</strong>されます。（ここでは、 <a href="https://petstore.swagger.io/">Swagger Petstore</a> を実行した結果を掲載しています）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ npx prism mock ./swagger.yaml -p 8080</span><br><span class="line">[14:30:40] › [CLI] …  awaiting  Starting Prism…</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/pet</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      PUT        http://127.0.0.1:8080/pet</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/pet/findByStatus?status=sold,sold,sold,available,pending,pending,pending,pending,available,available,available,pending,pending,sold,available,available,pending,sold,available,pending</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/pet/findByTags?tags=quis,aperiam,velit,repudiandae,et,rem,accusantium,omnis,ut,eius,dolor,enim,nam,et,ipsam,velit,est,veritatis,nesciunt,possimus</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/pet/127</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/pet/128</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      DELETE     http://127.0.0.1:8080/pet/483</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/pet/641/uploadImage</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/store/inventory</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/store/order</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/store/order/10</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      DELETE     http://127.0.0.1:8080/store/order/963</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/user</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/user/createWithArray</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      POST       http://127.0.0.1:8080/user/createWithList</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/user/login?username=itaque&amp;password=exercitationem</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/user/<span class="built_in">logout</span></span><br><span class="line">[14:30:40] › [CLI] ℹ  info      GET        http://127.0.0.1:8080/user/quo</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      PUT        http://127.0.0.1:8080/user/fugiat</span><br><span class="line">[14:30:40] › [CLI] ℹ  info      DELETE     http://127.0.0.1:8080/user/minima</span><br><span class="line">[14:30:40] › [CLI] ▶  start     Prism is listening on http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>確かにこの表示されたURLにアクセスしてみると、モックデータが返却されるようです。</p><p>例として、 <code>GET /pet/&#123;petId&#125;</code> を見てみましょう。<a href="https://petstore.swagger.io/">Swagger Petstore</a> のOpenAPI定義ファイルでは、以下のように記述されています。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">/pet/&#123;petId&#125;:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;pet&quot;</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;Find pet by ID&quot;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&quot;Returns a single pet&quot;</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">&quot;getPetById&quot;</span></span><br><span class="line">      <span class="attr">produces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;application/xml&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;application/json&quot;</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;petId&quot;</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">&quot;ID of pet to return&quot;</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&quot;int64&quot;</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">&quot;200&quot;:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">&quot;successful operation&quot;</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&quot;#/definitions/Pet&quot;</span></span><br><span class="line">        <span class="attr">&quot;400&quot;:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">&quot;Invalid ID supplied&quot;</span></span><br><span class="line">        <span class="attr">&quot;404&quot;:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">&quot;Pet not found&quot;</span></span><br><span class="line">      <span class="attr">security:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">api_key:</span> []</span><br><span class="line"><span class="string">(中略)</span></span><br><span class="line"><span class="attr">definitions:</span></span><br><span class="line">  <span class="attr">Pet:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">&quot;object&quot;</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;photoUrls&quot;</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">id:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&quot;int64&quot;</span></span><br><span class="line">      <span class="attr">category:</span></span><br><span class="line">        <span class="string">$ref:</span> <span class="string">&quot;#/definitions/Category&quot;</span></span><br><span class="line">      <span class="attr">name:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">        <span class="attr">example:</span> <span class="string">&quot;doggie&quot;</span></span><br><span class="line">      <span class="attr">photoUrls:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;array&quot;</span></span><br><span class="line">        <span class="attr">xml:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&quot;photoUrl&quot;</span></span><br><span class="line">          <span class="attr">wrapped:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;array&quot;</span></span><br><span class="line">        <span class="attr">xml:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&quot;tag&quot;</span></span><br><span class="line">          <span class="attr">wrapped:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="string">$ref:</span> <span class="string">&quot;#/definitions/Tag&quot;</span></span><br><span class="line">      <span class="attr">status:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">&quot;pet status in the store&quot;</span></span><br><span class="line">        <span class="attr">enum:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;available&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;pending&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;sold&quot;</span></span><br><span class="line">    <span class="attr">xml:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;Pet&quot;</span></span><br></pre></td></tr></table></figure><p>ここでは、 <code>name</code> というプロパティに <code>example</code> として <code>Doggie</code> という値が指定されています。では、モックサーバから返却される値を見てみます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;category&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>:<span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;string&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;doggie&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;photoUrls&quot;</span>:[</span><br><span class="line">      <span class="string">&quot;string&quot;</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;tags&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;id&quot;</span>:<span class="number">0</span>,</span><br><span class="line">         <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;string&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;available&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ちゃんとexampleで指定した値が返ってきていることがわかります。exampleを指定していない部分は、 <code>0</code> や　<code>&quot;string&quot;</code> に固定されてしまうものの、正しい型で返ってきています。なお、モックサーバの起動時に <code>-d</code> オプションをつけることで、値をランダムに変更することができます。</p><h3 id="basePath-が反映されない"><a href="#basePath-が反映されない" class="headerlink" title="basePath が反映されない"></a><code>basePath</code> が反映されない</h3><p>ここが詰まったポイントです。今回Prismを導入したプロジェクトではOAS2.0を使用しており、現行最新版のOAS3.0と比べると、仕様が異なる点があります。</p><p>OAS2.0では、エンドポイントのパスを以下のように設定します。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">&quot;petstore.swagger.io&quot;</span></span><br><span class="line"><span class="attr">basePath:</span> <span class="string">&quot;/v2&quot;</span></span><br><span class="line"><span class="attr">schemes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;https&quot;</span></span><br></pre></td></tr></table></figure><p>OAS3.0では <code>basePath</code> が削除され、以下のように記述します。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">https://petstore.swagger.io/v2</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">server</span> <span class="string">description</span></span><br></pre></td></tr></table></figure><p><code>schemes</code>、 <code>host</code>、 <code>basePath</code> が <code>servers</code> という一つのプロパティにまとまったおかげで見やすくなりました。</p><p>Prismはv3からOAS3.0での書き方に準拠するようになり、 <strong>OAS2.0のファイルを読み込ませると、<code>basePath</code>を読み取ってくれず、エンドポイントのパスに反映されません</strong> 。つまり、 <code>https://petstore.swagger.io/v2/pets</code> というエンドポイントを定義していたとしても、Prismでは <code>https://petstore.swagger.io/pets</code> として認識してしまいます。</p><p>これではモックサーバとしての意味を為さないため、<strong>エンドポイントのパスを変更する必要</strong>があります。</p><h4 id="Vue-CLIのプロキシ機能で解決する"><a href="#Vue-CLIのプロキシ機能で解決する" class="headerlink" title="Vue CLIのプロキシ機能で解決する"></a>Vue CLIのプロキシ機能で解決する</h4><p>今回のフロントエンドで利用しているVue.jsは、Vue CLIを用いて環境構築されています。Vue CLIには、webpackの <code>DevServer</code> の機能が内包されており、ホットリロードなどを実現しています。この機能の一つに、 <strong>APIサーバなど外部のサーバをプロキシして接続する機能</strong>があります。</p><p>このプロキシ機能で、 <code>pathRewrite</code> というオプションを指定すると、<strong>パスを上書き</strong>することができます。</p><p>実際に設定してみましょう。例えば、フロントエンドから <code>http://localhost:3000/api1/v1/</code> にリクエストを飛ばすと、 <code>http://localhost:8080/api1/v1/</code> に繋がるようになっている環境であるとします。</p><figure class="highlight javascript"><figcaption><span>vue.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;^/api1/&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://localhost:8080/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;^/api2/&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://localhost:8081/&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/20210410/image.png"></p><p>このAPIサーバ <code>api1</code> と <code>api2</code> をモックサーバに置き換えたいとします。しかし、前述の通りPrismでは <code>/api1/v1</code> の部分を無視してしまうため、そのままではアクセスすることができません。そこで使うのが、 <code>pathRewrite</code> オプションです。</p><p>例えば以下の例では、 <code>NODE_ENV</code> に <code>design</code> という値が設定されている場合のみ、 <code>http://localhost:3000/api1/v1/</code> が <code>http://localhost:8080/</code> にプロキシされるように設定しています。</p><figure class="highlight javascript"><figcaption><span>vue.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;^/api1/&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://localhost:8080/&#x27;</span>,</span><br><span class="line">        pathRewrite:</span><br><span class="line">          process.env.NODE_ENV === <span class="string">&#x27;design&#x27;</span> ? &#123; <span class="string">&#x27;^/api1/v1/&#x27;</span>: <span class="string">&#x27;/&#x27;</span> &#125; : <span class="literal">null</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;^/api2/&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://localhost:8081/&#x27;</span>,</span><br><span class="line">        pathRewrite:</span><br><span class="line">          process.env.NODE_ENV === <span class="string">&#x27;design&#x27;</span> ? &#123; <span class="string">&#x27;^/api2/v1/&#x27;</span>: <span class="string">&#x27;/&#x27;</span> &#125; : <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/20210410/image_2.png"></p><p>これで、実際に先ほどの手順でモックサーバを起動してみて、 <code>http://localhost:3000/api/v1/</code> にアクセスしレスポンスが返ってきたらOKです。</p><h3 id="npm-scriptでコマンド一つで起動できるようにする"><a href="#npm-scriptでコマンド一つで起動できるようにする" class="headerlink" title="npm scriptでコマンド一つで起動できるようにする"></a>npm scriptでコマンド一つで起動できるようにする</h3><p>せっかくなので<strong>コマンド一つで起動できるようにして、楽に開発がスタートできるように</strong>しておきたいです。まずは、以下のパッケージをインストールします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D cross-env concurrently</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/cross-env">cross-env</a> は、Windows環境下で <code>NODE_ENV</code> を指定すると正常にコマンドを実行できない問題があるため、<strong>環境差異を解消</strong>すべく導入しています。</p><p><a href="https://www.npmjs.com/package/concurrently">concurrently</a> は、<strong>同時に複数のコマンドを実行できる</strong>ようにします。今回はPrismによるモックサーバを2つ、vue-cliの開発サーバを1つ、合計3つのコマンドを同時実行させます。</p><p>インストールできたら、 <code>package.json</code> の <code>scripts</code> に追記します。ここでは、モックサーバの起動スクリプトを別に分けて、モックサーバを個別で起動できるようにもしています。</p><figure class="highlight"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  scripts: &#123;</span><br><span class="line">    &quot;design&quot;: &quot;cross-env NODE_ENV=design concurrently \&quot;npm run mock-1\&quot; \&quot;npm run mock-2\&quot; \&quot;vue-cli-service serve --mode design --open\&quot;&quot;,</span><br><span class="line">    &quot;mock-1&quot;: &quot;npx prism mock ./swagger1.yaml -p 8080&quot;,</span><br><span class="line">    &quot;mock-2&quot;: &quot;npx prism mock ./swagger2.yaml -p 8081&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>あとは、</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run design</span><br></pre></td></tr></table></figure><p>を実行すれば、モックサーバが2つとVue CLIの開発サーバが立ち上がり、 <code>http://localhost:3000</code> で確認できるようになります。これで、簡単にフロントエンドを開発できるようになりました！🎉</p><h2 id="補足-nginxを使ってプロキシする方法"><a href="#補足-nginxを使ってプロキシする方法" class="headerlink" title="補足: nginxを使ってプロキシする方法"></a>補足: nginxを使ってプロキシする方法</h2><p>今回のプロジェクトでは、Vue CLIを使っていたため、簡単にプロキシすることができました。しかし、中にはプロキシ機能をもたないものを利用しているケースもあると思います。</p><p>そこで、 <code>docker-compose</code> を用いて <code>nginx</code> と <code>prism</code> のコンテナを立てて、<code>nginx</code>にプロキシさせる方法を紹介します。</p><h3 id="docker-composeファイル"><a href="#docker-composeファイル" class="headerlink" title="docker-composeファイル"></a>docker-composeファイル</h3><p>まず、<code>nginx</code> のコンテナに <code>nginx:alpine</code> のイメージを選択し、8080番ポートと8081番ポートを開け、volumesに設定ファイルを指定します。次に、それぞれのモックサーバのコンテナに <code>stoplight/prism:3</code> のイメージを選択し、volumesにOpenAPIファイルを指定します。</p><figure class="highlight yaml"><figcaption><span>docker-compose.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.19-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./default.conf:/etc/nginx/conf.d/default.conf</span></span><br><span class="line">  <span class="attr">api1-mock:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">stoplight/prism:4</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mock</span> <span class="string">-h</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="string">/swagger.yaml</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./swagger1.yaml:/swagger.yaml</span></span><br><span class="line">  <span class="attr">api2-mock:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">stoplight/prism:4</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mock</span> <span class="string">-h</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="string">/swagger.yaml</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./swagger2.yaml:/swagger.yaml</span></span><br></pre></td></tr></table></figure><h3 id="nginx設定ファイル"><a href="#nginx設定ファイル" class="headerlink" title="nginx設定ファイル"></a>nginx設定ファイル</h3><p>nginx設定ファイルは、 <code>location</code> の部分にパスを書き、プロキシの設定を書くことで、<strong>そのパス以降に来たリクエストをリバースプロキシすることができる</strong>ようになります。この例では、 <code>0.0.0.0:8080/api1/v1</code> に来たアクセスを、 <code>api1-mock</code> コンテナの4010番ポートにプロキシするように設定しています。</p><figure class="highlight plain"><figcaption><span>default.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  0.0.0.0:8080;</span><br><span class="line">    location &#x2F;api1&#x2F;v1&#x2F; &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Server $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;api1-mock:4010&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       8081;</span><br><span class="line">    server_name  0.0.0.0:8081;</span><br><span class="line">    location &#x2F;api2&#x2F;v1&#x2F; &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Server $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;api2-mock:4010&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>あとは、docker-compose.yamlファイルがある場所で、以下のコマンドを実行すると、2つのモックサーバを同時に立ち上げることができます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -p (任意の名前) up -d</span><br></pre></td></tr></table></figure><p>立ち上げた後に、 <code>http://localhost:8080/api1/v1/</code> にアクセスして、レスポンスが返ってきたらOKです。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Prismを使うことで、OpenAPIファイルさえ記述していれば簡単にモックサーバとして機能し、開発に効果的に組み込むことができます。ローカルにバックエンドサーバを立ち上げる手間が省けて、<strong>開発体験を格段に向上</strong>させることができました。</p><p>ぜひ皆さんも快適な開発環境構築のために、導入を検討してみてはいかがでしょうか。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは！フューチャー22卒内定者の大岩と申します。現在は、TIG DXユニットでアルバイトとして従事しています。&lt;/p&gt;
&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Swagger" scheme="https://future-architect.github.io/tags/Swagger/"/>
    
    <category term="OpenAPI" scheme="https://future-architect.github.io/tags/OpenAPI/"/>
    
    <category term="Vue.js" scheme="https://future-architect.github.io/tags/Vue-js/"/>
    
    <category term="Prism" scheme="https://future-architect.github.io/tags/Prism/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.16のgo:embedとNext.jsの相性が悪い問題と戦う</title>
    <link href="https://future-architect.github.io/articles/20210409/"/>
    <id>https://future-architect.github.io/articles/20210409/</id>
    <published>2021-04-08T15:00:00.000Z</published>
    <updated>2021-04-11T08:23:22.297Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210409/nextjs_and_go_icon.svg" class="img-middle-size"><p>前エントリーの<a href="/articles/20210408/">Go 1.16のembedとchiとSingle Page Application</a>では、Vue.jsで生成したファイルをバンドルしました。Vue.jsや、Parcel V2でビルドしたコンテンツを配信するにはこれで問題ありません。しかし、React（Next.js）は要注意です。</p><p>フロントエンドの環境整備をどうやって行うかはいつも悩みの種ですが、そんな中、僕が3年ほど前から他の人にお勧めしていたのがNext.jsでした。ほとんどの最低限必要なツール群は整備済みで、最近のバージョンであればTypeScriptを使うのも簡単。Linter(npm exec eslint –init)とFormatter(npm install prettierと環境整備)ぐらいでコードを書き始められます。</p><p>しかし、環境構築が簡単なNext.js製のウェブアプリケーションのビルド済みのフロントエンドのファイル群をGoアプリにバンドルしようとしたらうまく動かず、それの追試をしました。</p><h1 id="試した環境"><a href="#試した環境" class="headerlink" title="試した環境"></a>試した環境</h1><p>go:embedはフォルダ指定するときは現在地よりも親のフォルダは指定できません。ディレクトリトラバーサルの脆弱性を生み出さないための制約かと思われます。こんな感じのフォルダ構成にしてました。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── cmd</span><br><span class="line">│   └── single-go-web</span><br><span class="line">│       └── main.go</span><br><span class="line">├── embed.go              : go:embedディレクティブコメントを書いたファイル</span><br><span class="line">├── frontend              : npm exec create-next-appで生成</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── next-env.d.ts</span><br><span class="line">│   ├── out&#x2F;              : npm exec next exportが生成する成果物のフォルダ</span><br><span class="line">│   ├── package-lock.json</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── pages&#x2F;</span><br><span class="line">│   └── tsconfig.json</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── handler.go</span><br><span class="line">└── notfound.go</span><br></pre></td></tr></table></figure><p>embed.goはこんな感じです。</p><figure class="highlight go"><figcaption><span>embed.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goweb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;embed&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed frontend/out/*</span></span><br><span class="line"><span class="keyword">var</span> assets embed.FS</span><br></pre></td></tr></table></figure><h1 id="何が起きたのか"><a href="#何が起きたのか" class="headerlink" title="何が起きたのか"></a>何が起きたのか</h1><p>作ったNext.jsのファイルを取り込んでウェブサーバーとして起動するコードを書いたのですが、トップページの静的なタグは表示されるものの、具体的にはファイルがいくつか取得できないようでうまく動きませんでした。こんな感じです。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021&#x2F;03&#x2F;17 08:52:23 not found &#x2F;_next&#x2F;static&#x2F;chunks&#x2F;pages&#x2F;_app-e86e439f5882a1d9aed3.js</span><br><span class="line">2021&#x2F;03&#x2F;17 08:52:23 not found &#x2F;_next&#x2F;static&#x2F;ZBndKz8ZARrIJBK8V3vpd&#x2F;_buildManifest.js</span><br><span class="line">2021&#x2F;03&#x2F;17 08:52:23 not found &#x2F;_next&#x2F;static&#x2F;ZBndKz8ZARrIJBK8V3vpd&#x2F;_ssgManifest.js</span><br></pre></td></tr></table></figure><p>エラーになったファイル以外のindex.htmlとか他のファイルは読み込めていました。go embedの説明によると、ディレクトリを自動で探索する場合にアンダースコアとピリオドスタートのファイルは無視されるとのこと。ただし、明示的に指定すれば良いみたいです。</p><blockquote><p>If a pattern names a directory, all files in the subtree rooted at that directory are embedded (recursively), except that files with names beginning with ‘.’ or ‘_’ are excluded. So the variable in the above example is almost equivalent to:</p></blockquote><p>実験してみました。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── _test</span><br><span class="line">│   ├── a.txt</span><br><span class="line">│   ├── _b.txt</span><br><span class="line">│   └── dir</span><br><span class="line">│       ├── c.txt</span><br><span class="line">│       └── _d.txt</span><br><span class="line">├── embed-test</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── test</span><br><span class="line">    ├── _f.txt</span><br><span class="line">    └── e.txt</span><br></pre></td></tr></table></figure><p>それぞれ、go:embedディレクティブに書いたセレクターと選択されるファイルの相関は次の通りです。</p><table><thead><tr><th align="center">ファイル</th><th align="center"><code>_test</code>, <code>test</code></th><th align="center"><code>_test/*</code>, <code>test/*</code></th><th align="center"><code>_test/*</code>, <code>_test/*/*</code>, <code>test/*</code></th></tr></thead><tbody><tr><td align="center"><code>_test/a.txt</code></td><td align="center">✔︎</td><td align="center">✔︎</td><td align="center">✔︎</td></tr><tr><td align="center"><code>_test/_b.txt</code></td><td align="center"></td><td align="center">✔︎</td><td align="center">✔︎</td></tr><tr><td align="center"><code>_test/dir/c.txt</code></td><td align="center">✔︎</td><td align="center">✔︎</td><td align="center">✔︎</td></tr><tr><td align="center"><code>_test/dir/_d.txt</code></td><td align="center"></td><td align="center"></td><td align="center">✔︎</td></tr><tr><td align="center"><code>test/e.txt</code></td><td align="center">✔︎</td><td align="center">✔︎</td><td align="center">✔︎</td></tr><tr><td align="center"><code>text/_f.txt</code></td><td align="center"></td><td align="center">✔︎</td><td align="center">✔︎</td></tr></tbody></table><p>深いフォルダでもアスタリスクを駆使すればなんとかなりそうです。 ということで、改めてNext.jsのファイルのバンドルに挑戦。</p><h1 id="新たな敵、空フォルダ"><a href="#新たな敵、空フォルダ" class="headerlink" title="新たな敵、空フォルダ"></a>新たな敵、空フォルダ</h1><p>というわけでバシバシ追加していったのですが、次のようなエラーがビルド時に出るようになりました。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build</span><br><span class="line">../../embed.go:8:12: pattern frontend/out/*/*: cannot embed directory frontend/out/_next/qi68kQOpQjkJ0HbA6IoFl: contains no embeddable files</span><br></pre></td></tr></table></figure><p>Next.jsがビルド時にこのフォルダを作るのですが、ファイルが一個もなく、それを処理できないようです。選択可能なファイルがない場合にエラーになるので、.keepみたいなファイルをおいてもダメです（選択がアスタリスクとアンダーバーは無視されるので）。一番簡単なのはこういうフォルダを削除しておくことです。空フォルダが絶対必要です、というシステムがあるとダメなので、その場合は別の方法が必要ですね。</p><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>最終的にアセットをバンドルするディレクティブコメントはこのようになりました。これで無事、実行に必要なファイルを全てバンドルできました。きちんとGo製のサーバーも動きました。</p><p>少なくともNext.js 10.0.9ではこれで動きそうです。まあとてもシンプルな画面しか作っていないのでもっといろんな要素を入れていったり、Next.jsのバージョンが上がると動かなくなる可能性もありますが・・・</p><figure class="highlight go"><figcaption><span>asset.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:embed frontend/out/*</span></span><br><span class="line"><span class="comment">//go:embed frontend/out/_next/static/*/*</span></span><br><span class="line"><span class="comment">//go:embed frontend/out/_next/static/chunks/pages/*.js</span></span><br><span class="line"><span class="comment">//go:embed frontend/out/_next/static/chunks/pages/next/dist/pages/*</span></span><br><span class="line"><span class="keyword">var</span> assets embed.FS</span><br></pre></td></tr></table></figure><p>前回とちょっと違うところが1つあります。Next.jsの静的サイト生成の場合、<code>pages/page2.tsx</code>ファイルは<code>page2.html</code>ファイルとなります。しかし、他のページから遷移すると<code>/page2</code>というパスがアドレスバーに表示されます。ここでリロードしたりすると、最初に<code>/page2</code>という拡張子なしのファイルを読み込もうとしますが、それではうまく動作しません。<code>index.html</code>にフォールバックしてもダメでした。</p><p>この場合は、<code>/page2</code>にリクエストがきたら、<code>/page2.html</code>を返してあげれば良いので、失敗時のフォールバックをもう一つ増やして、拡張子つきで再リトライしてみるようにしてあげる必要があります。</p><figure class="highlight go"><figcaption><span>notfound.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFoundHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// まずはリクエストされた通りにファイルを探索</span></span><br><span class="line">err := tryRead(assets, <span class="string">&quot;frontend/out&quot;</span>, r.URL.Path, w)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SSGでは.htmlファイルが生成されるが、リクエストされるページは拡張子なし</span></span><br><span class="line"><span class="comment">// かもしれない</span></span><br><span class="line">err = tryRead(assets, <span class="string">&quot;frontend/out&quot;</span>, r.URL.Path+<span class="string">&quot;.html&quot;</span>, w)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 見つからなければindex.htmlを返す</span></span><br><span class="line">err = tryRead(assets, <span class="string">&quot;frontend/out&quot;</span>, <span class="string">&quot;index.html&quot;</span>, w)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これでNext.jsで作った静的サイトも、Go 1.16にバンドルできるようになります。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210409/nextjs_and_go_icon.svg&quot; class=&quot;img-middle-size&quot;&gt;

&lt;p&gt;前エントリーの&lt;a href=&quot;/articles/20210408/&quot;&gt;Go 1.16のembedとchiとSingl</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.16" scheme="https://future-architect.github.io/tags/Go1-16/"/>
    
    <category term="Next.js" scheme="https://future-architect.github.io/tags/Next-js/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.16のembedとchiとSingle Page Application</title>
    <link href="https://future-architect.github.io/articles/20210408/"/>
    <id>https://future-architect.github.io/articles/20210408/</id>
    <published>2021-04-07T15:00:00.000Z</published>
    <updated>2021-04-11T08:20:25.892Z</updated>
    
    <content type="html"><![CDATA[<p>シングルページアプリケーションは、一つのHTMLファイルであらゆるページを表現します。history APIを使ってそのようなページが実際にあるかのように振る舞います。</p><p>一方で、画面がリロードされたとき、メールでSNSでシェアされたときにその該当ページをきちんと再現するためには、サーバー側でハンドリングを行う必要があります。具体的には、存在しないページがリクエストされたら、アプリケーションのルートとなるHTMLファイルの内容をそのURLから配信するというものです。</p><p><a href="https://angular.jp/guide/deployment#server-configuration">https://angular.jp/guide/deployment#server-configuration</a></p><p>それにより、どのURLでもJavaScriptが動作し、そのURLで表示すべきコンテンツが表示されます。もし想定していないパスの場合は、ウェブサーバーではなく、JavaScriptがエラーを出します。</p><p>Goでウェブサーバーを作る時もSingle Page Applicationをホストする場合、同じような動作をさせる必要があります。以前、ファイルをバンドルするパッケージを作った時は、そのようなライブラリもセットで実装しました。今回は<code>go:embed</code>で同じことをやってみます。</p><p><a href="https://pkg.go.dev/go.pyspa.org/brbundle">https://pkg.go.dev/go.pyspa.org/brbundle</a></p><h1 id="ファイルの配信のハンドラー"><a href="#ファイルの配信のハンドラー" class="headerlink" title="ファイルの配信のハンドラー"></a>ファイルの配信のハンドラー</h1><p>やることは単純で、まず<code>go:embed</code>からファイルを探し、見つからなかったら、指定のファイル（index.html)を返します。拡張子からmimeタイプを決定してヘッダーフィルドに設定しています。</p><figure class="highlight go"><figcaption><span>notfound.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;embed&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;mime&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrDir = errors.New(<span class="string">&quot;path is dir&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRead</span><span class="params">(fs embed.FS, prefix, requestedPath <span class="keyword">string</span>, w http.ResponseWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := fs.Open(path.Join(prefix, requestedPath))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goのfs.Openはディレクトリを読みこもとうしてもエラーにはならないがここでは邪魔なのでエラー扱いにする</span></span><br><span class="line">stat, _ := f.Stat()</span><br><span class="line"><span class="keyword">if</span> stat.IsDir() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contentType := mime.TypeByExtension(filepath.Ext(requestedPath))</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, contentType)</span><br><span class="line">_, err = io.Copy(w, f)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFoundHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// まずはリクエストされた通りにファイルを探索</span></span><br><span class="line">err := tryRead(assets, <span class="string">&quot;frontend/dist&quot;</span>, r.URL.Path, w)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 見つからなければindex.htmlを返す</span></span><br><span class="line">err = tryRead(assets, <span class="string">&quot;frontend/dist&quot;</span>, <span class="string">&quot;index.html&quot;</span>, w)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このハンドラを起動するコードは以下のような感じです。環境変数からポート番号を決定するためにサードパーティパッケージを使っています。</p><p>chiにはマッチしなかったときに呼び出されるNotFoundハンドラがあるので、それに先に作ったハンドラを設定します。サーバーAPIがある場合は、同じrouter上に定義しておけばアセットの配布とAPIが共存できます。同じオリジンなので、CORSとかは考えなくてもOK。</p><p>きちんとシグナルを受けてgraceful shutdownもするように、<a href="https://future-architect.github.io/articles/20210212/">Go 1.16で追加されたsignal.NotifyContext()</a>を利用してシグナルに応答するようにしておきます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-chi/chi/v5&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/kelseyhightower/envconfig&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 環境変数からポート番号を取得するための構造体</span></span><br><span class="line"><span class="keyword">type</span> Env <span class="keyword">struct</span> &#123;</span><br><span class="line">Port <span class="keyword">uint16</span> <span class="string">`envconfig:&quot;PORT&quot; default:&quot;8000&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ハンドラの実装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHandler</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">router := chi.NewRouter()</span><br><span class="line"></span><br><span class="line">router.Route(<span class="string">&quot;/api&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(r chi.Router)</span></span> &#123;</span><br><span class="line"><span class="comment">// 何かAPIを足したい場合はここに足す</span></span><br><span class="line">r.Get(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// シングルページアプリケーションを配布するハンドラをNotFoundに設定</span></span><br><span class="line">router.NotFound(NotFoundHandler)</span><br><span class="line"><span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> env Env</span><br><span class="line">err := envconfig.Process(<span class="string">&quot;&quot;</span>, &amp;env)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;Can&#x27;t parse environment variables: %s\n&quot;</span>, err.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, os.Kill)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:    <span class="string">&quot;:&quot;</span> + strconv.FormatUint(<span class="keyword">uint64</span>(env.Port), <span class="number">10</span>),</span><br><span class="line">Handler: newHandler(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;start receiving at :%d\n&quot;</span>, env.Port)</span><br><span class="line">fmt.Fprintln(os.Stderr, server.ListenAndServe())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これでウェブサービスを1つのバイナリで提供できるようになります。GCP Cloud Runでも、AWS LambdaやGCP Functionsでも好きなようにデプロイできますね。</p><h1 id="フロントエンドのコードも作ってみる"><a href="#フロントエンドのコードも作ってみる" class="headerlink" title="フロントエンドのコードも作ってみる"></a>フロントエンドのコードも作ってみる</h1><p>複数のページがあるSPAのページを作ってみます。vue-cliでVue 3+TypeScript+Routerな感じで作りました。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% npx -p @vue/cli vue create frontend</span><br><span class="line"></span><br><span class="line">Vue CLI v4.5.12</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: Choose Vue version, Babel, TS, Router, Linter</span><br><span class="line">? Choose a version of Vue.js that you want to start the project with 3.x (Preview)</span><br><span class="line">? Use class-style component syntax? No</span><br><span class="line">? Use Babel alongside TypeScript (required <span class="keyword">for</span> modern mode, auto-detected polyfills, transpiling JSX)? Yes</span><br><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback <span class="keyword">in</span> production) Yes</span><br><span class="line">? Pick a linter / formatter config: Prettier</span><br><span class="line">? Pick additional lint features: Lint on save</span><br><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.? In dedicated config files</span><br><span class="line">? Save this as a preset <span class="keyword">for</span> future projects? No</span><br></pre></td></tr></table></figure><p>これで複数ページを持ったSPAなWebページができあがるので、ビルドして静的HTMLとJSなどにします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br><span class="line"></span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"> DONE  Build complete. The dist directory is ready to be deployed.</span><br><span class="line"> INFO  Check out deployment instructions at https://cli.vuejs.org/guide/deployment.html</span><br></pre></td></tr></table></figure><p>これをバイナリにバンドルするためのファイルを定義します。</p><figure class="highlight go"><figcaption><span>asset.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;embed&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed frontend/dist/*</span></span><br><span class="line"><span class="keyword">var</span> assets embed.FS</span><br></pre></td></tr></table></figure><p>あとは先ほどのmain.goとnotfound.goも一緒に置いて、ビルドして実行したら完成です。トップのページだけではなく、<code>/about</code>のページで画面をリロードして（最初の読み込みがファイル上存在しない<code>/about</code>）も、正しく表示されればOKです。</p><p><img src="/images/20210408/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-03-18_21.53.16.png"></p><p>コードは以下のところに置いてあります。</p><p><a href="https://github.com/shibukawa/spa-go-1.16">https://github.com/shibukawa/spa-go-1.16</a></p><h2 id="2021-04-09追記"><a href="#2021-04-09追記" class="headerlink" title="2021/04/09追記"></a>2021/04/09追記</h2><p>続編の<a href="/articles/20210408/">Go 1.16のgoembedとNext.jsの相性が悪い問題と戦う</a> が公開されました。合わせてどうぞ。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;シングルページアプリケーションは、一つのHTMLファイルであらゆるページを表現します。history APIを使ってそのようなページが実際にあるかのように振る舞います。&lt;/p&gt;
&lt;p&gt;一方で、画面がリロードされたとき、メールでSNSでシェアされたときにその該当ページをきちん</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.16" scheme="https://future-architect.github.io/tags/Go1-16/"/>
    
    <category term="SPA" scheme="https://future-architect.github.io/tags/SPA/"/>
    
    <category term="chi" scheme="https://future-architect.github.io/tags/chi/"/>
    
  </entry>
  
</feed>
