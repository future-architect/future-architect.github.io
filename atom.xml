<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2021-08-19T15:32:42.959Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 1.17の sync／atomic パッケージ更新点と CompareAndSwap</title>
    <link href="https://future-architect.github.io/articles/20210820a/"/>
    <id>https://future-architect.github.io/articles/20210820a/</id>
    <published>2021-08-19T15:00:00.000Z</published>
    <updated>2021-08-19T15:32:42.959Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210820a/cas.png" alt="" width="900" height="393" loading="lazy"><p>The Gopher character is based on the Go mascot designed by <a href="http://reneefrench.blogspot.com/">Renee French</a>.</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIGの市川です。<a href="/articles/20210810a/">Go 1.17連載</a>のラストです。前回は宮崎さんによる「<a href="/articles/20210819b/">Go1.17で警告されるようになったerror#Is/As/Unwrap</a>」の解説でした。</p><p>この記事では、Go 1.17で変更になった <code>sync/atomic</code> パッケージについて解説します。</p><h2 id="Go-1-17の-sync-atomic-パッケージ更新点"><a href="#Go-1-17の-sync-atomic-パッケージ更新点" class="headerlink" title="Go 1.17の sync/atomic パッケージ更新点"></a>Go 1.17の sync/atomic パッケージ更新点</h2><p><code>sync/atomic</code> パッケージの <code>atomic.Value</code> に以下のメソッドが追加されました。</p><ul><li>CompareAndSwap</li><li>Swap</li></ul><p>Go 1.16以前でもCompare And Swap(以下CAS)とSwapの関数はintとuintの32, 64型とPointer型の関数が用意されてました。今回の変更により <code>atomic.Value</code> でCASが利用可能になりました。</p><h2 id="CASについて"><a href="#CASについて" class="headerlink" title="CASについて"></a>CASについて</h2><p>CASは文字通り、比較と置換をアトミックに行う命令です。<br>処理は次の1~3です。</p><ol><li>「現在の値」と「以前取得した値」を比較</li><li>異なる場合はFalseを返す</li><li>一致した場合は「現在の値」を「新しい値に」入れ替えTrueを返す</li></ol><p>CASからFalseが返った場合には、割り込みによって値が変わったと判断し、改めて取得からやり直します。</p><p>通常ロックしてから処理を行う場合と比較し、ロック時間が短くなることが利点です。(<a href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html">こちらの記事</a>の図が非常に分かりやすいと感じました。)</p><h2 id="CompareAndSwap実装例"><a href="#CompareAndSwap実装例" class="headerlink" title="CompareAndSwap実装例"></a>CompareAndSwap実装例</h2><p>並列処理で <code>*big.Int</code> の共有カウンタを回す処理のサンプルです。<code>sync.WaitGroup</code> は並列処理の完了制御で利用してます。</p><p><a href="https://play.golang.org/p/7IKfoh7wYJT">https://play.golang.org/p/7IKfoh7wYJT</a></p><p>(Playground上では仕様により処理時間が0秒になります。)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter := big.NewInt(<span class="number">0</span>)</span><br><span class="line">delta := big.NewInt(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> m atomic.Value</span><br><span class="line">m.Store(counter) <span class="comment">// 値を保存</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Since(start))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">newVal := big.NewInt(<span class="number">0</span>)</span><br><span class="line">oldVal := m.Load().(*big.Int) <span class="comment">// 値を取得</span></span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">newVal.Add(oldVal, delta)</span><br><span class="line"><span class="keyword">if</span> m.CompareAndSwap(oldVal, newVal) &#123;</span><br><span class="line"><span class="comment">// oldValの値が一致し置換を成功</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(m.Load().(*big.Int)) <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int64などの場合には <code>atomic.AddInt64</code> などの専用の関数が用意されており、Compare And Swapを利用しなくても実装可能です。<br>実装例: <a href="https://play.golang.org/p/8IeIITMaMzs">https://play.golang.org/p/8IeIITMaMzs</a></p><h2 id="CompareAndSwapと別の処理方式との比較"><a href="#CompareAndSwapと別の処理方式との比較" class="headerlink" title="CompareAndSwapと別の処理方式との比較"></a>CompareAndSwapと別の処理方式との比較</h2><h3 id="CompareAndSwapPointerを使った実装との比較"><a href="#CompareAndSwapPointerを使った実装との比較" class="headerlink" title="CompareAndSwapPointerを使った実装との比較"></a>CompareAndSwapPointerを使った実装との比較</h3><p>既存で用意されている <code>CompareAndSwapPointer</code> を利用した実装です。</p><p><a href="https://play.golang.org/p/cFZhpZIZVni">https://play.golang.org/p/cFZhpZIZVni</a><br>(Playground上では仕様により処理時間が0秒になります。)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter := big.NewInt(<span class="number">0</span>)</span><br><span class="line">delta := big.NewInt(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Since(start))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">newVal := big.NewInt(<span class="number">0</span>)</span><br><span class="line">oldVal := atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;counter)))</span><br><span class="line">newVal.Add((*big.Int)(oldVal), delta)</span><br><span class="line"><span class="comment">//time.Sleep(time.Microsecond)</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;counter)), oldVal, unsafe.Pointer(newVal)) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println((*big.Int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;counter))))) <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CompareAndSwapPointer</code> での実装と比較し <code>unsafe.Pointer</code> を使わずに済み、<code>CompareAndSwap</code> のほうがシンプルに書けるようになりました。</p><p>ちなみに処理時間はあまり変わりませんでした。</p><h3 id="排他制御との比較"><a href="#排他制御との比較" class="headerlink" title="排他制御との比較"></a>排他制御との比較</h3><p>前章で記載した共有カウントを排他制御を使った実装です。</p><p><a href="https://play.golang.org/p/Lt9FYmefo5m">https://play.golang.org/p/Lt9FYmefo5m</a><br>(Playground上では仕様により処理時間が0秒になります。)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter := big.NewInt(<span class="number">0</span>)</span><br><span class="line">delta := big.NewInt(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> mt sync.Mutex</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Since(start))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">mt.Lock()</span><br><span class="line"><span class="keyword">defer</span> mt.Unlock()</span><br><span class="line"><span class="comment">//time.Sleep(time.Microsecond)</span></span><br><span class="line">counter.Add(counter, delta)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(counter) <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排他処理での実装はSwapの処理がいらないためシンプルな実装になります。</p><p><code>time.Sleep</code> のコメントアウトを外した場合の処理時間を比較すると手元の環境でCAS: 約23ms, 排他制御: 約500msと20倍以上の処理時間がかかりました。時間がかかる処理を行う場合にはCAS方式のほうが処理が早そうです。<br>(Sleepがない場合には、CAS: 約3.0ms, 排他制御: 約2.5msと排他制御のほうが処理時間が短い結果となりました。)</p><h2 id="Swapの実装サンプル"><a href="#Swapの実装サンプル" class="headerlink" title="Swapの実装サンプル"></a>Swapの実装サンプル</h2><p>Swapのほうは良い例を思いつかなかったので、単純なサンプルを載せます。<br><a href="https://play.golang.org/p/te6ewTUvomV">https://play.golang.org/p/te6ewTUvomV</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bi := big.NewInt(<span class="number">1</span>)</span><br><span class="line">newVal := big.NewInt(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> m atomic.Value</span><br><span class="line">m.Store(bi)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;before:&quot;</span>, m.Load().(*big.Int)) <span class="comment">// before: 1</span></span><br><span class="line">oldVal := m.Swap(newVal).(*big.Int)</span><br><span class="line">fmt.Println(<span class="string">&quot;oldVal:&quot;</span>, oldVal)             <span class="comment">// oldVal: 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;after:&quot;</span>, m.Load().(*big.Int)) <span class="comment">// after: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記のサンプルを既存の関数 <code>SwapPointer</code> で書くと以下のようになります。<br><a href="https://play.golang.org/p/HcUrh3J4uNo">https://play.golang.org/p/HcUrh3J4uNo</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bi := big.NewInt(<span class="number">1</span>)</span><br><span class="line">newVal := big.NewInt(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;before:&quot;</span>, (*big.Int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;bi))))) <span class="comment">// before: 1</span></span><br><span class="line">oldVal := atomic.SwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;bi)), unsafe.Pointer(newVal))</span><br><span class="line">fmt.Println(<span class="string">&quot;oldVal:&quot;</span>, (*big.Int)(oldVal))                                                    <span class="comment">// oldVal: 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;after:&quot;</span>, (*big.Int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;bi))))) <span class="comment">// after: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swapのケースでも既存の関数の利用と比べシンプルかつ <code>unsafe.Pointer</code> を使わずに記述出来るようになりました。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li><code>atomic.Value</code> で <code>CompareAndSwap</code>, <code>Swap</code> のメソッドが追加になった。</li><li>既存の <code>atomic.CompareAndSwapPointer</code>, <code>atomic.SwapPointer</code> 関数と比較し、 <code>unsafe.Pointer</code> を利用せずに任意の型でCASやSwapが実装可能になった。</li><li>処理時間がかかる場合には排他処理よりもCASが有利になるケースを確認した。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210820a/cas.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;393&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;The Gopher character is based on the Go mascot desi</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
    <category term="排他制御" scheme="https://future-architect.github.io/tags/%E6%8E%92%E4%BB%96%E5%88%B6%E5%BE%A1/"/>
    
    <category term="ロックフリー" scheme="https://future-architect.github.io/tags/%E3%83%AD%E3%83%83%E3%82%AF%E3%83%95%E3%83%AA%E3%83%BC/"/>
    
  </entry>
  
  <entry>
    <title>Go1.17で警告されるようになったerror#Is/As/Unwrap</title>
    <link href="https://future-architect.github.io/articles/20210819b/"/>
    <id>https://future-architect.github.io/articles/20210819b/</id>
    <published>2021-08-18T15:00:01.000Z</published>
    <updated>2021-08-19T04:07:12.826Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210819b/errors.png" alt="" width="900" height="304" loading="lazy"><p>The Gopher character is based on the Go mascot designed by <a href="http://reneefrench.blogspot.com/">Renee French</a>.</p><h1 id="始めに"><a href="#始めに" class="headerlink" title="始めに"></a>始めに</h1><p>TIG DXUnitの宮崎です。</p><p>2021/8/16にGo1.17がリリースされましたね。</p><p><a href="/articles/20210810a/">Go 1.17連載</a>第6回目ということで、Go Vetによる静的解析が強化され、<code>error</code>を実装した構造体に対する<code>Is/As/Unwrap</code>のシグネチャチェックが実施されるようになったという小ネタを紹介します。</p><p><code>errors.Is/As/Unwrap</code> に関しては<a href="/articles/20200523/">Go Tips連載6: Error wrappingされた各クラウドSDKの独自型エラーを扱う</a>記事で復習もできますので、なんだっけ？という方は参照いただけるとです。</p><p>なお、この記事では以下の表記ルールとしています。</p><ul><li><code>errors</code>パッケージの<code>Is/As/Unwrap</code>メソッド<br>= <code>errors.Is/As/Unwrap</code></li><li><code>error</code>インターフェースを実装した構造体の<code>Is/As/Unwrap</code>メソッド<br>= <code>error#Is/As/Unwrap</code></li></ul><h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul><li><code>error</code>インターフェースを実装し、かつ<code>Is/As/Unwrap</code>メソッドを実装する場合、以下シグネチャ以外は警告されるようになった。<ul><li><code>Is(error) bool</code></li><li><code>As(interface&#123;&#125;) bool</code></li><li><code>Unwrap() error</code></li></ul></li><li>あくまで警告であり、ビルドも実行も可能</li><li>挙動にも変更点はなし</li></ul><h1 id="error-Is-As-Unwrap-is-何"><a href="#error-Is-As-Unwrap-is-何" class="headerlink" title="error#Is/As/Unwrap is  何"></a><code>error#Is/As/Unwrap</code> is  何</h1><p>Go1.17のリリースノートを引用すると以下の通り。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The vet tool now warns about methods named As, Is or Unwrap on types implementing the error interface that have a different signature than the one expected by the errors package.</span><br><span class="line">The errors.&#123;As,Is,Unwrap&#125; functions expect such methods to implement either Is(error) bool, As(interface&#123;&#125;) bool, or Unwrap() error respectively.</span><br><span class="line">The functions errors.&#123;As,Is,Unwrap&#125; will ignore methods with the same names but a different signature.</span><br></pre></td></tr></table></figure><p><code>error</code>インターフェースを実装した時に<code>Is/As/Unwrap</code>のシグネチャが間違ってた時に怒ってくれるようになったらしいです。<code>Is/As/Unwrap</code>をなんとなーくしか捉えていなかったので、これを期にしっかり学んでみます。</p><h2 id="そもそもerror"><a href="#そもそもerror" class="headerlink" title="そもそもerror"></a>そもそも<code>error</code></h2><p>Goの<code>error</code>インターフェースについての復習から。ご存知の通り、Goには<code>try/catch</code>構文が存在しなく、<code>error</code>インターフェースを実装した構造体を返却することで例外発生を表現します。<code>error</code>インターフェースとはGoに組込まれているインターフェースで、具体的には以下の通り定義されています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Error()</code>というメソッドを実装して<code>string</code>を返せばなんでも<code>error</code>になれるということですね。シンプルですが、これだけではエラーとしての表現力が乏しく、実際使う場合は具体的にどの型のエラーなのか、どの型が発生源なのかを判別して挙動を分岐させたりします。</p><p><code>errors.Is/As/Unwrap</code>はGo 1.13で導入された<code>error</code>の階層化や型比較を実現するためのメソッドです。</p><p>※<code>error</code>に関する記述は<a href="https://golang.org/src/errors/">ソース</a>を見るのが一番早いです。</p><h2 id="errors-Unwrap-error-Unwrap"><a href="#errors-Unwrap-error-Unwrap" class="headerlink" title="errors.Unwrap/error#Unwrap"></a><code>errors.Unwrap</code>/<code>error#Unwrap</code></h2><p>Go 1.13にて以下が追加され<code>error</code>の階層化ができるようになりました。</p><ul><li><code>errors.Unwrap</code></li><li><code>fmt.Errorf()</code>に、<code>%w</code>識別子が追加</li></ul><p><code>fmt.Errorf()</code>で階層化させて<code>Unwrap</code>で取り出すという流れですね。<code>errors.Unwrap</code>の実装は下記の通り。<code>Unwrap() error</code>を実装しない構造体の場合は<code>nil</code>が返却されるようになってます。階層化を実現するための重要なメソッドなのにシグネチャ違いで実装されていると予期した通りに動かないので、Vetが気を効かせてくれるようになったみたいですね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">u, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Unwrap() error</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u.Unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="errors-Is-error-Is"><a href="#errors-Is-error-Is" class="headerlink" title="errors.Is/error#Is"></a><code>errors.Is</code>/<code>error#Is</code></h2><p><code>errors.Is</code>は特定のエラーとの比較を、再起的に階層を掘って実施してくれます。<br>実装は以下の通り。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err == target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider supporting target.Is(err). This would allow</span></span><br><span class="line"><span class="comment">// user-definable predicates, but also may allow for coping with sloppy</span></span><br><span class="line"><span class="comment">// APIs, thereby making it easier to get away with them.</span></span><br><span class="line"><span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>やっていることは↓の通り。</p><ul><li>targetが比較可能なら比較</li><li><code>err</code>に <code>Is(err error) bool</code>メソッドが実装されていればcall</li><li>errをUnwrapする。できなければfalse返却</li></ul><p><code>Unwrap</code>のときと同じ具合で、シグネチャを確認するような実装になっていますね。</p><h2 id="errors-As-error-As"><a href="#errors-As-error-As" class="headerlink" title="errors.As/error#As"></a><code>errors.As</code>/<code>error#As</code></h2><p><code>errors.As</code>はエラーに対する型アサーションを実施してくれます。<br>実装は以下の通り。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">val := reflectlite.ValueOf(target)</span><br><span class="line">typ := val.Type()</span><br><span class="line"><span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">targetType := typ.Elem()</span><br><span class="line"><span class="keyword">if</span> targetType.Kind() != reflectlite.Interface &amp;&amp; !targetType.Implements(errorType) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">err = Unwrap(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>やっていることは以下です。</p><ul><li>targetが有効なポインタでなければエラー（errの型アサーション結果代入先であるため）</li><li>ループ<ul><li>targetにerrが代入可能なら代入して終了</li><li><code>As(interface&#123;&#125;) bool</code>メソッドがあればそれを呼ぶ。trueが帰ってくれば終了</li><li>Unwrapして次ループに入る</li></ul></li></ul><p>指定した型として扱えるまで階層を掘って試行してくれていますね。</p><p>ここでもシグネチャが大事になってきます。</p><h1 id="警告されるようになった実装"><a href="#警告されるようになった実装" class="headerlink" title="警告されるようになった実装"></a>警告されるようになった実装</h1><p>リリースノートのサンプルに戻ります。</p><p>以下がVetによって警告されるようになったとのことですが、具体的に言うと<code>Is</code>のシグネチャが間違っていますね。<code>errors.Is</code>を有効に使用するには<code>Is(err error) bool</code>として実装する必要があります。</p><p>↓の実装だとどんなに頑張っても<code>errors.Is</code>が<code>false</code>を返すので、何もないと貴重な時間を無駄にしたり、最悪の場合バグに気づかずリリースなんてことにもなりかねません。今回の修正でVetが怒ってくれるようになったので、そんな不幸なことが起きることが無くなったわけですね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123; hint <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; ... &#125; <span class="comment">// MyError implements error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(MyError)</span> <span class="title">Is</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123; ... &#125; <span class="comment">// target is interface&#123;&#125; instead of error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">x, y := MyError&#123;<span class="string">&quot;A&quot;</span>&#125;, MyError&#123;<span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> errors.Is(x, y) <span class="comment">// returns false as x != y and MyError does not have an `Is(error) bool` function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>というわけで<code>error#Is/As/Unwrap</code>ネタでした。</p><p>少しだけ平和な世界に近づいたようです。</p><p>次回は連載最後で市川さんの記事です。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210819b/errors.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;304&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;The Gopher character is based on the Go mascot d</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
    <category term="エラーハンドリング" scheme="https://future-architect.github.io/tags/%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0/"/>
    
  </entry>
  
  <entry>
    <title>エキスパートPythonプログラミング改訂3版が出版されました</title>
    <link href="https://future-architect.github.io/articles/20210819a/"/>
    <id>https://future-architect.github.io/articles/20210819a/</id>
    <published>2021-08-18T15:00:00.000Z</published>
    <updated>2021-08-19T10:11:17.768Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210819a/302105001236.jpeg" alt="" width="400" height="513" loading="lazy"><p>TIGの渋川です。エキスパートPythonプログラミング改訂3版が出版されました。ますます厚みを増し、買ってくれた知人からは、<a href="https://altema.jp/ffrk/weapon/1581">学者専用武器</a>なのでは、とか銃弾止められそうとか感想をいただいております。</p><p>詳しくは共訳の清水川さんがすでに記事にしています。</p><ul><li><a href="http://www.freia.jp/taka/blog/expert-python-programming-3rd-intro/index.html">『エキスパートPythonプログラミング 改訂3版』の紹介</a></li></ul><p>僕が最初に触ったPython 2.2と比べても、また原著の初版の時代と比べても、言語から標準ライブラリから周辺ツールまで、かなりの進展がありました。本書もそのような言語のバージョンアップやエコシステムの変化を取り入れています。一部翻訳でいろいろ加えた内容などもあります。</p><p>一方で、現在話題の機械学習は触れていません。逆にいえば、そちらのライブラリなどはいろいろ進展があったとしても、本書の内容は古くなったり価値が減ったりはしません。言語のコアやテスト、ドキュメントやビルド周りなど、そういうところのストイックなところにフォーカスしています。</p><p>原著が説明対象にとりあげているPythonバージョンは3.7ですが、3.9とか一部3.10の話題とかも取り入れつつ、現時点で最新の話題を扱う書籍となっています。どうしても翻訳本というのは元のソフトウェアがリリースされてから原著が書かれるまでのリードタイム、翻訳のリードタイムと、どうしても最新情報からは遅れがちなのですが、これまで初版、改訂2版、改訂3版とやってきた中でずっと行ってきたように、鮮度の高い書籍としていろいろ訳注が追加されたりしています。このあたり、Pythonのコアメンバーでもある稲田さんのパワーは絶大でした。</p><p>僕自身もいろいろコラム的なやつとか章とかを追記したりしました。僕が書き足した内容はだいたいこれぐらいですかね。いくつかは下書きを技術ブログとしても出しています。</p><ul><li><a href="https://future-architect.github.io/articles/20200721/">PythonユーザーのためのGraalVM</a></li><li><a href="https://future-architect.github.io/articles/20200910/">「2020年代のコンテナ時代のPythonアーキテクチャ&amp;デプロイ」というテーマでPyCon.jp 2020で発表してきました</a></li><li><a href="https://future-architect.github.io/articles/20200513/">仕事でPythonコンテナをデプロイする人向けのDockerfile (1): オールマイティ編</a></li><li><a href="https://future-architect.github.io/articles/20200514/">仕事でPythonコンテナをデプロイする人向けのDockerfile (2): distroless編</a></li><li>型ヒントの仕様の遷移（PEP集）</li><li>セイウチ演算子（walrus operator）</li><li><a href="https://future-architect.github.io/articles/20201223/">2021年版Pythonの型ヒントの書き方 (for Python 3.9)</a></li></ul><p>これらの内容ですが、英語でもまとまった内容がなかったり（Docker周りとか）したところで調べつつブログにまとめて書籍にも入れているので、世界でもトップクラスに情報の新鮮な書籍にできたのではないか、と思っています。</p><p>改訂2版からもページ数は100ページ増なのにお値段ほぼ据え置きということでお得度はかなり高い本になっていると思います。ぜひ、お手にとっていただきたいと思います。</p><h1 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h1><ul><li><a href="https://www.kadokawa.co.jp/product/302105001236/">アスキードワンゴの商品ページ</a></li><li><a href="https://www.amazon.co.jp/dp/B09BHTY4Z8/">Amazonの商品ページ</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210819a/302105001236.jpeg&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;513&quot; loading=&quot;lazy&quot;&gt;


&lt;p&gt;TIGの渋川です。エキスパートPythonプログラミング改訂3版が出版されました</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Python" scheme="https://future-architect.github.io/tags/Python/"/>
    
    <category term="出版" scheme="https://future-architect.github.io/tags/%E5%87%BA%E7%89%88/"/>
    
    <category term="書籍" scheme="https://future-architect.github.io/tags/%E6%9B%B8%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>AWS Certified Solutions Architect - Associate 合格体験記</title>
    <link href="https://future-architect.github.io/articles/20210818b/"/>
    <id>https://future-architect.github.io/articles/20210818b/</id>
    <published>2021-08-17T15:00:01.000Z</published>
    <updated>2021-08-18T02:30:55.403Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、TIGの市川浩暉です。</p><p>先日、業務の合間を縫って少しづつ勉強を進めていた、AWS Certified Solutions Architect - Associate（AWS SAA）を受験し、合格することができました。</p><p>今回は合格までの学習方法と試験を受けた感想を共有したいと思います。</p><p>この記事がこれから受験する人の一助となれば幸いです。</p><img src="/images/20210818b/AWS-SolArchitect-Associate-2020.png" alt="合格バッチ" width="340" height="340" loading="lazy"><h1 id="AWS-Certified-Solutions-Architect-Associate-とは"><a href="#AWS-Certified-Solutions-Architect-Associate-とは" class="headerlink" title="AWS Certified Solutions Architect - Associate とは"></a>AWS Certified Solutions Architect - Associate とは</h1><blockquote><p>AWS 認定ソリューションアーキテクト - アソシエイト試験は、AWS における分散システムの可用性、コスト効率、高耐障害性およびスケーラビリティの設計に関する 1 年以上の実務経験を持つソリューションアーキテクト担当者を対象としています。<br>引用：<a href="https://aws.amazon.com/jp/certification/certified-solutions-architect-associate/">AWS 認定 ソリューションアーキテクト – アソシエイト</a></p></blockquote><p>AWS 認定 ソリューションアーキテクト – アソシエイト試験は、AWSで提供されている認定試験のうち、アソシエイトレベルに位置づけられている資格で、以下の能力が検証される試験になっています。</p><ul><li>AWSのテクノロジーを使ってセキュアかつ堅牢なソリューションを設計するための能力</li><li>適切なAWSのサービスを使用し、要件を基にアーキテクチャ原則に従ってソリューションを設計する能力</li><li>ワークロードのライフサイクルを通して、ベストプラクティスに基づく実装ガイダンスを組織に提供する能力</li></ul><p>試験ガイドはこちらです。<br><a href="https://d1.awsstatic.com/ja_JP/training-and-certification/docs-sa-assoc/AWS-Certified-Solutions-Architect-Associate_Exam-Guide.pdf">AWS Certified Solutions Architect – Associate(SAA-C02) Exam Guide</a></p><p>AWS Certified Solutions Architect - Associate試験は、試験名称が長いので、よく <code>AWS SAA</code> と略されることが多いです。<br>AWSの認定資格試験は現在12種類ありますが、個人的にはAWSの勉強を始める上で最初に受ける登竜門のような試験である印象を持っています。ベーシックレベルの試験として「<a href="https://aws.amazon.com/jp/certification/certified-cloud-practitioner/">クラウドプラクティショナー</a>」の試験もありますが、実務経験が一定程度あるのであればAWS SAAから受験して問題ないと思います。</p><p>この試験の勉強を通じて、AWSの主要サービスやAWSの推奨するアーキテクチャ構成の理解を深めることができます。</p><h1 id="受験したきっかけ"><a href="#受験したきっかけ" class="headerlink" title="受験したきっかけ"></a>受験したきっかけ</h1><p>以前所属していたプロジェクトが少人数体制であったこともあり、アプリ・インフラを横断的に見て課題解決に当たることが多くありました。そのため、業務では私が担当していたアプリの知識だけでなく、インフラの知識やAWSの知識が求められることが多く、ミーティングで話についていけない時があったため、話を理解できるようにしたかったのが受験したきっかけになります。</p><p>また、直近のプロジェクトでは要件定義に近いフェーズを実施していたため、機能実装や構築を行っておらず、技術力が下がっているのでは？、と少し不安を抱えていたため、資格を一つのマイルストンとして設定し、モチベーションを維持しようと考えました。</p><h1 id="試験対策"><a href="#試験対策" class="headerlink" title="試験対策"></a>試験対策</h1><p>以下に私が合格するまでに実施した勉強法を記載します。</p><h2 id="使用した教材"><a href="#使用した教材" class="headerlink" title="使用した教材"></a>使用した教材</h2><h3 id="Udemy教材"><a href="#Udemy教材" class="headerlink" title="Udemy教材"></a>Udemy教材</h3><ul><li><a href="https://www.udemy.com/course/aws-associate/">これだけでOK！ AWS 認定ソリューションアーキテクト – アソシエイト試験突破講座（SAA-C02試験対応版）</a></li></ul><p>他の合格体験記にもよく出てきますが、基本知識はこの教材で身につけました。<br>サービスの説明だけでなく、ハンズオンもついており、非常にわかりやすいです。<br>ハンズオンを含めると結構時間がかかるので、他の方の合格記ではハンズオンだけSkipしている方もいますが、私は理解を深める目的で全て実施しました。</p><ul><li><a href="https://www.udemy.com/course/aws-knan/">【SAA-C02版】AWS 認定ソリューションアーキテクト アソシエイト模擬試験問題集（6回分390問）</a></li></ul><p>これもUdemyの教材になりますが、比較的難易度の高めの問題などを中心に構成された問題集です。（講義はなく、問題のみのコンテンツ）<br>上記のアソシエイト試験突破講座にも小テストと問題集がついていますが、もう少し問題演習をしたい人は購入しても良いかと思います。</p><p>ただ、Udemyの仕様に引きづられているのかわからないのですが、この問題集は一問一答形式ではなく、65問解き終わって初めて正解が分かります。一気に65問解くのは結構ハードなので、一問一答形式で問題演習をしていきたい人は後述する「aws.koiwaclub.com」での問題演習をした方が勉強しやすいかもしれません。</p><h2 id="学習サイト-aws-koiwaclub-com"><a href="#学習サイト-aws-koiwaclub-com" class="headerlink" title="学習サイト aws.koiwaclub.com"></a>学習サイト aws.koiwaclub.com</h2><p>「AWS WEB問題集で学習しよう」というサービスで、実際の試験レベルに合った問題演習を行うことができます。問題数も豊富で、ここに記載されている<a href="https://aws.koiwaclub.com/passrecord/saa-experience/">合格体験記</a>を読んで勉強法や出題傾向を確認していました。</p><p>有料のサービスにはなりますが、問題の質は良く、ここから実際の試験に出てきた問題もいくつかありました。私は試験1週間前にこのサービスに申し込み、#90 〜 #148 の問題を解いてました。</p><p>また、解答形式は一問一答形式で、解説+関連するAWSの公式ドキュメントのリンクも付いているので非常に学習しやすく、理解も深めながら進めることができました。</p><h2 id="書籍"><a href="#書籍" class="headerlink" title="書籍"></a>書籍</h2><ul><li><a href="https://www.amazon.co.jp/dp/4815607389">AWS認定資格試験テキスト AWS認定ソリューションアーキテクト - アソシエイト 改訂第2版</a></li></ul><p>リファレンスとして、こちらの本を使っていました。<br>非常に整理されていてわかりやすく、動画や問題演習で身に付けた知識を整理するのに非常に有用でした。</p><p>AWSのSAAの試験内容が2020年に改定されたことに伴い、少し前に出版された本は現在のSAA-C02版に対応していない場合があります。そのため、書籍を購入する場合は、SAA-C02版の試験に対応している書籍かどうか、念のため確認したほうが良いと思います。</p><h2 id="AWS主催の試験準備ワークショップ-「ソリューションアーキテクト-アソシエイト」"><a href="#AWS主催の試験準備ワークショップ-「ソリューションアーキテクト-アソシエイト」" class="headerlink" title="AWS主催の試験準備ワークショップ 「ソリューションアーキテクト - アソシエイト」"></a>AWS主催の試験準備ワークショップ 「ソリューションアーキテクト - アソシエイト」</h2><p>私が学習をしていた時期にちょうどAWS Summit Onlineが開催されており、期間中に「AWS 認定 - 試験準備ワークショップ ソリューションアーキテクト - アソシエイト」という講座が配信されていたので、そちらを視聴しました。<br>内容としては、「レジリエント（回復性がある）アーキテクチャ設計」、「高パフォーマンスアーキテクチャの設計」、「セキュアなアプリケーションとアーキテクチャの設計」、「コスト最適化アーキテクチャの設計」の4つのセッションで構成されており、サンプル問題とその解説が行われます。</p><p>現在でも定期的にウェビナー形式で行われているので、もし時間に都合がつく方は受けてみると良いと思います。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">【AWS認定に挑戦しよう】「AWS 認定ソリューションアーキテクト – アソシエイト」試験準備ワークショップ➡️ <a href="https://t.co/DK3aTiehto">https://t.co/DK3aTiehto</a><a href="https://twitter.com/hashtag/AWS%E8%AA%8D%E5%AE%9A?src=hash&amp;ref_src=twsrc%5Etfw">#AWS認定</a> インストラクターが、試験問題を解く際のポイントをサンプル問題を用いて解説する無料ウェビナーを開催。ライブ Q&amp;A で質問も可能です！ <a href="https://t.co/CJPNTxy8UZ">pic.twitter.com/CJPNTxy8UZ</a></p>&mdash; AWS/アマゾン ウェブ サービス/クラウド (@awscloud_jp) <a href="https://twitter.com/awscloud_jp/status/1421984092741152775?ref_src=twsrc%5Etfw">August 2, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><h2 id="Black-Belt-Online-Seminar"><a href="#Black-Belt-Online-Seminar" class="headerlink" title="Black Belt Online Seminar"></a>Black Belt Online Seminar</h2><p>Black Belt Online Seminarとは、AWSの技術担当者が各サービスについてテーマごとに、そのサービスの概要を説明してくれる動画コンテンツです。過去に開催された Black Belt の動画や資料のアーカイブは<a href="https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/">こちら</a>から確認することができます。</p><p>動画だと理解が深まりやすい分、視聴するのに時間がかかるので、私は全てのサービスを視聴せず、上記教材でも理解が浅い領域のみ見ていました。</p><h1 id="勉強の反省点"><a href="#勉強の反省点" class="headerlink" title="勉強の反省点"></a>勉強の反省点</h1><p>当初はUdemyの講座を受けてハンズオンを行い問題演習をする流れで学習を進めていました。しかし、今振り返ってみると理解ができていないまま画面の通りに操作しているだけになってしまったかなと思います。ですので、一旦全体的な知識を身に付け、ある程度の問題演習をした後にハンズオンを実施する流れだと、理解がさらに深まったのではないかと思いました。</p><h1 id="受験方法"><a href="#受験方法" class="headerlink" title="受験方法"></a>受験方法</h1><p>ピアソンVUEを利用して自宅受験を選択しました。<br>というのも、私が受験する際に「<a href="https://pages.awscloud.com/Global_TrainCert_Japan_Online_Proctoringja.html">自宅からAWS認定を受験すると、1回目の受験が不合格でも、2回目の再受験が無料になるキャンペーン</a>」を実施しており、こちらを利用して受験しました。</p><p>結果、1回目で合格してしまったので2回目が無料になる特典は利用せずでしたが、精神的な余裕を持って試験に臨むことができたと思います。</p><p>担当いただいた試験官の方は海外の方でしたが、指示はチャット形式（日本語）で行われたので非常にスムーズで、自宅での認定試験受験は部屋を片付けないといけないこと以外は特に不自由はなく受験することができました。（少し前は試験官の方が海外の方だったっぽく、コミュニケーションが取りにくかったことがあったらしいのですが、現在は改善されているようです）</p><h1 id="試験での注意"><a href="#試験での注意" class="headerlink" title="試験での注意"></a>試験での注意</h1><p>AWSの認定試験ではよく変な日本語の問題があるとよく言われていますが、やはり今回の試験でも日本語がおかしい部分が多々散見されました。最初はとっつきにくさを感じますが、解いていくうちに次第に慣れてくるのと、表示を英語に切り替えて意味を理解することはできるので、そこまで大きな負担ではないかなと思います。</p><h1 id="合格後の特典"><a href="#合格後の特典" class="headerlink" title="合格後の特典"></a>合格後の特典</h1><p>AWS認定試験に合格すると、いくつかの特典を受けることができます。</p><img src="/images/20210818b/image.png" alt="合格後の特典" width="425" height="136" loading="lazy"><ul><li>50% Discount on your next Exam<ul><li>次回受ける認定試験の受験料が半額となる。</li></ul></li><li>AWS Free Practice Exam Voucher<ul><li>模擬試験（¥2,000 ~ ¥4,000）の無料クーポン</li></ul></li><li>Apply to join our Subject Matter Expert (SME) Program<ul><li>SMEへの参加資格を得られる。</li></ul></li><li>AWS Certified Associate: Store Access<ul><li>AWS公式グッズのストアへのアクセスができる。</li></ul></li><li>AWS Certified Global LinkedIn Community<ul><li>AWS認定資格に合格した者のみが参加できるLinkedInのコミュニティへ参加できる。</li></ul></li></ul><p>また、試験に合格した証として認定バッチも受け取ることができます。</p><img src="/images/20210818b/image_2.png" alt="認定バッチ" width="760" height="744" loading="lazy"><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>業務の合間を縫って資格試験の勉強をしていくことは非常に大変でしたが、そこで得た知識を業務に活かせていると実感できることがあり、勉強のモチベーションが下がることはありませんでした。また、前のプロジェクトで構築していたアプリケーションのアーキテクチャ構成がAWSのベストプラクティスに従って設計されていることを理解できたり、前プロジェクトで学んだ断片的なAWSの知識の点が、線で繋がっていく感覚を感じることができたのが非常に面白かったです。</p><p>また、広い範囲で多くの機能が提供されているAWSをただ闇雲に学ぶのではなく、資格をマイルストンとして設定してそれに向かって勉強を進めていくことは、効率的にAWSの概要やクラウドインフラで押さえておくべき知識を学ぶことができるという点で非常に有用だと思いました。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>今回、資格としての合格は得ることはできましたが、まだスタートラインに立ったばかりなので、これからも継続的に復習をして、レベルアップしていきたいと思います。また、AWS SAAだけでなく、AWS DVAやSOAなどの試験に向けて、継続して学習を進めていきたいと思います。</p><p>Future Tech Blogでは、今回扱ったAWS SAAの上位資格であるAWS Certified Solutions Architect - Professionalに合格した<a href="https://future-architect.github.io/articles/20210607a/">伊藤真彦さんの記事</a>やAWSだけでなく、<a href="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/">GCPやTerraform認定試験の合格記</a>もありますので、認定試験を受験する前にぜひご覧ください。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、TIGの市川浩暉です。&lt;/p&gt;
&lt;p&gt;先日、業務の合間を縫って少しづつ勉強を進めていた、AWS Certified Solutions Architect - Associate（AWS SAA）を受験し、合格することができました。&lt;/p&gt;
&lt;p&gt;今回は合格まで</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="合格記" scheme="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>Go1.17における go get の変更点</title>
    <link href="https://future-architect.github.io/articles/20210818a/"/>
    <id>https://future-architect.github.io/articles/20210818a/</id>
    <published>2021-08-17T15:00:00.000Z</published>
    <updated>2021-08-18T01:10:33.338Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210818a/go_get.png" alt="" width="900" height="388" loading="lazy"><p>The Gopher character is based on the Go mascot designed by <a href="http://reneefrench.blogspot.com/">Renee French</a>.</p><p>TIGの辻です。</p><p><a href="/articles/20210810a/">Go 1.17連載</a>の5日目の記事です。本記事ではGo1.17の <code>go get</code> に関するアップデートの詳細をお伝えします。</p><h2 id="go-get-に関する変更点サマリ"><a href="#go-get-に関する変更点サマリ" class="headerlink" title="go get に関する変更点サマリ"></a><code>go get</code> に関する変更点サマリ</h2><ul><li>モジュール外からの <code>go get</code> におけるコマンドインストール時に、警告を出力する</li><li><code>go get</code> の <code>-insecure</code> フラグは使えなくなった、代わりに環境変数 <code>GOINSECURE</code> を使う</li></ul><h3 id="モジュール外からの-go-get-におけるコマンドインストール時に、警告を出力する"><a href="#モジュール外からの-go-get-におけるコマンドインストール時に、警告を出力する" class="headerlink" title="モジュール外からの go get におけるコマンドインストール時に、警告を出力する"></a>モジュール外からの <code>go get</code> におけるコマンドインストール時に、警告を出力する</h3><h4 id="go-get-時の警告"><a href="#go-get-時の警告" class="headerlink" title="go get 時の警告"></a><code>go get</code> 時の警告</h4><p><a href="https://golang.org/doc/go1.16#go-command">Go1.16のリリースノート</a>でも、コマンドのインストールで <code>go get</code> を使うのは非推奨、とお知らせがありましたが、Go1.17では、モジュール外からコマンドのバイナリを <code>go get</code> を使ってインストール<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>した場合、警告が出るようになりました。いよいよ次のGo 1.18のリリースでは <code>go get</code> でコマンドのインストールができなくなりそうです。</p><ul><li>非推奨なインストール方法</li></ul><p>メインモジュール外で <code>go get</code> してコマンドをインストールしようとすると、以下のように警告が出力されます。将来的には <code>go get</code> 時にデフォルトで <code>-d</code> フラグが有効になるため、<code>go get</code> でバイナリをインストールすること自体ができなくなります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/future-architect/awsmfa/cmd/awsmfa</span><br><span class="line">go: downloading github.com/future-architect/awsmfa v1.1.1</span><br><span class="line">go: downloading gopkg.in/ini.v1 v1.62.0</span><br><span class="line">go get: installing executables with <span class="string">&#x27;go get&#x27;</span> <span class="keyword">in</span> module mode is deprecated.</span><br><span class="line">        Use <span class="string">&#x27;go install pkg@version&#x27;</span> instead.</span><br><span class="line">        For more information, see https://golang.org/doc/go-get-install-deprecation</span><br><span class="line">        or run <span class="string">&#x27;go help get&#x27;</span> or <span class="string">&#x27;go help install&#x27;</span>.</span><br></pre></td></tr></table></figure><ul><li>推奨されるインストール方法</li></ul><p>コマンドのインストールは以下のように <code>go install</code> を使いましょう。Go1.16の連載の <a href="https://future-architect.github.io/articles/20210209/">Go 1.16のgo installについて</a> の記事の中でも紹介していますが、Go1.16からツールなどの実行バイナリをローカル環境にインストールする場合に <code>go install</code> でバージョンを指定してインストールできます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/future-architect/awsmfa/cmd/awsmfa@v1.1.1</span><br></pre></td></tr></table></figure><h4 id="将来的にデフォルトで-go-get-時に-d-オプションが有効になることの影響"><a href="#将来的にデフォルトで-go-get-時に-d-オプションが有効になることの影響" class="headerlink" title="将来的にデフォルトで go get 時に -d オプションが有効になることの影響"></a>将来的にデフォルトで <code>go get</code> 時に <code>-d</code> オプションが有効になることの影響</h4><p>将来的には <code>go get</code> 時はデフォルトで <code>-d</code> フラグが有効になります。<code>-d</code> フラグはソースのみをインストールし、ビルドは行われません。<code>go.mod</code> ファイルを更新し、パッケージのビルドに必要なソースをダウンロードするだけです。</p><p><code>-d</code> がデフォルトで有効になると、<code>go get</code> 時はソースのダウンロードのみを行い、ビルドはしなくなるため、以下のような影響があります。</p><ul><li>1.<code>go get</code> がより高速になる</li><li>2.プラットフォーム依存のソースを、ローカルの環境でビルドできない場合、<code>go get</code> 時にエラー報告しなくなる</li></ul><p>1つ目のポイントは多くのGopherにとって嬉しいポイントかもしれません。</p><h4 id="なぜ非推奨になったのか"><a href="#なぜ非推奨になったのか" class="headerlink" title="なぜ非推奨になったのか"></a>なぜ非推奨になったのか</h4><p><a href="https://golang.org/doc/go-get-install-deprecation">Deprecation of ‘go get’ for installing executables</a> に背景が書いてあります。端的に言うと「<code>go get</code> の、コマンドをビルドしてインストールする機能が <code>go install</code> と重複するため」ということです。</p><h4 id="コントリビュートチャンス？！"><a href="#コントリビュートチャンス？！" class="headerlink" title="コントリビュートチャンス？！"></a>コントリビュートチャンス？！</h4><p>おまけですが、多くのREADMEなどのドキュメントではGo製のコマンドをインストールする方法として <code>go get</code> の手順を記載しています。<code>golang</code> のリポジトリにもコマンドインストールで <code>go get</code> を用いていた記述がいくつかありました。Goにコントリビュートしてみたい方はチャンスかもしれません。<code>golang/review</code> <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> などでも <code>go get</code> としてコマンドをインストールする手順がまだドキュメントに記載されています。もちろんFutureが公開しているGo製のツールのドキュメントも今後アップデートしていく必要があります。</p><h3 id="go-get-の-insecure-フラグは使えなくなった、代わりに環境変数-GOINSECURE-を使う"><a href="#go-get-の-insecure-フラグは使えなくなった、代わりに環境変数-GOINSECURE-を使う" class="headerlink" title="go get の -insecure フラグは使えなくなった、代わりに環境変数 GOINSECURE を使う"></a><code>go get</code> の <code>-insecure</code> フラグは使えなくなった、代わりに環境変数 <code>GOINSECURE</code> を使う</h3><p><code>go get</code> 時に <code>-insecure</code> を付与してコマンドを実行すると、<code>-insecure</code> フラグはサポートされなくなった旨が表示されるようになりました。<a href="https://golang.org/doc/go1.16">Go1.16のリリースノート</a>では将来 <code>-insecure</code> フラグを削除するよ、とお知らせがありましたが、それが実現しました。</p><ul><li>Go1.17で <code>-insecure</code> フラグを付与して <code>go get</code> したときの例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -insecure github.com/future-architect/<span class="keyword">go</span>-mcprotocol</span><br><span class="line"><span class="keyword">go</span> get: -insecure flag is no longer supported; use GOINSECURE instead</span><br></pre></td></tr></table></figure><p>Go1.14から環境変数 <code>GOINSECURE</code> が追加になっているので、安全でない方法でアクセスする必要があるときは環境変数 <code>GOINSECURE</code> に対象のホストを指定しましょう。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">ソースをダウンロードして、ソースからビルドしたバイナリを <code>$GOPATH/bin</code> に配備する、ということ</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://github.com/golang/review/tree/2e4fd9a232c3368afeca71043fd7538ed11c681c">https://github.com/golang/review/tree/2e4fd9a232c3368afeca71043fd7538ed11c681c</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://github.com/golang/review/tree/2e4fd9a232c3368afeca71043fd7538ed11c681c">https://github.com/golang/review/tree/2e4fd9a232c3368afeca71043fd7538ed11c681c</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210818a/go_get.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;388&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;The Gopher character is based on the Go mascot d</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.17からの負のruneの扱い</title>
    <link href="https://future-architect.github.io/articles/20210817a/"/>
    <id>https://future-architect.github.io/articles/20210817a/</id>
    <published>2021-08-16T15:00:00.000Z</published>
    <updated>2021-08-17T01:27:16.420Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210817a/runes-947831.jpg" alt="" title="Alex VolodskyによるPixabayからの画像" width="900" height="675" loading="lazy"><p>こんにちは、TIGの玉木です。<a href="https://future-architect.github.io/articles/20210810a/">Go 1.17連載</a>の4記事目です。</p><p>この記事ではGo 1.17で更新があった負のruneの扱いについてです。更新自体は簡単なもので、この記事ではruneの説明から行います。</p><h2 id="この記事を書いたきっかけ"><a href="#この記事を書いたきっかけ" class="headerlink" title="この記事を書いたきっかけ"></a>この記事を書いたきっかけ</h2><p>Go 1.17のRelsease Notes<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>を眺めていたらいくつかの箇所で <code>negative rune values</code>という記述があり、runeってなんだ？と気になったことがきっかけです。</p><h2 id="runeについて"><a href="#runeについて" class="headerlink" title="runeについて"></a>runeについて</h2><p>こちらの<a href="https://qiita.com/seihmd/items/4a878e7fa340d7963fee">seihmdさんのQiita記事</a>がとてもわかりやすかったです。詳細はそちらの記事に任せて、この記事では簡単な紹介に留めます。</p><p>コンピュータは文字を0と1のビットで表現します。例えば「”あ”, ”い”, “う”, “え”, “お”」の5種類の文字しかなければ、それぞれ「”000”, “001”, “010”, “011”, “100”」のように0と1で文字を表現することができます。このように文字に非負整数値を対応付け、コンピュータに利用できるように変換することを、文字符号化と呼びます。この文字符号化のうちの1つがUnicodeであり、対応する非負整数値をコードポイントと呼びます。例えば”あ”という文字のコードポイントは3042(16進数表記)となります。</p><p>Goではこのコードポイントをより短い用語としてruneを導入したようです<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。コードポイントとruneは全く同義です。</p><h2 id="報告されていた問題"><a href="#報告されていた問題" class="headerlink" title="報告されていた問題"></a>報告されていた問題</h2><p><a href="https://github.com/golang/go/issues/43254">https://github.com/golang/go/issues/43254</a></p><p>上記issueでは負のruneが来た場合、他の異常なruneと同じように振る舞うべきだがそうなっていないと報告しています。issueを報告している方が<a href="https://play.golang.org/p/9ZkvjGuE1so">Go Playgroundで共有しているコード</a>が以下になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unicode&quot;</span></span><br><span class="line"><span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// unicode.Is goes checks rangeTab.R16 with negative values.</span></span><br><span class="line"><span class="comment">// -2147483583 = 0x80000041</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;unicode.IsPrint(-2147483583) = %t\n&quot;</span>, unicode.IsPrint(<span class="number">-2147483583</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytes.Buffer.WriteRune runs the single-byte codepath with</span></span><br><span class="line"><span class="comment">// negative values, even writing invalid UTF-8.</span></span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">b.WriteRune(<span class="number">-2147483583</span>) <span class="comment">// 0x80000041</span></span><br><span class="line">b.WriteRune(<span class="number">-2147483393</span>) <span class="comment">// 0x800000ff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b.String() = %q\n&quot;</span>, b.String())</span><br><span class="line">fmt.Printf(<span class="string">&quot;utf8.ValidString(b.String()) = %t\n&quot;</span>, utf8.ValidString(b.String()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>出力(Go1.16以前)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unicode.IsPrint(-2147483583) = <span class="literal">true</span></span><br><span class="line">b.String() = <span class="string">&quot;A\xff&quot;</span></span><br><span class="line">utf8.ValidString(b.String()) = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>unicode.IsPrint()が負の整数を入れているにも関わらず、trueになっています。runeは非負整数しか取り得ないため、falseを返すべきです。</p><p>また、Builder.WriteRuneで負の整数を入れているにも関わらず、b.String()に文字が入っています。Unicodeではこのような場合、REPLACEMENT CHARACTERと呼ばれる文字�(rune: U+FFFD)に変換するのが一般的です<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。また、異常な文字が入ってしまっているため、utf8.ValidString(b.String())がfalseになっています。</p><h2 id="今回の更新について"><a href="#今回の更新について" class="headerlink" title="今回の更新について"></a>今回の更新について</h2><p>以下Go 1.17 Relsease Notesからの本記事に関係がある箇所の引用です。</p><blockquote><p>bufio<br>The Writer.WriteRune method now writes the replacement character U+FFFD for negative rune values, as it does for other invalid runes.</p></blockquote><blockquote><p>bytes<br>The Buffer.WriteRune method now writes the replacement character U+FFFD for negative rune values, as it does for other invalid runes.</p></blockquote><blockquote><p>strings<br>The Builder.WriteRune method now writes the replacement character U+FFFD for negative rune values, as it does for other invalid runes.</p></blockquote><blockquote><p>unicode<br>The Is, IsGraphic, IsLetter, IsLower, IsMark, IsNumber, IsPrint, IsPunct, IsSpace, IsSymbol, and IsUpper functions now return false on negative rune values, as they do for other invalid runes.</p></blockquote><ul><li>bufio</li><li>bytes</li><li>strings</li></ul><p>上記パッケージでは、負のruneを他の無効なruneと同じくU+FFFDに置き換えるように修正されています。</p><ul><li>unicode</li></ul><p>負のruneの場合、該当する関数ではfalseを返すように修正されています。</p><p>Go 1.17では、先程の問題を再現するコードは以下のような出力になります。</p><figure class="highlight bash"><figcaption><span>出力(Go1.17)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unicode.IsPrint(-2147483583) = <span class="literal">false</span></span><br><span class="line">b.String() = <span class="string">&quot;��&quot;</span></span><br><span class="line">utf8.ValidString(b.String()) = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>unicode.IsPrint()に負の整数を入れるとfalseを返すようになります。Builder.WriteRuneで負の整数を入れているため、�に置き換えられています。�が代わりに入るようになったため、utf8.ValidString()がtrueを返します。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Go 1.17では以下のように負のruneの扱いが修正されました。</p><ul><li>bufio, bytes, stringsパッケージでのWriteRuneメソッドにおいて、負のruneをU+FFFDに置き換える</li><li>unicodeパッケージでのいくつかの関数において、負のruneが来た場合falseを返す</li></ul><p>あまりコードを書いていて気にする箇所ではないかもしれませんが、この記事が参考になれば幸いです。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><a href="https://tip.golang.org/doc/go1.17">https://tip.golang.org/doc/go1.17</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;"><a href="https://ja.wikipedia.org/wiki/Specials_(Unicode_block)">https://ja.wikipedia.org/wiki/Specials_(Unicode_block)</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210817a/runes-947831.jpg&quot; alt=&quot;&quot; title=&quot;Alex VolodskyによるPixabayからの画像&quot; width=&quot;900&quot; height=&quot;675&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;こんにちは</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #14〜IDaaS/OSS/Managed比較〜</title>
    <link href="https://future-architect.github.io/articles/20210812b/"/>
    <id>https://future-architect.github.io/articles/20210812b/</id>
    <published>2021-08-11T15:00:01.000Z</published>
    <updated>2021-08-12T03:28:03.293Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210812b/key-2114046_1280.jpg" alt="" title="Arek SochaによるPixabayからの画像" width="640" height="408" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>Technology Innovation Group所属の山田です。2021年7月21日に <a href="https://future.connpass.com/event/218520/">Future Tech Night #14～認証認可（IDaaS）勉強会～</a>で発表させてもらいました。</p><p>元々は、Rails Devise+cancancan、Cognito User Pools（5年前）、Auth0の開発経験があり、改めてOSSも加えて学んでみたかったのが、テーマを決めた背景になります。</p><p>なお、一緒に発表をした市川さんが、Auth0でWebAuthnを試されており、認証において非常に重要な機能になりますので、合わせてご覧ください。私はとても勉強になりました。</p><ul><li><a href="/articles/20210811b/">Future Tech Night #14「生体認証・デバイス認証を活用するパスワードレスな認証規格「WebAuthn」を体験！」</a></li></ul><h1 id="資料"><a href="#資料" class="headerlink" title="資料"></a>資料</h1><p>発表資料はこちらです。</p><script async class="speakerdeck-embed" data-id="a6797af79a054b808d099e7f53f1d430" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h3 id="ハンズオン"><a href="#ハンズオン" class="headerlink" title="ハンズオン"></a>ハンズオン</h3><p>全てのプロダクトをまっさらな状態からハンズオンし、要した時間と、利用できるまでの工程をまとめてみました。<br>アプリケーションはVueで統一しています。</p><p>ソースコードはコピペで動くを事を目指し、参考URLも掲載しています。</p><ul><li> Auth0<br>Auth0の初期設定、vueを利用したハンズオン</li><li> keycloak<br>keycloakの初期設定、vueを利用したハンズオン</li><li> Cognito<br>Cognitoの初期設定、Amplify＋Vueを利用したハンズオン、hosted UI＋Vueを利用したハンズオン</li></ul><h3 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h3><ul><li>プラン<br>HPに掲載されている内容で、プランと価格を比較</li><li>機能<br>各プロダクトのダッシュボード画面、トップレベルメニューまでの機能比較</li></ul><h1 id="当日頂いたQA"><a href="#当日頂いたQA" class="headerlink" title="当日頂いたQA"></a>当日頂いたQA</h1><p>時間の関係で頂いたQAに返答できなかったため、改めてこの場で返答させて頂きます。</p><p><strong>Q.</strong> Firebase Auth はフューチャーさんの方で事例や検証などされたりしていますでしょうか？（Auth0 が最も事例がある感じでしょうか）もし Firebase Authの事例などがあれば、どういう基準で選んでいるのか回答頂けると助かります。<br><strong>A.</strong> 私の周囲では、Keycloak、Auth0の採用が多いです。<br>理由の1つとして、SSOの実現が必須になるケースが多く、central authentication serviceの仕組みが欲しくなってしまう為ですFirebase Auth（は知識が不足しており、定かではありませんが）やAmplify(+cognito)は単一アプリで利用するには良い印象ですが、IDPとして使う為には、追加の実装が必要になるため、採用するケースが少ないように思います。</p><hr><p><strong>Q.</strong> Auth0を導入される際に比較されたIDaaS, 比較ポイントがもしあれば教えていただけないでしょうか。例えばOktaなどは比較されましたでしょうか？<br><strong>A.</strong> 残念ながら、Oktaとの比較結果は持ち合わせておらず、申し訳ありません。<br>比較ポイントとして特殊なものは無く、機能、非機能、価格、開発の自由度で純粋に比較しています。機能であれば、SSOやAD/GSuiteなどとの統合、移行性、GDPRへの対応…etc<br>非機能であれば、認証スループット、可用性、データの所在…etc 等かと思います。</p><hr><p><strong>Q.</strong> IDaaSの選択肢として、Azure AD B2Cがどうか、私見で良いので聞きたいです。<br><strong>A.</strong> 勉強不足で申し訳ありません。Azure AD B2Cは初見でしたので機能を見てみました。<br>Customize性（Rules/Hooks）、SDKの充実度などはAuth0が有利に見えますが、基本的な機能は揃っており、価格メリットがあれば十分選択肢になりうると思えました。</p><hr><p><strong>Q.</strong> Futureでの各サービスやOSSの採用事例とその際の選定基準などあればお聞きしたいです<br><strong>A.</strong> プロジェクトによって、優先すべき内容が異なるため、決まった選定基準はありません。<br>基本的にはプロジェクト単位に定められた機能、非機能の要件で選定軸を作り、第3者レビューも通した上で採用プロダクトを決めています。</p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>次の機会があれば、追加で他のプロダクトも比較してみたいです。</p><p>ありがとうございました。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210812b/key-2114046_1280.jpg&quot; alt=&quot;&quot; title=&quot;Arek SochaによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;408&quot; loading=&quot;lazy&quot;&gt;


&lt;h1 id</summary>
      
    
    
    
    <category term="認証認可" scheme="https://future-architect.github.io/categories/%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Auth0" scheme="https://future-architect.github.io/tags/Auth0/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="IDaaS" scheme="https://future-architect.github.io/tags/IDaaS/"/>
    
    <category term="Keycloak" scheme="https://future-architect.github.io/tags/Keycloak/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.17のtesting新機能</title>
    <link href="https://future-architect.github.io/articles/20210812a/"/>
    <id>https://future-architect.github.io/articles/20210812a/</id>
    <published>2021-08-11T15:00:00.000Z</published>
    <updated>2021-08-12T02:27:56.453Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210812a/audit-3929140_640.jpg" alt="" title="mohamed HassanによるPixabayからの画像" width="640" height="371" loading="lazy"><p>TIGの伊藤真彦です。</p><p>この記事は<a href="/articles/20210810a/">Go1.17連載</a>の3記事目です。</p><h1 id="Go1-17からのtestingにおける新機能"><a href="#Go1-17からのtestingにおける新機能" class="headerlink" title="Go1.17からのtestingにおける新機能"></a>Go1.17からのtestingにおける新機能</h1><p><a href="https://tip.golang.org/doc/go1.17">Go1.17のリリースノート</a>にこのような記載があります。</p><blockquote><p>testing<br>Added a new testing flag -shuffle which controls the execution order of tests and benchmarks.</p><p>The new T.Setenv and B.Setenv methods support setting an environment variable for the<br>duration of the test or benchmark.</p><p>テストとベンチマークの実行順序を制御する新しいテストフラグ-shuffleを追加しました。</p><p>新しいT.SetenvおよびB.Setenvメソッドは、テストまたはベンチマークの期間中の環境変数の設定をサポートします。</p></blockquote><p>意外と根深い課題を解決できる嬉しい機能ですね、今回はこの新機能の紹介をすることにします。</p><h1 id="shuffleオプションについて"><a href="#shuffleオプションについて" class="headerlink" title="shuffleオプションについて"></a>shuffleオプションについて</h1><p>Goでテストを行う時はいくつかのフラグを追加することができます。<code>-run</code>で実行するテストを絞り込んだり、<code>-cover</code>でカバレッジを計測したりといった機能があります。</p><p>公式ドキュメントは<a href="https://pkg.go.dev/cmd/go/internal/test">こちら</a>です。</p><p>それらオプション群にshuffleが追加されました。</p><h3 id="shuffleオプションの使い方"><a href="#shuffleオプションの使い方" class="headerlink" title="shuffleオプションの使い方"></a>shuffleオプションの使い方</h3><p><a href="https://pkg.go.dev/cmd/go@master#hdr-Testing_flags">ドキュメント</a>に下記のように追記されています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-shuffle off,on,N</span><br><span class="line">Randomize the execution order of tests and benchmarks.</span><br><span class="line">It is off by default. If -shuffle is set to on, then it will seed</span><br><span class="line">the randomizer using the system clock. If -shuffle is set to an</span><br><span class="line">integer N, then N will be used as the seed value. In both cases,</span><br><span class="line">the seed will be reported for reproducibility.</span><br></pre></td></tr></table></figure><p><code>go test -shuffle=on</code>のように利用できます。<br><code>go test -shuffle=123</code>のように整数値を指定することで、ランダムな値の生成などにおけるseed値を指定する事ができます。</p><h3 id="テストをシャッフルすると何が嬉しいのか"><a href="#テストをシャッフルすると何が嬉しいのか" class="headerlink" title="テストをシャッフルすると何が嬉しいのか"></a>テストをシャッフルすると何が嬉しいのか</h3><p>テストの実行順番をランダムにする機能は、<code>Ruby On Rails</code>でのテストにおけるデファクトスタンダードである<code>rspec</code>など、他の言語、ライブラリでも実装されています。<br>順番をランダムにすることで、前に書いたテストの実行結果に依存する状態を検知し、回避できることが最大の目的です。</p><p>前に書いたテストの実行結果に依存する状態とは、下記のようなケースが該当します。</p><ul><li>前のテストケースでグローバル変数が宣言、変更された前提で次のテストケースが書かれている</li><li>前のテストケースでデータベースに保存された内容を次のテストケースで利用している</li></ul><p>これらの書き方は基本的にバッドプラクティスです。</p><p>何らかの事情でテストケースや実装に変更が加わった際に、一見無関係なテストが落ちて混乱を招くことになります。テストは各ケースの実行ごとにデータベースの内容を掃除するなど、クリーンな状態を保ちましょう。テストをランダム実行することで、上記のバッドプラクティスを早期に炙り出すことが可能になります。</p><p><a href="https://github.com/golang/go/issues/28592">当該機能を追加したissue</a>においても、グローバル変数の状態が変わる事で、テストの実行順序が実行結果に影響が出る例が記載されています。</p><blockquote><p>Those tests pass, everything looks fine, but they’re order dependent. Running them in another order will fail.<br>To prevent such hidden and hard to debug mistakes we need to make the order of test random for each test build.</p><p>これらのテストは合格し、すべてが正常に見えますが、順序によって異なります。それらを別の順序で実行すると失敗します。<br>このような隠れたデバッグの難しい間違いを防ぐために、テストビルドごとにテストの順序をランダムにする必要があります。</p></blockquote><p>Goに限った話ではないので、テストを書くときは気を付けていきたいですね。</p><h1 id="T-Setenv、B-Setenvについて"><a href="#T-Setenv、B-Setenvについて" class="headerlink" title="T.Setenv、B.Setenvについて"></a>T.Setenv、B.Setenvについて</h1><p>テストコード、並びにベンチマーク中に環境変数をセットする事ができるようになりました。<a href="https://pkg.go.dev/os#Setenv">osパッケージのSetenv</a>との違いは、テストが終了するとセットした内容が破棄され、環境変数が汚染されない事です。</p><p>元々の環境変数がセットされている場合は、きちんと元の値に戻ります、気軽に環境変数を変更できるようになりました。</p><p><code>t.Parallel</code>実行後に利用すると環境変数の寿命の扱いが破綻するため、エラーが発生する点だけ要注意です。</p><p>サンプルを探したところ、下記のように<a href="https://github.com/golang/go/blob/891547e2d4bc2a23973e2c9f972ce69b2b48478e/src/go/build/build_test.go#L556">Go本体のテスト</a>でも早速大活躍していました。</p><figure class="highlight go"><figcaption><span>test.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestImportVendor</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">testenv.MustHaveGoBuild(t) <span class="comment">// really must just have source</span></span><br><span class="line"></span><br><span class="line">t.Setenv(<span class="string">&quot;GO111MODULE&quot;</span>, <span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">ctxt := Default</span><br><span class="line">wd, err := os.Getwd()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">ctxt.GOPATH = filepath.Join(wd, <span class="string">&quot;testdata/withvendor&quot;</span>)</span><br><span class="line">p, err := ctxt.Import(<span class="string">&quot;c/d&quot;</span>, filepath.Join(ctxt.GOPATH, <span class="string">&quot;src/a/b&quot;</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;cannot find vendored c/d from testdata src/a/b directory: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">want := <span class="string">&quot;a/vendor/c/d&quot;</span></span><br><span class="line"><span class="keyword">if</span> p.ImportPath != want &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;Import succeeded but found %q, want %q&quot;</span>, p.ImportPath, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私たちのチームでは、今まではテスト実行時にはMakefileで環境変数を一通り整備してからテストを実行する運用をしていました。また、必要な環境変数が存在しない場合はエラーで落ちるロジックが保険として書かれているのですが、複雑度が低いためテストできていない事を許容していました。</p><p>これらの課題をGo1.17に上げ事で簡単に解決できる希望が見えてきました。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Go1.17ではテストの実装を改善する為、2点の新機能が追加されている。</p><ul><li>新しいテストフラグ-shuffle</li><li>環境変数をモックするT.SetenvおよびB.Setenv</li></ul><p>見落とさず活用していきたいなと感じたので、連載のトピックとして取り上げてみました。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210812a/audit-3929140_640.jpg&quot; alt=&quot;&quot; title=&quot;mohamed HassanによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;371&quot; loading=&quot;lazy&quot;&gt;

&lt;p</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="テスト" scheme="https://future-architect.github.io/tags/%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #14「生体認証・デバイス認証を活用するパスワードレスな認証規格「WebAuthn」を体験！」</title>
    <link href="https://future-architect.github.io/articles/20210811b/"/>
    <id>https://future-architect.github.io/articles/20210811b/</id>
    <published>2021-08-10T15:00:01.000Z</published>
    <updated>2021-08-12T03:17:17.593Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210811b/key-3348307_640.jpg" alt="" title="MasterTuxによるPixabayからの画像" width="640" height="360" loading=""><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIGの市川浩暉です。</p><p>2021年7月21日に<a href="https://future.connpass.com/event/218520/">Future Tech Night #14～認証認可（IDaaS）勉強会～</a> を開催し、「生体認証・デバイス認証を活用するパスワードレスな認証規格「WebAuthn」を体験！」というテーマで登壇させていただきました。</p><p>なお、登壇者の資料は <a href="https://future.connpass.com/event/218520/presentation/">こちら</a> に公開済みですので、興味があればご参照ください。</p><p>一緒にイベントに登壇した山田さんのレポートはも公開されています。</p><ul><li><a href="/articles/20210812b/">IDaaS(Auth0) vs OSS（Keycloak）vs Managed(Amazon Cognito)で使い勝手を確認</a></li></ul><p>参加申し込み数はこれまでのFuture Tech Night史上最多となる190名の申し込みをいただき、大盛況での開催となりました。</p><h1 id="発表内容"><a href="#発表内容" class="headerlink" title="発表内容"></a>発表内容</h1><script async class="speakerdeck-embed" data-id="29f23e7fea7f428c95401c17f52005f6" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><p>当日の発表では、以下のアジェンダに沿って発表を実施しました。</p><ul><li>自己紹介</li><li>WebAuthnの概要説明<ul><li>前置き</li><li>これまでの認証方式</li><li>FIDO（Fast IDentity Online）</li><li>登録、認証フロー</li><li>WebAuthnとは</li><li>2つの認証方式</li><li>WebAuthn対応ブラウザ</li><li>WebAuthnを利用するメリット・デメリット</li></ul></li><li>Auth0を用いたWebAuthnの構築</li><li>まとめ</li></ul><h1 id="発表の概要"><a href="#発表の概要" class="headerlink" title="発表の概要"></a>発表の概要</h1><p>まず、WebAuthnが生まれた背景を理解しやすいよう、認証方式の変遷を説明しました。</p><p>その中で、パスワード認証方式と2要素認証の課題を解決するために生まれたFIDOという考え方、そしてFIDOをWebでも使用できるようにしたFIDO2（WebAuthn, CTAP）が生まれ、WebAuthnの登録と認証のフローについて説明しました。</p><p>WebAuthnの概要を理解した後に、最近Auth0がリリースした機能を用いて実際に生体認証によるパスワードレス機能、そして実装してみた感想を発表しました。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="Webサーバーに公開鍵はどのタイミングで登録されるのでしょうか？"><a href="#Webサーバーに公開鍵はどのタイミングで登録されるのでしょうか？" class="headerlink" title="Webサーバーに公開鍵はどのタイミングで登録されるのでしょうか？"></a>Webサーバーに公開鍵はどのタイミングで登録されるのでしょうか？</h2><p>登録されるタイミングはWebサーバ側で送られてきたチャレンジキーの検証に成功したタイミングです。<br>スライドの<a href="https://speakerdeck.com/hichikawa1126/future-tech-night-14?slide=21">P.21</a>にあるとおり、⑥にて生成した公開鍵を⑦でWebサーバ側に送信し、⑧での検証成功後に公開鍵とユーザの紐付けを行って登録します。</p><h2 id="実際の業務でWebAuthenを用いたAuth0での認証を使用した事例はありますか？-またもし利用するとしたらどのような事例でしょうか？"><a href="#実際の業務でWebAuthenを用いたAuth0での認証を使用した事例はありますか？-またもし利用するとしたらどのような事例でしょうか？" class="headerlink" title="実際の業務でWebAuthenを用いたAuth0での認証を使用した事例はありますか？　またもし利用するとしたらどのような事例でしょうか？"></a>実際の業務でWebAuthenを用いたAuth0での認証を使用した事例はありますか？　またもし利用するとしたらどのような事例でしょうか？</h2><p>フューチャーではAuth0をIDaaSとして採用し、実際に本番環境にて運用しているケースは多いのですが、今回ご紹介した機能はリリースされたばかりということもあり、実際のプロジェクトでの導入までは至っておりません。</p><p>IDaaSとしてAuth0を採用する場合、今回ご説明したWebAuthnを用いる機能は要件として含めることは可能と考えており、機会があれば前向きに考えていきたいと考えております。</p><h1 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h1><p>初めての勉強会登壇でしたが、アンケートでの回答やTwitterでのリアルタイム反応を見るのは新鮮で、自分にとって学びの多い勉強会になりました。反省点としては、少し時間がオーバしてしまい質疑応答ができなかったので、次回以降のイベントでは改善していければと思います。</p><p>フューチャーではFuture Tech Nightの他にも様々なイベントを開催しており、引き続き、参加者の皆さんと交流できる場としてもイベントを盛り上げていければと考えています。今後も皆様のご参加をお待ちしております。次回のイベント情報はフューチャーの<a href="https://future.connpass.com/">connpass</a>で確認できます。</p><p>最後に、発表をご視聴いただいた方、当記事を最後まで読んでいただいた方、ありがとうございました。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210811b/key-3348307_640.jpg&quot; alt=&quot;&quot; title=&quot;MasterTuxによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;360&quot; loading=&quot;&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;</summary>
      
    
    
    
    <category term="認証認可" scheme="https://future-architect.github.io/categories/%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Auth0" scheme="https://future-architect.github.io/tags/Auth0/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="WebAuthn" scheme="https://future-architect.github.io/tags/WebAuthn/"/>
    
  </entry>
  
  <entry>
    <title>Go1.17のencoding/csv</title>
    <link href="https://future-architect.github.io/articles/20210811a/"/>
    <id>https://future-architect.github.io/articles/20210811a/</id>
    <published>2021-08-10T15:00:00.000Z</published>
    <updated>2021-08-12T04:01:22.845Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210811a/csv.png" alt="" title="CSV" width="841" height="403" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p><a href="/articles/20210810a/">Go1.17連載</a>の2つ目です。</p><p>TIG DXユニット真野です。前回Go1.16連載の時も2つ目で<a href="/articles/20210209/">Go 1.16のgo installについて</a>について触れました。今回は <code>encoding/csv</code> のマイナーチェンジ（APIが1個だけ追加した）という小ネタです。</p><h2 id="Minor-changes-to-the-library-in-encoding-csv"><a href="#Minor-changes-to-the-library-in-encoding-csv" class="headerlink" title="Minor changes to the library in encoding/csv"></a>Minor changes to the library in encoding/csv</h2><p><a href="https://tip.golang.org/doc/go1.17#encoding/binary">Go 1.17 Release Notes</a>でencoding/xml, encoding/binaryとともに、encoding/csvも微修正がありました。</p><blockquote><p>The new Reader.FieldPos method returns the line and column corresponding to the start of a given field in the record most recently returned by Read.<br>csv.ReaderにFieldPostメソッドが追加され、最後に読んだ列を返す</p></blockquote><p>これについて紹介します。選んだ理由は個人的にCSVとかJSONとかApache Parquetといったデータレイアウトが好きだからです。</p><p>Issueは<a href="https://github.com/golang/go/issues/44221">encoding/csv: add the ability to get the line number of a record #44221</a>です。2021.2.21に起票され同年5.21にクローズされているので3ヶ月くらいの期間での出来事でしょうか。</p><h2 id="どういう関数か"><a href="#どういう関数か" class="headerlink" title="どういう関数か"></a>どういう関数か</h2><p>追加されたのはcsv.Readerの以下の関数です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">FieldPos</span><span class="params">(field <span class="keyword">int</span>)</span> <span class="params">(line, column <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>csv.Readerは<code>Read</code>関数でCSVデータを1レコードずつ処理しますが（1行と呼ばない理由ですがCSVは項目中の改行が許容されているからです）、現在処理しているファイルの行や列を取得します。行と列は1始まり。列はルーンではなくバイト単位でカウントされるようです。</p><p>早速使っていきましょう。</p><figure class="highlight go"><figcaption><span>FieldPosをつかったサンプル</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/csv&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.Open(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">r := csv.NewReader(f)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">record, err := r.Read()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> record &#123;</span><br><span class="line">lineNo, column := r.FieldPos(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;lineNo:%d column:%d pos:%d record:%s\n&quot;</span>, lineNo, i, column, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilePosを利用したコードでした。対象データとしてはGoDocに書いてあったCSVを利用します。</p><figure class="highlight plaintext"><figcaption><span>name.csv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name,last_name,username</span><br><span class="line">&quot;Rob&quot;,&quot;Pike&quot;,rob</span><br><span class="line">Ken,Thompson,ken</span><br><span class="line">&quot;Robert&quot;,&quot;Griesemer&quot;,&quot;gri&quot;</span><br></pre></td></tr></table></figure><p>これを実行すると次の実行結果になりました。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run main.go name.csv</span><br><span class="line">lineNo:1 column:0 pos:1 record:first_name</span><br><span class="line">lineNo:1 column:1 pos:12 record:last_name</span><br><span class="line">lineNo:1 column:2 pos:22 record:username</span><br><span class="line">lineNo:2 column:0 pos:1 record:Rob</span><br><span class="line">lineNo:2 column:1 pos:7 record:Pike</span><br><span class="line">lineNo:2 column:2 pos:14 record:rob</span><br><span class="line">lineNo:3 column:0 pos:1 record:Ken</span><br><span class="line">lineNo:3 column:1 pos:5 record:Thompson</span><br><span class="line">lineNo:3 column:2 pos:14 record:ken</span><br><span class="line">lineNo:4 column:0 pos:1 record:Robert</span><br><span class="line">lineNo:4 column:1 pos:10 record:Griesemer</span><br><span class="line">lineNo:4 column:2 pos:22 record:gri</span><br></pre></td></tr></table></figure><p>lineNoが対象ファイルの行番号です（1行目から4行目まで出ていますね）。次のcoulmnはカラムインデックス、posがCSV各カラムの出現位置です（[1 12 22]だと1文字目、12文字目、22文字目からそのカラムが始まっているよという意味です）。シンプルですね。言ってしまえばそれだけです。</p><h2 id="なぜ追加されたか"><a href="#なぜ追加されたか" class="headerlink" title="なぜ追加されたか"></a>なぜ追加されたか</h2><p>FieldPosというAPI経由しなくても少なくても、ループ変数を用いればファイル番号は取得できるような気がします。Goの思想的に反して余計なAPIを追加したのか？と思われる人も多いのではないでしょうか？</p><p>理由としてはおそらく、先程触れたとおりCSVファイルの項目中の改行が許容される（実質標準な<a href="http://www.kasai.fm/wiki/rfc4180jp">RFC4180</a>でも規定）のが理由の1つになると思います。</p><p>例えば、以下のようなCSVも許容されます。</p><figure class="highlight plaintext"><figcaption><span>lf.csv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;aaa&quot;,&quot;b</span><br><span class="line"></span><br><span class="line">bb&quot;,&quot;ccc&quot;</span><br><span class="line">zzz,yyy,xxx</span><br></pre></td></tr></table></figure><p>上記のlf.csvは4行ですが、CSVとしては2レコードです。項目中の改行もダブルクォートで囲めば許容されるということです。lf.csvのようなケースにおいては空行すら許容されます。</p><p>この仕様を理解すると行番号≠CSVレコード番号が分かると思います。どうようにカラム位置も項目中の改行を考慮すると、APIとして利用した方が使い側としては助かるというのがイメージが湧くでしょう。</p><p>このlf.csvを先程のサンプルコードで動かすと以下の結果です。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go run main.go lf.csv</span><br><span class="line">&gt; go run main.go lf.csv</span><br><span class="line">lineNo:1 column:0 pos:1 record:aaa</span><br><span class="line">lineNo:1 column:1 pos:7 record:b</span><br><span class="line"></span><br><span class="line">bb</span><br><span class="line">lineNo:3 column:2 pos:5 record:ccc</span><br><span class="line">lineNo:4 column:0 pos:1 record:zzz</span><br><span class="line">lineNo:4 column:1 pos:5 record:yyy</span><br><span class="line">lineNo:4 column:2 pos:9 record:xxx</span><br></pre></td></tr></table></figure><p>結果を見ると、CSV1レコード目のcccのカラムの行番号が3であるのがわかります。少し面白いですね。そしてFilePosの面白いところは、FieldPosの引数にカラムのインデックスを指定できるため、同一レコードの処理中に置いてlineNoが変わることが、すなわち項目中の改行が含まれている判明するという点です。</p><p>一見、ちょっと面倒そうな関数ですが中々考えられていますね。</p><p>今回は項目中の改行を例に上げましたが、他にも何かしらCSVの処理中に想定されていないデータが含まれていた場合（例えば予期せぬ区切り文字の混入やダブルクォートのエスケープがされていないなど）に、FieldPosによってトレースがしやすくなるのが大きいです（Issueのニュアンスだとこっちの方が強いかもです）。CSVのパースをしくじって数値項目なのに隣の文字列項目が設定されてエラーにった経験はみなさん何度も何度も経験してきたと思います。それが数百万、数千行のデータともなればトレースが大変。こういったデバック用のAPIが増えるのは本当に好ましいです。</p><p>encoding/csvパッケージを生で使う人は直接恩恵を受けられますし、これらのラッパーライブラリも性能改善などでメリットがある良い改修だと思います。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li>Go1.17ではencoding/CSVのReaderにFieldPosというCSV処理中の行番号やカラム開始位置を返す関数が追加された</li><li>項目中の改行の考慮であったり、違反データのトレーサビリティ（デバッグ）としても有効なAPIで、従来の回避手法に比べて性能が良いとのことです</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210811a/csv.png&quot; alt=&quot;&quot; title=&quot;CSV&quot; width=&quot;841&quot; height=&quot;403&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
  </entry>
  
  <entry>
    <title>CypressでAPIの実行、異常系のテストを行う</title>
    <link href="https://future-architect.github.io/articles/20210810b/"/>
    <id>https://future-architect.github.io/articles/20210810b/</id>
    <published>2021-08-09T15:00:01.000Z</published>
    <updated>2021-08-10T03:37:43.140Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210810b/landscape-2022147_640.jpg" alt="" title="Artturi MäntysaariによるPixabayからの画像" width="640" height="360" loading="lazy"><p>TIGの伊藤真彦です。</p><p>フューチャー技術ブログでも何度か取り上げているCypressですが、私も最近触り始めました。</p><p>過去記事は<a href="https://future-architect.github.io/tags/Cypress/">Cypressタグの記事</a>を参照してください。</p><p>今回取り上げたいテーマは、フロントエンドアプリケーションで、特定の画面に表示する情報をサーバーから取得する機能や、ボタンを押すとバックエンドサーバーなどにHTTPリクエストを送信するような機能が実装されている場合の話です。</p><p>期待通りのリクエストパラメータでAPIが実行されていること、サーバーサイドでエラーがあった場合の異常系の挙動などをテストしたくなった時に調べたことをまとめます。</p><p>なお正しいレスポンスが返ってくることもテストできますが、そこはバックエンドでテストできている、するべき部分なのでフロントエンドのテストとしては私は実装していません。</p><h1 id="CypressでAPIの実行を検証する"><a href="#CypressでAPIの実行を検証する" class="headerlink" title="CypressでAPIの実行を検証する"></a>CypressでAPIの実行を検証する</h1><p>ボタンを押した時にAPIが実行されていることを検証するテストコードを書く際に便利な機能として、<code>cy.intercept</code>が用意されていました。</p><p>下記のコードのように利用できます。</p><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;API実行ボタンが動作すること&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.intercept(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://localhost:3000/api&#x27;</span>).as(<span class="string">&#x27;post_req&#x27;</span>)</span><br><span class="line">  cy.findByText(<span class="string">&#x27;submit&#x27;</span>).click()</span><br><span class="line">  cy.wait(<span class="string">&#x27;@post_req&#x27;</span>)</span><br><span class="line">  cy.contains(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://docs.cypress.io/api/commands/intercept#Syntax">ドキュメント</a>に記載の通り、<code>cy.intercept</code>は様々な形式の引数に対し柔軟に対応できます、いろいろ試して下記の形式に落ち着きました。</p><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.intercept(<span class="string">&#x27;HTTPメソッド&#x27;</span>, <span class="string">&#x27;URL&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>cy.wait</code>を利用することで、ボタンを押してもAPIが実行されなかった場合、<code>cy.intercept</code>で指定したURL以外にリクエストが送信された場合はテストが失敗します。</p><h1 id="APIのリクエスト、レスポンスの内容を検証する"><a href="#APIのリクエスト、レスポンスの内容を検証する" class="headerlink" title="APIのリクエスト、レスポンスの内容を検証する"></a>APIのリクエスト、レスポンスの内容を検証する</h1><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;API実行ボタンが動作すること&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.intercept(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://localhost:3000/api&#x27;</span>).as(<span class="string">&#x27;post_req&#x27;</span>)</span><br><span class="line">  cy.findByText(<span class="string">&#x27;submit&#x27;</span>).click()</span><br><span class="line">  cy.wait(<span class="string">&#x27;@post_req&#x27;</span>).should(<span class="function"><span class="params">xhr</span> =&gt;</span> &#123;</span><br><span class="line">    expect(xhr.response.statusCode).to.eq(<span class="number">201</span>)</span><br><span class="line">    expect(xhr.request.body).to.eq(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;cypress&quot;,&quot;id&quot;:&quot;01&quot;&#125;&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  cy.contains(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>cy.wait</code>の戻り値からHTTPリクエスト、レスポンスを上記のように詳細にテストすることができます。</p><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> assert_req_body <span class="keyword">from</span> <span class="string">&#x27;../../fixtures/request/post_api1.json&#x27;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;API実行ボタンが動作すること&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.intercept(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://localhost:3000/api&#x27;</span>).as(<span class="string">&#x27;post_req&#x27;</span>)</span><br><span class="line">  cy.findByText(<span class="string">&#x27;submit&#x27;</span>).click()</span><br><span class="line">  cy.wait(<span class="string">&#x27;@post_req&#x27;</span>).should(<span class="function"><span class="params">xhr</span> =&gt;</span> &#123;</span><br><span class="line">    expect(xhr.response.statusCode).to.eq(<span class="number">201</span>)</span><br><span class="line">    expect(xhr.request.body).to.eq(<span class="built_in">JSON</span>.stringify(assert_req_body))</span><br><span class="line">  &#125;)</span><br><span class="line">  cy.contains(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>リクエストボディの量によってはJSONファイルとして切り出すことで見通しの良い状態を保つことができます。</p><p>JSONとしてのシンタックスハイライトや構文エラーの検知が働くことで凡ミスを回避できる側面もあります。</p><h1 id="APIのレスポンスをスタブする"><a href="#APIのレスポンスをスタブする" class="headerlink" title="APIのレスポンスをスタブする"></a>APIのレスポンスをスタブする</h1><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> assert_req_body <span class="keyword">from</span> <span class="string">&#x27;../../fixtures/request/post_api1.json&#x27;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;API実行が失敗した場合アラートが表示されること&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.intercept(</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://localhost:3005/api&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">statusCode</span>: <span class="number">500</span>,</span><br><span class="line">      <span class="attr">body</span>: <span class="string">&#x27;&#123;&quot;error&quot;: &quot;internal error&quot;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).as(<span class="string">&#x27;post_req&#x27;</span>)</span><br><span class="line">  cy.findByText(<span class="string">&#x27;submit&#x27;</span>).click()</span><br><span class="line">  cy.wait(<span class="string">&#x27;@post_req&#x27;</span>)</span><br><span class="line">  cy.contains(<span class="string">&#x27;失敗&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>cy.intercept</code>は第三引数を利用することでレスポンスをスタブすることができます。全てのAPI実行をスタブすればバックエンドサーバーが存在しない状態でもテストできます。</p><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.intercept(<span class="string">&#x27;HTTPメソッド&#x27;</span>, <span class="string">&#x27;URL&#x27;</span>, &#123;期待するレスポンス&#125;)</span><br></pre></td></tr></table></figure><p><code>body</code>ではなく<code>fixture</code>というキーを使用することで、fixtureフォルダに配置したJSONファイルを参照することも可能です。</p><figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> assert_req_body <span class="keyword">from</span> <span class="string">&#x27;../../fixtures/request/post_api1.json&#x27;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">&#x27;API実行が失敗した場合アラートが表示されること&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.intercept(</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://localhost:3005/api&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">statusCode</span>: <span class="number">500</span>,</span><br><span class="line">      <span class="attr">fixture</span>: <span class="string">&#x27;response/post_error1.json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).as(<span class="string">&#x27;post_req&#x27;</span>)</span><br><span class="line">  cy.findByText(<span class="string">&#x27;submit&#x27;</span>).click()</span><br><span class="line">  cy.wait(<span class="string">&#x27;@post_req&#x27;</span>)</span><br><span class="line">  cy.contains(<span class="string">&#x27;失敗&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>異常応答だけでなく、データの内容が画面に影響する場合に全パターンのテストを行う事もこのような方法で行うことができます。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Cypressでは…</p><ul><li><code>cy.intercept</code>を利用してHTTPリクエストの実行を検証できる</li><li>リクエスト、レスポンスの内容を細かくテストできる</li><li>レスポンスをスタブすることもできる</li></ul><p>テストはただただ動かすだけでなく、異常系をいかに網羅するかが品質を左右します、リリース前にバグを見抜ける仕組みを整えていきましょう。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210810b/landscape-2022147_640.jpg&quot; alt=&quot;&quot; title=&quot;Artturi MäntysaariによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;360&quot; loading=&quot;la</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="E2Eテスト" scheme="https://future-architect.github.io/tags/E2E%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="Node.js" scheme="https://future-architect.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.17連載が始まります: コンパイラとgo mod</title>
    <link href="https://future-architect.github.io/articles/20210810a/"/>
    <id>https://future-architect.github.io/articles/20210810a/</id>
    <published>2021-08-09T15:00:00.000Z</published>
    <updated>2021-08-19T03:50:51.043Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210810a/evraiki-2514544_640.jpg" alt="" title="Наталья КоллеговаによるPixabayからの画像" width="640" height="480" loading="lazy"><p>前回のフューチャー技術ブログで行った<a href="https://future-architect.github.io/articles/20210207/">Go 1.16連載</a>に引き続き、今回もGo 1.17の集中連載を行います。</p><p>Go 1.17のリリースの足音が聞こえてきました。1.16のgo:embedのような「うぉっ」と声が出るような大きな新機能はなく、APIが変わらずに勝手に改善されるようなものと、小粒なAPIの追加が多い感じです。<a href="https://blog.golang.org/generics-next-step#TOC_4.">ジェネリクスは何も変更がなければ最短で1.17</a>という話もありましたが、今回は入っていません。</p><p>今回の連載ではこれらの変更をリレー形式で紹介していきます。</p><div class="scroll"><table><thead><tr><th align="center">公開日</th><th align="center">寄稿者</th><th align="left">記事</th></tr></thead><tbody><tr><td align="center">8月10日</td><td align="center">澁川喜規</td><td align="left">コンパイラとgo mod(この記事)</td></tr><tr><td align="center">8月11日</td><td align="center">真野隼記</td><td align="left"><a href="/articles/20210811a/">encoding/csv</a></td></tr><tr><td align="center">8月12日</td><td align="center">伊藤真彦</td><td align="left"><a href="/articles/20210812a/">testingの新機能</a></td></tr><tr><td align="center">8月17日</td><td align="center">玉木竜二</td><td align="left"><a href="/articles/20210817a/">rune</a></td></tr><tr><td align="center">8月18日</td><td align="center">辻大志郎</td><td align="left"><a href="/articles/20210818a/">go get</a></td></tr><tr><td align="center">8月19日</td><td align="center">宮崎将太</td><td align="left"><a href="/articles/20210819b">New warnings for Is, As and Unwrap methods</a></td></tr><tr><td align="center">8月20日</td><td align="center">市川燿</td><td align="left">sync/atomic</td></tr></tbody></table></div><p>また毎回恒例の<a href="https://gocon.connpass.com/event/216361/">Go 1.17リリースパーティ</a>も開催予定です。ぜひご参加ください。</p><h1 id="コンパイラ"><a href="#コンパイラ" class="headerlink" title="コンパイラ"></a>コンパイラ</h1><h2 id="関数呼び出しが5-高速化"><a href="#関数呼び出しが5-高速化" class="headerlink" title="関数呼び出しが5%高速化"></a>関数呼び出しが5%高速化</h2><p>1.16の時に予告されていたレジスタベースの関数呼び出しが入りました。呼び出し速度が5%、バイナリサイズが2%改善されました。特にコードの変更なく恩恵に授かれます。</p><p>あとはpanic時のスタックトレースの表示が改善され、今まで16進数で表示されていたのが改善されたらしいのですが、よくわかりませんでした。16進数は出なくなりましたが、試したが、…となるだけでした。</p><p>クロージャを含む関数がインライン展開されるようにもなりました。これもコード修正必要なく、パフォーマンスアップにつながる可能性があります。</p><p>なお、unsafeで怪しく引数を触ったりするとトラブルが発生する可能性がありますが、通常のGoの使用方法では問題になることはなさそうです。</p><h2 id="build-constraintのコメントが変更"><a href="#build-constraintのコメントが変更" class="headerlink" title="build constraintのコメントが変更"></a>build constraintのコメントが変更</h2><p>以前は次のようなコメント形式でした。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build windows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>これが次のようになります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//go:build windows</span><br><span class="line">// +build windows</span><br><span class="line"></span><br><span class="line">package main</span><br></pre></td></tr></table></figure><p>今は新旧併存ですが、1.1８が出て1.16サポートが切れたら新コメントのみ対応になると思われます。</p><p><code>//go:generate</code>とか<code>//go:noinline</code>と見た目が揃いますね。旧コメントは後ろに空行がないといけない（しかし、他のgodocなどは空行があってはダメ）など、いろいろ気難しい感じでしたが、新コメントはここは緩和されています。</p><p>go fmtでは互換性を考えて新・旧のコメントを生成したり、go vetでは新・旧のコメントの内容が違っていたら警告を出すなど、周辺エコシステムもこれを受けて変更されています。</p><h2 id="新しいターゲットの追加と削除"><a href="#新しいターゲットの追加と削除" class="headerlink" title="新しいターゲットの追加と削除"></a>新しいターゲットの追加と削除</h2><p>macOSのサポートが10.13 High Sierra以降のみになる、WindowsのARM64がサポートされる、64bit MIPS on OpenBSDがサポート、すべてのARM64環境でスタックフレームポインタが維持されるようになった（Linux/macOS/iOSは元々維持されていたのが全展開になった)、loong64がGOARCHの予約語に追加（サポートはまだ）、という感じでした。</p><p>WindowsのARM64は今後広がっていくんですかね。ARM64機よりも、M1 mac上でQEMUで動かす方が台数が増えそうな気がしないでもないですが・・・Surface Pro Xは少しお高かったので、安い機種が出てきたら興味はあります。</p><p>loong64とは何かよくわからなかったのですが、中国製CPUの龍芯ですね。MIPS64のカスタム版みたいなやつのようです。面白そう。</p><ul><li><a href="https://pc.watch.impress.co.jp/docs/topic/feature/1048911.html">PC Watch: MIPSなのにx86とARMアプリを高速に実行できる中国製CPU「龍芯」のカラクリ</a></li></ul><h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h1><p>今回一番変更が多かったのがgo mod周りですね。</p><h2 id="Module-Graph-Pruning-Lazy-Module-Loading"><a href="#Module-Graph-Pruning-Lazy-Module-Loading" class="headerlink" title="Module Graph Pruning (Lazy Module Loading)"></a>Module Graph Pruning (Lazy Module Loading)</h2><p>github.com/rs/xidとgithub.com/fatih/colorをgo getしてみたコードです。</p><figure class="highlight go"><figcaption><span>go.mod(1.16)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module go116sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/fatih/color v1<span class="number">.12</span><span class="number">.0</span></span><br><span class="line">        github.com/rs/xid v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>go.mod(1.17)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module go117sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.17</span></span><br><span class="line"></span><br><span class="line">require github.com/fatih/color v1<span class="number">.12</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-colorable v0<span class="number">.1</span><span class="number">.8</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.12</span> <span class="comment">// indirect</span></span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200223170610</span>-d5e6a3e2c0ae <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go 1.17の方は間接的に呼び出されているパッケージの情報まで含まれています。Go 1.16の場合は全モジュールグラフを取得する場合はどんどん子供を辿っていって完成させる必要がありますが、Go 1.17は必要な依存関係がすべて含まれているため、go.modを調べる必要性が減っています。</p><p>詳しくはこちらの<a href="https://tip.golang.org/ref/mod#graph-pruning">Go Modの説明</a>か、この<a href="https://go.googlesource.com/proposal/+/master/design/36460-lazy-module-loading.md">Module Graph PruningのDesign Document</a>参照と書かれています。</p><p>一見、pruningという言葉を言葉を見ると、刈り込みとか削除という意味なので1.16の動作の方が新しい挙動っぽくも感じたのですが、必要なサブパッケージの情報まで読み込みをしてflatten化して整理する、みたいなニュアンスなのかもしれません。英語難しい。</p><p>Design Documentの説明によると背景としてはこんな感じっぽいです</p><ul><li>今まではモジュールグラフを見ないと必要なライブラリとバージョンが決定できなかった</li><li>go.modを提供していないライブラリがあると、実行するたびに条件が変わりがちだし、必要なパッケージのバージョンが引き上げられたりする可能性もあるし、参照先がなくなってキャッシュされていない場合にビルドできなくなったりする</li><li>選択されたバージョンだけではなく、indirectな依存バージョンも登場するため、replaceディレクティブを使うのば難しかった</li><li>大量のgo.modを取得しなければならないことを避けたい</li></ul><p>必要になるまでgo.modの読み込みを遅延させる、go.modの読み込みの必要性を下げることが「Lazy Module Lodaing」という感じのようですね。</p><p>少ないgo.modの読み込みで完了するということですかね。ビルドが早くなったりしそうな気がしますが、とくにそういう効果は書かれてませんね。まあ条件が難しいから数値化もしにくそう。</p><h2 id="go-modコマンドでGoバージョンの更新や上書きが可能"><a href="#go-modコマンドでGoバージョンの更新や上書きが可能" class="headerlink" title="go modコマンドでGoバージョンの更新や上書きが可能"></a>go modコマンドでGoバージョンの更新や上書きが可能</h2><p>go mod周りは前述の変更などバージョンによって挙動が変わったりします。そのため、go.modの<code>go</code>ディレクティブのバージョン指定が大切になってきます。なお、今回からgo directivesがない時は、現在のバージョンではなく、go 1.11とみなすことになりました（1.12からはgo mod initをすれば勝手に<code>go</code>ディレクティブが入る）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go 1.17</span><br></pre></td></tr></table></figure><p>そのためにgo mod tidyコマンドのオプションが増えています。<code>-go</code>を設定すると、go.modをそのバージョンの方式で上書きして更新します。<code>-compat</code>はgo.modの変更はしません。指定のバージョンで実行したものとして実行する感じですかね？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy -go=1.17     # 更新</span><br><span class="line">$ go mod tidy -compat=1.17 # 旧バージョンサポートを上書きして実行</span><br></pre></td></tr></table></figure><h2 id="非推奨-deprecated-宣言"><a href="#非推奨-deprecated-宣言" class="headerlink" title="非推奨(deprecated)宣言"></a>非推奨(deprecated)宣言</h2><p>もうこのバージョンは古いよ、とかこのパッケージはメンテを停止したよ、ということをパッケージ開発者が情報を付与できるようになりました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deprecated: use example.com/mod/v2 instead.</span></span><br><span class="line">module example.com/mod</span><br></pre></td></tr></table></figure><p>goコマンドでビルドしたりパッケージ取得する場合は警告が出るようになりますし、次のコマンドで表示できるとのこと。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m -u</span><br></pre></td></tr></table></figure><h2 id="go-getの認証とかもろもろ"><a href="#go-getの認証とかもろもろ" class="headerlink" title="go getの認証とかもろもろ"></a>go getの認証とかもろもろ</h2><p><code>-insecure</code>で安全なHTTPS接続でなくても接続できるオプション（ついでにチェックサムのチェックなどを無視する）がありましたが、それがなくなるようです。<code>GOINSECURE</code>環境変数を使えとのこと。</p><p>あと、sshの認証が必要な場合に認証ダイアログが出るようになります。</p><h2 id="go-mod-downloadの挙動の変化"><a href="#go-mod-downloadの挙動の変化" class="headerlink" title="go mod downloadの挙動の変化"></a>go mod downloadの挙動の変化</h2><p><code>go mod download all</code>の<code>all</code>がない限りは、go.sumを更新することはなくなりました。1.15の挙動に戻るとのこと。</p><h2 id="go-mod-vendorでバージョン情報が付与"><a href="#go-mod-vendorでバージョン情報が付与" class="headerlink" title="go mod vendorでバージョン情報が付与"></a>go mod vendorでバージョン情報が付与</h2><p>go mod vendorしたときに生成されるvendor/modules.txtファイル。次のように、ちょびっとだけexplictの後ろにバージョンが付与されるという違いあります。それぞれのパッケージのgo.modに書かれていたバージョンが抽出されるようです。それぞれのパッケージはこのバージョンでビルドされる、go.modは無視されると書かれていますが、それぞれのバージョンのコンパイラがあるわけではないし、よくわからないですね。</p><figure class="highlight plaintext"><figcaption><span>go1.17</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># github.com/fatih/color v1.12.0</span><br><span class="line">## explicit; go 1.13</span><br><span class="line">github.com/fatih/color</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>go1.16</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># github.com/fatih/color v1.12.0</span><br><span class="line">## explicit</span><br><span class="line">github.com/fatih/color</span><br></pre></td></tr></table></figure><h2 id="go-runで外部パッケージを直接実行"><a href="#go-runで外部パッケージを直接実行" class="headerlink" title="go runで外部パッケージを直接実行"></a>go runで外部パッケージを直接実行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># バージョンを付けないとエラー</span></span><br><span class="line"></span><br><span class="line">% go run github.com/Songmu/gocredits/cmd/gocredits</span><br><span class="line">no required module provides package github.com/Songmu/gocredits/cmd/gocredits; to add it:</span><br><span class="line">go get github.com/Songmu/gocredits/cmd/gocredits</span><br><span class="line"></span><br><span class="line"><span class="comment"># 付けるとOK</span></span><br><span class="line">% go run github.com/Songmu/gocredits/cmd/gocredits@latest</span><br></pre></td></tr></table></figure><p>go generateでもダウンロードせずに直接実行できました。go modには追加されないため、ライブラリ作者だけが必要なツールはこちらの書き方にしておけば、ライブラリユーザーがそのツールをダウンロードする必要はなくなりそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate go run github.com/Songmu/gocredits/cmd/gocredits@latest -w</span></span><br></pre></td></tr></table></figure><p>1.16では@latestをつけてもエラーになり、build constraintでビルド対象にならないtools.goファイルを作ってgo getしてgo.modにも記録してあげるのがバッドノウハウとなっていました。あまり直感的とは言えない動作だったので、1.17の方式はありがたいですね。1.15ではできていましたが。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.16までのやり方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;github.com/Songmu/gocredits/cmd/gocredits&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210810a/evraiki-2514544_640.jpg&quot; alt=&quot;&quot; title=&quot;Наталья КоллеговаによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;480&quot; loading=&quot;lazy&quot;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="Go1.17" scheme="https://future-architect.github.io/tags/Go1-17/"/>
    
  </entry>
  
  <entry>
    <title>BacklogとSlackを連携するツールをGoで作りました</title>
    <link href="https://future-architect.github.io/articles/20210806b/"/>
    <id>https://future-architect.github.io/articles/20210806b/</id>
    <published>2021-08-05T15:00:01.000Z</published>
    <updated>2021-08-06T02:41:16.782Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です。</p><p>私のチームではタスク管理でバックログを使っています。</p><p>タスクのカテゴリ、マイルストーンやそれらを組み合わせた検索機能が充実している事や、タスクを入力するとバーンダウンチャートが自動で出来上がるところなど素晴らしいツールだと思っています。</p><p>チケット消化に貢献すると褒めてくれるのも良いですね。<br><img src="/images/20210806b/image.png" alt="Backlogのチャート" width="1200" height="558" loading="lazy"></p><p>さてチケット管理を行うとチケットを監視する仕事が産まれますが、それをある程度自動化するためのツールを作成しました。</p><h1 id="backlogslackify"><a href="#backlogslackify" class="headerlink" title="backlogslackify"></a>backlogslackify</h1><p>リポジトリはこちらです。</p><p><a href="https://github.com/future-architect/backlogslackify">https://github.com/future-architect/backlogslackify</a></p><p>未完了のBacklogチケットの存在をSlackに通知するツールです。</p><p>Slackと連携するものをslackifyと呼ぶのはRuby On Rails開発者時代にお世話になった<a href="https://github.com/onthebeach/capistrano-slackify">capistrano-slackify</a>を真似ています。</p><p>READMEに記載していますが、未完了のBacklogチケットのURL、リンク、担当者を画像のようにSlackに投稿してくれます。</p><img src="/images/20210806b/image_2.png" alt="ツールイメージ" width="946" height="322" loading="lazy"><p>GoでBacklogチケットを取り扱うロジックは<a href="https://developer.nulab.com/ja/docs/backlog/libraries/#">公式ドキュメント</a>にも紹介されている事から、<a href="https://github.com/kenzo0107/backlog">kenzo0107さんのライブラリ</a>を安心して利用することができ、仕事の片手間にササっと作ることができました、ありがとうございます。</p><h1 id="設定方法"><a href="#設定方法" class="headerlink" title="設定方法"></a>設定方法</h1><p>詳細な使用方法はREADMEに記載されていますので、補足資料として必要な情報を記載します。</p><h3 id="Configについて"><a href="#Configについて" class="headerlink" title="Configについて"></a>Configについて</h3><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientOption is input options to build client</span></span><br><span class="line"><span class="comment">// BacklogDueDate is &quot;weekend&quot; or &quot;end_of_month&quot; or relative days number like &quot;3&quot;</span></span><br><span class="line"><span class="comment">// required parameter is below</span></span><br><span class="line"><span class="comment">// BacklogApiKey</span></span><br><span class="line"><span class="comment">// BacklogBaseUrl</span></span><br><span class="line"><span class="comment">// SlackWebhookUrl</span></span><br><span class="line"><span class="comment">// SlackChannel</span></span><br><span class="line"><span class="comment">// SearchConditions</span></span><br><span class="line"><span class="keyword">type</span> ClientOption <span class="keyword">struct</span> &#123;</span><br><span class="line">BacklogApiKey    <span class="keyword">string</span>            <span class="string">`json:&quot;backlog_api_key&quot;`</span></span><br><span class="line">BacklogBaseUrl   <span class="keyword">string</span>            <span class="string">`json:&quot;backlog_base_url&quot;`</span></span><br><span class="line">BacklogDueDate   <span class="keyword">string</span>            <span class="string">`json:&quot;backlog_due_date&quot;`</span></span><br><span class="line">SlackWebhookUrl  <span class="keyword">string</span>            <span class="string">`json:&quot;slack_webhool_url&quot;`</span></span><br><span class="line">SlackChannel     <span class="keyword">string</span>            <span class="string">`json:&quot;slack_channel&quot;`</span></span><br><span class="line">SlackAccountName <span class="keyword">string</span>            <span class="string">`json:&quot;slack_account_name&quot;`</span></span><br><span class="line">SlackIconEmoji   <span class="keyword">string</span>            <span class="string">`json:&quot;slack_icon_emoji&quot;`</span></span><br><span class="line">SlackIconUrl     <span class="keyword">string</span>            <span class="string">`json:&quot;slack_icon_url&quot;`</span></span><br><span class="line">IsSinglePost     <span class="keyword">bool</span>              <span class="string">`json:&quot;is_single_post&quot;`</span></span><br><span class="line">DryRun           <span class="keyword">bool</span>              <span class="string">`json:&quot;dry_run&quot;`</span></span><br><span class="line">SearchConditions []SearchCondition <span class="string">`json:&quot;search_conditions&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SearchCondition is conditions to search backlog ticket</span></span><br><span class="line"><span class="comment">// it depends on github.com/kenzo0107/backlog</span></span><br><span class="line"><span class="keyword">type</span> SearchCondition <span class="keyword">struct</span> &#123;</span><br><span class="line">Name      <span class="keyword">string</span>                    <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Condition *backlog.GetIssuesOptions <span class="string">`json:&quot;condition&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コードに書いている通りですが、BacklogのAPIを実行するための各種設定、Slackに投稿するための各種設定、検索するチケットの設定を行います。チケットの検索条件にヒットしたもののうち、期限日が<code>BacklogDueDate</code>で設定した日数、または<code>weekend</code>にした場合週末を超過した場合、そのチケットが通知対象に追加されます。</p><p>きちんと期限日を設定しないとどれだけ放置されても検知できませんのでご注意ください。設定の内容を整備したら、適宜手動で実行するか、任意のアーキテクチャで定時バッチとして実行する使い方を想定しています。</p><h3 id="BacklogのAPIキーの取得方法"><a href="#BacklogのAPIキーの取得方法" class="headerlink" title="BacklogのAPIキーの取得方法"></a>BacklogのAPIキーの取得方法</h3><p><a href="https://support-ja.backlog.com/hc/ja/articles/360035641754-API%E3%81%AE%E8%A8%AD%E5%AE%9A">公式のリファレンス</a>を参照してください</p><h3 id="Slackの連携URL"><a href="#Slackの連携URL" class="headerlink" title="Slackの連携URL"></a>Slackの連携URL</h3><p>Slackとの連携にはIncoming Webhooksを利用しています。公式ドキュメントは<a href="https://api.slack.com/messaging/webhooks">こちら</a>です。</p><h3 id="チケットの検索条件について"><a href="#チケットの検索条件について" class="headerlink" title="チケットの検索条件について"></a>チケットの検索条件について</h3><p>Backlogの課題取得APIを実行しています。</p><p>APIリファレンスは<a href="https://developer.nulab.com/ja/docs/backlog/api/2/get-issue-list/#">こちら</a>です。<br><code>ProjectIDs</code>、<code>CategoryIDs</code>あたりがあれば実用充分だとは思いますが、APIで使えるものは何でも絞り込みに利用できます。絞り込みたい<code>CategoryIDs</code>を知りたい場合は、実際にBacklogでチケットを検索するとブラウザのアドレスバーに表示されています。</p><h2 id="実際に使ってみての感想"><a href="#実際に使ってみての感想" class="headerlink" title="実際に使ってみての感想"></a>実際に使ってみての感想</h2><p>毎朝9時にbotを動かすようにしました。</p><p>Slackに投稿されると何が嬉しいかというと、画像のようなノリで楽に終わってないチケットにツッコミを入れることができます。</p><img src="/images/20210806b/image_3.png" alt="" width="759" height="585" loading=""><p>未完了のチケットを調べて、誰の担当になっているかを確認して、適宜終わっているか確認するのは単純に手間がかかるだけでなく、急かしているような印象を与えないための配慮など、人対人のコミュニケーションには時間とスタミナを奪われがちです。</p><p>こういったものはなるべく自動化していきたいですね。</p><p>OSSにしたことでどこかで利用いただければ嬉しいです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;私のチームではタスク管理でバックログを使っています。&lt;/p&gt;
&lt;p&gt;タスクのカテゴリ、マイルストーンやそれらを組み合わせた検索機能が充実している事や、タスクを入力するとバーンダウンチャートが自動で出来上がるところなど素晴らしいツールだと</summary>
      
    
    
    
    <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Slack" scheme="https://future-architect.github.io/tags/Slack/"/>
    
    <category term="Backlog" scheme="https://future-architect.github.io/tags/Backlog/"/>
    
  </entry>
  
  <entry>
    <title>Cypressでテスト可能なドラッグアンドドロップ実装</title>
    <link href="https://future-architect.github.io/articles/20210806a/"/>
    <id>https://future-architect.github.io/articles/20210806a/</id>
    <published>2021-08-05T15:00:00.000Z</published>
    <updated>2021-08-06T02:39:34.019Z</updated>
    
    <content type="html"><![CDATA[<p>お仕事コードで、「Cypressで頑張ったけどドラッグアンドドロップのテストができない」という相談を受けました。僕も試行錯誤してみたのですが、どうもうまくいかず・・・</p><h1 id="なぜうまくいかないのか"><a href="#なぜうまくいかないのか" class="headerlink" title="なぜうまくいかないのか"></a>なぜうまくいかないのか</h1><p>CypressとかのE2Eテストは、完全なユーザーの入力をエミュレーションするわけではなくて、ユーザーが入力したときに発生するであろうイベントを擬似的に作って投げているにすぎません。実際に発生するイベントよりも少ないです。例えば、マウスが移動すると、マウスのしたの要素のmouseover/mouseleaveイベントが発生しまくると思いますが、テストではそういうことはせず、必要な要素のクリックとか、inputへのテキスト入力とか必要なイベントのみを発行します。</p><p>お仕事コードで使っていたのはこのライブラリです。さまざまなマウスジェスチャーを実現してくれる便利そうなライブラリですね。</p><p><a href="https://use-gesture.netlify.app/">https://use-gesture.netlify.app/</a></p><p>ドラッグアンドドロップのサンプルは<a href="https://codesandbox.io/s/fh8r8?file=/src/index.js">こちら</a>にあります。</p><p>これを見ると、マウスの座標をとって、現在位置を取得しています。そして、それをアニメーションライブラリに投げ込んでいるようですね。ドラッグ中に連続的に順番を入れ替えています。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bind = useDrag(<span class="function">(<span class="params">&#123; args: [originalIndex], active, movement: [, y] &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> curIndex = order.current.indexOf(originalIndex)</span><br><span class="line">  <span class="keyword">const</span> curRow = clamp(<span class="built_in">Math</span>.round((curIndex * <span class="number">100</span> + y) / <span class="number">100</span>), <span class="number">0</span>, items.length - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> newOrder = swap(order.current, curIndex, curRow)</span><br><span class="line">  <span class="comment">// Feed springs new style data, they&#x27;ll animate the view without causing a single render</span></span><br><span class="line">  setSprings(fn(newOrder, active, originalIndex, curIndex, y))</span><br><span class="line">  <span class="keyword">if</span> (!active) order.current = newOrder</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>こういうのはE2Eテストではやりにくいですね。</p><h1 id="E2Eテストしやすいドラッグアンドドロップ"><a href="#E2Eテストしやすいドラッグアンドドロップ" class="headerlink" title="E2Eテストしやすいドラッグアンドドロップ"></a>E2Eテストしやすいドラッグアンドドロップ</h1><p>実装してみたサンプルがこれです。3つの要素のリストを並べ替えします。</p><img src="/images/20210806a/スクリーンショット_2021-07-29_18.38.23.png" alt="ドラッグでリスト並び替え画面" width="1200" height="611" loading="lazy"><p>E2Eテストも通っています。これの実現方法を紹介します。</p><img src="/images/20210806a/スクリーンショット_2021-07-29_18.39.50.png" alt="ドラッグでリスト並び替え画面" width="1200" height="717" loading="lazy"><p>まずテストコード側から。テストしやすいドラッグアンドドロップは、「ドラッグする要素」と、「それを落とした要素」が明確であるケースです。この場合、data-item属性のついた要素がドラッグする赤い四角、data-targetはドロップ先で、各要素の間と、リストの先頭、末尾に4つあります。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">context(<span class="string">&quot;drag and drop&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    cy.visit(<span class="string">&quot;http://localhost:3000/&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;can drag and drop items&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    cy.get(<span class="string">&quot;[data-item=&#x27;B&#x27;]&quot;</span>).trigger(<span class="string">&quot;dragstart&quot;</span>).trigger(<span class="string">&quot;dragleave&quot;</span>);</span><br><span class="line">    cy.get(<span class="string">&quot;[data-target=&#x27;0&#x27;]&quot;</span>)</span><br><span class="line">      .trigger(<span class="string">&quot;dragenter&quot;</span>)</span><br><span class="line">      .trigger(<span class="string">&quot;dragover&quot;</span>)</span><br><span class="line">      .trigger(<span class="string">&quot;drop&quot;</span>)</span><br><span class="line">      .trigger(<span class="string">&quot;dragend&quot;</span>);</span><br><span class="line">    cy.get(<span class="string">&quot;.item:first&quot;</span>).contains(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>create-react-appで、TypeScriptのプロジェクトを作ります。その後、Tailwind CSSを設定した状態からスタートします。説明は公式ページを参照してください。ちょっと長くなるので本エントリーでは省略します。</p><ul><li><a href="https://create-react-app.dev/docs/adding-typescript/">Create React App: Adding TypeScript</a></li><li><a href="https://tailwindcss.com/docs/guides/create-react-app">Install Tailwind CSS with Create React App</a></li></ul><p>いきなり完成形だと長すぎるので、まずはイベントハンドラを実装する前の状態をお見せします。Listが親の要素、Elemがドラッグする要素、Targetがドロップ先の要素で、Listの中では<code>&lt;Target&gt;&lt;Elem&gt;&lt;Target&gt;...&lt;Elem&gt;&lt;Target&gt;</code>と互い違いに出力されます。</p><figure class="highlight js"><figcaption><span>index.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">props: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  label: string;</span></span></span><br><span class="line"><span class="params"><span class="function">  index: number;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">data-item</span>=<span class="string">&#123;props.label&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">item</span> <span class="attr">flex-initial</span> <span class="attr">border-4</span> <span class="attr">border-red-400</span> <span class="attr">p-4</span> <span class="attr">rounded</span> <span class="attr">cursor-move</span>`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span></span></span><br><span class="line"><span class="xml">      &#123;props.label&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Target</span>(<span class="params">props: &#123; index: number &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">target</span> <span class="attr">flex-initial</span> <span class="attr">p-2</span>`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">data-target</span>=<span class="string">&#123;props.index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = useState([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tags = [<span class="xml"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">index</span>=<span class="string">&#123;0&#125;</span> <span class="attr">onDrop</span>=<span class="string">&#123;onDrop&#125;</span> /&gt;</span></span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, item] <span class="keyword">of</span> items.entries()) &#123;</span><br><span class="line">    tags.push(</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Elem</span> <span class="attr">label</span>=<span class="string">&#123;item&#125;</span> <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> <span class="attr">onDrag</span>=<span class="string">&#123;onDrag&#125;</span> /&gt;</span></span>,</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">index</span>=<span class="string">&#123;i</span> + <span class="attr">1</span>&#125; <span class="attr">onDrop</span>=<span class="string">&#123;onDrop&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex border-2 border-blue-400 p-4 rounded&quot;</span>&gt;</span>&#123;tags&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一つずつ完成させていきましょう。まず、ドラッグ可能な要素は、onDragStart/onDragEndのイベントを実装します。onDragStartで、自分がドラッグされているよ、ということを親に伝えます。それ以外は見た目の透明度を変えるぐらいですね。ここでは半透明にしていますが、完全に透明にしてしまって幅もゼロにしてしまうと、react-use-gestureのサンプルみたいな、リアルタイムにリストが書き変わって動いているような感じにできると思います。</p><figure class="highlight js"><figcaption><span>index.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">props: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  label: string;</span></span></span><br><span class="line"><span class="params"><span class="function">  index: number;</span></span></span><br><span class="line"><span class="params"><span class="function">  onDrag: (index: number) =&gt; <span class="keyword">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [dragging, setDragging] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> dragStart = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setDragging(<span class="literal">true</span>);</span><br><span class="line">    props.onDrag(props.index);</span><br><span class="line">  &#125;, [props]);</span><br><span class="line">  <span class="keyword">const</span> dragEnd = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setDragging(<span class="literal">false</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">data-item</span>=<span class="string">&#123;props.label&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">item</span> <span class="attr">flex-initial</span> <span class="attr">border-4</span> <span class="attr">border-red-400</span> <span class="attr">p-4</span> <span class="attr">rounded</span> <span class="attr">cursor-move</span> $&#123;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">dragging</span> ? &quot;<span class="attr">opacity-40</span>&quot; <span class="attr">:</span> &quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDragStart</span>=<span class="string">&#123;dragStart&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDragEnd</span>=<span class="string">&#123;dragEnd&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span></span></span><br><span class="line"><span class="xml">      &#123;props.label&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次はドロップ先です。onDragOver/onDragEnter/onDragLeave/onDropを実装します。これもonDropで親のリストに自分にドロップされたことを伝えます。このサンプルではTailwind CSSのパディング属性（p-2, p-6)で雑に空間を広げていますが、元の要素のサイズ＋要素間の隙間x2の幅にきちんと計算して表示してあげると、きれいな見た目になると思います。ついでにアニメーションでその幅に変わるようにしてあげるともっと良さそう。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Target</span>(<span class="params">props: &#123; index: number; onDrop: (index: number) =&gt; <span class="keyword">void</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [over, setOver] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> dragOver = useCallback(<span class="function">(<span class="params">e: DragEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">const</span> dragEnter = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setOver(<span class="literal">true</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">const</span> dragLeave = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setOver(<span class="literal">false</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">const</span> drop = useCallback(</span><br><span class="line">    <span class="function">(<span class="params">e: DragEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      setOver(<span class="literal">false</span>);</span><br><span class="line">      props.onDrop(props.index);</span><br><span class="line">    &#125;,</span><br><span class="line">    [props]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDragOver</span>=<span class="string">&#123;dragOver&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDragEnter</span>=<span class="string">&#123;dragEnter&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDragLeave</span>=<span class="string">&#123;dragLeave&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">onDrop</span>=<span class="string">&#123;drop&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">target</span> <span class="attr">flex-initial</span> $&#123;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">over</span> ? &quot; <span class="attr">border-2</span> <span class="attr">border-dotted</span> <span class="attr">border-red-200</span> <span class="attr">p-6</span>&quot; <span class="attr">:</span> &quot;<span class="attr">p-2</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">data-target</span>=<span class="string">&#123;props.index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後が親のリストです。子供の「ドラッグされたよ」「ドロップされたよ」情報を受け取り、useEffectで並び替えを実行します。</p><figure class="highlight js"><figcaption><span>index.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">props: &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = useState([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]);</span><br><span class="line">  <span class="keyword">let</span> [src, setSrc] = useState(-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> [target, setTarget] = useState(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onDrag = useCallback(<span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    setSrc(index);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`🥚 onDrag <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onDrop = useCallback(<span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`🐣 onDrop <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    setTarget(index);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src !== -<span class="number">1</span> &amp;&amp; target !== -<span class="number">1</span>) &#123;</span><br><span class="line">      setItems(swap(items, src, target));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [src, target]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tags = [<span class="xml"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">index</span>=<span class="string">&#123;0&#125;</span> <span class="attr">onDrop</span>=<span class="string">&#123;onDrop&#125;</span> /&gt;</span></span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, item] <span class="keyword">of</span> items.entries()) &#123;</span><br><span class="line">    tags.push(</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Elem</span> <span class="attr">label</span>=<span class="string">&#123;item&#125;</span> <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> <span class="attr">onDrag</span>=<span class="string">&#123;onDrag&#125;</span> /&gt;</span></span>,</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">index</span>=<span class="string">&#123;i</span> + <span class="attr">1</span>&#125; <span class="attr">onDrop</span>=<span class="string">&#123;onDrop&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex border-2 border-blue-400 p-4 rounded&quot;</span>&gt;</span>&#123;tags&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>並び替えはもっと効率がいい実装はありますが、とりあえず雑に。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">items: readonly string[], src: number, dest: number</span>): <span class="title">string</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (src &lt; dest) &#123;</span><br><span class="line">    dest--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> srcItem = items[src];</span><br><span class="line">  <span class="keyword">const</span> tmp = [...items.slice(<span class="number">0</span>, src), ...items.slice(src + <span class="number">1</span>)];</span><br><span class="line">  <span class="keyword">switch</span> (dest) &#123;</span><br><span class="line">    <span class="keyword">case</span> tmp.length:</span><br><span class="line">      tmp.push(srcItem);</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> [srcItem, ...tmp];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [...tmp.slice(<span class="number">0</span>, dest), srcItem, ...tmp.slice(dest)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑らかなアニメーションはもうちょっとCSSを頑張る必要がありそうですが、ひとまずこんな感じでCypressでテスト可能なドラッグアンドドロップ処理が実装できました。</p><p>実際にこのまま利用するとドラッグアンドドロップなロジックがべったりなので、必要なイベントハンドラの錬成とかをカスタムフックでまとめるとか、あるいはここのListとTarget相当をライブラリ化して、子供の要素をprops.childrenか何かでもらったのをソートして結果をコールバックするようなSortableListみたいなコンポーネントにするか、そんな感じになるかと思います。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;お仕事コードで、「Cypressで頑張ったけどドラッグアンドドロップのテストができない」という相談を受けました。僕も試行錯誤してみたのですが、どうもうまくいかず・・・&lt;/p&gt;
&lt;h1 id=&quot;なぜうまくいかないのか&quot;&gt;&lt;a href=&quot;#なぜうまくいかないのか&quot; class</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="React" scheme="https://future-architect.github.io/tags/React/"/>
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="Frontend" scheme="https://future-architect.github.io/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #13「アジャイルと品質保証を考える勉強会」</title>
    <link href="https://future-architect.github.io/articles/20210804b/"/>
    <id>https://future-architect.github.io/articles/20210804b/</id>
    <published>2021-08-03T15:00:01.000Z</published>
    <updated>2021-08-04T02:20:15.518Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210804b/sea-985545_640.jpg" alt="" title="MerioによるPixabayからの画像" width="640" height="573" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャーアーキテクトの岡部です<br>2021/7/9（金）に<a href="https://future.connpass.com/event/217290/">Future Tech Night #13～アジャイルと品質保証を考える勉強会～</a>を開催しました。</p><p>私は新卒でフューチャーアーキテクトに入社して、現在は品質管理部門で、全社横断で設計開発の品質向上プロセスの策定・実行を担っています。</p><p>品質管理部門として、アジャイル開発を採用しているプロジェクトに関わることがあり、縁があって今回の勉強会に登壇することになりました。</p><p>今までのFuture Tech Nightでは、プレゼンによる事例紹介がメインでしたが、今回は事例紹介に加えて、パネルディスカッション形式を取り入れて、開催を試みました。当ブログ記事にて、当日のコンテンツ紹介いたします！</p><h1 id="事例紹介"><a href="#事例紹介" class="headerlink" title="事例紹介"></a>事例紹介</h1><p>当社のコンサルタントの宮崎より、アジャイル開発の基本的な考え方と推進する上での苦労話や実際の工夫・心掛けているポイントを現場の実体験を添えて、紹介してもらいました。</p><p>詳細は、以下の資料をご覧ください。</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/EBBSFVs939AcyO" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/shotamiyazaki6/future-tech-night-agile-20210709" title=" Future Tech Night Agile勉強会 20210709" target="_blank"> Future Tech Night Agile勉強会 20210709</a> </strong> from <strong><a href="https://www.slideshare.net/shotamiyazaki6" target="_blank">shotamiyazaki6</a></strong> </div><p>余談ですが、宮崎とは新卒同期で数年前に同じプロジェクトで仕事をしていたこともありました。私自身はアジャイルでの開発経験はないのですが、現場がイメージできる内容のプレゼンでした。</p><h1 id="パネルディスカッション"><a href="#パネルディスカッション" class="headerlink" title="パネルディスカッション"></a>パネルディスカッション</h1><p>パネラーには事例紹介を行った宮崎に、当社のコンサルタントの<a href="/authors/%E6%BE%81%E5%B7%9D%E5%96%9C%E8%A6%8F/">澁川</a>を加えて、私がモデレーターを務めて、パネルディスカッションを行いました。<br>ディスカッションテーマは下記の2つ用意して、参加者からQAを交えながら、進めていきました。</p><p><strong>①アジャイルならでは勘所とは</strong><br>キーワード：ベロシティ、スクラムマスター、見積もり、etc</p><p><strong>②アジャイル開発での品質保証</strong><br>キーワード：非機能要件、仕様書作成、テスト手法、etc</p><p>私からはウォータフォール開発(以下WF開発)とアジャイル開発の比較という切り口で質問をして、ディスカッションを深めていきました。事例紹介で上がっていた「ベロシティが上がらない」、「品質が維持しにくい。」、について対するディスカッションを一部抜粋して紹介します。</p><h2 id="ベロシティが上がらない"><a href="#ベロシティが上がらない" class="headerlink" title="ベロシティが上がらない"></a>ベロシティが上がらない</h2><p><strong>岡部</strong>「アジャイル開発において、ベロシティが上がらないことは、WF開発における遅延にならないか。アジャイル開発ならでは難しさはあるか？」<br><strong>宮崎</strong>「アジャイル開発とWF開発の大きな価値観の違いとして、アジャイル開発はベストエフォートで進めるという価値観があり、ときには進捗が上がらないことを許容できる状況でないアジャイルはやりにくい、納期や機能数が決まっている状況では、WF開発を選択した方がいい。」<br><strong>澁川</strong>「ベストエフォートと違う言い方をすると、バッファを積むか積まないかの違いだと思う。WF開発は見積もりにバッファを入れることが通例であるが、アジャイル開発はバッファを積まず、予定より早く終わったら、次の機能開発に着手するという考え方があり、バッファを積まない。その代わりにベロシティが上がらない場合は目標調整を行うことがある。」</p><h2 id="品質が維持しにくい。"><a href="#品質が維持しにくい。" class="headerlink" title="品質が維持しにくい。"></a>品質が維持しにくい。</h2><p><strong>岡部</strong>「アジャイル開発での品質保証するために実践していることは？」<br><strong>宮崎</strong>「顧客と相談は必要であるが、一定のスプリントを経たら、地盤固めするためのスプリントを設けることがあります。一定のスプリントで機能追加した内容を振り返り、ドキュメントの整備や非機能要件のテストを行えるのとよい。」<br><strong>澁川</strong>「機能開発を優先したい顧客が納得いただくのは難しい場面もあるが、ひとつのスプリントを地盤固めに専念できる環境が作れると品質保証に専念できてよい。」</p><h1 id="登壇した感想"><a href="#登壇した感想" class="headerlink" title="登壇した感想"></a>登壇した感想</h1><p>ディスカッションする中で、WF開発とアジャイル開発を比較することで、各々の開発手法の向き・不向きを再認識できてよかったです。</p><p>プロジェクト特性を鑑みた上でより効果的な開発手法を選定する、言われたものを作るだけシステム開発するだけではなく、顧客を巻き込みよりよいシステムを作るというスタンスがITコンサルタントの醍醐味のひとつだと改めて感じました。パネルディスカッションも初めての試みながら、アンケート結果は概ね良好でした。今後のFuture Tech Nightの採用を考えてみたいと思います。</p><p>改めてご参加いただい方はありがとうございました。なにか学びを得る機会になっていれば幸いです。</p><p>次回のイベント情報は<a href="https://future.connpass.com/">connpass</a>で確認できます。<br>ぜひ遊びに来てください。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210804b/sea-985545_640.jpg&quot; alt=&quot;&quot; title=&quot;MerioによるPixabayからの画像&quot; width=&quot;640&quot; height=&quot;573&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="アジャイル" scheme="https://future-architect.github.io/tags/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB/"/>
    
  </entry>
  
  <entry>
    <title>SQLファイルから型安全なコードを生成するsqlc</title>
    <link href="https://future-architect.github.io/articles/20210804a/"/>
    <id>https://future-architect.github.io/articles/20210804a/</id>
    <published>2021-08-03T15:00:00.000Z</published>
    <updated>2021-08-04T01:16:23.354Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの辻です。<a href="https://future-architect.github.io/articles/20210726a/">GoのORマッパー連載</a>8日目です。本記事では <code>sqlc</code> を紹介します。早速ですが、結論から行きましょう。</p><h2 id="sqlc-まとめ"><a href="#sqlc-まとめ" class="headerlink" title="sqlc まとめ"></a><code>sqlc</code> まとめ</h2><ul><li>SQLファイルからデータベースにアクセスできる型安全なGoのコードを生成するライブラリ<ul><li>構造体のモデルの手書き実装不要</li><li>複数テーブルをJOINしたときのマッパー実装不要</li><li>生成されるコードは不要なリフレクションなし</li></ul></li></ul><p>SQLをがんがん書きたい、でも面倒なマッパー構造体は書きたくない、という開発者にとっては大きな味方になります。</p><h2 id="sqlc-の紹介"><a href="#sqlc-の紹介" class="headerlink" title="sqlc の紹介"></a><code>sqlc</code> の紹介</h2><img src="/images/20210804a/sqlc.png" alt="" width="600" height="345" loading="lazy"><p><code>sqlc</code> はSQLファイルからGoのアプリケーションコードを生成するライブラリです。2020/2に <a href="https://github.com/kyleconroy/sqlc/releases/tag/v1.0.0"><code>v1.0.0</code></a> をリリースし、着々とスターを伸ばしています。2021/08現在は <a href="https://github.com/kyleconroy/sqlc/releases/tag/v1.8.0"><code>v1.8.0</code></a> をリリースしています。本資料で生成しているコードも <code>v1.8.0</code> を用いています。</p><img src="/images/20210804a/e70cd691-4302-0845-34f9-7a7434236a16.png" alt="" width="941" height="625" loading="lazy"><p><a href="https://star-history.t9t.io/#kyleconroy/sqlc">https://star-history.t9t.io/#kyleconroy/sqlc</a></p><p>2021/08現在ではMySQLとPostgreSQLの2つのデータベースを<a href="https://docs.sqlc.dev/en/v1.8.0/reference/language-support.html">サポート</a>しています。</p><p>データベースのパーサを適用してクエリを解析している点が設計上の大きな特徴です。解析エンジンがPostgreSQLの場合、実際のPostgreSQLサーバーのソースを <code>cgo</code> を経由して、Goから呼び出せるようになっています。PostgreSQLのクエリ解析エンジン本体は <a href="https://github.com/pganalyze/pg_query_go"><code>pganalyze/pg_query_go</code></a> が提供しています。</p><p>ひとたび以下のようなSQLを実装すれば、<code>sqlc generate</code> コマンドを実行することで、型安全なGoのアプリケーションコードが生成できます。SQLファイルは複数に分割することもできます。ユースケースごとにSQLファイルを分ける、といった使い方ができるでしょう。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: GetAuthor :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: ListAuthors :many</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: CreateAuthor :one</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> author (id, name) <span class="keyword">VALUES</span> ($<span class="number">1</span>, $<span class="number">2</span>) RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: DeleteAuthor :exec</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: ListBookOverPrice :many</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">        b.title</span><br><span class="line">     ,a.name</span><br><span class="line">     ,b.price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    book b</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    author a</span><br><span class="line">    <span class="keyword">ON</span><span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> b.author_id <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    price <span class="operator">&gt;</span> $<span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    b.title</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>※データベースのスキーマ例</p><p>本記事ではデータベースはPostgreSQLとします。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> author</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">integer</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">99</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    created_at <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> book</span><br><span class="line">(</span><br><span class="line">    id        <span class="type">integer</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title     <span class="type">varchar</span>(<span class="number">99</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    price     <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    author_id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    created_at <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> book <span class="keyword">add</span> <span class="keyword">foreign</span> key (author_id) <span class="keyword">references</span> author (id);</span><br></pre></td></tr></table></figure><p><code>sqlc</code> の作者が書いている記事 <a href="https://conroy.org/introducing-sqlc">Introducing sqlc - Compile SQL queries to type-safe Go</a> の中にある <code>How to use sqlc in 3 steps</code> という謳い文句に嘘はないです。とてもシンプル。</p><ul><li>SQLのクエリを書く</li><li><code>sqlc</code> コマンドを実行して、クエリに対する型安全性の高いインターフェースを提供するGoのコードを生成する</li><li><code>sqlc</code> で生成したメソッドを呼び出すアプリケーションコードを書く</li></ul><p>実際に上のSQLファイルに対して <code>sqlc generate</code> コマンドを実行すると以下のようなGoのコードが生成されます。</p><h3 id="生成されたSQLファイル"><a href="#生成されたSQLファイル" class="headerlink" title="生成されたSQLファイル"></a>生成されたSQLファイル</h3><ul><li>db.go</li><li>models.go</li><li>query.sql.go</li></ul><figure class="highlight go"><figcaption><span>db.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by sqlc. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DBTX <span class="keyword">interface</span> &#123;</span><br><span class="line">ExecContext(context.Context, <span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, error)</span><br><span class="line">PrepareContext(context.Context, <span class="keyword">string</span>) (*sql.Stmt, error)</span><br><span class="line">QueryContext(context.Context, <span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, error)</span><br><span class="line">QueryRowContext(context.Context, <span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(db DBTX)</span> *<span class="title">Queries</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Queries&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queries <span class="keyword">struct</span> &#123;</span><br><span class="line">db DBTX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">WithTx</span><span class="params">(tx *sql.Tx)</span> *<span class="title">Queries</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Queries&#123;</span><br><span class="line">db: tx,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>models.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by sqlc. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int32</span></span><br><span class="line">Name      <span class="keyword">string</span></span><br><span class="line">CreatedAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">int32</span></span><br><span class="line">Title     <span class="keyword">string</span></span><br><span class="line">Price     <span class="keyword">int32</span></span><br><span class="line">AuthorID  <span class="keyword">int32</span></span><br><span class="line">CreatedAt time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>query.sql.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by sqlc. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">// source: query.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createAuthor = <span class="string">`-- name: CreateAuthor :one</span></span><br><span class="line"><span class="string">    INSERT INTO author (id, name) VALUES ($1, $2) RETURNING id, name, created_at</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreateAuthorParams <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="keyword">int32</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">CreateAuthor</span><span class="params">(ctx context.Context, arg CreateAuthorParams)</span> <span class="params">(Author, error)</span></span> &#123;</span><br><span class="line">row := q.db.QueryRowContext(ctx, createAuthor, arg.ID, arg.Name)</span><br><span class="line"><span class="keyword">var</span> i Author</span><br><span class="line">err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.CreatedAt)</span><br><span class="line"><span class="keyword">return</span> i, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deleteAuthor = <span class="string">`-- name: DeleteAuthor :exec</span></span><br><span class="line"><span class="string">    DELETE FROM author</span></span><br><span class="line"><span class="string">    WHERE id = $1</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">DeleteAuthor</span><span class="params">(ctx context.Context, id <span class="keyword">int32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := q.db.ExecContext(ctx, deleteAuthor, id)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAuthor = <span class="string">`-- name: GetAuthor :one</span></span><br><span class="line"><span class="string">    SELECT id, name, created_at FROM author</span></span><br><span class="line"><span class="string">    WHERE id = $1 LIMIT 1</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">GetAuthor</span><span class="params">(ctx context.Context, id <span class="keyword">int32</span>)</span> <span class="params">(Author, error)</span></span> &#123;</span><br><span class="line">row := q.db.QueryRowContext(ctx, getAuthor, id)</span><br><span class="line"><span class="keyword">var</span> i Author</span><br><span class="line">err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.CreatedAt)</span><br><span class="line"><span class="keyword">return</span> i, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listAuthors = <span class="string">`-- name: ListAuthors :many</span></span><br><span class="line"><span class="string">    SELECT id, name, created_at FROM author</span></span><br><span class="line"><span class="string">    ORDER BY id</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">ListAuthors</span><span class="params">(ctx context.Context)</span> <span class="params">([]Author, error)</span></span> &#123;</span><br><span class="line">rows, err := q.db.QueryContext(ctx, listAuthors)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">var</span> items []Author</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> i Author</span><br><span class="line"><span class="keyword">if</span> err := rows.Scan(&amp;i.ID, &amp;i.Name, &amp;i.CreatedAt); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">items = <span class="built_in">append</span>(items, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := rows.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> items, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listBookOverPrice = <span class="string">`-- name: ListBookOverPrice :many</span></span><br><span class="line"><span class="string">    SELECT</span></span><br><span class="line"><span class="string">            b.title</span></span><br><span class="line"><span class="string">         ,a.name</span></span><br><span class="line"><span class="string">         ,b.price</span></span><br><span class="line"><span class="string">    FROM</span></span><br><span class="line"><span class="string">        book b</span></span><br><span class="line"><span class="string">            LEFT JOIN</span></span><br><span class="line"><span class="string">        author a</span></span><br><span class="line"><span class="string">        ON1 = 1</span></span><br><span class="line"><span class="string">            AND b.author_id = a.id</span></span><br><span class="line"><span class="string">    WHERE</span></span><br><span class="line"><span class="string">        price &gt; $1</span></span><br><span class="line"><span class="string">    ORDER BY</span></span><br><span class="line"><span class="string">        b.title</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListBookOverPriceRow <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Name  <span class="keyword">string</span></span><br><span class="line">Price <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queries)</span> <span class="title">ListBookOverPrice</span><span class="params">(ctx context.Context, price <span class="keyword">int32</span>)</span> <span class="params">([]ListBookOverPriceRow, error)</span></span> &#123;</span><br><span class="line">rows, err := q.db.QueryContext(ctx, listBookOverPrice, price)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">var</span> items []ListBookOverPriceRow</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> i ListBookOverPriceRow</span><br><span class="line"><span class="keyword">if</span> err := rows.Scan(&amp;i.Title, &amp;i.Name, &amp;i.Price); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">items = <span class="built_in">append</span>(items, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := rows.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> items, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記では <code>db</code> パッケージとして生成されました。パッケージ名は <code>sqlc</code> の<a href="https://docs.sqlc.dev/en/latest/reference/config.html">設定ファイル</a>で調整できます。</p><h3 id="アプリケーション実装例"><a href="#アプリケーション実装例" class="headerlink" title="アプリケーション実装例"></a>アプリケーション実装例</h3><p><code>sqlc</code> が生成したコードを使うアプリケーションの実装例は以下のような感じです。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/d-tsuji/go-sandbox/sqlc/db&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/jackc/pgx/v4/stdlib&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pgx, err := sql.Open(<span class="string">&quot;pgx&quot;</span>, <span class="string">&quot;postgres://booktest:pass@localhost:15432/testdb?sslmode=disable&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">q := db.New(pgx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// create user</span></span><br><span class="line">param := db.CreateAuthorParams&#123;</span><br><span class="line">ID:   <span class="number">104</span>,</span><br><span class="line">Name: <span class="string">&quot;Daishiro Tsuji&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">u, err := q.CreateAuthor(ctx, param)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u)</span><br><span class="line"><span class="comment">// &#123;104 Daishiro Tsuji 2021-08-02 08:53:51.40108 +0000 UTC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get user</span></span><br><span class="line">u, err = q.GetAuthor(ctx, <span class="number">101</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u)</span><br><span class="line"><span class="comment">// &#123;101 Mat Ryer 2021-08-02 08:53:44.580572 +0000 UTC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete user</span></span><br><span class="line"><span class="keyword">if</span> err := q.DeleteAuthor(ctx, <span class="number">104</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list user</span></span><br><span class="line">ls, err := q.ListBookOverPrice(ctx, <span class="number">3500</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> ls &#123;</span><br><span class="line">fmt.Println(l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;Go言語でつくるインタプリタ Thorsten Ball 3740&#125;</span></span><br><span class="line"><span class="comment">// &#123;Go言語によるWebアプリケーション開発 Mat Ryer 3520&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="個人的に特に嬉しいポイント"><a href="#個人的に特に嬉しいポイント" class="headerlink" title="個人的に特に嬉しいポイント"></a>個人的に特に嬉しいポイント</h2><ul><li>クエリベースでコード生成可能</li></ul><p>データベースに対して発行するSQLのSELECT文は、経験上、複数のテーブルをJOINすることが多く、また、複雑になりがちです。またデータベースクライアントでデータベースに接続し、実際にクエリを発行し、実行計画を確認しながらクエリの性能をチェックすることが多いです。</p><p>SQLを書いてしまうことが多く、記述したSQLをもとに型安全なGoのアプリケーションコードを生成できるのはかなり嬉しいポイントです。</p><ul><li>自作のマッパー構造体不要</li></ul><p>また、他のORMを使った場合、モデルのコードがテーブルベースであることが多く、生のSQLをORMに実装したとしても、結果を取得するマッパーのモデルはクエリ個別に作ることが必要になることもあります。こうしたSELECT文におけるマッパーが不要な点も <code>sqlc</code> を使う嬉しいポイントと言えます。</p><ul><li>ORMライブラリ不要</li></ul><p>生成されたコードを用いることで直接クエリの結果を取得できます。すなわち、<code>database/sql</code> パッケージを直接用いることでORMライブラリは不要となります。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/kyleconroy/sqlc">https://github.com/kyleconroy/sqlc</a></li><li><a href="https://conroy.org/introducing-sqlc">https://conroy.org/introducing-sqlc</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TIGの辻です。&lt;a href=&quot;https://future-architect.github.io/articles/20210726a/&quot;&gt;GoのORマッパー連載&lt;/a&gt;8日目です。本記事では &lt;code&gt;sqlc&lt;/code&gt; を紹介します。早速ですが、結論から行き</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
    <category term="コード生成" scheme="https://future-architect.github.io/tags/%E3%82%B3%E3%83%BC%E3%83%89%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Go言語で2WaySQL</title>
    <link href="https://future-architect.github.io/articles/20210803a/"/>
    <id>https://future-architect.github.io/articles/20210803a/</id>
    <published>2021-08-02T15:00:00.000Z</published>
    <updated>2021-08-04T01:21:43.471Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210803a/blue-2137333_1280.jpg" alt="" width="1280" height="670" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>この記事は<a href="/articles/20210726b/">ORMとクエリビルダー連載</a>の7記事目です。</p><p>こんにちは。2021年4月入社の本田です。私が当社でアルバイトをしていたときに作成した<a href="https://gitlab.com/osaki-lab/twowaysql">twowaysql</a>というツールについて紹介します。</p><p>Javaでは<a href="https://future-architect.github.io/uroborosql-doc/">uroboroSQL</a>や<a href="https://doma.readthedocs.io/en/2.45.0/">DOMA</a>など広く使われている2WaySQLライブラリが存在しますが、Goでこれがデファクトスタンダートというものは現在のところ存在しません。</p><p>そのためGo言語でtwowaysqlという2WaySQLライブラリを実装することにしました。</p><h1 id="2WaySQLとは"><a href="#2WaySQLとは" class="headerlink" title="2WaySQLとは"></a>2WaySQLとは</h1><p>2WaySQLとは二つの実行方法を持つSQL文のことです。コメントとして<code>/* IF */</code>, <code>/* ELIF */</code>, <code>/* ELSE */</code>, <code>/* END */</code>という制御構造や、<code>/* value */</code>のようにバインドしたい変数を記述します。</p><p>2WaySQLはtwowaysqlで処理してから実行することもできますし、そのままSQLクライアントツールで実行することもできます。</p><h1 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line"><span class="string">&quot;gitlab.com/osaki-lab/twowaysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">EmpNo     <span class="keyword">int</span>    <span class="string">`db:&quot;employee_no&quot;`</span></span><br><span class="line">DeptNo    <span class="keyword">int</span>    <span class="string">`db:&quot;dept_no&quot;`</span></span><br><span class="line">FirstName <span class="keyword">string</span> <span class="string">`db:&quot;first_name&quot;`</span></span><br><span class="line">LastName  <span class="keyword">string</span> <span class="string">`db:&quot;last_name&quot;`</span></span><br><span class="line">Email     <span class="keyword">string</span> <span class="string">`db:&quot;email&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Params <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span> <span class="string">`twowaysql:&quot;name&quot;`</span></span><br><span class="line">EmpNo    <span class="keyword">int</span>    <span class="string">`twowaysql:&quot;EmpNo&quot;`</span></span><br><span class="line">MaxEmpNo <span class="keyword">int</span>    <span class="string">`twowaysql:&quot;maxEmpNo&quot;`</span></span><br><span class="line">DeptNo   <span class="keyword">int</span>    <span class="string">`twowaysql:&quot;deptNo&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">db, err := sqlx.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;user=postgres password=postgres dbname=postgres sslmode=disable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">tw := twowaysql.New(db)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people []Person</span><br><span class="line"><span class="keyword">var</span> params = Params&#123;</span><br><span class="line">MaxEmpNo: <span class="number">2000</span>,</span><br><span class="line">DeptNo:   <span class="number">15</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = tw.Select(ctx, &amp;people, <span class="string">`SELECT * FROM persons WHERE employee_no &lt; /*maxEmpNo*/1000 /* IF deptNo */ AND dept_no &lt; /*deptNo*/1 /* END */`</span>, &amp;params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;select failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n%#v\n%#v&quot;</span>, people[<span class="number">0</span>], people[<span class="number">1</span>], people[<span class="number">2</span>])</span><br><span class="line"><span class="comment">//Person&#123;EmpNo:1, DeptNo:10, FirstName:&quot;Evan&quot;, LastName:&quot;MacMans&quot;, Email:&quot;evanmacmans@example.com&quot;&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;EmpNo:3, DeptNo:12, FirstName:&quot;Jimmie&quot;, LastName:&quot;Bruce&quot;, Email:&quot;jimmiebruce@example.com&quot;&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;EmpNo:2, DeptNo:11, FirstName:&quot;Malvina&quot;, LastName:&quot;FitzSimons&quot;, Email:&quot;malvinafitzsimons@example.com&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="twowaysqlの現在の公開関数"><a href="#twowaysqlの現在の公開関数" class="headerlink" title="twowaysqlの現在の公開関数"></a>twowaysqlの現在の公開関数</h1><h2 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h2><p>Evalは2WaySQLクエリとパラメータを受け取ってプリペアードステートメントとして実行できるクエリとパラメータの組を返します。</p><p>Evalのシグネチャは以下のようになっています。inputParamsにはタグ付き構造体を渡します。<code>twowaysql:&quot;tag_name&quot;</code>という形式でなくてはいけません。タグがついていない場合はプロパティの名前がキーとして使われます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Eval</span><span class="params">(inputQuery <span class="keyword">string</span>, inputParams <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用例-1"><a href="#使用例-1" class="headerlink" title="使用例"></a>使用例</h3><h4 id="コード"><a href="#コード" class="headerlink" title="コード"></a>コード</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Params &#123;</span><br><span class="line">Name       <span class="keyword">string</span>      <span class="string">`twowaysql:&quot;name&quot;`</span></span><br><span class="line">MaxEmpNo   <span class="keyword">int</span>         <span class="string">`twowaysql:&quot;maxEmpNo&quot;`</span></span><br><span class="line">DeptNo     <span class="keyword">int</span>         <span class="string">`twowaysql:&quot;deptNo&quot;`</span></span><br><span class="line">GenderList []<span class="keyword">string</span>    <span class="string">`twowaysql:&quot;gender_list&quot;`</span></span><br><span class="line">IntList    []<span class="keyword">int</span>       <span class="string">`twowaysql:&quot;int_list&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="string">`SELECT * FROM person WHERE employee_no = /*maxEmpNo*/1000 AND /* IF int_list !== null */  person.gender in /*int_list*/(3,5,7) /* END */`</span></span><br><span class="line"><span class="keyword">var</span> params = Params&#123;</span><br><span class="line">                Name: <span class="string">&quot;Jeff&quot;</span>,</span><br><span class="line">                MaxEmpNo: <span class="number">3</span>,</span><br><span class="line">                DeptNo: <span class="number">12</span>,</span><br><span class="line">                GenderList: []<span class="keyword">string</span>&#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;F&quot;</span>&#125;,</span><br><span class="line">                IntList: []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">             &#125;</span><br><span class="line">resultQuery, resultParams, err := Eval(query, params)</span><br></pre></td></tr></table></figure><h4 id="期待出力"><a href="#期待出力" class="headerlink" title="期待出力"></a>期待出力</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resultQuery: <span class="string">`SELECT * FROM person WHERE employee_no = ?/*maxEmpNo*/ AND person.gender in (?, ?, ?)/*int_list*/`</span></span><br><span class="line">resultParams: []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h2><p>Execは<a href="https://golang.org/pkg/database/sql/">sql</a>パッケージのExecContext関数の薄いラッパーです。</p><p>検索結果を取得しない場合(INSERT, UPDATE, DELETE等)に使われます。関数内部で、Evalの呼び出し、適切なプレースホルダーへの変換を行い、sqlパッケージのExecにクエリとパラメータを渡しています。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>Selectは<a href="https://github.com/jmoiron/sqlx">sqlx</a>パッケージのSelectContext関数の薄いラッパーです。検索結果を取得する場合(SELECT)に使われます。</p><h1 id="twowaysqlの機能"><a href="#twowaysqlの機能" class="headerlink" title="twowaysqlの機能"></a>twowaysqlの機能</h1><h2 id="バインドパラメータ"><a href="#バインドパラメータ" class="headerlink" title="バインドパラメータ"></a>バインドパラメータ</h2><p>SQLにバインドするパラメータを<code>/* parameter name */</code>の形式で使用することができます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> person <span class="keyword">where</span> dept_no <span class="operator">=</span> <span class="comment">/* deptNo */</span><span class="number">10</span> <span class="keyword">AND</span> first_name <span class="operator">=</span> <span class="comment">/* firstName */</span>&quot;Jeff&quot;</span><br></pre></td></tr></table></figure><p>上の例では<code>/* deptNo */</code>、<code>/* firstName */</code>がバインドパラメータです。Generate関数にかけられると、後ろに続く10、”Jeff”が削除され、?が追加されます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> person <span class="keyword">where</span> dept_no <span class="operator">=</span> ?<span class="comment">/* deptNo */</span> <span class="keyword">AND</span> first_name <span class="operator">=</span> ?<span class="comment">/* firstName */</span></span><br></pre></td></tr></table></figure><h2 id="IN句"><a href="#IN句" class="headerlink" title="IN句"></a>IN句</h2><p>スライス型の値をIN句にバインドパラメータとして指定することができます。現在対応しているの型は[]stringと[]intです。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="comment">/* IF gender_list !== null */</span> <span class="keyword">where</span> person.gender <span class="keyword">in</span> <span class="comment">/*gender_list*/</span>(&quot;M&quot;) <span class="comment">/* END */</span></span><br></pre></td></tr></table></figure><p>gender_listとして(“M”, “F”)を指定すると以下のように変換されます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">where</span> person.gender <span class="keyword">in</span> (?, ?)<span class="comment">/*gender_list*/</span></span><br></pre></td></tr></table></figure><h2 id="条件分岐-IF-ELIF-ELSE-END"><a href="#条件分岐-IF-ELIF-ELSE-END" class="headerlink" title="条件分岐(/* IF */, /* ELIF */, /* ELSE */, /* END */)"></a>条件分岐(/* IF */, /* ELIF */, /* ELSE */, /* END */)</h2><p><code>/* IF */</code>, <code>/* ELIF */</code>, <code>/* ELSE */</code>, <code>/* END */</code>を使ってSQLを動的に制御することができます。</p><p>記述方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IF [評価式]*/</span></span><br><span class="line"><span class="comment">-- IFの評価式が真の場合に適用されるSQL</span></span><br><span class="line"><span class="comment">/*ELIF [評価式]*/</span></span><br><span class="line"><span class="comment">-- ELIFの評価式が真の場合に適用されるSQL</span></span><br><span class="line"><span class="comment">/*ELSE*/</span></span><br><span class="line"><span class="comment">-- IF,ELIFの評価式が偽の場合に適用されるSQL</span></span><br><span class="line"><span class="comment">/*END*/</span></span><br></pre></td></tr></table></figure><p>IF、ELIFの条件はGo言語で実装されたJavaScriptインタプリタである<a href="https://github.com/robertkrimen/otto">otto</a>に渡されて評価されます。したがって、条件部にはJavaScriptの式を記述することが可能です。</p><h1 id="書いてみた所感"><a href="#書いてみた所感" class="headerlink" title="書いてみた所感"></a>書いてみた所感</h1><p>Go言語で最低限のコア機能を持った2WaySQL処理ツールを実装してみました。</p><p>初めに2WaySQL処理ツールを実装してほしいと言われたときは、ソースコードが一行もない状態で、Goの経験と言えば<a href="https://go-tour-jp.appspot.com/welcome/1">A Tour Of Go</a>をやったことがある程度の自分が書けるのだろうかと不安だったのですが、先輩方の手厚いコードレビューや、<a href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門</a>を途中まで読んでいて、字句解析や構文解析の知識が少しだけあったという幸運もあり、何とか形にすることができました。</p><p>開発の経験を積んでみたい学生の方は、当社でアルバイトをすると、つよつよな技術部隊の方にコードレビューをしてもらって開発ができ、かつ給料ももらえる(私の時は時給1500円でした)ので、とてもおススメです！</p><p>次は辻さんの<a href="/articles/20210804a/">SQLファイルから型安全なコードを生成するsqlc</a>です。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210803a/blue-2137333_1280.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; height=&quot;670&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="SQL" scheme="https://future-architect.github.io/tags/SQL/"/>
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>SQLビルダーgoquの使い方</title>
    <link href="https://future-architect.github.io/articles/20210802a/"/>
    <id>https://future-architect.github.io/articles/20210802a/</id>
    <published>2021-08-01T15:00:00.000Z</published>
    <updated>2021-08-03T03:43:13.261Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="/articles/20210726b/">ORMとクエリビルダー連載</a>の6記事目です。</p><p>TIGの伊藤真彦です。業務では専らDynamoDBに触れており、１年以上RDBMSの世界から離れていたのですが、連載のために帰ってきました。というわけで無からネタを考え、goqu体験記を書くことにしました。</p><h1 id="goquとは"><a href="#goquとは" class="headerlink" title="goquとは"></a>goquとは</h1><img src="/images/20210802a/goqu.png" alt="" width="800" height="329" loading="lazy"><p>リポジトリは<a href="https://github.com/doug-martin/goqu">こちら</a>です。</p><blockquote><p><code>goqu</code> is an expressive SQL builder and executor<br><code>goqu</code>は、表現力豊かなSQLビルダーおよびエグゼキューターです。</p></blockquote><p>との説明の通り、SQLビルダーとして単独に機能しつつ、SQLの実行も可能なライブラリです。</p><p>どちらかというとSQLビルダーとしての役割に注力しており、アソシエーションやフックを利用したORマッパーとしての機能を求めている場合は<a href="https://github.com/jinzhu/gorm">gorm</a>や<a href="https://github.com/eaigner/hood">hood</a>の使用がREADMEでも推奨されています。</p><blockquote><p>While goqu may support the scanning of rows into structs it is not intended to be used as an ORM if you are looking for common ORM features like associations, or hooks I would recommend looking at some of the great ORM libraries such as:</p><ul><li><p>gorm</p></li><li><p>hood</p></li></ul><p>goquは行の構造体へのスキャンをサポートしている場合がありますが、関連付けやフックなどの一般的なORM機能を探している場合は、ORMとして使用することを意図していません。次のような優れたORMライブラリのいくつかを調べることをお勧めします。</p></blockquote><p>その上でgoquを開発した意図もREADMEに書いてあります。</p><blockquote><p>We tried a few other sql builders but each was a thin wrapper around sql fragments that we found error prone. goqu was built with the following goals in mind:</p><p>Make the generation of SQL easy and enjoyable<br>Create an expressive DSL that would find common errors with SQL at compile time.<br>Provide a DSL that accounts for the common SQL expressions, NOT every nuance for each database.<br>Provide developers the ability to:<br>Use SQL when desired<br>Easily scan results into primitive values and structs<br>Use the native sql.Db methods when desired</p></blockquote><blockquote><p>他のいくつかのSQLビルダーを試しましたが、それぞれがエラーが発生しやすいSQLフラグメントの薄いラッパーでした。goqu次の目標を念頭に置いて構築されました。</p><p>SQLの生成を簡単で楽しいものにします<br>コンパイル時にSQLで一般的なエラーを見つける表現力豊かなDSLを作成します。<br>各データベースのすべてのニュアンスではなく、一般的なSQL式を説明するDSLを提供します。<br>開発者に次の機能を提供します。<br>必要に応じてSQLを使用する<br>結果を簡単にスキャンしてプリミティブ値と構造体にする<br>必要に応じて、ネイティブのsql.Dbメソッドを使用します</p></blockquote><p>私は残念ながら仕事でgormなどGo製ORマッパーをゴリゴリ使い込むようなことをしていないため、作者のdoug-martin氏への共感を持てる経験は持っていないのですが、好評な意見は各所で聞いています。</p><p>動作確認ついでに<a href="https://github.com/doug-martin/goqu/pull/286">ちょっとしたコメント修正のPR</a>を送ってみましたが、次の日にはマージされました、活発にメンテナンスされているようです。</p><h2 id="触ってみた"><a href="#触ってみた" class="headerlink" title="触ってみた"></a>触ってみた</h2><h3 id="SQLを発行する"><a href="#SQLを発行する" class="headerlink" title="SQLを発行する"></a>SQLを発行する</h3><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/doug-martin/goqu/v9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sql, _, err := goqu.From(<span class="string">&quot;test&quot;</span>).ToSQL()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sql) <span class="comment">// -&gt; SELECT * FROM &quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>importしてサッと使うだけでSQLが文字列として取得できます。</p><p>Goには”database/sql”パッケージがあるので、素朴にそれと組み合わせるか、ORマッパーの痒いところに手が届かない部分をgoquで補うような使い方ができます。</p><p>上記で使っていないToSQLの戻り値は<a href="https://github.com/doug-martin/goqu/blob/2eb18c0814fe39f64a7c7a325bb7c9d508c49342/exec/query_executor.go#L33">実装</a>を見ると[]interface{}型の変数argsが帰ってきています。</p><p>これはSQLの表現の方法を変えたいときに利用できます。</p><p>READMEで<code>Parameter interpolation</code>として説明されている機能ですね。</p><p>テストコードに良いサンプルがあります。<code>.Prepared(true)</code>を付与することでパラメータ部分をargsに分離して使う前提のSQLが発行されます。</p><figure class="highlight go"><figcaption><span>test.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleDialect_datasetMysql</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// import _ &quot;github.com/doug-martin/goqu/v9/adapters/mysql&quot;</span></span><br><span class="line"></span><br><span class="line">d := goqu.Dialect(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">ds := d.From(<span class="string">&quot;test&quot;</span>).Where(goqu.Ex&#123;</span><br><span class="line"><span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line"><span class="string">&quot;baz&quot;</span>: []<span class="keyword">int64</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#125;).Limit(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">sql, args, _ := ds.ToSQL()</span><br><span class="line">fmt.Println(sql, args)</span><br><span class="line"></span><br><span class="line">sql, args, _ = ds.Prepared(<span class="literal">true</span>).ToSQL()</span><br><span class="line">fmt.Println(sql, args)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// SELECT * FROM `test` WHERE ((`baz` IN (1, 2, 3)) AND (`foo` = &#x27;bar&#x27;)) LIMIT 10 []</span></span><br><span class="line"><span class="comment">// SELECT * FROM `test` WHERE ((`baz` IN (?, ?, ?)) AND (`foo` = ?)) LIMIT ? [1 2 3 bar 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Where句の利用やInsert文の場合など、細かい利用方法はREADMEに記載がありますので割愛します。</p><h2 id="特定のDBに適したSQLを発行する"><a href="#特定のDBに適したSQLを発行する" class="headerlink" title="特定のDBに適したSQLを発行する"></a>特定のDBに適したSQLを発行する</h2><p>goquでは<code>Dialect</code>と称して、DB毎の細かな違いをドライバを切り替えるような機能が存在します。</p><p>PostgreSQLの場合を見てみます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/doug-martin/goqu/v9&quot;</span></span><br><span class="line">  <span class="comment">// import the dialect</span></span><br><span class="line">  _ <span class="string">&quot;github.com/doug-martin/goqu/v9/dialect/postgres&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// look up the dialect</span></span><br><span class="line">dialect := goqu.Dialect(<span class="string">&quot;postgres&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use dialect.From to get a dataset to build your SQL</span></span><br><span class="line">ds := dialect.From(<span class="string">&quot;test&quot;</span>).Where(goqu.Ex&#123;<span class="string">&quot;id&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">sql, args, err := ds.ToSQL()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;An error occurred while generating the SQL&quot;</span>, err.Error())</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  fmt.Println(sql, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;test&quot; <span class="keyword">WHERE</span> &quot;id&quot; <span class="operator">=</span> <span class="number">10</span> []</span><br></pre></td></tr></table></figure><p>続いてMySQLの場合です。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/doug-martin/goqu/v9&quot;</span></span><br><span class="line">  <span class="comment">// import the dialect</span></span><br><span class="line">  _ <span class="string">&quot;github.com/doug-martin/goqu/v9/dialect/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// look up the dialect</span></span><br><span class="line">dialect := goqu.Dialect(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use dialect.From to get a dataset to build your SQL</span></span><br><span class="line">ds := dialect.From(<span class="string">&quot;test&quot;</span>).Where(goqu.Ex&#123;<span class="string">&quot;id&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">sql, args, err := ds.ToSQL()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;An error occurred while generating the SQL&quot;</span>, err.Error())</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  fmt.Println(sql, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQLの内容が変わりました。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">10</span> []</span><br></pre></td></tr></table></figure><p>詳しくは<a href="https://github.com/doug-martin/goqu/blob/master/docs/dialect.md">ドキュメント</a>に記載があります。</p><h3 id="SQLを実行する"><a href="#SQLを実行する" class="headerlink" title="SQLを実行する"></a>SQLを実行する</h3><p>ORマッパー的な使い方が推奨されていない手前もあるのか、トップページのREADMEではあまり触れられていませんが、”database/sql”を利用したDBクライアントを組み込んで、goquのメソッドチェーンでSQLを実行したり、取得した結果を構造体にマッピングすることも可能です。<br>下記のコードがテーブルに書込みを行い、読み取り結果を構造体にマッピングするコードです。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/doug-martin/goqu/v9&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/doug-martin/goqu/v9/dialect/postgres&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   []<span class="keyword">uint8</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlDb, err := sql.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;user=postgres dbname=goqutest sslmode=disable &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">db := goqu.New(<span class="string">&quot;postgres&quot;</span>, sqlDb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">insert:= db.Insert(<span class="string">&quot;test&quot;</span>).Rows(</span><br><span class="line">goqu.Record&#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>&#125;,</span><br><span class="line"><span class="comment">// Record&#123;Id: []uint8&#123;49, 32, 32, 32&#125;, Name: &quot;test&quot;&#125;,でも可</span></span><br><span class="line">).Executor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = insert.Exec(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> records []Record</span><br><span class="line">err = db.From(<span class="string">&quot;test&quot;</span>).ScanStructs(&amp;records)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, records) <span class="comment">// -&gt; [&#123;[49 32 32 32] test&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実際に試してみたい方のために動作をサクッと確認するための手順も説明します。</p><p>手軽に試すためにdockerでPostgreSQLを起動します。<br>MySQLにしなかったのは発掘したサンプルコードがたまたまPostgreSQLだったからです、どちらも好きです。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    -p 5432:5432 \</span><br><span class="line">    -v postgres-tmp:/var/lib/postgresql/data \</span><br><span class="line">    -e POSTGRES_HOST_AUTH_METHOD=trust \</span><br><span class="line">    postgres:12-alpine</span><br></pre></td></tr></table></figure><p>PostgreSQLのクライアントで起動したDBにログインします</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h localhost -p 5432 -U postgres</span><br></pre></td></tr></table></figure><p>psqlコマンドが実行できない場合はPostgreSQLのインストールが必要です</p><p>ログインできたらテストで使うDB、テーブルを用意します。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">データベース作成</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE goqutest;</span><br><span class="line"></span><br><span class="line">作成したデータベースに切り替え</span><br><span class="line">\c goqutest</span><br><span class="line"></span><br><span class="line">テーブル作成</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test</span><br><span class="line">(id <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name text <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id));</span><br><span class="line"></span><br><span class="line">テーブル確認</span><br><span class="line">\d</span><br></pre></td></tr></table></figure><p>この状態でサンプルコードを実行すれば動くはずです。[]uint8になると思っていなかったのでテストのためのDBでidをchar(4)にしたのは失敗でした。</p><p>ScanStructsなどのマッピング系の機能はドキュメントの<a href="https://github.com/doug-martin/goqu/blob/master/docs/selecting.md">Selecting</a>に、Insert機能の詳しい使い方は<a href="https://github.com/doug-martin/goqu/blob/master/docs/inserting.md">Inserting</a>に記載があります。</p><p>これらのRead, WriteはContextとの組み合わせにも対応しています</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/doug-martin/goqu/v9&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/doug-martin/goqu/v9/dialect/postgres&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   []<span class="keyword">uint8</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlDb, err := sql.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;user=postgres dbname=goqutest sslmode=disable &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">db := goqu.New(<span class="string">&quot;postgres&quot;</span>, sqlDb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write</span></span><br><span class="line">insert := db.Insert(<span class="string">&quot;test&quot;</span>).Rows(</span><br><span class="line">goqu.Record&#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>&#125;,</span><br><span class="line"><span class="comment">// Record&#123;Id: []uint8&#123;49, 32, 32, 32&#125;, Name: &quot;test&quot;&#125;,でも可</span></span><br><span class="line">).Executor()</span><br><span class="line"></span><br><span class="line">ctx := context.TODO()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = insert.ExecContext(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read</span></span><br><span class="line"><span class="keyword">var</span> records []Record</span><br><span class="line">err = db.From(<span class="string">&quot;test&quot;</span>).ScanStructsContext(ctx, &amp;records)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, records) <span class="comment">// -&gt; [&#123;[49 32 32 32] test&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ToSQLの戻り値を使わなくても、メソッドチェーンの流れでExecutorを利用すればそのままSQLの実行までできるため、わざわざ使うかというと微妙ですが、Parameter interpolationをこのように利用してデータを読み取ることもできます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql, args, _ := db.From(<span class="string">&quot;test&quot;</span>).Prepared(<span class="literal">true</span>).Where(goqu.Ex&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>&#125;).ToSQL()</span><br><span class="line">db.ScanStructs(&amp;records, sql, args...)</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>goquはSQLビルダーとしての役割に軸足を置いたライブラリである。汎用的なものから特定のDBに特化したものまでSQLを発行できる。ORマッパーとしての利用を推奨していないながらも単体で動作することが可能になっている。</p><p>どのライブラリが好みに合うかは人それぞれですが、触ってみた感触としては多機能ながらも学習障壁の高さを感じる部分は少なかったです。</p><p>とはいえ軽く触った程度ではまだまだ紹介するべき本領を発揮できていないんじゃないかと感じる程度には機能が豊富でした。</p><p>一部の機能が刺さるユースケースには勿論ですが、ひとまずこれを使ってみるという用途としても充分オススメできると感じました。</p><p>明日は本田さんの<a href="/articles/20210803a/">Go言語で2WaySQL</a>です。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;/articles/20210726b/&quot;&gt;ORMとクエリビルダー連載&lt;/a&gt;の6記事目です。&lt;/p&gt;
&lt;p&gt;TIGの伊藤真彦です。業務では専らDynamoDBに触れており、１年以上RDBMSの世界から離れていたのですが、連載のために帰ってきまし</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="SQL" scheme="https://future-architect.github.io/tags/SQL/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>SQLBoiler（とoapi-codegen）でつくるREST APIサーバ</title>
    <link href="https://future-architect.github.io/articles/20210730a/"/>
    <id>https://future-architect.github.io/articles/20210730a/</id>
    <published>2021-07-29T15:00:00.000Z</published>
    <updated>2021-08-04T01:04:04.997Z</updated>
    
    <content type="html"><![CDATA[<p>ライブリッツの筒井です。</p><p><a href="/articles/20210726a/">GoのORマッパー連載</a>、折り返して5日目です。</p><p>SQLBoilerを使用したDBスキーマ駆動なREST APIサーバの開発ワークフローを紹介します。</p><h2 id="なぜSQLBoilerを選ぶのか"><a href="#なぜSQLBoilerを選ぶのか" class="headerlink" title="なぜSQLBoilerを選ぶのか?"></a>なぜSQLBoilerを選ぶのか?</h2><p>自分たちのチームでは、REST APIサーバを開発する際にはまずデータベースのテーブル設計から始めることが多いです。その次にAPI定義の設計へ入るのですが、既にテーブル定義は出来上がっているため、<strong>なんとなくSQL文が頭に思い浮かんだ状態</strong>でAPIのRequest / Responseを考えることになります。</p><p>ゆえにORMに一番に求めるのは、「<strong>いかにストレスなく思い描いていたSQL文を実行し、Goの文脈に持ち込めるか</strong>」ということです。</p><p>この基準を元に、次のような観点からSQLBoilerを選定しています。</p><h3 id="複雑なSELECT文でDSLに苦悩したくない"><a href="#複雑なSELECT文でDSLに苦悩したくない" class="headerlink" title="複雑なSELECT文でDSLに苦悩したくない"></a>複雑なSELECT文でDSLに苦悩したくない</h3><p>前述の通り、我々の頭の中にはなんとなくのSELECT文が既に浮かんでいます。このSELECT文を組み立てるために、ORM特有のDSLに悪戦苦闘することは避けたいものです。</p><p>SQLBoilerのクエリビルダはSQLの基本的な構文と大きく違わないため、直感的に使用することができました。またGoのコードが生成されているため、カラム名、テーブル名を指定する際にコード補完が効くのも嬉しいポイントです。</p><p>相関サブクエリを使った集計などはクエリ相当複雑になってしまいますが、Raw SQLの実行、StructへのBindも容易なので、「複雑なクエリはSQLをそのまま実行」というアプローチが取れます。</p><p>（これについては <a href="http://jmoiron.github.io/sqlx/">jmoiron/sqlx</a> も同様です）</p><h3 id="INSERT-UPDATE-DELETEはSQLを書きたくない"><a href="#INSERT-UPDATE-DELETEはSQLを書きたくない" class="headerlink" title="INSERT, UPDATE, DELETEはSQLを書きたくない"></a>INSERT, UPDATE, DELETEはSQLを書きたくない</h3><p>SELECT文が複雑になることは多々ありますが、INSERT, UPDATE, DELETEはそうでもありません。</p><p>これらのDMLはORMに乗っかり、Type Safeに書きたいところです。</p><p>SQLBoilerでは、INSERT, UPDATE, DELETEはStructのメソッドとしてコードが生成されます。JSONからUnmarshalしてInsertといった処理が簡単に書けます。</p><h3 id="Schema-Migrationはいらない"><a href="#Schema-Migrationはいらない" class="headerlink" title="Schema Migrationはいらない"></a>Schema Migrationはいらない</h3><p>これには「データベースの寿命 &gt; アプリケーションの寿命」という前提があります。</p><p>Migration機能も含め、データベースをアプリケーションからは独立した1サービスとして扱う、という考え方をとっています。</p><p>一方「データベースの寿命 == アプリケーションの寿命」とできる場合は、ActiveRecordのようにデータベースをアプリケーションの1機能として扱えたほうが開発効率は上がるでしょう。</p><p>SQLBoilerにはSchema Migration機能は含まれておらず、既存のデータベースからコードを生成するアプローチを取っています。</p><p>別ツール  (<a href="https://flywaydb.org/">Flyway</a>を使うことが多いです) でSchemaを管理している自分たちにはピッタリでした。</p><h2 id="SQLBoilerの使い方"><a href="#SQLBoilerの使い方" class="headerlink" title="SQLBoilerの使い方"></a>SQLBoilerの使い方</h2><p>プロジェクトのセットアップについては<a href="https://github.com/volatiletech/sqlboiler">公式ドキュメント</a>に詳しいため割愛します。</p><h3 id="テーブル定義"><a href="#テーブル定義" class="headerlink" title="テーブル定義"></a>テーブル定義</h3><p>今回使用するテーブル定義です。<br>ユーザ、イベント、イベント参加ユーザの3テーブルで、イベント・ユーザ間は <code>1 : 0...N</code> の関係です。</p><img src="/images/20210730a/image.png" alt="テーブル定義" width="403" height="283" loading="lazy"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &quot;user&quot; (</span><br><span class="line">    &quot;id&quot; uuid <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> gen_random_uuid()</span><br><span class="line">    , &quot;name&quot; <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    , &quot;created_at&quot; <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &quot;user&quot; <span class="keyword">add</span> <span class="keyword">primary</span> key (&quot;id&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &quot;event&quot; (</span><br><span class="line">    &quot;id&quot; uuid <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> gen_random_uuid()</span><br><span class="line">    , &quot;name&quot; <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    , &quot;date&quot; <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    , &quot;created_at&quot; <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &quot;event&quot; <span class="keyword">add</span> <span class="keyword">primary</span> key (&quot;id&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &quot;event_user&quot; (</span><br><span class="line">    &quot;event_id&quot; uuid <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    , &quot;user_id&quot; uuid <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    , &quot;registered_at&quot; <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">    , &quot;created_at&quot; <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> now()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &quot;event_user&quot; <span class="keyword">add</span> <span class="keyword">primary</span> key (&quot;event_id&quot;, &quot;user_id&quot;);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &quot;event_user&quot; <span class="keyword">add</span> <span class="keyword">foreign</span> key (&quot;event_id&quot;) <span class="keyword">references</span> &quot;event&quot; (&quot;id&quot;);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &quot;event_user&quot; <span class="keyword">add</span> <span class="keyword">foreign</span> key (&quot;user_id&quot;) <span class="keyword">references</span> &quot;user&quot; (&quot;id&quot;);</span><br></pre></td></tr></table></figure><h3 id="シンプルなINSERT-SELECT"><a href="#シンプルなINSERT-SELECT" class="headerlink" title="シンプルなINSERT, SELECT"></a>シンプルなINSERT, SELECT</h3><p>まずはユーザ作成処理を考えます。<br>先にコードを掲載します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(ctx context.Context, b []<span class="keyword">byte</span>)</span> <span class="params">(*boiler.User, error)</span></span> &#123;</span><br><span class="line">u := &amp;boiler.User&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(b, u); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err := u.Insert(ctx, db, boil.Infer())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boiler.User</code> は、SQLBoilerによって生成された <code>user</code> テーブルに対応するStructです。<br>カラムに設定したコメントが反映されているのが地味に便利なポイントです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User is an object representing the database table.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="keyword">string</span> <span class="string">`boil:&quot;id&quot; json:&quot;id&quot; toml:&quot;id&quot; yaml:&quot;id&quot;`</span></span><br><span class="line"><span class="comment">// 所属する組織ID</span></span><br><span class="line">OrganizationID <span class="keyword">string</span> <span class="string">`boil:&quot;organization_id&quot; json:&quot;organizationID&quot; toml:&quot;organizationID&quot; yaml:&quot;organizationID&quot;`</span></span><br><span class="line"><span class="comment">// ユーザ名</span></span><br><span class="line">Name      <span class="keyword">string</span>    <span class="string">`boil:&quot;name&quot; json:&quot;name&quot; toml:&quot;name&quot; yaml:&quot;name&quot;`</span></span><br><span class="line">CreatedAt time.Time <span class="string">`boil:&quot;created_at&quot; json:&quot;-&quot; toml:&quot;-&quot; yaml:&quot;-&quot;`</span></span><br><span class="line"></span><br><span class="line">R *userR <span class="string">`boil:&quot;-&quot; json:&quot;-&quot; toml:&quot;-&quot; yaml:&quot;-&quot;`</span></span><br><span class="line">L userL  <span class="string">`boil:&quot;-&quot; json:&quot;-&quot; toml:&quot;-&quot; yaml:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行結果は次の通りです。<br>DB側で採番されたIDがStructにセットされています。便利ですね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// DB接続Helper</span></span><br><span class="line">testConfigureDatabase(t)</span><br><span class="line">d := <span class="string">`&#123;&quot;organizationID&quot;:&quot;00000001-0000-0000-0000-000000000000&quot;,&quot;name&quot;:&quot;Emmett Brown&quot;&#125;`</span></span><br><span class="line">got, err := CreateUser(context.TODO(), []<span class="keyword">byte</span>(d))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;CreateUser() error = %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JSONでログ出力するHelper</span></span><br><span class="line">logJson(t, got)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;54629dbd-2c32-4e71-8592-be66be0a5385&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;organizationID&quot;</span>: <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Emmett Brown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次にユーザ一覧を取得する処理を考えます。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> organization_id <span class="operator">=</span> $<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Goのコードは次の通りです。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var db <span class="operator">*</span>sql.DB</span><br><span class="line"></span><br><span class="line">func ListUsers(ctx context.Context, orgID string) ([]<span class="operator">*</span>boiler.User, error) &#123;</span><br><span class="line">users, err :<span class="operator">=</span> boiler.Users(</span><br><span class="line">qm.Where(&quot;organization_id = ?&quot;, orgID),</span><br><span class="line">).<span class="keyword">All</span>(ctx, db)</span><br><span class="line">if err <span class="operator">!=</span> nil &#123;</span><br><span class="line"><span class="keyword">return</span> nil, err</span><br><span class="line">&#125;</span><br><span class="line">if users <span class="operator">=</span><span class="operator">=</span> nil &#123;</span><br><span class="line">users <span class="operator">=</span> []<span class="operator">*</span>boiler.User&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> users, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この程度のシンプルなクエリであれば自動生成コードで簡単に実装可能です。</p><p>実行結果は次のようになります。<code>json</code> タグもSQLBoilerが付けてくれているので、サクッとSerializeが可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListUsers</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// DB接続するHelper</span></span><br><span class="line">    testConfigureDatabase(t)</span><br><span class="line">orgID := <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span></span><br><span class="line">got, err := ListUsers(context.TODO(), orgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;ListUsers() error = %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// JSON形式でログ出力するHelper</span></span><br><span class="line">logJson(t, got)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000001-0001-0000-0000-000000000000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;organizationID&quot;</span>: <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ユーザ01&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000001-0002-0000-0000-000000000000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;organizationID&quot;</span>: <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ユーザ02&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="中間テーブルのJOINを含むSELECT"><a href="#中間テーブルのJOINを含むSELECT" class="headerlink" title="中間テーブルのJOINを含むSELECT"></a>中間テーブルのJOINを含むSELECT</h3><p>イベントとその主催者ユーザ、参加者ユーザ一覧を取得する処理を考えます。</p><p>SQLで書くならば次のようになるでしょう。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;event&quot;.<span class="operator">*</span>, &quot;participant&quot;.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> &quot;event&quot;</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> &quot;event_user&quot; r1 <span class="keyword">on</span> r1.event_id <span class="operator">=</span> event.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> &quot;user&quot; participant <span class="keyword">on</span> participant.id <span class="operator">=</span> r1.user_id</span><br></pre></td></tr></table></figure><p>SQLBoilerで実装する場合、Eager Loadingによって結合先テーブルを読み込む形になります。Eager Loadingのコードも、SQLBoilerが外部キー制約を読み取って自動生成してくれています。</p><p>クエリ時に <code>qm.Load()</code> で結合先テーブルを読み込んでおけば、<code>FromTable.R.JoinTable</code> の形式でGoからアクセス可能です。</p><p>JoinのJoinも、ドット区切りで結合先テーブルを記述すると読み込み可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">*boiler.Event</span><br><span class="line"><span class="comment">// イベント参加者</span></span><br><span class="line">ParticipantUsers []*boiler.User <span class="string">`json:&quot;participantUsers&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListEvents</span><span class="params">(ctx context.Context)</span> <span class="params">([]*Event, error)</span></span> &#123;</span><br><span class="line">es, err := boiler.Events(</span><br><span class="line">qm.OrderBy(boiler.EventColumns.Date+<span class="string">&quot; desc&quot;</span>),</span><br><span class="line">qm.Load(fmt.Sprintf(<span class="string">&quot;%s.%s&quot;</span>, boiler.EventRels.EventUsers, boiler.EventUserRels.User)),</span><br><span class="line">).All(ctx, db)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>([]*Event, <span class="built_in">len</span>(es))</span><br><span class="line"><span class="keyword">for</span> i, e := <span class="keyword">range</span> es &#123;</span><br><span class="line">ps := <span class="built_in">make</span>([]*boiler.User, <span class="built_in">len</span>(e.R.EventUsers))</span><br><span class="line"><span class="keyword">for</span> j, u := <span class="keyword">range</span> e.R.EventUsers &#123;</span><br><span class="line">ps[j] = u.R.User</span><br><span class="line">&#125;</span><br><span class="line">res[i] = &amp;Event&#123;</span><br><span class="line">Event:            e,</span><br><span class="line">ParticipantUsers: ps,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行結果は次の通りです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000000-0000-0000-0000-000000000001&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;イベント01&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2015-10-21T00:00:00Z&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;participants&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000001-0002-0000-0000-000000000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;organizationID&quot;</span>: <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ユーザ02&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000001-0003-0000-0000-000000000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;organizationID&quot;</span>: <span class="string">&quot;00000001-0000-0000-0000-000000000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ユーザ03&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>実行されたSQLは次の3つでした。Eager Loadingがきちんと効いていますね。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> event <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> event_user <span class="keyword">WHERE</span> (event_user.event_id <span class="keyword">IN</span> ($<span class="number">1</span>));</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (user.id <span class="keyword">IN</span> ($<span class="number">1</span>,$<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="集計を含むSELECT"><a href="#集計を含むSELECT" class="headerlink" title="集計を含むSELECT"></a>集計を含むSELECT</h3><p>参加者数の多いイベントを取得する処理を考えます。</p><p>SQLは次の通りです。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> event.<span class="operator">*</span>, <span class="built_in">coalesce</span>(r1.participants, <span class="number">0</span>) <span class="keyword">as</span> participants</span><br><span class="line"><span class="keyword">from</span> event</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> event_id <span class="keyword">as</span> id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> participants</span><br><span class="line">    <span class="keyword">from</span> event_user</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> event_id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> participants <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">10</span></span><br><span class="line">) r1 <span class="keyword">on</span> event.id <span class="operator">=</span> r1.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> participants <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>ここまで来るとクエリビルダに頭を悩ませるのも大変なので、SQLをそのまま実行させます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventPopularity <span class="keyword">struct</span> &#123;</span><br><span class="line">boiler.Event <span class="string">`boil:&quot;,bind&quot;`</span></span><br><span class="line">Participants <span class="keyword">int</span> <span class="string">`boil:&quot;participants&quot; json:&quot;participants&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListPopularEvents</span><span class="params">(ctx context.Context)</span> <span class="params">([]*EventPopularity, error)</span></span> &#123;</span><br><span class="line">r := []*EventPopularity&#123;&#125;</span><br><span class="line">queries.Raw(<span class="string">`</span></span><br><span class="line"><span class="string">select event.*, coalesce(r1.participants, 0) as participants</span></span><br><span class="line"><span class="string">from event</span></span><br><span class="line"><span class="string">left join (</span></span><br><span class="line"><span class="string">select event_id as id, count(*) as participants</span></span><br><span class="line"><span class="string">from event_user</span></span><br><span class="line"><span class="string">group by event_id</span></span><br><span class="line"><span class="string">order by participants desc</span></span><br><span class="line"><span class="string">limit 10</span></span><br><span class="line"><span class="string">) r1 on event.id = r1.id</span></span><br><span class="line"><span class="string">order by participants desc</span></span><br><span class="line"><span class="string">`</span>).Bind(ctx, db, &amp;r)</span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行結果は次の通りです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;00000000-0000-0000-0000-000000000001&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;イベント01&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2015-10-21T00:00:00Z&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;participants&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="SQLBoilerのつらいところ"><a href="#SQLBoilerのつらいところ" class="headerlink" title="SQLBoilerのつらいところ"></a>SQLBoilerのつらいところ</h2><h3 id="Bulk-Insertが出来ない"><a href="#Bulk-Insertが出来ない" class="headerlink" title="Bulk Insertが出来ない"></a>Bulk Insertが出来ない</h3><p>SQLBoilerで生成されたコードにBulk InsertのAPIは含まれていません。複数件のInsertを行うためにはfor文を使う、などの対応となります。</p><p>ただ、テンプレートを追加することでBulk Insertのコードを生成している方もいるようです。<br>参考: <a href="https://qiita.com/touyu/items/4b25fbf12804f12778b7">https://qiita.com/touyu/items/4b25fbf12804f12778b7</a></p><h3 id="テーブル設計に若干の制約が生じる"><a href="#テーブル設計に若干の制約が生じる" class="headerlink" title="テーブル設計に若干の制約が生じる"></a>テーブル設計に若干の制約が生じる</h3><p>主な制約は以下の2つです。</p><ul><li>関連するテーブルには外部キー制約を設定する必要がある</li><li>中間テーブルには結合先2テーブルの主キーを使った複合主キーを設定する必要がある<ul><li>上記例の <code>event_user</code> テーブルでは、複合主キー <code>(event_id, user_id)</code> を設定することが<strong>必須</strong>です。</li></ul></li></ul><p>これらの制約は主にEager Loadingのためのもので、クリアできない場合には各テーブルを手動でJoinする必要が出てきます。</p><p>プロジェクトによっては「外部キー制約は使わない」という設計ポリシーを取っていることもあるかと思いますので要注意ポイントです。</p><h3 id="そもそもデータベースが無いと開発が進まない"><a href="#そもそもデータベースが無いと開発が進まない" class="headerlink" title="そもそもデータベースが無いと開発が進まない"></a>そもそもデータベースが無いと開発が進まない</h3><p>これはSQLBoilerが悪いわけではありません。</p><p>ただ「データベースを元にコードを生成する」というアプローチ上、<br>開発初期で頻繁にテーブル設計を変更するようなシーンで煩わしさを覚えてしまうのは致し方ありません。</p><p>このようなシーンが頻発するのであれば、Migration機能を持つGORMなどのほうが適任かもしれません。</p><h2 id="SQLBoilerとoapi-codegenによるREST-APIサーバ開発"><a href="#SQLBoilerとoapi-codegenによるREST-APIサーバ開発" class="headerlink" title="SQLBoilerとoapi-codegenによるREST APIサーバ開発"></a>SQLBoilerとoapi-codegenによるREST APIサーバ開発</h2><p>タイトル回収です。SQLBoilerと<a href="https://github.com/deepmap/oapi-codegen">oapi-codegen</a>によるコード生成を活用したREST APIの開発フローを紹介します。</p><p>oapi-codegenの詳細はここでは割愛します。以下記事を御覧ください。<br>c.f. <a href="https://future-architect.github.io/articles/20200701/">Go の Open API 3.0 のジェネレータ oapi-codegen を試してみた</a></p><p>まず、設計書としてデータベースのDDL、API定義のopenapi.ymlが用意されている前提です。<br>これを元に、DBアクセスを担うパッケージ <code>boiler</code> と、ルーティング他を担う <code>restapi</code> を生成します。</p><p>我々が開発するのは、上記2パッケージのグルーコード、ビジネスロジックを担う <code>app.go</code> です。</p><img src="/images/20210730a/sqlboiler.png" alt="ddlとopenapi.ymlを駆動としたコード生成とアプリ開発のフロー図" width="800" height="320" loading="lazy"><h3 id="開発例"><a href="#開発例" class="headerlink" title="開発例"></a>開発例</h3><p>今回は例として次のようなOpenAPI定義を用意しました。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">openapi:</span> <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/user:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Returns</span> <span class="string">an</span> <span class="string">array</span> <span class="string">of</span> <span class="string">User</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">listUsers</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">&#x27;200&#x27;:</span></span><br><span class="line">          <span class="attr">content:</span></span><br><span class="line">            <span class="attr">application/json:</span></span><br><span class="line">              <span class="attr">schema:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">array</span></span><br><span class="line">                <span class="attr">items:</span></span><br><span class="line">                  <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span></span><br><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">schemas:</span></span><br><span class="line">    <span class="attr">User:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">      <span class="attr">required:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">id</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">id:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">format:</span> <span class="string">uuid</span></span><br><span class="line">        <span class="attr">name:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">example:</span> <span class="string">&quot;Emmett Brown&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>この定義を元にoapi-codegenを実行すると、次のようなStructが出来ます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// User defines model for User.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">        Id   <span class="keyword">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">        Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このStructに、<a href="https://github.com/fatih/gomodifytags">gomodifytags</a> によって <code>boil</code> タグを追加します。<br><code>openapi.yml</code> の <code>x-oapi-codegen-extra-tags</code> を利用すると任意のタグを付与することも可能ですが、ひとつひとつのフィールドに追加するのは漏れが出そうだったので、gomodifytagsを使っています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment">// User defines model for User.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">string</span> <span class="string">`json:&quot;id&quot; boil:&quot;id&quot;`</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; boil:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>あとはSQLの実行結果をこのStructにBindすれば完成です。</p><p>この例ではAPI定義の <code>User</code> のフィールドはすべてテーブル定義の <code>User</code> に含まれているため、SQLBoilerで生成されたSelect文から直接Bindが可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListUser</span><span class="params">(ctx context.Context)</span> <span class="params">([]*model.User, error)</span></span> &#123;</span><br><span class="line">res := []*model.User&#123;&#125;</span><br><span class="line">err := boiler.Users().Bind(ctx, db, &amp;res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考までに、コード生成のためのMakefileを掲載します。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: generate</span></span><br><span class="line"><span class="section">generate: boiler restapi/types.go</span></span><br><span class="line"><span class="section">boiler:</span></span><br><span class="line">sqlboiler psql</span><br><span class="line"><span class="section">restapi:</span></span><br><span class="line">mkdir -p <span class="variable">$@</span></span><br><span class="line"><span class="section">restapi/types.go: openapi.yml restapi</span></span><br><span class="line">oapi-codegen -generate types -package restapi -o <span class="variable">$@</span>.tmp <span class="variable">$&lt;</span></span><br><span class="line">gomodifytags -all -add-tags boil -transform snakecase -all -file <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span></span><br><span class="line">rm -f <span class="variable">$@</span>.tmp</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>SQLBoilerの使い方と、これを使ったREST APIサーバの開発フローを紹介させていただきました。</p><p>私は過去約3年ほど、数プロジェクトでSQLBoilerを採用しています。</p><p>この間Goは1.10から1.16となり、SQLBoilerはv2からv4に（主にGo modules対応で破壊的変更はありませんでした）進化しています。</p><p>その性質上うまくハマらないプロジェクトもあるかと思いますが、うまくハマればとても使いやすいライブラリと感じています。</p><p>なお、今回利用したコード、プロジェクトは<a href="https://github.com/uhey22e/sqlboiler-restapi-example">こちらのリポジトリ</a>にまとめてあります。</p><p>次は伊藤真彦さんの<a href="/articles/20210802a/">SQLビルダーgoquの使い方</a>です。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ライブリッツの筒井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/articles/20210726a/&quot;&gt;GoのORマッパー連載&lt;/a&gt;、折り返して5日目です。&lt;/p&gt;
&lt;p&gt;SQLBoilerを使用したDBスキーマ駆動なREST APIサーバの開発ワークフローを紹介します。&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="OpenAPI" scheme="https://future-architect.github.io/tags/OpenAPI/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
    <category term="コード生成" scheme="https://future-architect.github.io/tags/%E3%82%B3%E3%83%BC%E3%83%89%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>GORM v1 と v2 のソースコードリーディングしてみた</title>
    <link href="https://future-architect.github.io/articles/20210729a/"/>
    <id>https://future-architect.github.io/articles/20210729a/</id>
    <published>2021-07-28T15:00:00.000Z</published>
    <updated>2021-07-30T01:40:23.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20210729a/image.png"><br><a href="https://gorm.io/">GORM v2 doc</a> より</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>TIG DXユニット 多賀です。<a href="/articles/20210726a/">GoのORマッパー連載</a>の4日目の記事です。</p><p>GORM の v1 と v2 の実装を比較して、何が変わっているのかを調査してみました。<br>v1 -&gt; v2 への移行や、詳細な変更点については別の記事を見ていただいたほうが良いかと思います。</p><ul><li><a href="https://gorm.io/docs/v2_release_note.html">GORM 2.0 Release Note | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li><li><a href="https://tech.techtouch.jp/entry/gorm-v2">GORM v2 触ってみた Major Features 編 - Techtouch Developers Blog</a></li><li><a href="https://tech.techtouch.jp/entry/gorm-v2-breaking-changes">GORM v2 触ってみた Breaking Changes 編 - Techtouch Developers Blog</a></li></ul><p>当記事では、ソースコードの差分を眺めてみてなにか学びがないかを調べてみた記事になっています。<br>完全にスクラッチで書き直しているとのことで、エッセンスが吸収できると良いなと思っています。</p><p>調査バージョン</p><div class="scroll"><table><thead><tr><th>バージョン</th><th>リポジトリ</th><th>タグ</th></tr></thead><tbody><tr><td>v1</td><td><a href="https://github.com/jinzhu/gorm/tree/v1.9.16">jinzhu/gorm</a></td><td>v1.9.16</td></tr><tr><td>v2</td><td><a href="https://github.com/go-gorm/gorm/tree/v1.21.11">go-gorm/gorm</a></td><td>v1.21.11</td></tr></tbody></table></div><h3 id="ディレクトリ構造"><a href="#ディレクトリ構造" class="headerlink" title="ディレクトリ構造"></a>ディレクトリ構造</h3><p>まずはディレクトリ構造の差分を比較してみます。</p><figure class="highlight sh"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 --dirsfirst</span><br><span class="line">.</span><br><span class="line">├── dialects</span><br><span class="line">├── License</span><br><span class="line">├── README.md</span><br><span class="line">├── association.go</span><br><span class="line">├── association_test.go</span><br><span class="line">├── callback.go</span><br><span class="line">├── callback_create.go</span><br><span class="line">├── callback_delete.go</span><br><span class="line">├── callback_query.go</span><br><span class="line">├── callback_query_preload.go</span><br><span class="line">├── callback_row_query.go</span><br><span class="line">├── callback_save.go</span><br><span class="line">├── callback_system_test.go</span><br><span class="line">├── callback_update.go</span><br><span class="line">├── callbacks_test.go</span><br><span class="line">├── create_test.go</span><br><span class="line">├── customize_column_test.go</span><br><span class="line">├── delete_test.go</span><br><span class="line">├── dialect.go</span><br><span class="line">├── dialect_common.go</span><br><span class="line">├── dialect_mysql.go</span><br><span class="line">├── dialect_postgres.go</span><br><span class="line">├── dialect_sqlite3.go</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── embedded_struct_test.go</span><br><span class="line">├── errors.go</span><br><span class="line">├── errors_test.go</span><br><span class="line">├── field.go</span><br><span class="line">├── field_test.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── interface.go</span><br><span class="line">├── join_table_handler.go</span><br><span class="line">├── join_table_test.go</span><br><span class="line">├── logger.go</span><br><span class="line">├── main.go</span><br><span class="line">├── main_test.go</span><br><span class="line">├── migration_test.go</span><br><span class="line">├── model.go</span><br><span class="line">├── model_struct.go</span><br><span class="line">├── model_struct_test.go</span><br><span class="line">├── multi_primary_keys_test.go</span><br><span class="line">├── naming.go</span><br><span class="line">├── naming_test.go</span><br><span class="line">├── pointer_test.go</span><br><span class="line">├── polymorphic_test.go</span><br><span class="line">├── preload_test.go</span><br><span class="line">├── query_test.go</span><br><span class="line">├── scaner_test.go</span><br><span class="line">├── scope.go</span><br><span class="line">├── scope_test.go</span><br><span class="line">├── search.go</span><br><span class="line">├── search_test.go</span><br><span class="line">├── test_all.sh</span><br><span class="line">├── update_test.go</span><br><span class="line">├── utils.go</span><br><span class="line">└── wercker.yml</span><br><span class="line"></span><br><span class="line">1 directory, 56 files</span><br></pre></td></tr></table></figure><figure class="highlight sh"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 --dirsfirst</span><br><span class="line">.</span><br><span class="line">├── callbacks</span><br><span class="line">├── clause</span><br><span class="line">├── logger</span><br><span class="line">├── migrator</span><br><span class="line">├── schema</span><br><span class="line">├── tests</span><br><span class="line">├── utils</span><br><span class="line">├── License</span><br><span class="line">├── README.md</span><br><span class="line">├── association.go</span><br><span class="line">├── callbacks.go</span><br><span class="line">├── chainable_api.go</span><br><span class="line">├── errors.go</span><br><span class="line">├── finisher_api.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── gorm.go</span><br><span class="line">├── interfaces.go</span><br><span class="line">├── migrator.go</span><br><span class="line">├── model.go</span><br><span class="line">├── prepare_stmt.go</span><br><span class="line">├── scan.go</span><br><span class="line">├── soft_delete.go</span><br><span class="line">├── statement.go</span><br><span class="line">└── statement_test.go</span><br><span class="line"></span><br><span class="line">7 directories, 18 files</span><br></pre></td></tr></table></figure><p>v1 ではパッケージが切られていない設計に対して、v2 ではパッケージを分けた設計に変更されています。<br><code>callbacks_xxx.go</code> が <code>callbacks</code> パッケージにまとめられていそうですが、その他の実装がどのように変更されたかはディレクトリ構造を見るだけではわからないですね。</p><h3 id="gorm-Open"><a href="#gorm-Open" class="headerlink" title="gorm.Open"></a>gorm.Open</h3><p>GORM 利用時は、 <code>gorm.Open</code> 関数を利用して <code>database/sql</code> パッケージの <code>sql.DB</code> をラップした GORM 向けの <code>gorm.DB</code> オブジェクトを取得します。取得のインターフェイス含めて何が変わっているのでしょうか？</p><p>API を見てみると、インターフェイス自体がまず変わっていて、第一引数の dialect を文字列ではなく <code>gorm.Dialector</code> で受けるようになっています。なので、 <code>&quot;postgres&quot;</code> や <code>&quot;mysql&quot;</code> の文字列指定ができなくなっていますね。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(db *DB, err error)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span></span><br></pre></td></tr></table></figure><p><code>gorm.Dialector</code> を見てみると、 interface が定義されています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://pkg.go.dev/gorm.io/gorm#Dialector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dialector GORM database dialector</span></span><br><span class="line"><span class="keyword">type</span> Dialector <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">Initialize(*DB) error</span><br><span class="line">Migrator(db *DB) Migrator</span><br><span class="line">DataTypeOf(*schema.Field) <span class="keyword">string</span></span><br><span class="line">DefaultValueOf(*schema.Field) clause.Expression</span><br><span class="line">BindVarTo(writer clause.Writer, stmt *Statement, v <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">QuoteTo(clause.Writer, <span class="keyword">string</span>)</span><br><span class="line">Explain(sql <span class="keyword">string</span>, vars ...<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dialector interface の実装ですが、<a href="https://gorm.io/docs/v2_release_note.html#How-To-Upgrade">ドキュメント</a>を見てみると別リポジトリでされていることがわかりました。各 DB driver 毎に <code>dialector</code> が実装されています。</p><ul><li><a href="https://github.com/go-gorm/postgres">https://github.com/go-gorm/postgres</a></li><li><a href="https://github.com/go-gorm/mysql">https://github.com/go-gorm/mysql</a></li><li><a href="https://github.com/go-gorm/sqlite">https://github.com/go-gorm/sqlite</a></li><li><a href="https://github.com/go-gorm/sqlserver">https://github.com/go-gorm/sqlserver</a></li><li><a href="https://github.com/go-gorm/clickhouse">https://github.com/go-gorm/clickhouse</a></li><li><a href="https://github.com/go-gorm/bigquery">https://github.com/go-gorm/bigquery</a></li></ul><p>(BigQuery 向けの <code>dialector</code> が実装されているのが意外でした。)<br>使い方としては、 各パッケージにて <code>Open</code> 関数が定義されているようでそちらを呼び出して、各 DB ごとの <code>dialector</code> を取得します。 (※ module 名がリポジトリ URL と異なるので注意が必要です。)</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">&quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dialector := sqlite.Open(<span class="string">&quot;gorm.db&quot;</span>)</span><br><span class="line">db, err := gorm.Open(dialector, &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>v1 と異なり、利用者側で driver を blank import しなくて良くなりました。 GORM が提供する dialector の実装内で既に定義されているためです。それぞれの dialector の実装を見たところ、 Postgres の driver が <a href="https://github.com/jackc/pgx">jackc/pgx</a> になっていた点が意外でした ( <a href="https://github.com/lib/pq">lib/pq</a> をよく使っていました )。<br>driver を変更したい場合は、 <code>gorm.Dialector</code> interface を実装する必要があり、少し選択の自由度が下がってますね。</p><hr><p><code>余談</code><br><a href="https://github.com/jackc/pgx">jackc/pgx</a> は <code>database/sql</code> と 独自のインターフェイスのどちらも対応している点が <a href="https://github.com/lib/pq">lib/pq</a> と異なり、独自のインターフェイスではより Postgres の特徴を利用できる模様です。</p><ul><li><a href="https://github.com/jackc/pgx#comparison-with-alternatives">GitHub - jackc/pgx: PostgreSQL driver and toolkit for Go</a></li><li><a href="https://github.com/jackc/pgx/issues/73">[QUESTION] Comparison with lib/pq · Issue #73 · jackc/pgx · GitHub</a></li></ul><hr><p>第2引数以降の指定も変更されています。 Functional options パターンが使われるようになっていますね。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(db *DB, err error)</span></span></span><br><span class="line">                          ↑ この部分</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span></span><br><span class="line">                               ↑ この部分</span><br></pre></td></tr></table></figure><p><code>Option</code> は interface になっています。 <code>Apply(*Config) error</code> が適用される option です。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">Apply(*Config) error</span><br><span class="line">AfterInitialize(*DB) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gorm.Open</code> のAPI 変更は、全体的に型付けを厳格化して Open の実装ミスをコンパイル時にある程度検知できるように、設計変更されていると感じました。</p><p>ソースコードの面でも、インターフェイスの変更に伴い、更新が入っています。</p><details><summary>[v1 gorm.Open](https://github.com/jinzhu/gorm/blob/v1.9.16/main.go#L58)</summary><div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">err = errors.New(<span class="string">&quot;invalid database source&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> dbSQL SQLCommon</span><br><span class="line"><span class="keyword">var</span> ownDbSQL <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value := args[<span class="number">0</span>].(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">var</span> driver = dialect</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span> &#123;</span><br><span class="line">source = value</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">driver = value</span><br><span class="line">source = args[<span class="number">1</span>].(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line">dbSQL, err = sql.Open(driver, source)</span><br><span class="line">ownDbSQL = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> SQLCommon:</span><br><span class="line">dbSQL = value</span><br><span class="line">ownDbSQL = <span class="literal">false</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid database source: %v is not a valid type&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = &amp;DB&#123;</span><br><span class="line">db:        dbSQL,</span><br><span class="line">logger:    defaultLogger,</span><br><span class="line">callbacks: DefaultCallback,</span><br><span class="line">dialect:   newDialect(dialect, dbSQL),</span><br><span class="line">&#125;</span><br><span class="line">db.parent = db</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send a ping to make sure the database connection is alive.</span></span><br><span class="line"><span class="keyword">if</span> d, ok := dbSQL.(*sql.DB); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err = d.Ping(); err != <span class="literal">nil</span> &amp;&amp; ownDbSQL &#123;</span><br><span class="line">d.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details><summary>[v2 gorm.Open](https://github.com/go-gorm/gorm/blob/v1.21.11/gorm.go#L112)</summary><div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line">config := &amp;Config&#123;&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(opts, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, isConfig := opts[i].(*Config)</span><br><span class="line">_, isConfig2 := opts[j].(*Config)</span><br><span class="line"><span class="keyword">return</span> isConfig &amp;&amp; !isConfig2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line"><span class="keyword">if</span> opt != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := opt.Apply(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> errr := opt.AfterInitialize(db); errr != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errr</span><br><span class="line">&#125;</span><br><span class="line">&#125;(opt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d, ok := dialector.(<span class="keyword">interface</span>&#123; Apply(*Config) error &#125;); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err = d.Apply(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.NamingStrategy == <span class="literal">nil</span> &#123;</span><br><span class="line">config.NamingStrategy = schema.NamingStrategy&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Logger == <span class="literal">nil</span> &#123;</span><br><span class="line">config.Logger = logger.Default</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.NowFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">config.NowFunc = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> time.Now().Local() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dialector != <span class="literal">nil</span> &#123;</span><br><span class="line">config.Dialector = dialector</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Plugins == <span class="literal">nil</span> &#123;</span><br><span class="line">config.Plugins = <span class="keyword">map</span>[<span class="keyword">string</span>]Plugin&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.cacheStore == <span class="literal">nil</span> &#123;</span><br><span class="line">config.cacheStore = &amp;sync.Map&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = &amp;DB&#123;Config: config, clone: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">db.callbacks = initializeCallbacks(db)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.ClauseBuilders == <span class="literal">nil</span> &#123;</span><br><span class="line">config.ClauseBuilders = <span class="keyword">map</span>[<span class="keyword">string</span>]clause.ClauseBuilder&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Dialector != <span class="literal">nil</span> &#123;</span><br><span class="line">err = config.Dialector.Initialize(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preparedStmt := &amp;PreparedStmtDB&#123;</span><br><span class="line">ConnPool:    db.ConnPool,</span><br><span class="line">Stmts:       <span class="keyword">map</span>[<span class="keyword">string</span>]Stmt&#123;&#125;,</span><br><span class="line">Mux:         &amp;sync.RWMutex&#123;&#125;,</span><br><span class="line">PreparedSQL: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">&#125;</span><br><span class="line">db.cacheStore.Store(preparedStmtDBKey, preparedStmt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.PrepareStmt &#123;</span><br><span class="line">db.ConnPool = preparedStmt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Statement = &amp;Statement&#123;</span><br><span class="line">DB:       db,</span><br><span class="line">ConnPool: db.ConnPool,</span><br><span class="line">Context:  context.Background(),</span><br><span class="line">Clauses:  <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !config.DisableAutomaticPing &#123;</span><br><span class="line"><span class="keyword">if</span> pinger, ok := db.ConnPool.(<span class="keyword">interface</span>&#123; Ping() error &#125;); ok &#123;</span><br><span class="line">err = pinger.Ping()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">config.Logger.Error(context.Background(), <span class="string">&quot;failed to initialize database, got error %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p>第一に、Open の返却値である DB struct のフィールド構成が大きく変更されています。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.RWMutex</span><br><span class="line">Value        <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Error        error</span><br><span class="line">RowsAffected <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// single db</span></span><br><span class="line">db                SQLCommon</span><br><span class="line">blockGlobalUpdate <span class="keyword">bool</span></span><br><span class="line">logMode           logModeValue</span><br><span class="line">logger            logger</span><br><span class="line">search            *search</span><br><span class="line">values            sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// global db</span></span><br><span class="line">parent        *DB</span><br><span class="line">callbacks     *Callback</span><br><span class="line">dialect       Dialect</span><br><span class="line">singularTable <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function to be used to override the creating of a new timestamp</span></span><br><span class="line">nowFuncOverride <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">*Config</span><br><span class="line">Error        error</span><br><span class="line">RowsAffected <span class="keyword">int64</span></span><br><span class="line">Statement    *Statement</span><br><span class="line">clone        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 では 設定値が <code>Config</code> struct の埋め込みで表現されていて、設定値のフィールド項目がわかりやすくなっています。また先程の、 <code>Option</code> interface を <code>Config</code> struct が満たしているため、設定値をまとめて渡すことができるようになっています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(dialector, &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>v1, v2 とも <code>sql.DB</code> をラップしているのですが、 struct をぱっと見ただけではどこに持っているのかわからないです。実態はこちらです。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">db SQLCommon <span class="comment">// *sql.DB</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">ConnPool ConnPool <span class="comment">// *sql.DB</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>どちらも、 <code>sql.DB</code> を満たす interface が定義されているのですが、interface 定義も少し改良が加えられています。 v2 では Context 対応のメソッドを利用するように変更されていて、 Context に正式に対応していることがわかります。 <code>database/sql</code> のインターフェイスは以下の 4メソッドだけしか利用されていないのも少々驚きました。(正確には、Transaction 系のメソッドも利用されています。 別で <code>TxBeginner</code> <code>TxCommitter</code> interface が GORM 内で定義されており、型変換により <code>dabase/sql</code> の各 Transaction 系のメソッドを呼び出していました。)</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SQLCommon <span class="keyword">interface</span> &#123;</span><br><span class="line">Exec(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, error)</span><br><span class="line">Prepare(query <span class="keyword">string</span>) (*sql.Stmt, error)</span><br><span class="line">Query(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, error)</span><br><span class="line">QueryRow(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnPool <span class="keyword">interface</span> &#123;</span><br><span class="line">PrepareContext(ctx context.Context, query <span class="keyword">string</span>) (*sql.Stmt, error)</span><br><span class="line">ExecContext(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, error)</span><br><span class="line">QueryContext(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, error)</span><br><span class="line">QueryRowContext(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ちなみに、sql.DB の生成については、 v1 は直接 <code>sql.Open</code> を呼び出しているのですが、 v2 では <code>gorm.Dialector.Initialize()</code> を経由して、 GORM が提供している driver 内で sql.Open を呼び出しています。</p><p>参考: <a href="https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L47">https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L47</a></p><p><code>エッセンス</code></p><ul><li>interface を利用して型付けを厳格にして実行時エラーを防御</li><li>任意の項目は Functional options パターンで設定できるようにすると良い</li><li>config 値は、struct として定義して埋め込みで定義することで、設定値と struct で利用するフィールドを分離</li><li>標準API から必要なメソッドのみを、抜き出して interface 定義することで、利用するメソッドを絞り込む</li></ul><h4 id="おまけ-Prepared-Statement"><a href="#おまけ-Prepared-Statement" class="headerlink" title="(おまけ) Prepared Statement"></a>(おまけ) Prepared Statement</h4><p>v2 では Prepared Statement モードに対応しています。 <code>gorm.Open</code> 内で実装箇所がありましたので、併せて調べてみます。<br>ちなみに、 v1 の <code>SQLCommon</code> 上は <code>Prepare()</code> の呼び出しに対応していますが、検索したところ実装上は呼ばれていなかったので Prepared Statement は使えなかった状態と考えられます。<br>v2 では、 <code>gorm.Open()</code> の呼び出し時の <code>opts</code> に <code>gorm.Config&#123;PrepareStmt: true&#125;</code> と指定することで利用できます。</p><p>実装としては、 <code>gorm.PreparedStmtDB</code> structをキャッシュで持ち、 <code>ConnPool</code> (= <code>sql.DB</code>) と差し替えを実施しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">preparedStmt := &amp;PreparedStmtDB&#123;</span><br><span class="line">ConnPool:    db.ConnPool,</span><br><span class="line">Stmts:       <span class="keyword">map</span>[<span class="keyword">string</span>]Stmt&#123;&#125;,</span><br><span class="line">Mux:         &amp;sync.RWMutex&#123;&#125;,</span><br><span class="line">PreparedSQL: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">&#125;</span><br><span class="line">db.cacheStore.Store(preparedStmtDBKey, preparedStmt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.PrepareStmt &#123;</span><br><span class="line"><span class="comment">// db.ConnPool を prepared statement 対応版へ差し替え</span></span><br><span class="line">db.ConnPool = preparedStmt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Statement = &amp;Statement&#123;</span><br><span class="line">DB:       db,</span><br><span class="line">ConnPool: db.ConnPool,</span><br><span class="line">Context:  context.Background(),</span><br><span class="line">Clauses:  <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PreparedStmtDB</code> struct にて prepare された Stmt を管理して、クエリ実行時に prepare されているかキャッシュ ( <code>Stmts</code> フィールド) を検索して利用しています。</p><p><a href="https://github.com/go-gorm/gorm/blob/v1.21.11/prepare_stmt.go#L14">gorm/prepare_stmt.go at v1.21.11 · go-gorm/gorm</a></p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PreparedStmtDB <span class="keyword">struct</span> &#123;</span><br><span class="line">Stmts       <span class="keyword">map</span>[<span class="keyword">string</span>]Stmt <span class="comment">// Stmt キャッシュ</span></span><br><span class="line">PreparedSQL []<span class="keyword">string</span></span><br><span class="line">Mux         *sync.RWMutex</span><br><span class="line">ConnPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">*sql.Stmt <span class="comment">// database/sql 標準を利用</span></span><br><span class="line">Transaction <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query の場合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *PreparedStmtDB)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(rows *sql.Rows, err error)</span></span> &#123;</span><br><span class="line">stmt, err := db.prepare(ctx, db.ConnPool, <span class="literal">false</span>, query) <span class="comment">// ここで Stmt キャッシュを検索</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">rows, err = stmt.QueryContext(ctx, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.Mux.Lock()</span><br><span class="line">stmt.Close()</span><br><span class="line"><span class="built_in">delete</span>(db.Stmts, query)</span><br><span class="line">db.Mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rows, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="クエリ発行"><a href="#クエリ発行" class="headerlink" title="クエリ発行"></a>クエリ発行</h3><p>クエリ発行の比較として、先頭一行を SELECT する <code>First()</code> 関数の実装を読んでみます。</p><p><a href="https://github.com/jinzhu/gorm/blob/v1.9.16/main.go#L329">v1: gorm/main.go#First</a></p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span> <span class="title">First</span><span class="params">(out <span class="keyword">interface</span>&#123;&#125;, where ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line">newScope := s.NewScope(out)</span><br><span class="line">newScope.Search.Limit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newScope.Set(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>, <span class="string">&quot;ASC&quot;</span>).</span><br><span class="line">inlineCondition(where...).callCallbacks(s.parent.callbacks.queries).db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/go-gorm/gorm/blob/v1.21.11/finisher_api.go#L114">v2: gorm/finisher_api.go#First</a></p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">First</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.Limit(<span class="number">1</span>).Order(clause.OrderByColumn&#123;</span><br><span class="line">Column: clause.Column&#123;Table: clause.CurrentTable, Name: clause.PrimaryKey&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.Statement.RaiseErrorOnNotFound = <span class="literal">true</span></span><br><span class="line">tx.Statement.Dest = dest</span><br><span class="line"><span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API のインターフェイスは変わっていないですが、引数の命名が変更されています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql の結果の出力先は destination と名付けられている模様です</span></span><br><span class="line">out -&gt; dest</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition へ命名を統一している模様です</span></span><br><span class="line"><span class="comment">// v1 から inlineCondition 等で condition を使っているため</span></span><br><span class="line">where -&gt; conds</span><br></pre></td></tr></table></figure><p>実装を読むと、v1 は <code>Scope</code> struct を利用して SQL を実行していたのに対して、v2 では特に <code>Scope</code> struct は利用せず <code>gorm.DB</code> を tx 変数へ格納の上で、そのまま利用しています。<br>そもそも v1 の <code>Scope</code> はどういった利用用途であったかを調べてみると、 <code>Scope</code> のコメントにあるように実行する特定のクエリ操作の状態のみを含むオブジェクト、を指している模様です。 <code>First()</code> で呼び出している <code>db.NewScope()</code> メソッドを見ると、 <code>gorm.DB</code> を clone して <code>Scope</code> へ渡しておりクエリ発行毎に <code>Scope</code> を生成していることがわかります。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope contain current operation&#x27;s information when you perform any operation on the database</span></span><br><span class="line"><span class="keyword">type</span> Scope <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewScope create a scope for current operation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span> <span class="title">NewScope</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Scope</span></span> &#123;</span><br><span class="line">dbClone := s.clone()</span><br><span class="line">dbClone.Value = value</span><br><span class="line">scope := &amp;Scope&#123;db: dbClone, Value: value&#125;</span><br><span class="line"><span class="keyword">if</span> s.search != <span class="literal">nil</span> &#123;</span><br><span class="line">scope.Search = s.search.clone()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">scope.Search = &amp;search&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 では、 <code>First()</code> 内で直接呼び出してはないですが、 <code>First()</code> で呼び出している <code>Limit()</code> や <code>Order()</code> 内の <code>gorm.DB.getInstance()</code> メソッドで同様の処理をしています。<br>v2 では <code>gorm.DB</code> をそのままコピーして利用しつつ、<code>Statement</code> をクエリ発行毎に 発行 or clone しています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Limit</span><span class="params">(limit <span class="keyword">int</span>)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.getInstance() <span class="comment">// この部分</span></span><br><span class="line">tx.Statement.AddClause(clause.Limit&#123;Limit: limit&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.clone &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx := &amp;DB&#123;Config: db.Config, Error: db.Error&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> db.clone == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// clone with new statement</span></span><br><span class="line">tx.Statement = &amp;Statement&#123;</span><br><span class="line">DB:       tx,</span><br><span class="line">ConnPool: db.Statement.ConnPool,</span><br><span class="line">Context:  db.Statement.Context,</span><br><span class="line">Clauses:  <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">Vars:     <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">8</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// with clone statement</span></span><br><span class="line">tx.Statement = db.Statement.clone()</span><br><span class="line">tx.Statement.DB = tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Statement</code> の定義は以下です。 <code>scopes</code> はフィールドで持つ構造になっています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Statement <span class="keyword">struct</span> &#123;</span><br><span class="line">*DB</span><br><span class="line">TableExpr            *clause.Expr</span><br><span class="line">Table                <span class="keyword">string</span></span><br><span class="line">Model                <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Unscoped             <span class="keyword">bool</span></span><br><span class="line">Dest                 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ReflectValue         reflect.Value</span><br><span class="line">Clauses              <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause</span><br><span class="line">BuildClauses         []<span class="keyword">string</span></span><br><span class="line">Distinct             <span class="keyword">bool</span></span><br><span class="line">Selects              []<span class="keyword">string</span> <span class="comment">// selected columns</span></span><br><span class="line">Omits                []<span class="keyword">string</span> <span class="comment">// omit columns</span></span><br><span class="line">Joins                []join</span><br><span class="line">Preloads             <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Settings             sync.Map</span><br><span class="line">ConnPool             ConnPool</span><br><span class="line">Schema               *schema.Schema</span><br><span class="line">Context              context.Context</span><br><span class="line">RaiseErrorOnNotFound <span class="keyword">bool</span></span><br><span class="line">SkipHooks            <span class="keyword">bool</span></span><br><span class="line">SQL                  strings.Builder</span><br><span class="line">Vars                 []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">CurDestIndex         <span class="keyword">int</span></span><br><span class="line">attrs                []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">assigns              []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">scopes               []<span class="function"><span class="keyword">func</span><span class="params">(*DB)</span> *<span class="title">DB</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scope を生成しているところから、Statement へ変更されていますが、実態としては大きな変更は入っていない印象でした。<br>(データモデルやインターフェイスは変わっていますが、やっていることはあまり変わっていないため。)</p><p>続いて実際のクエリ発行と、model への適用はどこでやっているのでしょうか。<br>v1, v2 ともにレコード取得は以下のメソッド呼び出しで完結しています。</p><figure class="highlight go"><figcaption><span>v1&v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 と v2 どちらも同様</span></span><br><span class="line">db.First(&amp;product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>v1 から見てみると、<code>First</code> メソッド内のどこかしらでクエリ発行が行われているはずですが、実装を見ても正直良くわからないです。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 First()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span> <span class="title">First</span><span class="params">(out <span class="keyword">interface</span>&#123;&#125;, where ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line">newScope := s.NewScope(out)</span><br><span class="line">newScope.Search.Limit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newScope.Set(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>, <span class="string">&quot;ASC&quot;</span>).</span><br><span class="line">inlineCondition(where...).callCallbacks(s.parent.callbacks.queries).db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>おそらく、 <code>callCallbacks</code> にて実行されていると推測しましたが、実装をみると引数で渡された関数を呼び出しているのみでした。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(scope *Scope)</span> <span class="title">callCallbacks</span><span class="params">(funcs []*<span class="keyword">func</span>(s *Scope)</span>) *<span class="title">Scope</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> db, ok := scope.db.db.(sqlTx); ok &#123;</span><br><span class="line">db.Rollback()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">(*f)(scope)</span><br><span class="line"><span class="keyword">if</span> scope.skipLeft &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callCallbacks</code> の引数である、<code>s.parent.callbacks.queries</code> にクエリを実行する関数が渡っていそうなので、どこで定義しているか調べてみると、 <code>gorm.Open</code> にて <code>DefaultCallback</code> を渡していました。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">db = &amp;DB&#123;</span><br><span class="line">db:        dbSQL,</span><br><span class="line">logger:    defaultLogger,</span><br><span class="line">callbacks: DefaultCallback,</span><br><span class="line">dialect:   newDialect(dialect, dbSQL),</span><br><span class="line">&#125;</span><br><span class="line">db.parent = db</span><br></pre></td></tr></table></figure><p>さらに、 <code>DefaultCallback</code> をみると、 <code>Callback</code> struct が格納されているだけで、 <code>queries</code> フィールドが初期化されていません。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultCallback = &amp;Callback&#123;logger: nopLogger&#123;&#125;&#125; <span class="comment">// 初期化されていない..?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>どこかで初期化しているところはないか、調べてみると <code>init()</code> が利用されてました。 <code>init()</code> が利用されていると、ソースコードが追いづらくて、読みづらかったです。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback_query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:query&quot;</span>, queryCallback)</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:preload&quot;</span>, preloadCallback)</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:after_query&quot;</span>, afterQueryCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>クエリ発行の実態は、 <code>Register()</code> で渡されている <code>queryCallback</code> 関数でした。</p><details><summary>[v1 gorm.queryCallback](https://github.com/jinzhu/gorm/blob/v1.9.16/callback_query.go#L17)</summary><div><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryCallback</span><span class="params">(scope *Scope)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, skip := scope.InstanceGet(<span class="string">&quot;gorm:skip_query_callback&quot;</span>); skip &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we are only preloading relations, dont touch base model</span></span><br><span class="line"><span class="keyword">if</span> _, skip := scope.InstanceGet(<span class="string">&quot;gorm:only_preload&quot;</span>); skip &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> scope.trace(NowFunc())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">isSlice, isPtr <span class="keyword">bool</span></span><br><span class="line">resultType     reflect.Type</span><br><span class="line">results        = scope.IndirectValue()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> orderBy, ok := scope.Get(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>); ok &#123;</span><br><span class="line"><span class="keyword">if</span> primaryField := scope.PrimaryField(); primaryField != <span class="literal">nil</span> &#123;</span><br><span class="line">scope.Search.Order(fmt.Sprintf(<span class="string">&quot;%v.%v %v&quot;</span>, scope.QuotedTableName(), scope.Quote(primaryField.DBName), orderBy))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, ok := scope.Get(<span class="string">&quot;gorm:query_destination&quot;</span>); ok &#123;</span><br><span class="line">results = indirect(reflect.ValueOf(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kind := results.Kind(); kind == reflect.Slice &#123;</span><br><span class="line">isSlice = <span class="literal">true</span></span><br><span class="line">resultType = results.Type().Elem()</span><br><span class="line">results.Set(reflect.MakeSlice(results.Type(), <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resultType.Kind() == reflect.Ptr &#123;</span><br><span class="line">isPtr = <span class="literal">true</span></span><br><span class="line">resultType = resultType.Elem()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> kind != reflect.Struct &#123;</span><br><span class="line">scope.Err(errors.New(<span class="string">&quot;unsupported destination, should be slice or struct&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scope.prepareQuerySQL()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !scope.HasError() &#123;</span><br><span class="line">scope.db.RowsAffected = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> str, ok := scope.Get(<span class="string">&quot;gorm:query_hint&quot;</span>); ok &#123;</span><br><span class="line">scope.SQL = fmt.Sprint(str) + scope.SQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> str, ok := scope.Get(<span class="string">&quot;gorm:query_option&quot;</span>); ok &#123;</span><br><span class="line">scope.SQL += addExtraSpaceIfExist(fmt.Sprint(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rows, err := scope.SQLDB().Query(scope.SQL, scope.SQLVars...); scope.Err(err) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">scope.db.RowsAffected++</span><br><span class="line"></span><br><span class="line">elem := results</span><br><span class="line"><span class="keyword">if</span> isSlice &#123;</span><br><span class="line">elem = reflect.New(resultType).Elem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scope.scan(rows, columns, scope.New(elem.Addr().Interface()).Fields())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSlice &#123;</span><br><span class="line"><span class="keyword">if</span> isPtr &#123;</span><br><span class="line">results.Set(reflect.Append(results, elem.Addr()))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">results.Set(reflect.Append(results, elem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">scope.Err(err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> scope.db.RowsAffected == <span class="number">0</span> &amp;&amp; !isSlice &#123;</span><br><span class="line">scope.Err(ErrRecordNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p>scope を利用して、いくつか処理を挟んでいますが、クエリの実行と model への代入は以下の部分です。<br><a href="https://github.com/jinzhu/gorm/blob/v1.9.16/scope.go#L476">scope.scan()</a> の実装を読むと、 <code>interface&#123;&#125;</code> で model を渡していることもあり、 reflection が多用されていました。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryCallback</span><span class="params">(scope *Scope)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// SQLDB() で gorm.SQLCommon を取得</span></span><br><span class="line"><span class="comment">// gorm.SQLCommon = *sql.DB であり、標準の Query を呼び出している</span></span><br><span class="line"><span class="keyword">if</span> rows, err := scope.SQLDB().Query(scope.SQL, scope.SQLVars...); scope.Err(err) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">scope.db.RowsAffected++</span><br><span class="line"></span><br><span class="line">elem := results</span><br><span class="line"><span class="keyword">if</span> isSlice &#123;</span><br><span class="line">elem = reflect.New(resultType).Elem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3 引数 の []*Fields を更新してレコードの値を代入</span></span><br><span class="line">scope.scan(rows, columns, scope.New(elem.Addr().Interface()).Fields())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>v1 での実装はここまでにして、 v2 の <code>First()</code> はどうなっているかを紐解いていきます。<br>実装を読む限り、 <code>tx.callbacks.Query().Execute(tx)</code> でクエリが実行されていそうなことがわかり、読みやすくなっています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2 First()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">First</span><span class="params">(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tx *DB)</span></span> &#123;</span><br><span class="line">tx = db.Limit(<span class="number">1</span>).Order(clause.OrderByColumn&#123;</span><br><span class="line">Column: clause.Column&#123;Table: clause.CurrentTable, Name: clause.PrimaryKey&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.Statement.RaiseErrorOnNotFound = <span class="literal">true</span></span><br><span class="line">tx.Statement.Dest = dest</span><br><span class="line"><span class="keyword">return</span> tx.callbacks.Query().Execute(tx) <span class="comment">// おそらくここ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>まず、 <code>tx.callbacks.Query()</code> の実装を見ると、 mapに格納された query 向けの processor を取得しています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span> <span class="title">Query</span><span class="params">()</span> *<span class="title">processor</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v1 と同様に、processors が初期化されている実装を探してみると、 <code>initializeCallbacks()</code> が定義されており、 <code>gorm.Open</code> から呼ばれていました。 <code>init()</code> ではないので、ソースコードが追いやすく明示的に初期化できるようになっており、とても良い設計変更だと思いました。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span> *<span class="title">callbacks</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">processors: <span class="keyword">map</span>[<span class="keyword">string</span>]*processor&#123;</span><br><span class="line"><span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line"><span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gorm.Open で呼び出されている</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">db.callbacks = initializeCallbacks(db)</span><br></pre></td></tr></table></figure><p><code>initializeCallbacks()</code> の実装をよくみると、各 processor に <code>gorm.DB</code> を渡しているのみであることがわかります。要するに、 <code>create</code> と <code>query</code> に渡している processor に違いがない状態です。違いがない状態で、どのように発行するクエリを切り替えているのでしょうか。<br>(v1 では、processor ごとに異なる関数を渡すことで実装を切り替えてました。)</p><p><code>First()</code> に戻ると、 <code>tx.callbacks.Query().Execute(tx)</code> が実行されているので、processor の <code>Execute()</code> メソッドが呼ばれていることがわかります。</p><details><summary>[v2 processor.Execute()](https://github.com/go-gorm/gorm/blob/v1.21.11/callbacks.go#L75)</summary><div><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"><span class="comment">// call scopes</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(db.Statement.scopes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">scopes := db.Statement.scopes</span><br><span class="line">db.Statement.scopes = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, scope := <span class="keyword">range</span> scopes &#123;</span><br><span class="line">db = scope(db)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">curTime           = time.Now()</span><br><span class="line">stmt              = db.Statement</span><br><span class="line">resetBuildClauses <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stmt.BuildClauses) == <span class="number">0</span> &#123;</span><br><span class="line">stmt.BuildClauses = p.Clauses</span><br><span class="line">resetBuildClauses = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign model values</span></span><br><span class="line"><span class="keyword">if</span> stmt.Model == <span class="literal">nil</span> &#123;</span><br><span class="line">stmt.Model = stmt.Dest</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> stmt.Dest == <span class="literal">nil</span> &#123;</span><br><span class="line">stmt.Dest = stmt.Model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse model values</span></span><br><span class="line"><span class="keyword">if</span> stmt.Model != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := stmt.Parse(stmt.Model); err != <span class="literal">nil</span> &amp;&amp; (!errors.Is(err, schema.ErrUnsupportedDataType) || (stmt.Table == <span class="string">&quot;&quot;</span> &amp;&amp; stmt.SQL.Len() == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, schema.ErrUnsupportedDataType) &amp;&amp; stmt.Table == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">db.AddError(fmt.Errorf(<span class="string">&quot;%w: Table not set, please set it like: db.Model(&amp;user) or db.Table(\&quot;users\&quot;)&quot;</span>, err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.AddError(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign stmt.ReflectValue</span></span><br><span class="line"><span class="keyword">if</span> stmt.Dest != <span class="literal">nil</span> &#123;</span><br><span class="line">stmt.ReflectValue = reflect.ValueOf(stmt.Dest)</span><br><span class="line"><span class="keyword">for</span> stmt.ReflectValue.Kind() == reflect.Ptr &#123;</span><br><span class="line"><span class="keyword">if</span> stmt.ReflectValue.IsNil() &amp;&amp; stmt.ReflectValue.CanAddr() &#123;</span><br><span class="line">stmt.ReflectValue.Set(reflect.New(stmt.ReflectValue.Type().Elem()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt.ReflectValue = stmt.ReflectValue.Elem()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !stmt.ReflectValue.IsValid() &#123;</span><br><span class="line">db.AddError(ErrInvalidValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">f(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Logger.Trace(stmt.Context, curTime, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> db.Dialector.Explain(stmt.SQL.String(), stmt.Vars...), db.RowsAffected</span><br><span class="line">&#125;, db.Error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !stmt.DB.DryRun &#123;</span><br><span class="line">stmt.SQL.Reset()</span><br><span class="line">stmt.Vars = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resetBuildClauses &#123;</span><br><span class="line">stmt.BuildClauses = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p>(<code>Execute()</code> を読んでみても、どこで SQL が実行されているかよくわからないですね..。)<br>よくわからなかったので、v2 の <code>First()</code> を呼ぶ簡易な実装をして、デバッグ実行してみたところ、 <code>processor.fns</code> にクエリを実行する関数がセットされていることがわかりました。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span> <span class="title">Execute</span><span class="params">(db *DB)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// クエリ発行はこの部分</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">f(db)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// セットされていた関数</span></span><br><span class="line"><span class="comment">// ./callbacks/query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.AddError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gorm.Open</code> で呼び出している <code>initializeCallbacks()</code> の実装を読む限りは、特に <code>processor.fns</code> がセットされていません。どこでセットしているか調べてみたところ、<code>dialector</code> の実装にて定義されていました。(つまり別パッケージで定義されていました。。)</p><p><a href="https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L40">go-gorm/sqlite/blob/master/sqlite.go#L40</a></p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dialector Dialector)</span> <span class="title">Initialize</span><span class="params">(db *gorm.DB)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dialector.DriverName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">dialector.DriverName = DriverName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓ こちら</span></span><br><span class="line">callbacks.RegisterDefaultCallbacks(db, &amp;callbacks.Config&#123;</span><br><span class="line">LastInsertIDReversed: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>GORM にて定義されている、<code>callbacks.RegisterDefaultCallbacks</code> 関数内にて、 <code>Query</code> 関数を <code>Register</code> 関数を通して、 <code>processor.fns</code> へセットしています。</p><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">queryCallback := db.Callback().Query()</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query) <span class="comment">// Query 関数をセット</span></span><br></pre></td></tr></table></figure><p>この実装を読み解くのに、一番苦労しました。 <code>callback</code> の登録である、 <code>RegisterDefaultCallbacks</code> 関数の呼び出しは、 <code>dialector</code> 側に委ねずに、 <code>gorm.Open</code> の <code>gorm.DB</code> 生成時に実行すればよいのではと思いました。 <code>dialector</code> を新たに実装する際に抜け漏れる可能性もありますし、そもそもデフォルト値の設定なので別パッケージ側での呼び出しを期待するのは少々違和感があるなと感じました。(何よりも読みづらかったです。)</p><p>GORM のクエリ発行は、v1 と v2 どちらも <code>callback</code> を中心に設計されていました。 特定のクエリ操作(<code>Create</code>, <code>Query</code>, …) に対して複数の <code>callback</code>  が定義され、<code>callback</code> 関数を順序を意識してセットしています。実際のクエリ呼び出しでは、セットされた <code>callback</code> 関数を呼び出すことだけをしています。これにより、 <code>callback</code> 関数を追加・削除することで柔軟にクエリ発行をアレンジすることができるようになっています。ここは v1 と v2 で変わっていない部分だと読み取れました。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback_query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:query&quot;</span>, queryCallback)</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:preload&quot;</span>, preloadCallback)</span><br><span class="line">DefaultCallback.Query().Register(<span class="string">&quot;gorm:after_query&quot;</span>, afterQueryCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callbacks/query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">queryCallback := db.Callback().Query()</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>エッセンス</code></p><ul><li>クエリ発行のような外部リソース呼び出しを行う関数は、呼び出しを実行していることがわかるような名前付けをすると良い</li><li>init() 関数はコードを追いかける範囲外での定義のためコードが読みづらい。代わりに initialize 関数を定義して明示的に呼び出すと良い</li><li>デフォルト値設定の呼び出しをパッケージ外にて期待するような実装はコードが読みづらい</li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>v2 からは返却値の <code>gorm.DB</code> に対して、副作用なく debug モードが定義できるようになりました。v2 では元の <code>gorm.DB</code> を更新する実装でしたが、 v2 からは元の <code>gorm.DB</code> は更新せず新たに debug モードの <code>gorm.DB</code> が生成されていました。一部の処理だけ debug モードにしたいといった用途に対応できるようになっています。</p><figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.LogMode(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;v2_test.db&quot;</span>), &amp;gorm.Config&#123;</span><br><span class="line">Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// やっていることは上の実装のラッパー</span></span><br><span class="line">db = db.Debug()</span><br></pre></td></tr></table></figure><p><code>エッセンス</code></p><ul><li>副作用のない実装をすることで、影響範囲を狭めることができる</li></ul><h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><p>GORM v1 と v2 のソースコード比較をしてみました。元々は、 v1 と v2 の機能比較も考えていたのですが、すでに記事もいくつかあり新たにまとめなくてもよいかと思い、ちょっと別の切り口にしてみました。インターフェイスを大きく崩すことなく、スクラッチで再実装したいケースの参考と慣れば良いなと思います。<br>v2 は読みづらい部分もありましたが、全体的にはきれいに再設計されていて、v1 と比較してより良くなっていると感じました。 データモデルの部分が若干わかっていないところがありまとめきれていないですが、モデル設計から再設計されている印象を受けました(DB, Statement, Scope 等)。<br>最後に、記載したエッセンスの一覧を載せておきます。</p><h3 id="エッセンスまとめ"><a href="#エッセンスまとめ" class="headerlink" title="エッセンスまとめ"></a>エッセンスまとめ</h3><ul><li>interface を利用して型付けを厳格にして実行時エラーを防御</li><li>任意の項目は Functional options パターンで設定できるようにすると良い</li><li>config 値は、struct として定義して埋め込みで定義することで、設定値と struct で利用するフィールドを分離</li><li>標準API から必要なメソッドのみを、抜き出して interface 定義することで、利用するメソッドを絞り込む</li><li>クエリ発行のような外部リソース呼び出しを行う関数は、呼び出しを実行していることがわかるような名前付けをする</li><li>init() 関数はコードを追いかける範囲外での定義のためコードが読みづらい。代わりに initialize 関数を定義して明示的に呼び出すと良い</li><li>デフォルト値設定の呼び出しをパッケージ外にて期待するような実装はコードが読みづらい</li><li>副作用のない実装をすることで、影響範囲を狭めることができる</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://v1.gorm.io/docs/index.html">GORM Guides (v1) | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li><li><a href="https://github.com/jinzhu/gorm/tree/v1.9.16">jinzhu/gorm at v1.9.16</a></li><li><a href="https://gorm.io/docs/index.html">GORM Guides (v2) | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li><li><a href="https://github.com/go-gorm/gorm/tree/v1.21.11">go-gorm/gorm at v1.21.11</a></li><li><a href="https://future-architect.github.io/articles/20201117/">Goのデバッグ環境 on VSCode | フューチャー技術ブログ</a></li></ul><p>次は筒井さんの<a href="/articles/20210730a/">SQLBoiler（とoapi-codegen）でつくるREST APIサーバ</a>です。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20210729a/image.png&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://gorm.io/&quot;&gt;GORM v2 doc&lt;/a&gt; より&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
    <category term="GORM" scheme="https://future-architect.github.io/tags/GORM/"/>
    
  </entry>
  
</feed>
