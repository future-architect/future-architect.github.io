<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  <icon>https://future-architect.github.io/feed_icon.png</icon>
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2021-10-27T15:43:33.889Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人月の神話を読んでみた</title>
    <link href="https://future-architect.github.io/articles/20211028a/"/>
    <id>https://future-architect.github.io/articles/20211028a/</id>
    <published>2021-10-27T15:00:00.000Z</published>
    <updated>2021-10-27T15:43:33.889Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です</p><p>この記事は<a href="/articles/20211027a/">秋のブログ週間</a>の2記事目です。</p><p>この前新宿で複数の用事を済ませていた際、隙間時間が暇になったため人月の神話を買ってみました。紀伊国屋新宿本店の技術書コーナーはほぼ全ての技術書が置いてあるのではと感じるほどの物量があるのでおススメです。</p><p>名著として名高い事は知っており、タイトルに惹かれて読んでみましたがとても良いものでした、読書の秋におススメの一冊として紹介します。</p><h2 id="人月の神話とは"><a href="#人月の神話とは" class="headerlink" title="人月の神話とは"></a>人月の神話とは</h2><img src="/images/20211028a/image.png" alt="image.png" width="357" height="499" loading="lazy"><p>皆さんは「<a href="https://www.amazon.co.jp/%E4%BA%BA%E6%9C%88%E3%81%AE%E7%A5%9E%E8%A9%B1%E3%80%90%E6%96%B0%E8%A3%85%E7%89%88%E3%80%91-Jr-FrederickP-Brooks/dp/4621066080">人月の神話</a>」という書籍をご存じでしょうか。</p><p>ITの世界には名著と呼ばれる書籍がいくつかあります。人月の神話はそのうちの一冊です。フレデリック・ブルックスによるソフトウェア工学、およびプロジェクトマネジメントに関する書籍です。</p><p>最初の刊行はなんと1975年、実に40年以上の時を経て未だに読まれている書籍です。進歩が速く、常に新しい知識が求められるイメージのIT業界において、これ程の期間変わらず支持されている書籍がどんなものか読んでみたくなりました。</p><h2 id="書籍の概要"><a href="#書籍の概要" class="headerlink" title="書籍の概要"></a>書籍の概要</h2><p>フレデリック・ブルックスの自身の経験に基づいた、プロジェクトの成功、失敗に関する分析、タイトルの通り人月という単位での計算をもってプロジェクトを見積もったり、遅延を解消できるという見通しが誤りであることが神話という表現を用いて展開されます。</p><blockquote><p>私たちが使っている見積もり手法は、コスト計算を中心に作られたものであり、労力と進捗を混同している。人月は、人を惑わす危険な神話である。なぜなら、人月は、人と月が置き換え可能であることを暗示しているからである。</p></blockquote><p>各章がどのようなトピックで記載されているかは<a href="https://ja.wikipedia.org/wiki/%E4%BA%BA%E6%9C%88%E3%81%AE%E7%A5%9E%E8%A9%B1">wikipedia</a>にもまとめられています。</p><h2 id="人月の神話の何が良いのか"><a href="#人月の神話の何が良いのか" class="headerlink" title="人月の神話の何が良いのか"></a>人月の神話の何が良いのか</h2><p>この書籍を読むことでプロジェクトが失敗する事のない最強のノウハウが手に入るわけではなく、プロジェクトが上手くいかない経験を積み重ねた人生経験を追体験するような読後感を得ることができます。</p><p>20周年記念に追記された「銀の弾などない——ソフトウェアエンジニアリングの本質と偶有的事項」といった章題からも冷静な分析眼が伺えます。</p><p>この書籍の素晴らしい所は、フレデリック・ブルックスがエンジニアであり、またエンジニアの中でも極めて難しい課題を経験してきた事から産まれる着眼点をもって執筆されている所にあると私は感じています。</p><h3 id="エンジニア的着眼点"><a href="#エンジニア的着眼点" class="headerlink" title="エンジニア的着眼点"></a>エンジニア的着眼点</h3><p>この書籍では、難航するプロジェクトを第1章でタールの沼と表現しています。</p><blockquote><p>太古の昔から、タールの沼に落ちた巨大な獣が死にもの狂いで岸に這い上がろうとしている光景ほど、鮮烈なものはない。恐竜やマンモス、それにサーベル・タイガーが、タールに捕らえられまいとしてもがく様が目に浮かぶ。激しくもがけばもがくほど、タールは一層絡みつき、どんなに力強い獣でも、また賢く器用な獣でも、ついには沈んでいってしまう。<br>　大規模システムプログラム開発は、過去十年以上もの間そうしたタールの沼のようなものだった。そして、多くの強大な獣たちが、その中へ乱暴に突き落とされてきた。たいていは稼働システムを作り、這い上がってきたものの、目標とスケジュール、それに予算にかなったものはほとんどなかった。</p></blockquote><p>また、同じ章でエンジニアとしての仕事の楽しみを、作る喜びと称して下記のように説明しています。</p><blockquote><p>なぜプログラミングは楽しいのだろうか。プログラミングする人は、一体どんな満足を得ようとしているのだろう。<br>まず言えることは、物を作り上げる純粋な喜びがあるということだ。子供が泥団子ではしゃぐように、大人は物を組み立てること、特に自分でデザインしたものを作り上げることを楽しむ。</p></blockquote><p>この1章の時点で作者が書籍執筆業で生きるために本を書いている人物ではなく、生粋のエンジニアである事が感じられます。以降の章で語られるプロジェクトの経験談も刺さる人にとっては共感できる内容の塊です。</p><p>プログラミング自体が楽しく創造的なものであることは同じく名著として名高い「<a href="https://www.amazon.co.jp/%E3%83%8F%E3%83%83%E3%82%AB%E3%83%BC%E3%81%A8%E7%94%BB%E5%AE%B6-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E6%99%82%E4%BB%A3%E3%81%AE%E5%89%B5%E9%80%A0%E8%80%85%E3%81%9F%E3%81%A1-%E3%83%9D%E3%83%BC%E3%83%AB-%E3%82%B0%E3%83%AC%E3%82%A2%E3%83%A0/dp/4274065979">ハッカーと画家</a>」でも語られていました。</p><p>こうしたマインドセットの持ち主から、人月の神話はバイブルとして長らく支えられてきたのでしょう。</p><h3 id="フレデリック・ブルックスの経験値"><a href="#フレデリック・ブルックスの経験値" class="headerlink" title="フレデリック・ブルックスの経験値"></a>フレデリック・ブルックスの経験値</h3><p>フレデリック・ブルックスが携わったプロジェクトはIBM のメインフレームである System/360 およびそのオペレーティングシステム OS/360の開発が大きな業績として挙げられています。</p><p>OSを作るということは、製品の用途は無限とも思えるほど膨大であり、用途、ユーザーが定義できるシステムと比べ途方もない労力が必要になることが想像できます。実際OS/360は1000人規模のチームが5年かけた5000人年のプロジェクトだったようです。</p><p>それが如何に難しいプロジェクトであるかは書籍の中でも、プログラム、プログラミング製品、プログラミングシステム、プログラミングシステム製品、という表現で説明されています。</p><ul><li>プログラム: 作成者によって実行可能な完結したプログラム</li><li>プログラミング製品: 誰でもテスト、修正、拡張が可能なものとして信頼性を高め、ドキュメントを整備したプログラム</li><li>プログラミングシステム: 相互に関連するプログラムが調整され、形式が統制され、大きな仕事をするために集まったもの</li><li>プログラミングシステム製品: プログラミングシステムをプログラミング製品として整備するもの</li></ul><p>OSは言うまでもなくプログラミングシステム製品の中でも究極的に大きなものです。</p><p>製品としての高い評価を得る品質を満たすためには、あらゆる入力へのテストケースを網羅し、信頼性を充分なものにする必要があります。膨大なプログラムのシステム間連携により膨れ上がった組み合わせは幾何学級数的に増えていき、単純なプログラムの9倍の労力が必要であると書かれています。</p><p>大抵は特定のユーザーに向けた用途の決まったシステム開発を経験する事の方が圧倒的に多く、業務としてこのレベルで複雑なシステムを経験する事は少ないはずです。そんなOS開発者がタールの沼に沈み苦しんだ経験であれば人生の大先輩から得られる教訓としてはこの上ないものだと思います。</p><h2 id="何故数十年にわたり読まれるのか"><a href="#何故数十年にわたり読まれるのか" class="headerlink" title="何故数十年にわたり読まれるのか"></a>何故数十年にわたり読まれるのか</h2><p>この書籍で語られている事は特定の技術、また開発手法にフォーカスしたものではありません。</p><p>普遍的な事が鋭く信頼できる精度で述べられています。例えば人工知能が人間の仕事を革命的に変えていく事はない、といったことが1995年の追記の段階で書かれるなど、先進的かつ2020年基準の現時点で見ても正解と言っても良いものが書かれています。</p><p>また執筆20年目の段階で、18章『人月の神話』の命題　-真か偽かが追記され、書かれた内容が正しかったか否かを著者本人が改めて分析すると同時にまとめを行っています。</p><p>普遍的なものであるため、読むことで明日から仕事ぶりが変わるようなものではありませんが、物の見方は変わると思います。そもそも銀の弾丸は無いと書いてある本を読むわけですからこの本を読んでも明日から劇的に何かが変わるわけではありません。銀の弾丸は無い事と、人を追加してもプロジェクトの進捗は良くならない事を知ることができるわけです、ベテランの視座が手に入る書籍です。</p><p>関わったプロジェクトが上手くいかない事に悩む時は誰にもあると思いますが、先にタールの沼に沈んだ人の経験談を読むことは精神衛生を保つうえで大きく役に立つと感じました。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li>人月の神話は40年経っても名著として評価されている</li><li>信頼できる生粋のエンジニアが書いたものであり、読者がエンジニアであればきっと刺さる</li><li>内容は普遍的であるため40年経っても風化しない</li></ul><p>個人的にはプロジェクトマネジメントの教科書的な書籍はエンジニアの言葉で書かれていない物が多く、読んでも薄味で実りになるものが少ないと感じていました。<br>この書籍はそういった物足りなさを埋めてくれるものであり、今回お勧めしたいと思いました。</p><p><a href="/articles/20211027a/">秋のブログ週間</a>の2つ目でした。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です&lt;/p&gt;
&lt;p&gt;この記事は&lt;a</summary>
        
      
    
    
    
    <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
    <category term="マネジメント" scheme="https://future-architect.github.io/tags/%E3%83%9E%E3%83%8D%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88/"/>
    
    <category term="書籍" scheme="https://future-architect.github.io/tags/%E6%9B%B8%E7%B1%8D/"/>
    
    <category term="書評" scheme="https://future-architect.github.io/tags/%E6%9B%B8%E8%A9%95/"/>
    
    <category term="人月の神話" scheme="https://future-architect.github.io/tags/%E4%BA%BA%E6%9C%88%E3%81%AE%E7%A5%9E%E8%A9%B1/"/>
    
  </entry>
  
  <entry>
    <title>リモートワークになって始めた1 on 1ミーティング</title>
    <link href="https://future-architect.github.io/articles/20211027b/"/>
    <id>https://future-architect.github.io/articles/20211027b/</id>
    <published>2021-10-26T15:00:01.000Z</published>
    <updated>2021-10-27T10:48:27.525Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211027b/top.jpeg" alt="" title="Uwe KernによるPixabayからの画像" width="1200" height="800"><p><a href="/articles/20211027a/">秋のブログ週間2021</a>の1日目の記事です。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DXユニット真野です。小さいですが複数チームのマネージャーをしています。</p><p>フューチャーでは<a href="https://note.future.co.jp/n/n4bda3e393137">フューチャー流「コロナ時代」の子育てワークスタイル | 未来報</a>にあるように、2020年の2月からリモートワーク率が急激に上昇し（体感）、同年4月からは全社フルリモート体制になりました。私もまともに出社したのは事前に郵送で送ればよいはずの年末調整書類を直前までサボって物理的に配送したのと、チームの座席エリア開放のために放置していた書籍類を回収にした2回くらいの記憶です。</p><p>リモートワークを行う前からGoogle Workspaceやら<a href="https://future-architect.github.io/articles/20210712a/">Slack Enterprise Gridを導入したり</a>やらGitLab（GitHub）などの頼もしい非同期コミュニケーションツールが整理されていたし、ナレッジはこういった技術ブログに投稿する雰囲気があったので割とすぐ順応できているなと記憶があります。</p><p>そんな感じで業務は円滑に回り、プレイングマネージャーちっくに自分の仕事を進行する分には良いのですが、圧倒的にメンバーとのコミュニケーションは減りました。もちろんタスクやアーキテクチャや開発手法の説明は積極的にGoogle Meetを使って時間を確保するようにしましたが、メンバーその人自身に向き合う時間がどうしても減ったためか、どうも距離感を感じるようになりました。一言でいえば期待値のちょっとしたズレを感じるようになりました。</p><p>そのため、定期的にコミュニケーションやフィードバックを目的に、1 on 1 をすることに決めました。実際に運用を開始して1年以上経過しています。その結果としていくつかナレッジらしきものが貯まってきたのでまとめて紹介します。</p><h2 id="1-on-1とは"><a href="#1-on-1とは" class="headerlink" title="1 on 1とは"></a>1 on 1とは</h2><p> <a href="https://www.adecco.co.jp/client/useful/190918_1on1">1on1ミーティングとは？ 意味やメリット、話すことがない場合の対処法や事例など｜企業のご担当者様（アデコ）</a>から引用します。</p><blockquote><p>1on1ミーティングは、もともと米国のシリコンバレー企業が取り組みはじめたマネジメントの手法です。半導体メーカーの巨人、インテルがはじめたといわれていて、同社においては上司と部下の関係性構築のうえで欠かせない取り組みとなっています。<br>1on1ミーティングは、部下が主役となり、上司と1対1で行います。頻度は週1回から月1回ほどで定期的に開催し、部下は業務の課題や悩みを上司と共有するというスタイルです。上司は部下の話を真摯に聴き、フィードバックを行います。</p></blockquote><p>名前の通り、1対1で話す面談のようなものです。お悩み相談も実施しますが、自分（リーダー）から見てのフィードバックや、メンバー自身の成長を促すような、振り返りの場としての機能も持たせます。最初は距離感がつかめない場合もあると思いますので、適度に雑談を聞いたりもします。</p><p>同僚の高野さんがたまにOne on Oneって言ってきて、ワンワンワン🐶かなって見間違えすることも多いですが、1 on 1と記載することが周囲では多いなという印象です。</p><p>書籍としては<a href="https://www.amazon.co.jp/dp/B08YJ9Q19S/">実践！１ｏｎ１ミーティング (日経文庫)</a> が読んでいてとても学びになりました。個人的には1 on 1の開催手法を学ぶ以外にも、コーチングとしての大事なことも知れた気がしています。</p><h2 id="規模感、どれくらいの頻度、回数なのか"><a href="#規模感、どれくらいの頻度、回数なのか" class="headerlink" title="規模感、どれくらいの頻度、回数なのか"></a>規模感、どれくらいの頻度、回数なのか</h2><p>私が実施している概況です。特筆すべき点は無いと思います。</p><ul><li>受け持っているメンバー<ul><li>徐々に増えていますが最初は3名程度</li><li>2021年10月では10名に対して1 on 1を継続しています</li></ul></li><li>頻度<ul><li>基本的には1回/月・人</li><li>なれるまでは隔週</li><li>本当に細かく見たいときは週次にしていますが、割と大変なのですぐ隔週にします</li></ul></li><li>時間<ul><li>1回あたり30分にしています</li><li>どんなに早くても25分間は何か話すようにしています</li><li>延長はほぼ無いですが、たまに盛り上がると2,3分オーバーします（タイムマネジメントが悪いですね、良くないですね）</li></ul></li><li>ツール<ul><li>Google Meetをつかっています。何でも良いと思います</li></ul></li></ul><h2 id="実施のコツ"><a href="#実施のコツ" class="headerlink" title="実施のコツ"></a>実施のコツ</h2><p>相手をするのが人間であるため、ケースバイケースのことが多いですがなるべく汎用そうなネタをまとめました。</p><h3 id="初回は開催の意図をしっかり伝える"><a href="#初回は開催の意図をしっかり伝える" class="headerlink" title="初回は開催の意図をしっかり伝える"></a>初回は開催の意図をしっかり伝える</h3><p>お初のメンバー（特に新人さん）は、1 on 1が何か（雑談するの？とか）分かっていない方も多いので、どういう意図・目的で実施しているかしっかり伝えます。</p><p>私がよく伝える内容は以下です</p><ul><li>1 on 1 を開催する意図とは？<ul><li>こまめなフィードバックをしたい<ul><li>半期ごとの評価時に行うフィードバックをもっと刻みたい</li><li>「あの時、実はこうして欲しかった」みたいに伝える人もいるけど、「その時に言ってよ」と過去の自分が思ったのも影響している</li></ul></li><li>私のビュー（視点）からはこういうふうに見えていると伝えたい<ul><li>良くも悪くも事実だと思うので、やったことが伝わってない場合は見せ方を変えるなどに活かしてほしい。活かしたくないなら無視して欲しい</li></ul></li><li>アドバイスをできる範囲で。一方で自分過去の武勇伝を語っても仕方ないので、なるべく自分で考える切っ掛けを与えようと思う</li><li>振り返りの場としても活用して欲しい</li><li>キャリア志向にそったタスクアサインにも活かしたい</li><li>もちろん、不満や業務上の聞きにくい質問もOK。それで時間が潰れたら別途枠を用意する</li></ul></li></ul><h3 id="1-on-1の会議通知はリーダー（自分）から設定する"><a href="#1-on-1の会議通知はリーダー（自分）から設定する" class="headerlink" title="1 on 1の会議通知はリーダー（自分）から設定する"></a>1 on 1の会議通知はリーダー（自分）から設定する</h3><ul><li>1 on 1はリーダー（自分）が実施したいはずなので、その気持ち通り自分で設定します</li><li>おそらく私がメンバーの立場で、自由に会議通知を入れてねって言われたら多分面倒くさがって入れないので、そういう人を予防する目的です<ul><li>そして、おそらくリーダーの方がカレンダーが会議通知で埋まっているので、探す手間をメンバーにおわせない方がヘルシー</li></ul></li><li>そもそも、リーダーの方がおそらく突然の会議など差し込みが多く予定が変動的なので、自分で管理した方が楽だという結論を得ました<ul><li>もし差し込みが入った場合は自分でリスケするだけです</li></ul></li><li>Google Calendarの場合は繰り返し設定を入れれば良いので簡単です</li></ul><h3 id="1-on-1時の見せ方"><a href="#1-on-1時の見せ方" class="headerlink" title="1 on 1時の見せ方"></a>1 on 1時の見せ方</h3><ul><li>私のカメラはONにしています。特に「自分のビューからこう見えているよ」と伝えるときは、どういう表情で言っているか重要かもしれないためです<ul><li>もう何年もすると、カメラON/OFFとか気にならなくなる人類が増えそうですよね</li><li>メンバー側は不要だと思います（ON/OFFを気にしたことがない）</li></ul></li><li>VS Codeでとっている面談メモを画面にリアルタイム表示する<ul><li>自分の顔を大画面でずっと見たくないだろう…、というネガティブな感情が生まれた背景ですが、便利で良いです</li><li>何かしらテキストに起こすと、話が脱線しても元に戻りやすくて非常に良いです</li><li>私がメモを取るようにしています。基本的にはメンバーには手ぶらで参加できるようにしています</li></ul></li><li>メモは「●●さん_1on1メモ.md」とかってタイトルにして、どんどん追記するようにしています<ul><li>この取得したメモは、毎回終了後にSlackのDMに送ってシェアするようにしています</li><li>ついでに、なんか一言を添えて共有すると親近感も湧くかなと思っています</li></ul></li></ul><p>画面共有でメモ表示はけっこう重要かなって思っています。あと、重要ですがSlackとかTwitterは見ないようにしています。脇見、内職は当然厳禁。</p><h3 id="毎回、立ち上がりは前回メモを読んでいる"><a href="#毎回、立ち上がりは前回メモを読んでいる" class="headerlink" title="毎回、立ち上がりは前回メモを読んでいる"></a>毎回、立ち上がりは前回メモを読んでいる</h3><ul><li>前回作成したメモは、次の会でも見るようにしています<ul><li>その時に考えた反省点とか、改善プランとかがどうなった？みたいなところから話すようにしています<ul><li>自分も過去に話した内容を思い出すということで、ワンクッション置くのは良いTipsだなと思います</li></ul></li></ul></li><li>「前回はこういうこと話したよね」からの、これは解決したけど別の事案がでて大変だったよーとか</li><li>何かしらアクション（目標）を立てていたら、少しでもできたかどうかを観測します<ul><li>抽象度が高い目標を経てても隔週～1ヶ月だとなかなか改善が難しいので、大体はより具体的な目標設定にすることが多いです</li></ul></li></ul><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><p>基本的にはメンバーに準備をさせないというポリシーをとっています。</p><ul><li>業務の邪魔をしたくない</li><li>手ぶらで、気軽にがポリシー</li></ul><p>そして正直運営側の自分もほぼ準備していないです。たまに明らかにこうした方が良いなって思うことがあれば事前にメモに追記しておきます。</p><ul><li>準備していないから、1 on 1をリスケする、といった本末転倒なことにならないようにします</li><li>何もなくても前回のメモがあるため、少なくてもその内容を読み合わせるだけで変わった点を話してもらって、一緒に悩んだり考えたりすることができます</li></ul><p>何回か、事前にGitHubのPull Requestの内容や、Slackなどでの議論内容を探して読み込んでいましたが、なぜかあまり役立たずほとんど見なくなりました。なんというか断片的な情報を元にして話すと、一面的すぎてあまり役立たなかったです。</p><h3 id="ペース配分を無理しない"><a href="#ペース配分を無理しない" class="headerlink" title="ペース配分を無理しない"></a>ペース配分を無理しない</h3><p>1 on 1立ち上げ時から、現実的な頻度や時間でもって <strong>継続できること</strong> に何よりこだわりました。そのため、1人に対して30分・月次がベースラインにしています。前提として<a href="/articles/20200129/">リモートワークを促進させるDaily Stand-up Meeting </a>などで一定の情報交換があるので、月次が可能かなと思います。関わりが薄い場合は隔週頻度にしたほうが良いかなと思います。</p><p>特に月次だと足りないと思うタイミングは以下です</p><ul><li>新規参画者の場合（特にカルチャーの違うチームからのジョインや・他社からの転職者）<ul><li>この場合は、月次だと遅すぎるので、最初の1ヶ月は週次が良いかなと思います</li></ul></li><li>自分が直接関わっていないチームのメンバー<ul><li>業務上の関わりが限定的で、Slackチャネルを見れるとか、週1のミーティングで同席する程度だとします</li><li>この場合は月次だと色々タイミングを逃すことが多いかも知れないので、いったん厚めに取ることをお勧めします</li></ul></li></ul><h3 id="OJTメンバーに対して"><a href="#OJTメンバーに対して" class="headerlink" title="OJTメンバーに対して"></a>OJTメンバーに対して</h3><p>逆に1 on 1はOJT中のメンバーに対しては実施しないポリシーです。</p><ul><li>OJT面談はOJT自体の取り組みとして開催しているはず</li><li>OJTトレーナーと異なるアドバイスをして、混乱させてしまうと申し訳ない</li></ul><p>どちらかといえば、もしOJT中のメンバーに対してフィードバックをしたい場合は、OJT面談に自分も参加した方が良いと思います。</p><h3 id="1-on-1に別の人が参加してきたいと言って来た時"><a href="#1-on-1に別の人が参加してきたいと言って来た時" class="headerlink" title="1 on 1に別の人が参加してきたいと言って来た時"></a>1 on 1に別の人が参加してきたいと言って来た時</h3><p>基本的には1対1の面談だと思っているので、自分とは別のリーダ役が参加したいと言ってきた場合は、別枠を確保してそちらで話したほうが良いでしょう。</p><p>特にメンバー1人に対して、1 on 1をするリーダーが1名であるという縛りは無いため、必要に応じて複数人で実施するのもありかなとは思います。色々な人が関わってメンバーのキャリア形成に寄与していきたいですね。</p><h3 id="業務（仕事）についての話題にならないか"><a href="#業務（仕事）についての話題にならないか" class="headerlink" title="業務（仕事）についての話題にならないか"></a>業務（仕事）についての話題にならないか</h3><p>1 on 1面談なのに、「あのタスクの背景は～」とか「タスクAを終わらせてからタスクBに着手しよう」といったバリバリ業務の内容の方が盛り上がることがあります。正直、これはこれでありかと思います。つまり本業務に対する同期コミュニケーションが不足していたということが分かったということだからです。</p><p>この場合は以下の手順を取ります。</p><ul><li>1 on 1面談としては業務の話の方が優先度が高い（盛り上がる）のであればその時間に当てる<ul><li>リーダーとして意思決定や、メンバーに対するインプットが不足しているのであれば、別途リーダーである自分自身の振る舞いを改善する</li></ul></li><li>その翌週など別の開催日に改めて 1 on 1面談を実施する<ul><li>もっとメンバーにとって中長期的にプラスな内容を話せるようになるまで繰り返す</li></ul></li></ul><h3 id="雑談にならないか"><a href="#雑談にならないか" class="headerlink" title="雑談にならないか"></a>雑談にならないか</h3><p>雑談ですが、やはり適度に入れた方が有効です。お互いのキャラクターが分かったほうが、発言の真意が掴めやすいので適度に差し込みます。</p><p>注意としては、初回～2回目くらいまでは雑談を入れないことです。最初に雑談成分が多めだと、そういう趣旨の話だと勘違いされる恐れがあるためです。</p><p>適度に回数をこなした3回目以降に織り交ぜていく方がベターかなと思います。</p><h3 id="鑑定魔法"><a href="#鑑定魔法" class="headerlink" title="鑑定魔法"></a>鑑定魔法</h3><p>たまに用いる、状態を把握する質問です。自分自身が普通に気になるということでもあります。</p><ul><li>「成長実感を感じていますか？」<ul><li>業務で学びのポイントが減っていると、仕事のクオリティも下がる可能性があるので注意です</li><li>純粋にロールを変えることもあれば、見方を変えたり立ち位置を変えられないかといったこともアドバイスします</li><li>技術的には、多少オーバーエンジニアリングにトライしてみるなども有効打です（ちょっとしたツールなどは特にお勧め）</li></ul></li><li>「今後、伸ばしたい領域があるか」<ul><li>技術面なのか、ソフトスキル面なのかなど</li><li>目線が直近の部分に向きすぎている時にバランスを取る時に使ったりもします</li></ul></li></ul><h3 id="あまり心を開いてくれなさそうなメンバーに対して"><a href="#あまり心を開いてくれなさそうなメンバーに対して" class="headerlink" title="あまり心を開いてくれなさそうなメンバーに対して"></a>あまり心を開いてくれなさそうなメンバーに対して</h3><p>うまく心理的安全性をリーダーである自分自身が作れないと感じるときがあります（過去1例）。その時は別途メンター役を別の同僚に依頼します。</p><p>1 on 1 だからといって、全てリーダー自身が解決する必然性もないですし、うまく周りを巻き込みましょう。どうしても相性ってあるかなと思います。</p><ul><li>メンターを依頼するのはあり<ul><li>Nヶ月などスポットの依頼だと気軽にOKしてくれやすい気がします</li></ul></li></ul><p>もし、メンバーの状況によってはメンタルケア的なものが重要な場合もあります。もし、話していて状態がよろしくなければ、まず以下のどの状態かは見極めるようにします。</p><ul><li>コンフォートゾーン</li><li>ストレッチゾーン</li><li>パニックゾーン</li></ul><p>参考→ <a href="https://motivation-up.com/motivation/comfortzone.html">コンフォートゾーンとは？成長のために理解すべき３つの領域｜モチラボ</a></p><p>パニックゾーンにちょっと踏み込んでいるなと感じたら、任せたロールの一部を巻き取ったり移譲したりとスコープ調整をします。これまたメンターと話してもらったりすることも検討します。万が一こういった状態でしたら、超特急で対応するようにしています。パニックゾーン寄りになるパターンは、新しいチームにジョインしたタイミングとかが多いので、そこの見極めは気をつけるとベターかなと思います。</p><h3 id="急ぎは禁物"><a href="#急ぎは禁物" class="headerlink" title="急ぎは禁物"></a>急ぎは禁物</h3><p>なるべくすぐに成長してほしいな～という考えから、改善ポイントを大量に伝えたい状況も多々あります。</p><p>ただ、これはリーダーから見たときの押しつけになっていないか注意を払う必要があります。他のトピックにも書きましたが本人がその課題/改善点に自分から実感を持って気がつくことが非常に重要です。それでないと、先々週（先月）も同じことを言ったのに改善していないな…となりお互い不幸な時間が続いてしまいます。もちろん状況次第ですが、焦らず、じっくりとメンバー側の考えを引き出すように心がけます。</p><p>また、メンバーのランクアップ志向を見極めることはけっこう重要だなと思います。例えば、今期、来期などなるべく早くランクアップしたいと考えているのであれば、ややインプットを多めに伝えても良いかなと思います。一方でランクアップより地力をじっくりと自分のペースで高めたい人には、その人のペースで伝えてあげた方が響くと思います。相手の志向に応じて使い分ける、言ってみれば当たり前のことなんですが私は最初全然できていなかったので引き続き注意して臨んでいます。</p><h3 id="話すときの態度"><a href="#話すときの態度" class="headerlink" title="話すときの態度"></a>話すときの態度</h3><ul><li>できる限り（限界はあるけど）客観的に仕事ぶりを見ての所感を伝える<ul><li>この時、良いところは”褒める”。可能な限り正しい評価関数であるために</li><li>何か改善ポイントを伝えるために、2,3個褒める</li></ul></li><li>どういう成果出したというよりは、どこに悩みがありそうか（伸びしろがありそうか）を探す</li><li>改善点は感情を込めず伝える。あくまで悪いところではなく、”伸びしろ” であることはけっこう強調しする</li></ul><p>基本的にはメンバーの中長期的な成長を見出すコーチングとしての側面が強いと思うので、そこを踏み間違えない。</p><p>また、成長があまり感じられない場面もあります。本人の意思が大事だなと感じます。</p><ul><li>本人の意欲があるならいろいろ一緒に考える<ul><li>リーダー側が張り切って「●●なところがあるから、こうしたら？」が全く響かない時があるので、無理強いはしない</li></ul></li><li>注意として、本人から改善の言葉がでたとしても、実はあんまり前向きじゃないときもある<ul><li>むしろ強みを伸ばす方向に持っていって自信を持ってもらって勢いを付けたほうが良いこともあるのでバランス</li><li>確実に成長しそうな方面に持っていくのもあり<ul><li>全てはつながっているし、遠回りしても良いと思う（一ヶ月単位で人間は変わるものだと考える）</li></ul></li></ul></li></ul><p>また、基本的な姿勢は <strong>傾聴</strong> だと思うので、できる限りうまく問いかけて、その考えを聞くということを心がけます。</p><h3 id="継続に向けての心構え"><a href="#継続に向けての心構え" class="headerlink" title="継続に向けての心構え"></a>継続に向けての心構え</h3><p>1 on 1 ですが、開始する前は時間かかりすぎじゃね？って思っていました。今は次のように考えています</p><ul><li>時間は <strong>天引き</strong> だと考える<ul><li>午前の朝会に連続するとちょうどよい</li></ul></li><li>メンバー1人1人に、<strong>時間を取るという姿勢そのものが重要</strong><ul><li>何を話すかではなく、時間をとるという行為そのものが重要だって誰かが言っていて、励まされています</li><li>うまいこと言えなくてもセーフ</li></ul></li><li>メンバー1人に対して、隔週開催で月1hも投下できないとすると、そもそもチーミングが崩壊している気がする<ul><li>チーミングを見直すキッカケになる？</li></ul></li><li>仮に、あるメンバーが離脱すると考えるとリスクが大きい。リスクヘッジとして1人に対して月1~2回で0.5h開催は悪くない投資</li></ul><h2 id="実施してみてどうなったか"><a href="#実施してみてどうなったか" class="headerlink" title="実施してみてどうなったか"></a>実施してみてどうなったか</h2><p>対話を通してリーダーである自分自身も色々な着眼点を得ることができているなと思います。</p><ul><li>自分・メンバーの評価のすれ違いは減った<ul><li>半年ごとの評価でのズレはほぼなくなった</li></ul></li><li>副作用として、業務上インプットや基礎スキルが不足している状態も素早く分かり、タスク組み換えなど本業務の推進にも役立っています</li></ul><p>特に期待値のすり合わせは抜群です。</p><p>すぐにでも●●な仕事ができてほしいとモヤモヤしている人が、かなりマイペースで数ヶ月ではなく数年スパンでそういった仕事ができれば良いと考えているなど、成長を目指す点は同じかも知れないですが、スピード感という点で様々な考えがあることに気が付きました。（当たり前の話ですよね）</p><p>総じて、もはやこれを実施していない時がどういう状態か想像できないほど不可欠だなと感じています。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>フルリモートワークになって1.5年くらいですが、その中で1 on 1ミーティングを継続してみて自分が大事だなと思った点をまとめました。</p><p>扱うのは人間であるため、奥深い領域ですが、うまく1 on 1ミーティングを活用してお互い成長したいですね。</p><p><a href="/articles/20211027a/">秋のブログ週間2021</a>の1日目の記事でした。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211027b/top.jpeg&quot; alt=&quot;&quot; title=&quot;Uwe KernによるPixabayからの画像&quot; width=&quot;1200&quot; height=&quot;800&quot;&gt;

&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
    <category term="マネジメント" scheme="https://future-architect.github.io/tags/%E3%83%9E%E3%83%8D%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88/"/>
    
    <category term="リモートワーク" scheme="https://future-architect.github.io/tags/%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"/>
    
    <category term="1on1" scheme="https://future-architect.github.io/tags/1on1/"/>
    
  </entry>
  
  <entry>
    <title>秋のブログ週間連載2021を始めます</title>
    <link href="https://future-architect.github.io/articles/20211027a/"/>
    <id>https://future-architect.github.io/articles/20211027a/</id>
    <published>2021-10-26T15:00:00.000Z</published>
    <updated>2021-10-27T15:36:44.688Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です。</p><p>2020年に実施した秋のブログ週間を開始します。2021年も引き続き9名の執筆陣による9記事を予定しています。</p><img src="/images/20211027a/pexels-olia-danilevich-5490805.jpg" alt="pexels-olia-danilevich-5490805.jpg" width="1200" height="800" loading="lazy"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>2021年の秋はApple M1 Pro/Maxチップを搭載したMacBook Proが発売されたのが大きな話題でしょうか。</p><p>気温の変化が例年より激しく、秋の趣を楽しむ間も無い勢いですが、秋のブログ週間の時期がやってきました。</p><p><a href="/articles/20201026/">2020年の連載</a>同様、秋の夜長を楽しめるような、コーヒーや紅茶やお酒を片手にゆっくり読めるような <strong>いつもより読み物成分多め</strong>の連載を行います。</p><h2 id="秋のブログ週間連載とは"><a href="#秋のブログ週間連載とは" class="headerlink" title="秋のブログ週間連載とは"></a>秋のブログ週間連載とは</h2><p>2020年から始まったブログ連載企画で、秋の読書週間（文化の日を中心とした10/27〜11/9の2週間）の平日にブログ記事を投稿していこうというイベントです。普段は○○技術への入門といった形式の記事が多いですが、そういったプログラミングとは少し趣を変えていきます。普段フューチャー技術ブログをあまり読まない人にも記事が届くと良いなと考えています。</p><h2 id="公開スケジュール"><a href="#公開スケジュール" class="headerlink" title="公開スケジュール"></a>公開スケジュール</h2><div class="scroll"><table><thead><tr><th>日付</th><th>執筆者</th><th>タイトル</th></tr></thead><tbody><tr><td>10/27</td><td>真野隼記</td><td><a href="/articles/20211027b/">リモートワークになって始めた1 on 1ミーティング</a></td></tr><tr><td>10/28</td><td>伊藤真彦</td><td><a href="/articles/20211028a/">人月の神話を読んでみた</a></td></tr><tr><td>10/29</td><td>伊藤太斉</td><td>IaCを実践して思うこと</td></tr><tr><td>11/01</td><td>井上圭</td><td>キーパッドを、基盤から自作してみた</td></tr><tr><td>11/02</td><td>前原応光</td><td>マルチクラウドについて考えてみた</td></tr><tr><td>11/04</td><td>澁川喜規</td><td>Cheetah Grid を Reactから利用する</td></tr><tr><td>11/05</td><td>山本力世</td><td>極小LinuxマシンでSwiftを動かしてみた</td></tr><tr><td>11/08</td><td>ヴーホアン・ミン</td><td>PlantUMLテーマを作ったら公式になった話</td></tr><tr><td>11/09</td><td>前川喜洋</td><td>仮想通貨の個人ウォレットの守り方</td></tr></tbody></table></div><p>※公開スケジュールは変更になったり、入れ替わることがあります。ご了承ください。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今年も2週間ほどの連載となりますが、いつもの空気を感じるテーマから普段は聞けない話まで、お楽しみいただければ幸いです。</p><p>その他連載企画もお見逃しなく!</p><ul><li><a href="/articles/20210414a/">春の入門連載2021を始めます</a></li><li><a href="/articles/20210823a/">夏の自由研究連載2021を始めます</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;2020年に実施した秋のブログ週間を開始します。2021年も引き続き9名の執筆陣による9記事を予定しています。&lt;/p&gt;
&lt;img</summary>
        
      
    
    
    
    <category term="Culture" scheme="https://future-architect.github.io/categories/Culture/"/>
    
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="秋ブログ週間" scheme="https://future-architect.github.io/tags/%E7%A7%8B%E3%83%96%E3%83%AD%E3%82%B0%E9%80%B1%E9%96%93/"/>
    
  </entry>
  
  <entry>
    <title>Software Design 2021年11月号「Kaggleで知る機械学習」を寄稿しました</title>
    <link href="https://future-architect.github.io/articles/20211026b/"/>
    <id>https://future-architect.github.io/articles/20211026b/</id>
    <published>2021-10-25T15:00:01.000Z</published>
    <updated>2021-10-26T01:47:11.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><img src="/images/20211026b/642111.jpeg" alt="642111.jpeg" width="600" height="847" loading="lazy"><p>TIGの玉木です。先日10月18日に発売された<a href="https://gihyo.jp/magazine/SD/archive/2021/202111">Software Design 2021年11月号</a>の第一特集、「Kaggleで知る機械学習 前処理から学習モデルの構築，スコアの上げ方までわかる」をフューチャーの農見、玉木、金子が担当しました。数日経ってしまいましたが、簡単に紹介させていただきます。</p><h2 id="コンセプト"><a href="#コンセプト" class="headerlink" title="コンセプト"></a>コンセプト</h2><p><a href="https://future-architect.github.io/articles/20210511a/">以前の記事</a>でも紹介しましたが、すでに世の中にはたくさんのKaggleを題材とした素晴らしい書籍があります。Kaggleは機械学習用のデータセット、実行環境が用意されており、機械学習を学ぶ題材として適しています。私達はまだあまり日本語の書籍がないテーマである、</p><ul><li>自然言語処理</li><li>画像処理</li></ul><p>の2つの分野について、機械学習をこれから始めたい方向けに記事を書くことにしました。<br>雑誌という形態上ページ数が限られているのもありますが、なるべく最新の動向も含めつつ、最新の動向を理解するための最低限の知識についても紹介しました。</p><p>また、Kaggleの楽しさを伝えよう、というのもコンセプトのうちの1つです。少しずつ精度が上がっていく楽しさがわかるように、どのようにすれば精度が上がるのかという点を中心に書かせていただきました。実際にKaggle Notebookで実行できるように作っているので、興味のある方はぜひKaggle上で試してみていただきたいと思っています。</p><h2 id="2章、3章の自然言語処理パートについて"><a href="#2章、3章の自然言語処理パートについて" class="headerlink" title="2章、3章の自然言語処理パートについて"></a>2章、3章の自然言語処理パートについて</h2><p>Kaggle上で開かれている初心者向けのコンペティションである、<a href="https://www.kaggle.com/c/contradictory-my-dear-watson">Contradictory, My Dear Watson</a>を題材として自然言語処理を学びます。</p><ul><li>機械学習全般の「データの前処理・学習・推論」の流れ</li><li>自然言語処理の代表的なモデルであるBERTの紹介</li><li>Huggingfaceの<a href="https://github.com/huggingface/transformers">Transformers</a>の紹介</li><li>TPUを用いた学習</li><li>最小限のコード、モデル変更での精度の向上</li></ul><p>について紹介しています。このパートを読めば、近年の自然言語処理コンペティションの解法が理解しやすくなると思います。<br>また、フルスクラッチでサブミッションまでたどり着けるようになります。</p><h2 id="4章、5章の自然言語処理パートについて"><a href="#4章、5章の自然言語処理パートについて" class="headerlink" title="4章、5章の自然言語処理パートについて"></a>4章、5章の自然言語処理パートについて</h2><p>4章、5章では、機械学習用くずし字データセット、<a href="http://codh.rois.ac.jp/kmnist/">KMNIST</a>を題材として、画像処理を学びます。EfficientNetV2をベースラインとして用い、そこから</p><ul><li>Data Augmentation</li><li>Snapshot Ensemble</li><li>オプティマイザの変更</li><li>Learning Rate Schduler</li></ul><p>等の変更を行い、精度向上を目指します。</p><p>2章、3章では基本的なところから説明がスタートしますが、5章ではまだ日本語の書籍にはないような近年の手法を用いた工夫も紹介しています。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Software Design 2021年11月号の第一特集、「Kaggleで知る機械学習 前処理から学習モデルの構築，スコアの上げ方までわかる」について簡単に紹介させていただきました。</p><p>u++さんにも感想を頂いています、ありがとうございます。よければu++さんの記事も参考にしてください。</p><p><a href="https://upura.hatenablog.com/entry/2021/10/22/200707">https://upura.hatenablog.com/entry/2021/10/22/200707</a></p><p>自然言語処理、画像処理をこれから学んでみたいと思っている方はぜひ読んでみてください！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;img src=&quot;/images/20211026b/642111.jpeg&quot; alt=&quot;642111.jpeg&quot;</summary>
        
      
    
    
    
    <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
    <category term="機械学習" scheme="https://future-architect.github.io/tags/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/"/>
    
    <category term="NLP" scheme="https://future-architect.github.io/tags/NLP/"/>
    
    <category term="出版" scheme="https://future-architect.github.io/tags/%E5%87%BA%E7%89%88/"/>
    
    <category term="書籍" scheme="https://future-architect.github.io/tags/%E6%9B%B8%E7%B1%8D/"/>
    
    <category term="Kaggle" scheme="https://future-architect.github.io/tags/Kaggle/"/>
    
    <category term="画像処理" scheme="https://future-architect.github.io/tags/%E7%94%BB%E5%83%8F%E5%87%A6%E7%90%86/"/>
    
    <category term="SoftwareDesign" scheme="https://future-architect.github.io/tags/SoftwareDesign/"/>
    
  </entry>
  
  <entry>
    <title>AWS利用時に read: connection reset by peer が出たときのリトライ検討</title>
    <link href="https://future-architect.github.io/articles/20211026a/"/>
    <id>https://future-architect.github.io/articles/20211026a/</id>
    <published>2021-10-25T15:00:00.000Z</published>
    <updated>2021-10-27T10:47:52.880Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211026a/loop-button.png" alt="" title="febrian eka saputraによるPixabayからの画像" width="632" height="433"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DXユニットの真野です。</p><p>DynamoDBやKinesis Data Streamsなどを利用するサービスをそれなりの期間で稼働させているとポツポツ下記のようなエラーが発生することが分かりました。</p><figure class="highlight sh"><figcaption><span>エラーログ(改行を追加しています)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[MY-APP-ERROR-LOG] RequestError: send request failedcaused by:</span><br><span class="line">  Post <span class="string">&quot;https://kinesis.ap-northeast-1.amazonaws.com/&quot;</span>:</span><br><span class="line">    <span class="built_in">read</span> tcp 169.254.0.1:55638-&gt;3.113.218.4:443:</span><br><span class="line">      <span class="built_in">read</span>: connection reset by peer</span><br></pre></td></tr></table></figure><p>ここで疑問に思ったのは、少なくてもAWS SDK for Goを使っている限りは必要に応じてデフォルトでリトライをしてくれているはずです。下記のドキュメントでは通常は3回のリトライを実施してくれるとあります</p><ul><li><a href="https://aws.github.io/aws-sdk-go-v2/docs/configuring-sdk/retries-timeouts/">Retries and Timeouts | AWS SDK for Go V2</a></li></ul><p>では、上記のようなエラーがでるということはリトライを使い果たしても失敗したのでしょうか？ そもそも <code>read: connection reset by peer</code> って正確には何だ？という状態だったので調べました。</p><h2 id="read-connection-reset-by-peer-とは"><a href="#read-connection-reset-by-peer-とは" class="headerlink" title="read: connection reset by peer とは"></a>read: connection reset by peer とは</h2><p>サーバ側から（今回だとKinesis Data Streamsのエンドポイントのサーバ）から <code>RST(Reset TCP)</code> パケット（正確言うとRSTフラグが1のパケット）が送られて来た時にハンドリングされたエラーメッセージです。これを送信された場合は、接続要求や通信状態が拒否されたものとみなし、通信をリセットして終了する必要があるとのことです。発生条件はサーバ側の処理能力を超えた場合などに発生しうるそうです。</p><ul><li><a href="https://e-words.jp/w/RST%E3%83%91%E3%82%B1%E3%83%83%E3%83%88.html">RSTパケット（reset packet）とは - IT用語辞典 e-Words</a></li></ul><p>発生箇所は色々考えられますが、 エラーメッセージに <code>read tcp xxxx</code> とある場合はリクエストを送信して、レスポンスを読み込もうとして（read tcpしようとして）発生したと推測できます。</p><p>つまり、今回のログで言うと <code>Post &quot;https://kinesis.ap-northeast-1.amazonaws.com/&quot;</code> のリクエストはサーバ側に届いたものの、レスポンスを受信するタイミングでTPCレイヤーで通信に失敗したと見なせると思います。（自信が無いので間違っていましたらご指摘下さい）</p><p>Go側ではRSTパッケージを送られたかどうかは、エラーの文字列に <code>connection reset by peer</code> が含まれているかどうかでも分かりますし、ガンバるのであれば、syscallパッケージで判定できそうです。</p><figure class="highlight go"><figcaption><span>RST判定のサンプル実装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsRSTErr</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> opErr, ok := err.(*net.OpError); ok &#123;</span><br><span class="line"><span class="keyword">if</span> sysErr, ok := opErr.Err.(*os.SyscallError); ok &#123;</span><br><span class="line"><span class="keyword">return</span> sysErr.Err == syscall.ECONNRESET</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本題から少し逸れたので、リトライについて話を戻します。</p><h2 id="AWS-SDK-for-Go側のリトライハンドリングについて"><a href="#AWS-SDK-for-Go側のリトライハンドリングについて" class="headerlink" title="AWS SDK for Go側のリトライハンドリングについて"></a>AWS SDK for Go側のリトライハンドリングについて</h2><p>AWS SDK for Goのリトライ処理についてはカスタマイズ可能です。方法は辻さんが過去にブログを書いてくれています。</p><ul><li><a href="/articles/20210218/">AWS SDK for Goのリトライアルゴリズムを差し替える方法 | フューチャー技術ブログ</a></li></ul><p>デフォルトの仕組みは、DefaultRetryerの<a href="https://github.com/aws/aws-sdk-go/blob/d8a5a9febe5602f134648c18e9f83546284cda35/aws/client/default_retryer.go#L131">ShouldRetry</a> で、どのようなエラーが発生した時に、<strong>リトライすべきか否か</strong> を判定しています。<code>ShoudRetry</code> をさらに追っていくと、<code>IsErrorRetryable</code> という関数からさらに <a href="https://github.com/aws/aws-sdk-go/blob/d8a5a9febe5602f134648c18e9f83546284cda35/aws/request/retryer.go#L208">isErrConnectionReset</a> という関数があることに気が付きます。</p><p><a href="https://github.com/aws/aws-sdk-go/blob/d8a5a9febe5602f134648c18e9f83546284cda35/aws/request/connection_reset_error.go#L7">connection_reset_error.goに実装された関数isErrConnectionReset</a>を見ると、かなり興味深い実装です。</p><figure class="highlight go"><figcaption><span>connection_reset_error.goから抜粋</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isErrConnectionReset</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;read: connection reset&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;use of closed network connection&quot;</span>) ||</span><br><span class="line">strings.Contains(err.Error(), <span class="string">&quot;connection reset&quot;</span>) ||</span><br><span class="line">strings.Contains(err.Error(), <span class="string">&quot;broken pipe&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>なんと、<code>read: connection reset</code> が含まれている場合は、 <strong>リトライを行わない</strong> 判定になっていました。<code>read</code> が入っていない <code>connection reset</code> はリトライを行うとは対照的です。</p><p>コミットのハッシュ値からこのコードへの補足を探すと、簡潔に説明しているコメントが見つかります。</p><ul><li><a href="https://github.com/aws/aws-sdk-go/pull/2926#issuecomment-553196888">https://github.com/aws/aws-sdk-go/pull/2926#issuecomment-553196888</a></li><li><a href="https://github.com/aws/aws-sdk-go/pull/2926#issuecomment-553637658">https://github.com/aws/aws-sdk-go/pull/2926#issuecomment-553637658</a></li></ul><p>書いていることを整理しました。</p><ul><li>（今回で言うとKinesis）へのサービスへのリクエストの書き込みに成功/失敗について、SDK側は分からない<ul><li>レスポンス読み取りに失敗しただけなので、リクエスト自体は成功した（Kinesisにデータはputできた）かもしれない</li></ul></li><li>とはいえ、失敗した可能性があるのであれば自動でリトライをしても良い気がするが…？<ul><li>SDKとしては指定された操作が冪等であるか分からないので、デフォルトの挙動としては安全側に倒しリトライしない</li></ul></li></ul><p>…なるほど、理由が分かるとスッキリしますね。<br><code>read</code>がない <code>connection reset</code> をリトライするのは、おそらく書き込み側（リクエストを送信する時）にエラーになったケースなので、その場合は処理が成功することはありえないので、リトライを行うということだったようです。</p><h2 id="その上で今回はリトライすべきかどうか"><a href="#その上で今回はリトライすべきかどうか" class="headerlink" title="その上で今回はリトライすべきかどうか"></a>その上で今回はリトライすべきかどうか</h2><p>今回の構築したサービスの仕様だと、Kinesis Data Streamsをサブスクライブしているアプリは <strong>冪等</strong> であることを期待しているので、重複してputすることを許容し、そのままリトライさせることにします。（ていうかKinesisであればそもそもサービスとしてAt Least Onceなので、SDK側の判断で重複リトライしてもよいのでは..という気もしましたが、ダメなケースがあるのかな）。</p><p>リトライ方法ですが、先程のカスタムリトライの記事にあったとおり、DefaultRetryerを拡張して実装します。</p><h2 id="カスタムリトライの実装"><a href="#カスタムリトライの実装" class="headerlink" title="カスタムリトライの実装"></a>カスタムリトライの実装</h2><p>aws/aws-sdk-go のリポジトリの <a href="https://github.com/aws/aws-sdk-go/tree/main/example/aws/request/customRetryer">exampleフォルダ</a>にカスタムリトライのサンプルコードがあり参考にできます。</p><p>実装を見ると、500番台のエラーは常に <strong>リトライしない</strong> という拡張なようです。</p><figure class="highlight go"><figcaption><span>custom_retryer.goから抜粋</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomRetryer <span class="keyword">struct</span> &#123;</span><br><span class="line">client.DefaultRetryer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r CustomRetryer)</span> <span class="title">ShouldRetry</span><span class="params">(req *request.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.HTTPResponse.StatusCode &gt;= <span class="number">500</span> &#123;</span><br><span class="line"><span class="comment">// Don&#x27;t retry any 5xx status codes.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback to SDK&#x27;s built in retry rules</span></span><br><span class="line"><span class="keyword">return</span> r.DefaultRetryer.ShouldRetry(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今回私が実装したいのは、<strong>read: connection reset</strong> の時も <strong>リトライを行いたい</strong> ということなのでその条件のときに <code>return true</code> という、ほぼ同じ考えが適用できるステキなサンプルでした。</p><p>次に実装をあげますが、元のDefaultRetryerがtemporaryというインターフェースでスイッチしていた実装なのでそれを切り貼りしています。</p><figure class="highlight go"><figcaption><span>read_connection_resetの時もリトライする</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomRetryer <span class="keyword">struct</span> &#123;</span><br><span class="line">client.DefaultRetryer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r CustomRetryer)</span> <span class="title">ShouldRetry</span><span class="params">(req *request.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> origErr := req.Error; origErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> origErr.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> temporary:</span><br><span class="line"><span class="keyword">if</span> strings.Contains(origErr.Error(), <span class="string">&quot;read: connection reset&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// デフォルトのSDKではリトライしないが、リトライ可にする</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.DefaultRetryer.ShouldRetry(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の実装だと、<code>read: connection reset</code>が発生した場合に規定の回数より多くリトライをしてしまうのでは？という懸念が浮かびましたが、ドキュメントを読むと最大リトライの配慮は別処理でなされるので問題ないようです。</p><blockquote><p>// Implementations may consider request attempt count when determining if a<br>// request is retryable, but the SDK will use MaxRetries to limit the<br>// number of attempts a request are made<br>ShouldRetry(*Request) bool<br><a href="https://docs.aws.amazon.com/sdk-for-go/api/aws/request/#Retryer">https://docs.aws.amazon.com/sdk-for-go/api/aws/request/#Retryer</a></p></blockquote><p>それ以外の判定はDefaultRetryerに最終的な判断を移譲させます。</p><p>実装したカスタムリトライは aws sessionで設定できます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kc = kinesis.New(session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Retryer: CustomRetryer&#123;&#125;,</span><br><span class="line">&#125;),</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>DefaultRetryer側の設定を変えたい場合は、埋め込んでいるためそのまま設定できます。</p><figure class="highlight go"><figcaption><span>NumMaxRetriesを変更した例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kc = kinesis.New(session.Must(</span><br><span class="line">session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Retryer: CustomRetryer&#123;</span><br><span class="line">DefaultRetryer: client.DefaultRetryer&#123;</span><br><span class="line">NumMaxRetries: client.DefaultRetryerMaxNumRetries,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;),</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>既存のパッケージの機能をそのまま使えるのは安心感があると思います。こういう薄いラッパーが作りやすいのは嬉しい仕組みですね。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>今まであまり深く気に留めていなかった <code>read: connection reset by peer</code> といったエラーに関しても、SDK実装者側の設計や配慮を抑え、アプリ開発に活かすと不明瞭な点が減り、より自信を持ったコードを書けるようになりました。</p><p>AWS SDK for GoはGitHub上でのやり取り含めてちゃんと運用されており、学びになります。ハマったときはコードの内部を追ってみるのもオススメだと思いました。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211026a/loop-button.png&quot; alt=&quot;&quot; title=&quot;febrian eka saputraによるPixabayからの画像&quot; width=&quot;632&quot; height=&quot;433&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Network" scheme="https://future-architect.github.io/tags/Network/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="リトライ" scheme="https://future-architect.github.io/tags/%E3%83%AA%E3%83%88%E3%83%A9%E3%82%A4/"/>
    
  </entry>
  
  <entry>
    <title>AWS SDK for GoでDynamoDBの式を扱うヘルパーパッケージの使い方</title>
    <link href="https://future-architect.github.io/articles/20211025a/"/>
    <id>https://future-architect.github.io/articles/20211025a/</id>
    <published>2021-10-24T15:00:00.000Z</published>
    <updated>2021-10-25T01:22:03.310Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211025a/top.png" alt="" width="1200" height="676"><p>by <a href="http://reneefrench.blogspot.com/">Renée French</a></p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG真野です。</p><p>DynamoDBをGoで操作することにかけては、<a href="/tags/DynamoDB%C3%97Go/">DynamoDB×Go連載</a> に参加するくらい関心があるのですが、AWS SDK for Goの公式ライブラリに含まれる、ヘルパーパッケージについて存在を今までスルーしていました。使ってみると業務的には利用一択だと思ったので今後使っていくぞという覚書としてまとめます。</p><h2 id="DynamoDBの式をダイレクトに実装した例"><a href="#DynamoDBの式をダイレクトに実装した例" class="headerlink" title="DynamoDBの式をダイレクトに実装した例"></a>DynamoDBの式をダイレクトに実装した例</h2><p>私は公式のAWS SDK for Goの<a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/">dynamodbパッケージ</a>を用いる時に、ドキュメントのExampleに書いてあるように、ちまちま <code>ExpressionAttributeNames</code>や<code>ExpressionAttributeValues</code>や<code>FilterExpression</code>や<code>ProjectionExpression</code>を指定していました。</p><p>どんな感じかと言うと次のような感じです。</p><figure class="highlight go"><figcaption><span>Exampleに書いてあるような実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    db := dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line">    result, err := db.Scan(&amp;dynamodb.ScanInput&#123;</span><br><span class="line">        ExpressionAttributeNames: <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;#AT&quot;</span>: aws.String(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line">            <span class="string">&quot;#ST&quot;</span>: aws.String(<span class="string">&quot;SongTitle&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        ExpressionAttributeValues: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line">            <span class="string">&quot;:a&quot;</span>: &#123;</span><br><span class="line">                S: aws.String(<span class="string">&quot;No One You Know&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        FilterExpression:     aws.String(<span class="string">&quot;Artist = :a&quot;</span>),</span><br><span class="line">        ProjectionExpression: aws.String(<span class="string">&quot;#ST, #AT&quot;</span>),</span><br><span class="line">        TableName:            aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// エラーハンドリング</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> recs []Record</span><br><span class="line">    <span class="keyword">if</span> err := dynamodbattribute.UnmarshalListOfMaps(page.Items, &amp;recs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// エラーハンドリング</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これはこれで、DynamoDBのREST APIの仕様に詳しくなれるのと、AWS CLIを用いたDynamoDBアクセスする時と知識を流用できるので学びにはなるのですが、利用項目や条件が増えてくるとレビュー観点でツライですし、自分が実装するときも<code>ExpressionAttributeNames</code> が抜けていてエラーになるなど、生産性という意味では開発者側が試されているなと感じることが多かったです。</p><h2 id="ヘルパーパッケージの福音"><a href="#ヘルパーパッケージの福音" class="headerlink" title="ヘルパーパッケージの福音"></a>ヘルパーパッケージの福音</h2><p>業務でも様々な技術ブログでも DynamoDB SDK for Goを実装するときは上記のような設定をするコードをよく見ますが、実は公式に便利なヘルパーが用意されています。 <code>expression</code> パッケージです。式の組み立て全般をサポートしてくれるビルダーを提供してくれます。</p><ul><li><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/">https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/</a></li></ul><p><code>expression</code>パッケージ を用いると、<code>ExpressionAttributeNames</code> や <code>ExpressionAttributeValues</code> や <code>FilterExpression</code> などのDynamoDBの式を型安全に構築することができます。例をあげます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>), expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>))</span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db := dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line">result, err := db.Scan(&amp;dynamodb.ScanInput&#123;</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">FilterExpression:          expr.Filter(),</span><br><span class="line">ProjectionExpression:      expr.Projection(),</span><br><span class="line">TableName:                 aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expression</code> パッケージを利用して、フィルター条件やプロジェクション式を構築しています。ややコードとしては長くなりましたが、<code>dynamodb.ScanInput</code> のフィールドがの設定が一律シンプル下したことがわかります。この勢いで <code>TableName</code> も <code>expr</code> から指定したい気もしますが、それはパッケージの担当外なようです。</p><p>サンプルコードだけ見ると、心理的なハードルが高く思えるかもしれませんが、そもそも元の実装にあるような、<code>ExpressionAttributeNames</code> や <code>ExpressionAttributeValues</code> や <code>FilterExpression</code> の記載方法を覚え、正しく使用することの方が大変です。 <code>expression</code> パッケージを用いると、何かしら指定が論理的に正しくない場合は、式のビルド時にエラーで検知することができるため、開発時のトラブルシュートにも役立つと思います。</p><p>AWS SDK for Goを生で用いてDynamoDBアクセスを行うのであれば、基本的には積極的に使っていくパッケージでしょう。</p><h2 id="論理式"><a href="#論理式" class="headerlink" title="論理式"></a>論理式</h2><p>先程の例ではEqualでしたが、ドキュメントを見る通り、AND, OR, NotEqualや、LessThan, GreaterThan などなど、一通りの演算子が揃っています。選び放題・使い放題のガッツがあるパッケージです。</p><p><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/">https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/</a></p><p>例えばフィルターで、Artistが Red, Green, Blue のどれかという条件を指定すると以下のようになります。</p><figure class="highlight go"><figcaption><span>OR条件を指定した例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Red&quot;</span>)).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Green&quot;</span>))).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Blue&quot;</span>)))</span><br><span class="line"></span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>), expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>もちろんAND, ORをネスト化することもできます。<code>Artist</code> が <code>Blue</code> のときは <code>Year</code> が <code>2021</code> 年であると追加します。</p><figure class="highlight go"><figcaption><span>ネストした条件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Red&quot;</span>)).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Green&quot;</span>))).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Blue&quot;</span>)).</span><br><span class="line">And(expression.Name(<span class="string">&quot;Year&quot;</span>).Equal(expression.Value(<span class="string">&quot;2021&quot;</span>))),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>式で表現すると <code>Artist == Red || Artist == Green || (Artist == Blue &amp;&amp; Year == 2021)</code> といった感じでしょうか。式が複雑になる場合はこういった擬似コードでコメントの補足を入れると良いかなと思います。</p><h2 id="ProjectionExpressionを指定するのが面倒問題"><a href="#ProjectionExpressionを指定するのが面倒問題" class="headerlink" title="ProjectionExpressionを指定するのが面倒問題"></a>ProjectionExpressionを指定するのが面倒問題</h2><p><code>expression</code>パッケージを利用していくと、Projectionの設定が面倒な場合があります。</p><figure class="highlight go"><figcaption><span>面倒な例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line"></span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;Rate&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;PublishedAt&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;Price&quot;</span>))  <span class="comment">// やたら数が多くなるし項目追加時に見逃しやすい</span></span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合は自前で一工夫すると良いでしょう。ヘルパー関数をさらに作っても良いかもしれません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []expression.NameBuilder</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;SongTitle&quot;</span>, <span class="string">&quot;AlbumTitle&quot;</span>, <span class="string">&quot;Rate&quot;</span>, <span class="string">&quot;PublishedAt&quot;</span>, <span class="string">&quot;Price&quot;</span>&#125; &#123;</span><br><span class="line">names = <span class="built_in">append</span>(names, expression.Name(name))</span><br><span class="line">&#125;</span><br><span class="line">proj := expression.NamesList(names[<span class="number">0</span>], names[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このあたりを作り込みすぎると、独自DSLを作るような感じになるかと思いますが、愚直に書きすぎると表現の密度が下がりすぎて保守がツライ場合もあるので、バランスを見て取り入れて行くと良いかなと思います。</p><h2 id="クエリの場合"><a href="#クエリの場合" class="headerlink" title="クエリの場合"></a>クエリの場合</h2><p>先程まではScanの例でしたが、Queryの場合はさらに <code>expression</code> が役立ちます。ハッシュキーにDeviceID、ソートキーにTimestampという典型的な時系列データを保持するDeviceLogというテーブルに対しての実装例です。</p><figure class="highlight go"><figcaption><span>クエリの実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryTable</span><span class="params">(ctx context.Context, deviceID <span class="keyword">string</span>, start, end time.Time)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">keyCond := expression.Key(<span class="string">&quot;DeviceID&quot;</span>).Equal(expression.Value(deviceID)).</span><br><span class="line">And(expression.Key(<span class="string">&quot;Timestamp&quot;</span>).Between(</span><br><span class="line">expression.Value(start.Format(time.RFC3339)),</span><br><span class="line">expression.Value(end.Format(time.RFC3339))))</span><br><span class="line"></span><br><span class="line">filterCond := expression.Name(<span class="string">&quot;DeviceType&quot;</span>).Equal(expression.Value(<span class="string">&quot;Normal&quot;</span>)).</span><br><span class="line">And(expression.Name(<span class="string">&quot;CreatedYear&quot;</span>).GreaterThan(expression.Value(<span class="number">2018</span>)))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithKeyCondition(keyCond).WithFilter(filterCond).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result, err := db.QueryWithContext(ctx, &amp;dynamodb.QueryInput&#123;</span><br><span class="line">KeyConditionExpression:    expr.KeyCondition(),</span><br><span class="line">ProjectionExpression:      expr.Projection(),</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">FilterExpression:          expr.Filter(),</span><br><span class="line">TableName:                 aws.String(<span class="string">&quot;DeviceLog&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>あるデバイスに対して、開始～終了日時を指定し、さらに適当なフィルター条件も追加しました。クエリの場合は、<code>KeyConditionExpression</code>と <code>FilterExpression</code> の両方が設定できるため、<code>expression</code> パッケージを利用しない時は<code>ExpressionAttributeNames</code> と <code>ExpressionAttributeValues</code> の管理が煩雑になりがちでした。</p><h2 id="Update-Expression"><a href="#Update-Expression" class="headerlink" title="Update Expression"></a>Update Expression</h2><p>DynamoDBに対するUpdate式も、クエリと同様になかなかとっつき難かったです。<code>expression</code>パッケージを用いない場合は、通常の文字列なのでカンマの位置などかなり気をつけることが多いです。</p><figure class="highlight go"><figcaption><span>実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">_, err := db.UpdateItemWithContext(ctx, &amp;dynamodb.UpdateItemInput&#123;</span><br><span class="line">TableName:        aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">Key: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;Artist&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Acme Band&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;SongTitle&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Happy Day&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeNames: <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;#AT&quot;</span>:  aws.String(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line"><span class="string">&quot;#Y&quot;</span>:   aws.String(<span class="string">&quot;Year&quot;</span>),</span><br><span class="line"><span class="string">&quot;#REV&quot;</span>: aws.String(<span class="string">&quot;Revision&quot;</span>),</span><br><span class="line"><span class="string">&quot;#UPA&quot;</span>: aws.String(<span class="string">&quot;UpdatedAt&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeValues: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;:t&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Louder Than Ever&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:y&quot;</span>: &#123;</span><br><span class="line">N: aws.String(<span class="string">&quot;2015&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:inc&quot;</span>: &#123;</span><br><span class="line">N: aws.String(<span class="string">&quot;1&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:upa&quot;</span>: &#123;</span><br><span class="line">S: aws.String(time.Now().UTC().Format(time.RFC3339)),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">UpdateExpression: aws.String(<span class="string">&quot;SET #Y = :y, #AT = :t, #UPA = :upa ADD #REV :inc&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これは <code>expression</code> パッケージを用いると次のようになります。</p><figure class="highlight go"><figcaption><span>expressionを用いたUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">update := expression.Set(expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>), expression.Value(<span class="string">&quot;Louder Than Ever&quot;</span>)).</span><br><span class="line">Set(expression.Name(<span class="string">&quot;Year&quot;</span>), expression.Value(<span class="string">&quot;2015&quot;</span>)).</span><br><span class="line">Set(expression.Name(<span class="string">&quot;UpdatedAt&quot;</span>), expression.Value(time.Now())).</span><br><span class="line">Add(expression.Name(<span class="string">&quot;Revision&quot;</span>), expression.Value(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithUpdate(update).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := db.UpdateItemWithContext(ctx, &amp;dynamodb.UpdateItemInput&#123;</span><br><span class="line">TableName: aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">Key: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;Artist&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Acme Band&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;SongTitle&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Happy Day&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">UpdateExpression:          expr.Update(),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>式の構築部分が型セーフに実装できていることが分かると思います。</p><p>少し残念なのは、 <code>Key</code> の部分は <code>expr</code> から生成できないということでしょうか。ここだけはハッシュキー（とソートキー）をダイレクトに指定する必要があるので、レベル感がズレて勿体ない気がします。（KeyConditionのように指定したかったですね）</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>AWS SDK for Goの <code>dynamodb</code> パッケージを用いると時に必須とも言える、 <code>expression</code> パッケージの使い方について触れました。</p><p><code>expression</code> パッケージを用いると、従来DynamoDBのAPI仕様を理解したフィールドや、文字列で式を設定する必要があった部分を、型安全に構築することができます。</p><p>いくつか残念なところはあるにしろ、メリットは計り知れないのでうまく活用していきたいですね。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211025a/top.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;676&quot;&gt;

&lt;p&gt;by &lt;a href=&quot;http://reneefrench.blogspot.com/&quot;&gt;Renée</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="DynamoDB" scheme="https://future-architect.github.io/tags/DynamoDB/"/>
    
    <category term="式" scheme="https://future-architect.github.io/tags/%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Google Drive API v3をサービスアカウトとGoから利用</title>
    <link href="https://future-architect.github.io/articles/20211022a/"/>
    <id>https://future-architect.github.io/articles/20211022a/</id>
    <published>2021-10-21T15:00:00.000Z</published>
    <updated>2021-10-22T01:28:44.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG真野です。</p><p>Google DriveにアップロードされたExcelファイルを利用したちょっとしたジョブを実装する機会があり、処理を動かしたいのがAWSなど別のプラットフォームであったため、サービスアカウントを用いてGoogle Drive APIにアクセスするGoプログラムを作りました。</p><p>いくつかの人が書いている通り、Google Drive APIもv2, v3で情報が入り乱れていて本家のドキュメントを探したて見ながら試行錯誤したりちょっと悩みました。また、サービスアカウント利用する実装例が少なかったので手順をまとめていきます。</p><h2 id="認証方式"><a href="#認証方式" class="headerlink" title="認証方式"></a>認証方式</h2><p>Google Drive APIを用いたコード実装を始める前に、事前にアカウントなどの権限周りの準備を実施します。</p><p>Google Drive APIを使うための<a href="https://cloud.google.com/docs/authentication?hl=ja#getting_credentials_for_server-centric_flow">認証方式</a>には大きく4つの方法があります。</p><ol><li><strong>APIキー</strong>: 一般公開データに匿名でアクセスする</li><li><strong>OAuth2</strong>: エンドユーザーに代わって限定公開データにアクセスする</li><li><strong>環境提供のサービス アカウント</strong>: Google Cloud 環境内でサービス アカウントに代わって限定公開データにアクセスする</li><li><strong>サービスアカウント</strong>: Google Cloud 環境外でサービス アカウントに代わって非公開データにアクセスする</li></ol><p>今回はGCP以外の環境で動かしたいので、4のサービスアカウントを利用します。</p><h2 id="サービスアカウントの払い出し"><a href="#サービスアカウントの払い出し" class="headerlink" title="サービスアカウントの払い出し"></a>サービスアカウントの払い出し</h2><p>サービスアカウントはGCPのProjectに紐づきます。もし利用できるProjectが存在しなければ<a href="https://console.cloud.google.com/cloud-resource-manager">リソース管理ページ</a>から作成します。詳しくは<a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects">プロジェクトの作成と管理 - Google Cloud</a>を確認下さい。</p><p>続いて、Projectの<a href="https://console.cloud.google.com/apis/library/drive.googleapis.com">Google Drive API</a> から、Google Drive APIを有効にします。有効にしないとこのProjectから払い出したサービスアカウントの認証情報では、Google Drive APIを利用できないです。</p><img src="/images/20211022a/Google_Drive_APIの有効化.png" alt="Google_Drive_APIの有効化.png" width="1200" height="640" loading="lazy"><p>続いて、<a href="https://console.cloud.google.com/apis/api/drive.googleapis.com/credentials">APIとサービスにある、Google Drive APIの認証情報</a>タブから、「認証情報を作成」をクリックして、サービスアカウントの作成を行います。今回は適当に、google-drive-exampleという名前にしました。</p><img src="/images/20211022a/認証情報を作成.png" alt="認証情報を作成.png" width="1200" height="470" loading="lazy"><p>数十秒待つと、サービスアカウントの作成されます。その後は、サービスアカウントの「キー」から、キーを作成します。タイプはJSONで良いと思います。</p><img src="/images/20211022a/image.png" alt="image.png" width="1200" height="628" loading="lazy"><p>ダウンロードしたJSONファイルは大事に保存します。AWS上で使う場合は、AWS Systems Manager Parameter StoreにSecureString属性をつけて保存し利用すると良いでしょう。</p><h2 id="サービスアカウントのDriveへのアクセス権限を追加"><a href="#サービスアカウントのDriveへのアクセス権限を追加" class="headerlink" title="サービスアカウントのDriveへのアクセス権限を追加"></a>サービスアカウントのDriveへのアクセス権限を追加</h2><p>先程作成したサービスアカウントの <code>google-drive-example@xxxx-xxxx-123456.iam.gserviceaccount.com</code> に、アクセスしたいGoogle Drive先の権限を付与します。</p><p>アクセスさせたいフォルダなどを右クリックして、「共有」から先程のアカウントIDを指定します。</p><img src="/images/20211022a/権限付与.png" alt="権限付与.png" width="1200" height="388" loading="lazy"><p>これでgoogle-drive-exampleのIDから、Google Drive APIを用いて指定のフォルダにアクセスできるようになりました。</p><h2 id="実装（List）"><a href="#実装（List）" class="headerlink" title="実装（List）"></a>実装（List）</h2><p>GoからGoogle Drive API v3を利用します。</p><figure class="highlight sh"><figcaption><span>パッケージ取得</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/api/drive/v3</span><br></pre></td></tr></table></figure><p>まず指定されたフォルダ配下にあるファイルの一覧表示します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;google.golang.org/api/drive/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name)&quot;</span>).</span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line"><span class="built_in">println</span>(f.Name, f.Id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行する前に先程取得したJSONキーファイルを環境変数で指定する必要があります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOOGLE_APPLICATION_CREDENTIALS=./project-name-123456789abc.json</span><br></pre></td></tr></table></figure><p>環境変数に <code>GOOGLE_APPLICATION_CREDENTIALS</code> が設定されていれば、SDK側が自動で認証してくれます。詳しくは<a href="https://cloud.google.com/docs/authentication/production">サービス アカウントとして認証する - Google Cloud</a> を参照下さい。</p><p>実行すると、先程権限を付与したフォルダ配下のファイル一覧が取得できると思います。</p><h2 id="実装（ダウンロード）"><a href="#実装（ダウンロード）" class="headerlink" title="実装（ダウンロード）"></a>実装（ダウンロード）</h2><p>続いて、フォルダにExcelファイルがアップロードされているとして、それらをダウンロードします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package, import 部分は省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name, mimeType)&quot;</span>). <span class="comment">// mimeTypeを追加する</span></span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line"><span class="keyword">if</span> f.MimeType == <span class="string">&quot;application/vnd.google-apps.folder&quot;</span> &#123;</span><br><span class="line"><span class="comment">// フォルダの場合はスキップ</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := download(ctx, srv, f.Name, f.Id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to download: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(ctx context.Context, srv *drive.Service, name, id <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">create, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;create file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> create.Close()</span><br><span class="line"></span><br><span class="line">resp, err := srv.Files.Get(id).Context(ctx).Download()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;get drive file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(create, resp.Body); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>さきほどのList表示するコードと大部分は同じですが、mimeTypeを追加で設定しているのはご注意下さい。Fieldsに指定できる項目は<a href="https://developers.google.com/drive/api/v3/reference/files">Google Drive APIの開発者ページのfiles</a>に記載がありました。</p><p>今回はmimeTypeでフォルダに対してはダウンロード処理をしないようにスキップ処理を入れています。</p><p>ダウンロードですが、今回はExportではなくGetを利用しています。スプレッドシートの場合はExportを呼び出しxlsx形式にする必要があるかもしれませんが、単純にバイナリをそのまま落とすのであればGetです。</p><p>こちらを実行すると、権限付与したフォルダ配下のファイルを全て取得できると思います。</p><h2 id="指定したフォルダ配下のみのファイルをダウンロードしたい"><a href="#指定したフォルダ配下のみのファイルをダウンロードしたい" class="headerlink" title="指定したフォルダ配下のみのファイルをダウンロードしたい"></a>指定したフォルダ配下のみのファイルをダウンロードしたい</h2><p><a href="https://developers.google.com/drive/api/v3/reference/files/list">Google Drive APIの Files: list</a>を確認すると<code>q</code>オプションで検索対象の絞り込みが可能です。いくつか<a href="https://developers.google.com/drive/api/v3/search-files">検索例</a>がドキュメントに記載されています。</p><p><code>&#39;1234567&#39; in parents</code> といった例が記載されていますが、1234567には指定したいフォルダのIDを設定します。IDはブラウザで開いた時にURLで設定されている値です。複数を指定したい場合は <code>or</code> 条件で追加も可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name, mimeType, parents)&quot;</span>).</span><br><span class="line">Q(fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; in parents or &#x27;%s&#x27; in parents&quot;</span>, <span class="string">&quot;1234567&quot;</span>, <span class="string">&quot;890abcd&quot;</span>)). <span class="comment">// 特定のフォルダ配下</span></span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>どういった検索条件を指定できるかは、文法としてまとまっているので迷ったら確認すると早いです。</p><ul><li><a href="https://developers.google.com/drive/api/v3/ref-search-terms">https://developers.google.com/drive/api/v3/ref-search-terms</a></li></ul><h2 id="フォルダ指定かつ再帰的にファイルを探索したい"><a href="#フォルダ指定かつ再帰的にファイルを探索したい" class="headerlink" title="フォルダ指定かつ再帰的にファイルを探索したい"></a>フォルダ指定かつ再帰的にファイルを探索したい</h2><p>さきほどの <code>q</code> の指定で再帰的にファイルを指定するのは難しいです。</p><p>例えば、以下のようにネストした構造を保つ場合に、targetFolderのファイルIDを指定しても取得できるのは folder1, folder2までです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">targetFolder</span><br><span class="line">  └ folder1</span><br><span class="line">  |   └ file1.xlsx</span><br><span class="line">  |   └ file2.xlsx</span><br><span class="line">  └ folder2</span><br><span class="line">      └ file3.xlsx</span><br></pre></td></tr></table></figure><p>この場合は自前で再帰的にList APIをコールする処理を実装する必要があります。少し面倒ですね。少し面倒ですが、最初の実装にあるとおり、OR条件で親フォルダを決め打ちで指定するのが簡単で良いかもしれません。</p><p>（parents は複数要素が設定されると思うので、ネストした親フォルダも設定できた場合は、<code>q</code> に <code>&#39;FILE-ID&#39; in parents</code> の指定で実現できそうです。設定方法がよく分からず今回は上記の結論となりました）</p><h2 id="ページング"><a href="#ページング" class="headerlink" title="ページング"></a>ページング</h2><p>List APIのドキュメントを確認すると、pageSizeはデフォルトが100で、最大が1000までです。これを超過する場合は、pageTokenを指定してページング処理を行う（複数回APIをコールする）必要があります。</p><ul><li><a href="https://developers.google.com/drive/api/v3/reference/files/list">https://developers.google.com/drive/api/v3/reference/files/list</a></li></ul><p>簡単な実装例です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package, import 部分は省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> paging <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;nextPageToken, files(id, name, parents)&quot;</span>). <span class="comment">// nextPageTokenをFiledsに追加</span></span><br><span class="line">PageToken(paging).</span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s %s %+v\n&quot;</span>, f.Name, f.Id, f.Parents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">paging = r.NextPageToken</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(paging) == <span class="number">0</span> &#123; <span class="comment">// 次のページング先が無ければ終了</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ファイル数が1000を超過する可能性がある場合は、忘れないようにしたいですね。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>サービスアカウントを用いて、Google Drive API v3をGo SDKを用いて操作する例をいくつかまとめました。Google Drive上のファイルにアクセスできると、システムやアプリに機能として組み込まなくても、ちょっとした業務を効率化することができると思います。うまく役立てていけると良いなと考えています。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;TIG真野です。&lt;/p&gt;
&lt;p&gt;Google</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="GoogleDrive" scheme="https://future-architect.github.io/tags/GoogleDrive/"/>
    
    <category term="サービスアカウント" scheme="https://future-architect.github.io/tags/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88/"/>
    
    <category term="GoogleWorkspace" scheme="https://future-architect.github.io/tags/GoogleWorkspace/"/>
    
  </entry>
  
  <entry>
    <title>FigmaからFlutterに変換するプラグインを比較する</title>
    <link href="https://future-architect.github.io/articles/20211021a/"/>
    <id>https://future-architect.github.io/articles/20211021a/</id>
    <published>2021-10-20T15:00:00.000Z</published>
    <updated>2021-10-21T01:41:59.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャーでは、FigmaやAdobe XDなどのデザインツールの利用が以前よりも少しづつ増えています。今回の題材はFigmaです。</p><p>先月の「<a href="https://future-architect.github.io/articles/20210915a/">Adobe XDからFlutterに変換する</a>」の記事では、Adobe XDで作成したデザインをFlutterコードに落とし込むためのTipsを渋川さんが紹介してくれました。XD→Flutterの変換は、<a href="https://blog.adobe.com/jp/publish/2020/09/25/cc-web-xd-flutter-plugin-now-available.html">AdobeとGoogleが協力して開発している</a>プラグインがあるため、変換ツールの選択肢で迷うことはあまり無いのかなと思います。</p><p>それに対して、Figma→Flutterの変換は公式で開発 or 推奨されているツールが無く、様々な個人・企業が出しているツールからどれかを選択して利用する必要があります。この記事では、<strong>Figma→Flutterの変換をサポートする主なツールを紹介し、実際にそれらを使ってFlutterコードを出力した結果の比較を行っていきます。</strong>「Figmaからのコード生成って色々な方法があって何が良いのかよく分からん！」という人の参考になれば嬉しいです。</p><h1 id="Figma→Flutterを実現する方法"><a href="#Figma→Flutterを実現する方法" class="headerlink" title="Figma→Flutterを実現する方法"></a>Figma→Flutterを実現する方法</h1><p>FigmaからFlutter用のdartコードを生成する方法は主に以下の2パターンが存在するようです。</p><ol><li>Figmaのプラグインを使う方法</li><li>Figmaプラグインではない外部のサービスを利用する方法</li></ol><p>それぞれを紹介していきます。</p><h3 id="Figmaのプラグインを使う方法"><a href="#Figmaのプラグインを使う方法" class="headerlink" title="Figmaのプラグインを使う方法"></a>Figmaのプラグインを使う方法</h3><p>FigmaをFlutterに変換できると謳っているプラグインは複数存在していて、個人がメインで開発しているものから、企業が公開しているものまで様々です。ここでは、2021年10月時点のインストール数の上位4つを紹介します。<br>（<a href="https://www.figma.com/community/search?model_type=public_plugins&q=flutter">Figma Communityのページで検索する</a>と、インストール数がもっと少ないものもいくつか出てきます。）</p><p><strong>① Figma to Code（HTML, Tailwind, Flutter, SwiftUI）</strong></p><img src="/images/20211021a/Figma_to_Code.png" alt="Figmaからコード生成イメージ" width="1200" height="600" loading="lazy"><p>インストール数：28.5k<br>最終更新日：2021年3月9日</p><p><a href="https://www.figma.com/community/plugin/842128343887142055/Figma-to-Code-(HTML%2C-Tailwind%2C-Flutter%2C-SwiftUI)">Figma to Code (HTML, Tailwind, Flutter, SwiftUI</a>は、Bernardo Ferrariという人が主に開発をしているプラグインで、ソースが<a href="https://github.com/bernaferrari/FigmaToCode">githubに公開</a>されています。Figma→Flutter以外にもSwiftUI、tailwindcss、HTML5にも対応しているようですが、今回はFlutterの出力のみを試してみます。</p><p><strong>② Flutter Export</strong><br><img src="/images/20211021a/thumbnail-1.png" alt="Flutter Exportアイコン" width="1200" height="600" loading="lazy"><br>インストール数：11.3k<br>最終更新日：2019年11月22日</p><p><a href="https://www.figma.com/community/plugin/778755750523021654/Flutter-Export">Flutter Export</a>は、とてもFlutterに変換できそうな名前が付いていますが、Figmaで作ったものをPNG画像で出力するだけのプラグインのようです。インストールして少し試してみましたが、上手く動かすことができませんでした。最終更新日も約2年前と古く、メンテもされていなそうなので、今回の<strong>比較対象外</strong>とします。<br>（インストール数が少し多い理由が謎です。）</p><p><strong>③ FigmaToFlutter</strong><br><img src="/images/20211021a/thumbnail-2.png" alt="thumbnail-2.png" width="1200" height="600" loading="lazy"><br>インストール数：10.8k<br>最終更新日：2021年1月2日</p><p><a href="https://www.figma.com/community/plugin/844008530039534144/FigmaToFlutter">FigmaToFlutter</a>は、1つ目のFigma to Codeと同様に個人が開発しているプラグインで、使い方も非常に似ています。今回の<strong>比較対象</strong>とします。</p><p><strong>④ Assistant by Grida</strong><br><img src="/images/20211021a/thumbnail-3.png" alt="Assistant by Gridaイメージ" width="1200" height="600" loading="lazy"><br>インストール数：4.7k<br>最終更新日：2021年8月25日</p><p><a href="https://www.figma.com/community/plugin/896445082033423994/Assistant-by-Grida">Assistant by Grida</a>は、以前はBridgedという名前だったプラグインです。</p><p>Gridaという組織が開発しているようですが、<a href="https://www.grida.co/">Gridaのページ</a>を見てもGridaがどういう組織なのか（企業なのかどうかも）分からずでした。Gridaのページにはプラグインの<a href="https://www.grida.co/docs/getting-started">ドキュメント</a>もありますが、空ページが多かったり、まだ発展途上な感が否めないですが、今回の<strong>比較対象</strong>とします。</p><h3 id="Figmaのプラグイン以外を使う方法"><a href="#Figmaのプラグイン以外を使う方法" class="headerlink" title="Figmaのプラグイン以外を使う方法"></a>Figmaのプラグイン以外を使う方法</h3><p>Figmaのプラグインを使う方法以外にも、Figmaからコードを生成する方法はあるようです。<br>以下2つを紹介します。</p><p><strong>⑤ Flutlab.io</strong><br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.29.55.png" alt="Flutlab.ioイメージ" width="1031" height="460" loading="lazy"></p><p><a href="https://flutlab.io/">FlutLab.io</a>は、Flutter用のオンラインIDE（総合開発環境）で、その中の機能としてFigma to Flutter Converterというものがあるようです。オンラインIDEは、セキュリティ等のポリシー上、実際のPJで利用できるかが不透明なため、今回は<strong>比較対象外</strong>とします。</p><p><strong>⑥ Bravo Studio</strong><br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.30.51.png" alt="Bravo Studioイメージ図" width="927" height="432" loading="lazy"></p><p><a href="https://www.bravostudio.app/">Bravo Studio</a>は、デザインツールで作成したデザインをノーコードでアプリに変換するサービスです。最終的にネイティブコードを出力できたり、APIを叩く等の機能性を持たせることができたりするようで面白そうです。<br>ただし、このツール自体の使い方のキャッチアップが割と必要そうな印象を受けた（コードを上手く出力するためにFigma側のLayerの命名を調整する必要がある等）のと、実際のPJで利用できるだけの自由度があるかが未知数だったので、今回は<strong>比較対象外</strong>とします。</p><h3 id="今回の検証対象"><a href="#今回の検証対象" class="headerlink" title="今回の検証対象"></a>今回の検証対象</h3><p>様々なFigma→Flutterの実現方法を紹介してきましたが、今回の比較対象は以下の3つのFigmaプラグインとします。</p><ul><li><a href="https://www.figma.com/community/plugin/842128343887142055/Figma-to-Code-(HTML%2C-Tailwind%2C-Flutter%2C-SwiftUI)">Figma to Code (HTML, Tailwind, Flutter, SwiftUI</a></li><li><a href="https://www.figma.com/community/plugin/844008530039534144/FigmaToFlutter">FigmaToFlutter</a></li><li><a href="https://www.figma.com/community/plugin/896445082033423994/Assistant-by-Grida">Assistant by Grida</a></li></ul><h1 id="Figma→Flutterを試して比較してみる"><a href="#Figma→Flutterを試して比較してみる" class="headerlink" title="Figma→Flutterを試して比較してみる"></a>Figma→Flutterを試して比較してみる</h1><h2 id="比較方法"><a href="#比較方法" class="headerlink" title="比較方法"></a>比較方法</h2><h3 id="比較で使うFigmaとエクスポートの粒度"><a href="#比較で使うFigmaとエクスポートの粒度" class="headerlink" title="比較で使うFigmaとエクスポートの粒度"></a>比較で使うFigmaとエクスポートの粒度</h3><p>今回は、Figma上で作った以下のログイン画面をFlutterのコードに変換できるかを試していきます。<br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.44.54.png" alt="スクリーンショット_2021-10-08_14.44.54.png" width="543" height="434" loading="lazy"><br>「<a href="https://future-architect.github.io/articles/20210915a/">Adobe XDからFlutterに変換する</a>」の記事では、一つの画面を丸ごとエクスポートするのは、AdobeとGoogleが協力して開発しているプラグインであっても中々上手くいかないことが多く、要素ごとにエクスポートをして貼り付けていくことを推奨していました。</p><p>よって、今回のFigma→Flutterの検証では様々な粒度でのエクスポートを試していきます。具体的には下記の<strong>①〜③</strong>を試していきます。下図の<strong>画面全体</strong>は、OS側で描画するホームバー等もFigma上で表現してしまっていて、それらの要素を省くと<strong>①ログインフォーム全体</strong>との差分があまり無くなるので今回の検証では省略します。<br><img src="/images/20211021a/スクリーンショット_2021-10-11_15.24.18.png" alt="スクリーンショット_2021-10-11_15.24.18.png" width="911" height="525" loading="lazy"></p><p>また<strong>①〜③</strong>のUIパーツ生成の検証に加え、画像の扱いについても比較検証を行いたいと思います。</p><h3 id="比較で使うdartコード"><a href="#比較で使うdartコード" class="headerlink" title="比較で使うdartコード"></a>比較で使うdartコード</h3><p>Android Studioで新規のFlutterプロジェクトを作り、<a href="https://flutter.dev/docs/get-started/test-drive?tab=androidstudio">生成されるデモアプリ</a>のScaffoldからheaderとbodyの中身を消した状態にして、body部分にプラグインが生成したdartコードをそのまま貼っていきます。ログインフォームが画面の中央部あたりに来るようにCenterウィジェットで囲っておきます。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: <span class="comment">//ここにコードを貼り付けていきます</span></span><br><span class="line">          ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比較結果"><a href="#比較結果" class="headerlink" title="比較結果"></a>比較結果</h2><h3 id="比較①-ログインフォーム全体の出力"><a href="#比較①-ログインフォーム全体の出力" class="headerlink" title="比較①　ログインフォーム全体の出力"></a>比較①　ログインフォーム全体の出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_13.47.58.png" alt="ログインフォーム" width="340" height="231" loading="lazy"></td><td><img src="/images/20211021a/login_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/login_figma2flutter.png" alt="figma to flutter" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/login_assistantByGrida.png" alt="assistanbe by grid結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ログインフォーム全体を出力対象として、各プラグインで出力した結果を上に示しています。<br>出力結果がプラグインによって全く異なるため、一つづつ見てきましょう。</p><p>まず、<strong>Figma to Code</strong>は、最も生成されたコードの質が高かったです。ContainerでそれぞれのUI要素の枠組みを作り、ColumnとRowで並べて、Sized Boxで要素間の隙間を作っていて、比較的可読性も高いコードになっていました。工事現場のような黄色と黒の線が出ているのは一番外側のContainerのheightが足りなく、中の要素がはみ出しているためです。これは、足りないheightの値を調整するだけで解消しました。<br>入力欄やボタンを判別することはできないようなので、生成されたコードはただの箱が並んでいるだけですが、生成結果をベースとしながら手直しをしていく前提で考えれば、割と実用的かなという印象です。</p><p>次の<strong>FigmaToFlutter</strong>は、エラーが出てしまいました。少し手直ししてエラーを解消すればいいというレベルじゃないくらいそもそものコードの中身が足りていなかったです。出力対象をもっとシンプルにして、何かが変わるかを見てみたいと思います。</p><p>最後の<strong>Assistant by Grida</strong>は、テキストしか出力されず、惜しい結果となりました。生成されたコードを見ても、テキスト以外の要素を出そうとした形跡は無かったです。こちらについても、出力対象をもっとシンプルにして、何が変わるかを見てみたいと思います。</p><h3 id="比較②-ログインボタンのみの出力"><a href="#比較②-ログインボタンのみの出力" class="headerlink" title="比較②　ログインボタンのみの出力"></a>比較②　ログインボタンのみの出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_14.00.39.png" alt="ログインボタン" width="338" height="154" loading="lazy"></td><td><img src="/images/20211021a/button_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/button_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/button_assistantByGrida.png" alt="Assistant by Grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ログインのボタン（青いボタンとログインのテキスト）を出力対象として、各プラグインで出力した結果を上に示しています。出力結果を一つづつ見てきましょう。</p><p>まず、<strong>Figma to Code</strong>は、問題ない出力結果で、1つ目の検証で起こっていた「要素のはみ出し」現象も無くなりました。</p><p>次の<strong>FigmaToFlutter</strong>は、再びエラーが出てしまいました。FigmaToFlutterが生成するコードでは、Figma to Codeと異なり、Stackウィジェットが使われています。Stackウィジェットは要素を重ねるときに使うウィジェットなので、Figma上の要素の重なり方が出力結果に何かしら影響している可能性があります。（今回のケースの出力対象は「ログイン」というテキスト部分と青い角丸の四角部分を重ねて作っています。）よって、出力対象を更にシンプルにして、要素の重なりが全く無い場合どうなるかを見てみようと思います。</p><p>最後の<strong>Assistant by Grida</strong>は、一見何も表示されていないように見えますが、白い「ログイン」という字だけ表示されていて、背景と同化してしまっています。こちらについても生成コードがStackウィジェットを使っているので、Figma上の要素の重なりが無くなると出力品質が変わってくるかもしれません。</p><h3 id="比較③-ログインボタンの箱のみの出力"><a href="#比較③-ログインボタンの箱のみの出力" class="headerlink" title="比較③　ログインボタンの箱のみの出力"></a>比較③　ログインボタンの箱のみの出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_14.05.06.png" alt="Figmaログインボックスのみ" width="338" height="73" loading="lazy"></td><td><img src="/images/20211021a/box_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/box_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/box_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>最後に、ログインのボタンの箱（青い角丸の四角）部分のみを出力対象として、各プラグインで出力した結果を上に示しています。</p><p>まず、<strong>Figma to Code</strong>は、問題ない出力結果でした。安定感があります。</p><p>次の<strong>FigmaToFlutter</strong>は、初めてエラーが出ず、出力結果としても問題ないものになりました。やはり、少しでも要素の重なりがあると上手く動いてくれない傾向があるようです。あまり実用的ではないですね。</p><p>最後の<strong>Assistant by Grida</strong>では、やっとテキスト以外の要素を出力することができましたが、角丸の表現ができておらず、サイズも正しくありません。</p><h3 id="比較④-画像の扱い"><a href="#比較④-画像の扱い" class="headerlink" title="比較④　画像の扱い"></a>比較④　画像の扱い</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/Logo.png" alt="ロゴ" width="1200" height="513" loading="lazy"></td><td><img src="/images/20211021a/png_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/png_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/png_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr><tr><td><img src="/images/20211021a/SVGロゴ.png" alt="svgロゴ" width="74" height="67" loading="lazy"></td><td><img src="/images/20211021a/svg_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/svg_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/svg_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ラスター画像、ベクター画像をそれぞれ出力対象として、各プラグインで出力した結果を上に示しています。</p><p>まず、<strong>Figma to Code</strong>は、全ての画像をFlutterLogo()に差し替えてしまいます。画像を表示させる気がそもそも無さそうですね。</p><p>次の<strong>FigmaToFlutter</strong>は、画像の扱いが最も優れていました。ラスター画像の場合はAssetImageを使って表示をするコードが生成され、ベクター画像の場合は<a href="https://pub.dev/packages/flutter_svg">flutter_svg</a>パッケージを使ったコードを生成してくれます。また、画像ファイル自体をプラグインの画面上でダウンロードもできるようになっていました。</p><p>最後の<strong>Assistant by Grida</strong>では、下記のようなImage.network()を使ったコードが生成されますが、”grida://“で始まるURLが上手く動作しません。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">&quot;grida://assets-reservation/images/13902:10114&quot;</span>,</span><br><span class="line">  width: <span class="number">315</span>,</span><br><span class="line">  height: <span class="number">134</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="比較結果まとめ"><a href="#比較結果まとめ" class="headerlink" title="比較結果まとめ"></a>比較結果まとめ</h3><p>Figma→Flutterを実現するためのプラグインの比較を行ってきました。比較結果を以下の表に示します。</p><div class="scroll"><table><thead><tr><th>#</th><th>プラグイン名</th><th>総合評価</th><th>テキスト</th><th>シェイプ</th><th>ラスター画像</th><th>ベクター画像</th><th>要素のネスト/重なり</th></tr></thead><tbody><tr><td>1</td><td>Figma to Code</td><td>◎</td><td>◎</td><td>◎</td><td>✕</td><td>✕</td><td>◎</td></tr><tr><td>2</td><td>FigmaToFlutter</td><td>△</td><td>◯</td><td>◯</td><td>◎</td><td>◎</td><td>✕</td></tr><tr><td>3</td><td>Assistant by Grida</td><td>△</td><td>◯</td><td>△</td><td>✕</td><td>✕</td><td>✕</td></tr></tbody></table></div><p>比較をした3つのプラグインをそれぞれ一言で表すと、</p><ul><li><strong>Figma to Code</strong>は「安定感がある」</li><li><strong>FigmaToFlutter</strong>は「実用的ではないが今後に期待」</li><li><strong>Assistant by Grida</strong>は「ずっと惜しい」</li></ul><p>という結果になりました。<br>実際の開発に導入するのであれば、<strong>Figma to Code</strong>以外は選択肢から外れるかな、という印象です。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>今回紹介したプラグインとサービスのまとめ。</p><div class="scroll"><table><thead><tr><th>#</th><th>名称</th><th>種別</th><th>変換結果</th><th>備考</th></tr></thead><tbody><tr><td>1</td><td>Figma to Code</td><td>プラグイン</td><td>◎</td><td>安定感が感じられる</td></tr><tr><td>2</td><td>Flutter Export</td><td>プラグイン</td><td>ー</td><td>Figmaで作ったものをPNG画像化するのみ</td></tr><tr><td>3</td><td>FigmaToFlutter</td><td>プラグイン</td><td>△</td><td>今後に期待</td></tr><tr><td>4</td><td>Assistant by Grida</td><td>プラグイン</td><td>△</td><td>ずっと惜しい</td></tr><tr><td>5</td><td>Flutlab.io</td><td>外部サービス</td><td>ー</td><td>オンライン上の変換であったためPJによっては利用できない可能性を考慮し、今回は検証をスキップ</td></tr><tr><td>6</td><td>Bravo Studio</td><td>外部サービス</td><td>ー</td><td>Figma側の命名規則があるなどお作法があり今回は検証スキップ</td></tr></tbody></table></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;フューチャーでは、FigmaやAdobe</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="技術選定" scheme="https://future-architect.github.io/tags/%E6%8A%80%E8%A1%93%E9%81%B8%E5%AE%9A/"/>
    
    <category term="Figma" scheme="https://future-architect.github.io/tags/Figma/"/>
    
    <category term="モバイルアプリ" scheme="https://future-architect.github.io/tags/%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%E3%82%A2%E3%83%97%E3%83%AA/"/>
    
    <category term="Flutter" scheme="https://future-architect.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetryとgo-chiを繋げてみる</title>
    <link href="https://future-architect.github.io/articles/20211020a/"/>
    <id>https://future-architect.github.io/articles/20211020a/</id>
    <published>2021-10-19T15:00:00.000Z</published>
    <updated>2021-10-20T01:23:53.436Z</updated>
    
    <content type="html"><![CDATA[<p>OpenTelemetryのGoのTraceがstableになり、1.0がリリースされました。最初の1.0宣言からはだいぶ時間がかかりましたが、Go/Javaなどさまざまな言語の開発が同時進行で、共通のプロトコルも決めて、なおかつさまざまな拡張のAPIを提供して、さらに<a href="https://opentelemetry.io/registry/">その拡張も現時点で300以上も提供されている</a>あたり、かなり巨大な風呂敷をどかーんと広げたような感じがします。</p><div class="scroll"><table><thead><tr><th align="center">日時</th><th align="left">できごと</th></tr></thead><tbody><tr><td align="center">2021/02/17</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-specification-v1-0-0-tracing-edition-72dd08936978">OpenTelemetryのTracingの仕様が1.0に</a></td></tr><tr><td align="center">2021/02/26</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-net-reaches-v1-0-e7c5e975fd44">.NET実装が1.0に</a></td></tr><tr><td align="center">2021/03/06</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/tag/v1.0.0">Java実装が1.0に</a></td></tr><tr><td align="center">2021/03/27</td><td align="left"><a href="https://medium.com/opentelemetry/announcing-opentelemetry-python-1-0-4e097562b8e0">Python実装が1.0に</a></td></tr><tr><td align="center">2021/09/20</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-cpp/releases/tag/v1.0.0">C++実装が1.0に</a></td></tr><tr><td align="center">2021/09/21</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-go/releases/tag/v1.0.0">Go実装が1.0に</a></td></tr><tr><td align="center">2021/09/27</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-collector-achieves-tracing-stability-milestone-80e34cadbbf5">OpenTelemetry CollectorがGA</a></td></tr><tr><td align="center">2021/10/01</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-js/releases/tag/stable%2Fv1.0.0">JavaScript実装が1.0に</a></td></tr><tr><td align="center">2021/10/01</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-ruby/releases/tag/opentelemetry-sdk%2Fv1.0.0">Ruby実装が1.0に</a></td></tr></tbody></table></div><p>PHP/Rust/Swift/Erlangあたりはコミットチャンス？</p><h1 id="2年前からアップデートされていると感じたポイント"><a href="#2年前からアップデートされていると感じたポイント" class="headerlink" title="2年前からアップデートされていると感じたポイント"></a>2年前からアップデートされていると感じたポイント</h1><p>OpenTelemtryと、その前身のOpenCensusについてはこのブログでも取り上げました。</p><ul><li><a href="/articles/20190604/">OpenCensus(OpenTelemetry)とは | フューチャー技術ブログ</a></li></ul><p>基本的な考え方は前回紹介したものと変わっていませんが、2年前からいくつか変わったかも？と思ったところをピックアップするとこんなところですかね。</p><ul><li>OpenTelemetryはOpenTelemetry専用のエージェント（ログ中継サービス）の活用も最初から視野に入っており、エージェント向けのエクスポーターも提供されている（OpenCensusにもあったがバージョンが最終版でも0.1.11で安定版ではなかった）。</li><li>stdoutロガーが一級市民扱い？</li><li>トレース、メトリックスという2種類の機能のほかに、Fluentdのようなアプリケーションのログ機能も開発中</li></ul><p>今までは、エクスポーターを明示的にアプリケーションが設定する使い方がメインでした。エージェントを使うということは、アプリケーションは最終的なログ収集基盤について知る必要がなくなり、システムを疎結合にできます。</p><p>stdoutは地味でデバッグ用途っぽさが前のOpenCensusにはありましたが、stdoutロガーはコンテナとの相性が抜群です。ログを受けとって流す先をカスタマイズできるようにするために、コンテナ内部にエージェントの接続先設定を変更するロジックを仕込む必要はありません。コンテナの外から色々できます。認証とかを気にする必要もありません。クラウドサービスだと、ログドライバーの選択だけで良くなりますね。</p><p>で、stdoutに出すとなると、トレース以外の情報とかと混ざってしまいがちなので、アプリケーションログ出力とかも一緒に出せる仕組みが整備されるといいな、というところでアプリケーションログ機能もOpenTelemetryが備えるのはうれしいですね。ただ出すだけではなくて、<a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#trace-context-fields">トレースとリンクできるようにトレースIDを持つ</a>ことが検討されてるようですね。実装は<a href="https://github.com/observIQ/stanza">Go製のFluentd的なStanza</a>をベースにするとかなんとか。</p><h1 id="OpenTelemetryは分散しない人にも注目"><a href="#OpenTelemetryは分散しない人にも注目" class="headerlink" title="OpenTelemetryは分散しない人にも注目"></a>OpenTelemetryは分散しない人にも注目</h1><p>OpenTelemtryはその名の通り「テレメトリー」のためのソフトウェア群です。テレメトリーは一般用語です。次の解説がわかりやすいです。</p><ul><li><a href="https://tenbou.nies.go.jp/science/description/detail.php?id=87">環境技術解説: テレメトリー（環境展望台)</a></li></ul><p>分散システムのすべてにsshしてログファイルをtailするとかはナンセンスですし、野生動物のトラッキング的に遠隔で情報収集する仕組みですが、そうじゃない人にも、何の情報をどう出すか、の指標にまで踏み込もうとしている点は個人的に注目ポイントです。</p><p>例えば、ウェブサービスのエンドポイントやデータベース接続でどんな情報を出すのか、といった情報がまとまっています。小規模のアプリケーションを作る人にも参考になるでしょう。</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/trace/semantic_conventions">トレースのログ出力内容</a></li></ul><p>ログのエラーレベルについても<a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#severity-fields">ガイドライン</a>が作られています。まだまだログの実装自体は行われていませんが、このあたり、言語やロギングライブラリによっても指標はバラバラでした。エラーレベル自体はそこまでブレることはないですが（CRITICALとかがあったりなかったりはあるが）、どういうキーですか？（LEVEL？SEVERITY？)とかも違っていました。そのため、ログ収集基盤を作った時に何をエラーとして通知するかは毎回手作りしていたと思いますが、指標が決まってくるとデフォルトでいい感じに動くようになってくるでしょう。ということで、各言語の次世代ロギングライブラリを作ってOSS界隈で名前を売りたい会社は今がチャンスと言えます。</p><p>以前、<a href="https://future-architect.github.io/articles/20210427b/">Future Tech Nightでローカルで動くログビューア</a>を試しに作って発表しました。これも構造化ロギングを前提としたものですが、アプリケーションログ出力が平準化されるなら、少ない設定でいい感じに動くビューアーとかも開発しやすくなりますね。</p><h1 id="OpenTelemetryの始め方"><a href="#OpenTelemetryの始め方" class="headerlink" title="OpenTelemetryの始め方"></a>OpenTelemetryの始め方</h1><p>アプリケーションに組み込む方法を紹介します。スタートするにはまずOpenTelemetryのサイトのRegisteryを見ると良さそうです。生のAPIを叩いてもいいのですが、アプリケーションの特定のミドルウェアやフレームワークとのインタフェースがinstrumentationとして提供されています。アプリケーション側のトレース情報を取り出す便利ライブラリがいくつもあります。</p><img src="/images/20211020a/スクリーンショット_2021-10-02_11.52.04.png" alt="スクリーンショット_2021-10-02_11.52.04.png" width="1200" height="725" loading="lazy"><p>ここに対応したいプラグインが登録されていれば、そのサンプルコードを参考にするのが簡単です。例えば、gorilla/muxを使っていれば、<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/github.com/gorilla/mux">gorilla/mux用のinstrumentation</a>があるので<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/example/server.go#L44">このサンプルの通り</a>にアプリケーションに組み込めばいいので簡単ですね。gorilla/muxのミドルウェアとして実装されています。初期設定はありますが、実質一行です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Use(otelmux.Middleware(<span class="string">&quot;my-server&quot;</span>))</span><br></pre></td></tr></table></figure><p>ただ、これでは１つのスパンが作られるだけなので、内部でスパンを作ったりしたい場合は<code>context.Context</code>の内部に格納された情報をもとに新しいスパンを作るAPIがあるのでそれを使います。<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/example/server.go#L71-L72">サンプルの中にもあります</a>ね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, span := tracer.Start(ctx, <span class="string">&quot;getUser&quot;</span>, oteltrace.WithAttributes(attribute.String(<span class="string">&quot;id&quot;</span>, id)))</span><br><span class="line"><span class="keyword">defer</span> span.End()</span><br></pre></td></tr></table></figure><p>このサンプルもstdoutエクスポーターがが最初から設定されているので、まずはこの状態で動かしてみて、欲しい情報が出ているか確認します。確認できたら、エクスポーター側も変更して、実際の出力先へのインタフェースを追加していきます。GCPとか、OSSのJaegerとかZipkinとかもありますし、SaaSのSplunkとかNew Relicとかありますね。</p><p>AWSはコレクター向けのものがあるので、アプリのエクスポーターとしてはコレクターを選択してコレクターの設定をするとX-Rayに出せるようです。</p><h1 id="go-chiと繋ぐ"><a href="#go-chiと繋ぐ" class="headerlink" title="go-chiと繋ぐ"></a>go-chiと繋ぐ</h1><p>で、ここを見るとお気に入りのgo-chiがありません。go-chiに繋いでみます。gorilla/muxもgo-chiも、ミドルウェアとしては言語標準的なインタフェースを共有しているため、gorilla/muxが使えないか試してみましたが、スパン名がUnknownとなってしまいます。</p><p>というのも、インタフェースは同じであっても、<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/mux.go#L120-L130">gorilla/mux</a>のエクスポーターは、contextに入っているgorilla/mux専用のデータにアクセスしてパス情報をとってきているからです。</p><p>では標準ライブラリの<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/net/http">net/http向けのエクスポータ</a>が使えるかというと、これもそのままでは使えません。net/httpのエクスポータはスパン名をミドルウェア作成時に固定値（ここでは<code>&quot;Hello&quot;</code>)で渡す必要があります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">otelHandler := otelhttp.NewHandler(http.HandlerFunc(helloHandler), <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">&quot;/hello&quot;</span>, otelHandler)</span><br></pre></td></tr></table></figure><p>エンドポイントごとに別の名前を設定したい場合は、これをベースにchiのミドルウェアを作るとしたら（net/httpのexporterラッパー)次のようにエンドポイントごとに設定が必要ですし、URLのパスとスパン名と同じような名前を二度書かないといけないのはクールじゃないですね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/httpを使うとイマイチ</span></span><br><span class="line">r := chi.NewRouter()</span><br><span class="line">r.With(otel(<span class="string">&quot;hello&quot;</span>).Get(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">r.With(otel(<span class="string">&quot;bye&quot;</span>).Get(<span class="string">&quot;/bye&quot;</span>, byeHandler)</span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>高機能なRouterと繋ぐには新しいinstrumentationを実装する必要があることがわかりました。ただ、インタフェースも含めてgorilla/muxのものがほぼ近いのでこれを改造すれば良さそうです。gorilla/muxから情報をもらってくるところを書き換えれば良さそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 変更前</span></span><br><span class="line">route := mux.CurrentRoute(r)</span><br><span class="line"><span class="keyword">if</span> route != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">spanName, err = route.GetPathTemplate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">spanName, err = route.GetPathRegexp()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">spanName = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">routeStr := spanName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 変更後</span></span><br><span class="line">c := chi.RouteContext(r.Context())</span><br><span class="line">spanName := c.RoutePattern()</span><br></pre></td></tr></table></figure><p>これで完璧じゃん、と思ったが、spanNameが空文字にしかなりません。30分ぐらい悩んだところ、ミドルウェアから次のhttp.Hanlderの処理が終わった後にしか<a href="https://github.com/go-chi/chi/issues/270">正しい情報が返ってこないというissue</a>を発見。gorilla/muxのinstrumentationのミドルウェアの実装は、スパン作成時にattributeを設定していますが、APIを見るとあとからも設定できそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本ロジックを処理</span></span><br><span class="line">tw.handler.ServeHTTP(rrw.writer, r2)</span><br><span class="line"><span class="comment">// 終わってからchiのAPIを使っていろいろ情報を収集してspanの名前とか属性を変更</span></span><br><span class="line">c := chi.RouteContext(r.Context())</span><br><span class="line">spanName := c.RoutePattern()</span><br><span class="line">span.SetName(spanName)</span><br><span class="line">span.SetAttributes(semconv.HTTPServerAttributesFromHTTPRequest(tw.service, spanName, r)...)</span><br></pre></td></tr></table></figure><p>これでchiでもOpenTelemetryと繋がりました！ gorilla/muxのと同じように、1行<code>Use</code>を書くだけで全部のロジックにトレース出力が差し込めます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1行で全エンドポイントにパスをスパン名としたトレースログ出力ができるように</span></span><br><span class="line">r.Use(otelchi.Middleware(<span class="string">&quot;hello-world&quot;</span>))</span><br></pre></td></tr></table></figure><p>動く実装は次のところに置いておきます。</p><p><a href="https://gitlab.com/osaki-lab/otelchi">https://gitlab.com/osaki-lab/otelchi</a></p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>OpenTelemetryの概要と、個人的に気になっているアップデートの方向性、実際にアプリに組み込む方法、go-chiに繋いでみる方法などを紹介しました。</p><p>OpenTelemetryは単に便利なライブラリというだけでなく新しいエコシステムを作る土台となるものです。いろいろ作りたくなりますね。</p><p>本記事を書くにあたって<a href="https://twitter.com/ymotongpoo">@ymotongpoo氏</a>と<a href="https://twitter.com/katzchang">@katzchang</a>氏にアドバイスをいただきました。ありがとうございました。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://opentelemetry.io/">OpenTelemetry公式サイト</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-specification">OpenTelemetry仕様リポジトリ</a></li><li><a href="https://github.com/open-telemetry/docs-ja">OpenTelemetryドキュメント日本語化プロジェクト</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;OpenTelemetryのGoのTraceがstableになり、1.0がリリースされました。最初の1.0宣言からはだいぶ時間がかかりましたが、Go/Javaなどさまざまな言語の開発が同時進行で、共通のプロトコルも決めて、なおかつさまざまな拡張のAPIを提供して、さらに&lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="OpenTelemetry" scheme="https://future-architect.github.io/tags/OpenTelemetry/"/>
    
    <category term="CNCF" scheme="https://future-architect.github.io/tags/CNCF/"/>
    
    <category term="go-chi" scheme="https://future-architect.github.io/tags/go-chi/"/>
    
  </entry>
  
  <entry>
    <title>Engineer Camp2021: Python の AST モジュールを使ってクラス構造を可視化する</title>
    <link href="https://future-architect.github.io/articles/20211019a/"/>
    <id>https://future-architect.github.io/articles/20211019a/</id>
    <published>2021-10-18T15:00:00.000Z</published>
    <updated>2021-10-19T02:10:02.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Future のインターン Engineer Camp に参加した空閑です。<a href="/articles/20210927b/">Python連載</a>の9本目です。</p><p>今回のインターンではソースコード静的解析システムの開発に取り組みました。そこで本記事では、開発内容の一部である、Python の AST モジュールを使ったクラス構造の可視化について紹介します。</p><p>Python の環境構築については以下を参考にしました。</p><ul><li><a href="/articles/20210611a/">サーバーアプリ開発環境(Python／FastAPI) - Future Tech Blog</a></li></ul><p>また、本記事で出てくる AST については下記を参照ください。言語やパーサは違いますが基本的な考え方は同じです。</p><ul><li><a href="/articles/20200903/">ANTLRを業務で活用した話 - Future Tech Blog</a></li></ul><h1 id="Python-の-AST-モジュール"><a href="#Python-の-AST-モジュール" class="headerlink" title="Python の AST モジュール"></a>Python の AST モジュール</h1><p>Python では AST（抽象構文木）を扱うモジュールが<a href="https://docs.python.org/ja/3/library/ast.html">標準ライブラリ</a>として提供されています。まずは試しに、適当なソースコードの AST を取得してみます。</p><figure class="highlight py"><figcaption><span>target.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushed = <span class="keyword">not</span> self.pushed</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;target.py&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    source = f.read()</span><br><span class="line">    tree = ast.parse(source=source)</span><br><span class="line">    <span class="built_in">print</span>(ast.dump(tree, indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><details>  <summary>出力結果（長いので折り畳み）</summary>  <div>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        ClassDef(</span><br><span class="line">            name=&#x27;Button&#x27;,</span><br><span class="line">            bases=[],</span><br><span class="line">            keywords=[],</span><br><span class="line">            body=[</span><br><span class="line">                FunctionDef(</span><br><span class="line">                    name=&#x27;__init__&#x27;,</span><br><span class="line">                    args=arguments(</span><br><span class="line">                        posonlyargs=[],</span><br><span class="line">                        args=[</span><br><span class="line">                            arg(arg=&#x27;self&#x27;)],</span><br><span class="line">                        kwonlyargs=[],</span><br><span class="line">                        kw_defaults=[],</span><br><span class="line">                        defaults=[]),</span><br><span class="line">                    body=[</span><br><span class="line">                        Assign(</span><br><span class="line">                            targets=[</span><br><span class="line">                                Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Store())],</span><br><span class="line">                            value=Constant(value=False))],</span><br><span class="line">                    decorator_list=[]),</span><br><span class="line">                FunctionDef(</span><br><span class="line">                    name=&#x27;push&#x27;,</span><br><span class="line">                    args=arguments(</span><br><span class="line">                        posonlyargs=[],</span><br><span class="line">                        args=[</span><br><span class="line">                            arg(arg=&#x27;self&#x27;)],</span><br><span class="line">                        kwonlyargs=[],</span><br><span class="line">                        kw_defaults=[],</span><br><span class="line">                        defaults=[]),</span><br><span class="line">                    body=[</span><br><span class="line">                        Assign(</span><br><span class="line">                            targets=[</span><br><span class="line">                                Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Store())],</span><br><span class="line">                            value=UnaryOp(</span><br><span class="line">                                op=Not(),</span><br><span class="line">                                operand=Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Load())))],</span><br><span class="line">                    decorator_list=[])],</span><br><span class="line">            decorator_list=[])],</span><br><span class="line">    type_ignores=[])</span><br></pre></td></tr></table></figure>  </div></details><p><code>ast.parse</code> にソースコードを渡すことで AST が得られます。実際には、ツリーの根を表すAST ノードを取得することになります。<code>ast.dump</code> は引数に AST ノードを取り、そのノードを根とするツリーを、フォーマットした文字列として返します。</p><p>では次に、AST をたどって特定のノードに反応するコードを書いてみます。<code>ast.NodeVisitor</code> は AST をトラバースするための基底クラスで、このクラスを継承して独自の処理を追加します。これは Visitor パターンとなっているため、クラスごとに <code>visit_&#123;class_name&#125;</code> のメソッドを用意していきます。例えば、ソースコード内で定義されている関数名を列挙するためには、関数定義を表すノード <code>ast.FunctionDef</code> に反応する <code>visit_FunctionDef</code> メソッドを作成し、その中で関数名を表す <code>ast.FunctionDef.name</code> を参照します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNodeVisitor</span>(<span class="params">ast.NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_FunctionDef</span>(<span class="params">self, node: ast.FunctionDef</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(node.name)</span><br><span class="line">        self.generic_visit(node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;target.py&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    source = f.read()</span><br><span class="line">    tree = ast.parse(source=source)</span><br><span class="line">    MyNodeVisitor().visit(tree)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__init__</span><br><span class="line">push</span><br></pre></td></tr></table></figure><p><code>visit_&#123;class_name&#125;</code> を定義することで、<code>ast.&#123;class_name&#125;</code> のノードを訪れたときのみ実行されるメソッドが作成できます。また、以下の引用のように <code>self.generic_visit()</code> を省略してしまうと、そのノードの子ノードは訪れることができないので注意してください。</p><blockquote><p>注意して欲しいのは、専用のビジター・メソッドを具えたノードの子ノードは、このビジターが generic_visit() を呼び出すかそれ自身で子ノードを訪れない限り訪れられないということです。<br><a href="https://docs.python.org/ja/3/library/ast.html#ast.NodeVisitor.generic_visit">https://docs.python.org/ja/3/library/ast.html#ast.NodeVisitor.generic_visit</a></p></blockquote><h1 id="ツール概要"><a href="#ツール概要" class="headerlink" title="ツール概要"></a>ツール概要</h1><p>今回の目標は、パッケージ・モジュール・クラスをノードとする図のようなツリーの作成です。パッケージとモジュールはディレクトリ構造にしたがってつなぎ、モジュールの下にはその中で定義されているクラスをつなぎます。作成にあたり、モジュール違いの同名クラスなどが出現することに注意します。</p><img src="/images/20211019a/graph_sample.PNG" alt="graph_sample.PNG" width="1036" height="661" loading="lazy"><p>AST はディレクトリ構造までは表現しないため、今回は以下の手順で解析を行います。</p><ol><li>Node 定義</li><li>ディレクトリ構造解析</li><li>クラス定義解析</li><li>Graphviz で可視化</li></ol><h2 id="1-Node-定義"><a href="#1-Node-定義" class="headerlink" title="1. Node 定義"></a>1. Node 定義</h2><p>解析する前に準備として <code>Node</code> クラスを定義しておきます。これを可視化するツリーのノードと一対一で対応させます。そして <code>Node</code> を継承した <code>NodePackage</code>, <code>NodeModule</code>, <code>NodeClass</code> を定義し、可視化に必要な情報を保持しておきます。今回はノードの識別に最小限必要なパスおよびクラス名を保持しました。これらはグラフのラベル等に使用します。</p><figure class="highlight py"><figcaption><span>node.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">Optional</span>[Node] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        obj_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        self.children: <span class="built_in">list</span>[Node] = []</span><br><span class="line">        self.parent: <span class="type">Optional</span>[Node] = parent</span><br><span class="line">        self.path: <span class="type">Optional</span>[<span class="built_in">str</span>] = path</span><br><span class="line">        <span class="comment"># Graphviz で可視化する際のラベル</span></span><br><span class="line">        self.obj_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = obj_name</span><br><span class="line">        <span class="comment"># obj_name をルートノードから順にドットで連結したもの</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.obj_name_full: <span class="type">Optional</span>[<span class="built_in">str</span>] = obj_name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj_name_full = (</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;parent.obj_name_full&#125;</span>.<span class="subst">&#123;obj_name&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">if</span> parent.obj_name_full <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span> obj_name</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeRoot</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodePackage</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;パッケージ情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: NodeRoot | NodePackage,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="comment"># obj_name はディレクトリ名</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(path, parent, obj_name=os.path.basename(path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeModule</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;モジュール情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path: <span class="built_in">str</span>, parent: NodePackage</span>):</span></span><br><span class="line">        <span class="comment"># obj_name はファイル名から拡張子を取り除いたもの</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            path, parent, obj_name=os.path.splitext(os.path.basename(path))[<span class="number">0</span>]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeClass</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;クラス情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent: NodeModule | NodeClass, node: ast.ClassDef</span>):</span></span><br><span class="line">        <span class="comment"># obj_name はクラス名</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(path=parent.path, parent=parent, obj_name=node.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-ディレクトリ構造解析"><a href="#2-ディレクトリ構造解析" class="headerlink" title="2. ディレクトリ構造解析"></a>2. ディレクトリ構造解析</h2><p>探索対象のパス以下を再帰的に解析し、パッケージおよびモジュールのみのツリーを作成します。この時点では図のようなツリーが構築されています。</p><img src="/images/20211019a/graph_sample_pre.PNG" alt="graph_sample_pre.PNG" width="665" height="421" loading="lazy"><figure class="highlight py"><figcaption><span>tree.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_module_tree</span>(<span class="params">search_path: <span class="built_in">str</span>, root: <span class="type">Optional</span>[NodeRoot] = <span class="literal">None</span></span>) -&gt; NodeRoot:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;パスを再帰的にたどり、パッケージ・モジュールのみのツリーを作成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        search_path (str): 対象ファイル・ディレクトリのパス</span></span><br><span class="line"><span class="string">        root (NodeRoot, optional): ツリーのルート. Defaults to None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        NodeRoot: ツリーのルート</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">search_path: <span class="built_in">str</span>, parent_node: Node</span>):</span></span><br><span class="line">        <span class="comment"># 正規表現で検索</span></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> glob.iglob(search_path):</span><br><span class="line">            <span class="comment"># 絶対パス</span></span><br><span class="line">            abspath = os.path.abspath(path)</span><br><span class="line">            <span class="comment"># パッケージ</span></span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(parent_node, NodeRoot) <span class="keyword">or</span> <span class="built_in">isinstance</span>(</span><br><span class="line">                    parent_node, NodePackage</span><br><span class="line">                )</span><br><span class="line">                node_package = NodePackage(abspath, parent_node)</span><br><span class="line">                parent_node.children.append(node_package)</span><br><span class="line">                <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">                    dfs(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;file&#125;</span>&quot;</span>, node_package)</span><br><span class="line">            <span class="comment"># モジュール</span></span><br><span class="line">            <span class="keyword">elif</span> os.path.splitext(path)[<span class="number">1</span>] == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(parent_node, NodePackage)</span><br><span class="line">                node_module = NodeModule(abspath, parent_node)</span><br><span class="line">                parent_node.children.append(node_module)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        root = NodeRoot()</span><br><span class="line">    dfs(search_path, root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="3-クラス定義解析"><a href="#3-クラス定義解析" class="headerlink" title="3. クラス定義解析"></a>3. クラス定義解析</h2><p>各モジュールについて、クラス定義を解析していきます。<code>NodeModule</code> が指定するパスを読み込み、<code>visit_ClassDef</code> を実装した <code>ClassDefNodeVisitor</code> で処理します。また、<code>ClassDefNodeVisitor</code> には親ノードへのポインタを追加の情報として持たせています。<code>generic_visit</code> の前後で親ノードを入れ替えることで、クラス内クラスなども表現することができます。</p><figure class="highlight py"><figcaption><span>tree.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_definition_tree</span>(<span class="params">root: NodeModule</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;モジュール内のクラス定義のツリーを作成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        root (NodeModule): モジュールノード</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        NodeRoot: ツリーのルート</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> root.path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;to pass type check&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(root.path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8-sig&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            source = f.read()</span><br><span class="line">            tree = ast.parse(source=source)</span><br><span class="line">            ClassDefNodeVisitor(root).visit(tree)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e, file=sys.stderr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDefNodeVisitor</span>(<span class="params">ast.NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: NodeModule | NodeClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># クラス定義ノード到達時の処理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_ClassDef</span>(<span class="params">self, node: ast.ClassDef</span>):</span></span><br><span class="line">        c_node = NodeClass(self.parent, node)</span><br><span class="line">        self.parent.children.append(c_node)</span><br><span class="line">        pre_parent = self.parent</span><br><span class="line">        self.parent = c_node</span><br><span class="line">        self.generic_visit(node)</span><br><span class="line">        self.parent = pre_parent</span><br></pre></td></tr></table></figure><h2 id="4-Graphviz-で可視化"><a href="#4-Graphviz-で可視化" class="headerlink" title="4. Graphviz で可視化"></a>4. Graphviz で可視化</h2><p>詳細な実装はここにはあげませんが、実際に作成したツリーをトラバースしながら辺を張っていきます。同じラベルのノードはひとまとめにされてしまうので、異なるノードは異なる ID を持つように注意します。今回の実装では <code>obj_name_full</code> を ID として使うことができます。また、ノードの種類ごとに色を付けるのも良いでしょう。</p><h1 id="解析結果"><a href="#解析結果" class="headerlink" title="解析結果"></a>解析結果</h1><p>標準ライブラリの可視化結果を載せます。全体を載せるには大きすぎる（PDF で約 2 MB）ため、拡大しています。青がパッケージ、オレンジがモジュール、緑がクラスに対応しています。</p><img src="/images/20211019a/graph_2.PNG" alt="graph_2.PNG" width="1200" height="187" loading="lazy"><p>図では <code>http</code> パッケージの下に、<code>server</code> モジュールがあり、その下にいくつかのクラスがあることが確認できます。実際、該当ディレクトリを見に行くと下図のようになっており、可視化できていることがわかります。<br><img src="/images/20211019a/image.png" alt="image.png" width="1200" height="643" loading="lazy"></p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>今回は AST モジュールを使ってクラス構造を可視化しました。紹介した実装は静的解析の基礎となる部分であり、機能追加によって、メソッドノードの追加や型情報、コールグラフなど、より高度な情報を可視化できます。興味を持った方はぜひ、この記事から静的解析を始めていただければと思います。</p><h1 id="インターンの感想"><a href="#インターンの感想" class="headerlink" title="インターンの感想"></a>インターンの感想</h1><p>今回のインターンでは、プロジェクトの一員として開発に取り組みました。したがって、ミーティングやドキュメントなど、普段の個人開発ではほとんど発生しない、コミュニケーションの部分が特に重要に感じました。コミュニケーションによって文脈を共有することで、後に発生する意思決定や軌道修正などがしやすくなっていた気がします。その点では、毎日のミーティングや Slack での議論など、ご協力いただいた受け入れ先のプロジェクトの方々に感謝しています。</p><p>また、今回は静的解析ツールの開発に取り組みましたが、それでも linter や formatter など既存の静的解析ツールはかなり有用でした。デバッグにはもちろん、型ヒントやフォーマットを通してツール側からも文脈の共有が行えるため、コミュニケーションと併せてその重要性を感じました。今回のインターンは約一か月でしたが、より長期間で大規模なプロジェクトであれば、静的解析ツールはもはや必須といっても過言ではないと思います。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、Future のインターン Engineer Camp に参加した空閑です。&lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="インターン" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B3/"/>
    
    <category term="Python" scheme="https://future-architect.github.io/tags/Python/"/>
    
    <category term="コアテク" scheme="https://future-architect.github.io/tags/%E3%82%B3%E3%82%A2%E3%83%86%E3%82%AF/"/>
    
    <category term="構文解析" scheme="https://future-architect.github.io/tags/%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90/"/>
    
    <category term="インターン2021" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B32021/"/>
    
    <category term="静的解析" scheme="https://future-architect.github.io/tags/%E9%9D%99%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Engineer Camp2021（スマートファクトリー）での学び</title>
    <link href="https://future-architect.github.io/articles/20211018a/"/>
    <id>https://future-architect.github.io/articles/20211018a/</id>
    <published>2021-10-17T15:00:00.000Z</published>
    <updated>2021-10-21T03:30:39.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。フューチャーの夏季インターンシップEngineer Camp 2021に参加した森下です。<br>このインターンシップを通じて得た経験や学んだことをお話ししていきます。</p><img src="/images/20211018a/5374a3ec-6860-bbad-4295-474880d81f10.png" alt="" title="illustACからカフェラテさんのイラスト" width="1200" height="900" loading="lazy"><h1 id="インターンシップの内容"><a href="#インターンシップの内容" class="headerlink" title="インターンシップの内容"></a>インターンシップの内容</h1><p>フューチャーでは毎年夏に「Engineer Camp」「Project Camp」という2つのインターンシップが開催されています。私が参加したEngineer Campでは実際のプロジェクトの中で業務に携わり、フューチャーの技術やコンサルタントのあり方を学ぶことができます。</p><p>詳しい内容は「採用イベント情報」のnoteにも掲載されてますのでご覧ください。</p><ul><li><a href="https://note.com/future_event/n/n76e7e7d4beef#vDFIY">【対象：新卒】サマーインターン＜Engineer Camp＞｜採用イベント情報 | フューチャー株式会社｜note</a></li></ul><p>今年はフルリモートでの開催となり、11人のメンバーで4週間業務を体験しました。<br>私は参加したコースは「業界最大級のスマートファクトリー機能開発」です。</p><blockquote><p>②業界最大級のスマートファクトリー機能開発<br>スマートファクトリーを推進せよ。従来のアナログ工場制御系のイメージを打ち壊し、時代を先行く工場のさらなる進化を目指す</p></blockquote><blockquote><p>＜概要＞<br>我々の暮らしを支える製造現場には未だ多く課題があり、スマートファクトリー化することで操業を助けることは重要です。今回は、実際に構築し動いている工場システムの機能拡張および横展開として、以下のいずれか、または複数にチャレンジする予定です。</p></blockquote><blockquote><p>１）Go言語でのAPI設計・開発・テスト<br>２）Terraformを用いたAWS構築・エンハンス<br>３）TypeScriptを利用したフロントエンド開発</p></blockquote><h1 id="技術経験と参加目的"><a href="#技術経験と参加目的" class="headerlink" title="技術経験と参加目的"></a>技術経験と参加目的</h1><p>私は昨年Engineer Campに参加した先輩の勧めでこのインターンシップを知りました。</p><p>フューチャーはコンサルティングからシステム開発までを一気通貫して行う珍しい業務体系をした企業ですので、IT業界を中心に就職活動をしている私にとって業務をイメージできる良い経験になると考え参加を決意しました。</p><p>参加前の技術経験は以下の通りです。</p><ul><li>言語<ul><li>C言語：高専・大学での講義や研究に使用</li><li>Python：大学の研究に使用</li><li>Go言語：インターンに向けて一通りを勉強</li></ul></li><li>GiuHub：触れたことがある程度</li><li>技術系アルバイトやインターンの経験なし</li><li>チーム開発経験なし</li><li>資格：応用情報技術者試験</li></ul><p>このインターンに参加した大きな目的は実際の業務のイメージを持つことです。</p><p>私はこれまで技術系のアルバイトやチーム開発の経験が無かったため、就職活動を進める前にGitHubを使った作業の進め方や会議を中心としたコミュニケーションの取り方など体験したいと考えました。</p><h1 id="インターンで取り組んだこと"><a href="#インターンで取り組んだこと" class="headerlink" title="インターンで取り組んだこと"></a>インターンで取り組んだこと</h1><p>私が配属されたプロジェクトではアナログ制御された工場のDXを手掛けており、私は制御系の監視およびその通知を行うバックエンド寄りのシステム開発をさせていただきました。開発に際しては以下を使用しました。</p><ul><li>Go言語</li><li>AWS<ul><li>Lambda</li><li>DynamoDB</li></ul></li><li>Docker</li><li>GitHub</li></ul><p>インターン期間の序盤は配布されたPCのセットアップやプロジェクトのキャッチアップを中心に行いました。セットアップ際のプロキシ設定では、その方法が既にフューチャーの技術ブログに記事が掲載されており、導入がスムーズに行われました。他にも開発の様々な場面で技術ブログが活用されており、技術発信に力を入れているフューチャーの社風を感じられました。</p><p>キャッチアップでは稼働中のシステムのコードをたくさん読みましたが、どれも命名規則やドキュメントなどがしっかりしており、とても読みやすかったのが印象的でした。今後チーム開発を行ううえでも整ったコードを書く力は重宝されるため、大学在学のうちから綺麗なコードが書けるよう努力したいと感じました。</p><p>その後はドキュメント処理のタスクを行い実際の作業に移りました。</p><p>作業の中ではLambdaとDynamoDBを使用しましたが、私はインターン参加前までAWSに全く触れてこなかったため、共有されたコードや記事を読み社員の方からサポートを受けながら作業を進めました。一か月のインターン生の私にも個別のAWSのアカウントを割り振ってくださり、操作を通じて理解を深めることができました。</p><h1 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h1><p>今回のEngineer Campは「技術面」「コミュニケーション面」「企業面」で学びに溢れた4週間でした。</p><h3 id="技術面"><a href="#技術面" class="headerlink" title="技術面"></a>技術面</h3><p>このインターンでは実際のプロジェクトに携わることで業務に使用される様々な技術に触れることができます。AWSのサービスは「いつか使ってみたい！」と思いつつもハードルが高く手を出せずにいましたが、インターンの中で目的をもって活用することで意欲的に取り組むことができました。AWSやDockerに関して全くの初心者だったため業務で稼働しているコードや記事などから扱い方を学ぶのは大変でしたが、フューチャーにはAWSのエキスパートがたくさんいるためSlackを通じて多くの方がサポートしてくださり理解を深めることができました。</p><p>業務の中でコードのレビューをしていただいたことが大きな学びに繋がりました。これまで研究活動の中でコードを書く際には「自分が見返したときに分かる」ような命名や関数の分け方をしており、他の人にコードを共有する際には変数や関数の意味を説明しながら共有していました。ですがチーム開発ではコードを見ただけで伝わる書き方や厳格な命名規則が求められることを教わりました。実際に稼働しているシステムを見ても明示的な関数名やテストを意識した関数粒度などがなされており、今後身に付けるべき力だと感じました。</p><h3 id="コミュニケーション面"><a href="#コミュニケーション面" class="headerlink" title="コミュニケーション面"></a>コミュニケーション面</h3><p>今回のインターンはフルリモートで開催されたためコミュニケーションの手段がSlackとビデオ通話に限られます。そのため作業の進捗や詰まっている所を自ら発信しなくては仕事をしているのかすら伝わりません。初めは何を報告すべきなのか分かりませんでしたが「Twitter感覚で呟いて」と言われ、些細なことでも小まめに状況をSlackで報告をすると、問題なく進められた部分であっても追加のアドバイスがいただけたり、いざ困ったときに素直に質問ができるようになりました。対面で作業ができないコロナ渦ならではの問題ですが、小まめな報告の必要性を学ぶきっかけになりました。</p><p>「的確に伝える力」を鍛える必要があると教わりました。リモートワークに限らず自分が「何がわからないのか」「何をしたらどうなって困っているのか」を言葉で的確に伝える能力は必要です。実際の業務を行っていると質問の体系も複雑になり、質問したい個所を絞り込めずに何度も社員の方に意図を「推測」させてしまいました。この伝える筋力を着けることも今後の課題です。</p><h3 id="企業面"><a href="#企業面" class="headerlink" title="企業面"></a>企業面</h3><p>今年のEngineer Campはリモートでの開催でしたが、日々のSlack、ミーティング、懇親会で社員の方と触れ合う中で、フューチャーのアットホームな社風を強く感じました。またSlackで質問を投げかけた際には多くの方がサポートをしてくださったり、技術ブログでの発信力も含めてフューチャーの技術を共有する意識の高さを感じました。</p><p>Engineer Campでは週に一度、様々な社員の方が講義をしてくださいます。そこでは「経営面や業界から見たフューチャー」や「Vulsの開発に至るまで」の話など就活イベントなどではなかなか聞けない話をたくさん聞くことができ、フューチャーへの企業理解を深めることができました。</p><h1 id="結び"><a href="#結び" class="headerlink" title="結び"></a>結び</h1><p>リモートでの開催でコミュニケーションの手段に限りはありましたが、インターンの中で交流会や講義などのイベントもたくさん詰め込まれており、存分にフューチャーを体感した４週間だったと思います。また同年代のメンバーと技術面での交流ができたことが刺激になりました。</p><p>この記事を見て参加を検討されている学生がいましたら是非お勧めしたいインターンシップです！</p><p>最後になりますが受け入れ担当チームの皆様をはじめ、インターン期間中にサポートいただいたフューチャー社員の皆様、ありがとうございました！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。フューチャーの夏季インターンシップEngineer Camp</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="インターン" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B3/"/>
    
    <category term="工場" scheme="https://future-architect.github.io/tags/%E5%B7%A5%E5%A0%B4/"/>
    
    <category term="インターン2021" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B32021/"/>
    
  </entry>
  
  <entry>
    <title>AWS利用料金をSlackに円グラフ付きで投稿する</title>
    <link href="https://future-architect.github.io/articles/20211015a/"/>
    <id>https://future-architect.github.io/articles/20211015a/</id>
    <published>2021-10-14T15:00:00.000Z</published>
    <updated>2021-10-14T09:19:03.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、フューチャーにアルバイトとして参加中の中山です。</p><p>今日はアルバイトで参加しているプロジェクト内でAWSの利用料金をSlackに通知する仕組みを作成したので共有したいと思います。</p><p>私が参加しているプロジェクトでは、毎月AWSにいくらかかっているのか、加えてそれぞれのサービスは全体のコストの内どのぐらいの割合を占めているのか知りたいという話があり、今回AWSから利用額を取得しSlackに通知する仕組みを作る流れとなりました。</p><p>今回の記事では、実際に採用したAPIやサービスに加え、採用を検討したが実際には利用しなかったサービスなども交え、似たような仕組みを作ってみたいと思っている方に少しでも情報提供できればと考えています。</p><p>参考：<a href="https://github.com/furiko/aws-cost-notify-to-slack">今回のソースコード</a></p><h1 id="システム概要"><a href="#システム概要" class="headerlink" title="システム概要"></a>システム概要</h1><p>それでは実際にどのような仕組みで動いているか説明します。</p><p>図のように、</p><ol><li>CloudWatchにより定時起動でLambdaを呼び出す</li><li>GetCostAndUsageAPIを用いて先月分の利用料金を取得し、<a href="https://github.com/wcharczuk/go-chart">go-chart</a>を用いて円グラフ化</li><li>SlackにWebhookとfiles.uploadを用いて通知</li></ol><p>という仕組みになっています。Cloudwatchでは毎月1日にLambdaが起動するように設定しています。所属しているプロジェクトではGo言語を採用しているため、go-chartを採用してグラフを作成しています。</p><p>Webhookは、各サービスの利用料金を箇条書きで通知するために利用しており、files.uploadは円グラフをアップロードするために利用しています。</p><img src="/images/20211015a/cost-explorer.drawio.png" alt="cost-explorer.drawio.png" width="570" height="352" loading="lazy"><h2 id="投稿例"><a href="#投稿例" class="headerlink" title="投稿例"></a>投稿例</h2><p>Slackに実際に投稿されるものは、各サービスの利用料金を箇条書きにしたものとデータを元に作成された円グラフの2点です。以下に例を示します。<br>箇条書きの方は都合上、Othersという項目を追加していますが、実際にはAPIから返ってきた値を全てそのまま載せています。</p><h3 id="AWS利用料金箇条書き"><a href="#AWS利用料金箇条書き" class="headerlink" title="AWS利用料金箇条書き"></a>AWS利用料金箇条書き</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monthly Report</span><br><span class="line">AWS Account: 111111111111</span><br><span class="line">Start: 2021-08-01, End: 2021-08-31</span><br><span class="line">Total Cost: $1000</span><br><span class="line">Amazon DynamoDB: 500.00(50)%</span><br><span class="line">AWS Lambda: 200.00(20)%</span><br><span class="line">Amazon Kinesis: 150.00(15)%</span><br><span class="line">Others: 100.00(10)%</span><br><span class="line">Tax: 50.00(5)%</span><br></pre></td></tr></table></figure><h3 id="利用料金円グラフ"><a href="#利用料金円グラフ" class="headerlink" title="利用料金円グラフ"></a>利用料金円グラフ</h3><img src="/images/20211015a/output.png" alt="output.png" width="512" height="512" loading="lazy"><h2 id="GetCostAndUsage-API"><a href="#GetCostAndUsage-API" class="headerlink" title="GetCostAndUsage API"></a>GetCostAndUsage API</h2><p><a href="https://aws.amazon.com/jp/aws-cost-management/aws-cost-explorer/">AWS Cost Explorer</a>が提供するAPIで、指定した期間のアカウントに紐づくAWSの利用料金を取得することができます。パラメータの指定方法など詳細は、<a href="https://docs.aws.amazon.com/ja_jp/aws-cost-management/latest/APIReference/API_GetCostAndUsage.html">ドキュメント</a>を参照ください。</p><p>ここでは、1ヶ月分のAWS各サービスの利用料金を取得する場合のGo言語の場合のサンプルを載せておきます。<br>注意点として、このAPIは<code>us-east-1</code>でのみ提供されるのでLambdaを<code>ap-northeast-1</code>などにデプロイしている場合でもAPIを呼び出す際には必ず<code>us-east-1</code>を指定する必要があります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">granularity := <span class="string">&quot;MONTHLY&quot;</span></span><br><span class="line">metrics := []<span class="keyword">string</span>&#123;<span class="string">&quot;BlendedCost&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">svc := costexplorer.New(session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">    Region: aws.String(<span class="string">&quot;us-east-1&quot;</span>), <span class="comment">// GetCostAndUsageAPIはus-east-1のみで提供</span></span><br><span class="line">&#125;)))</span><br><span class="line"></span><br><span class="line">result, err := svc.GetCostAndUsage(&amp;costexplorer.GetCostAndUsageInput&#123;</span><br><span class="line">    TimePeriod: &amp;costexplorer.DateInterval&#123; <span class="comment">// 取得したい期間を指定</span></span><br><span class="line">        Start: aws.String(start),</span><br><span class="line">        End:   aws.String(end),</span><br><span class="line">    &#125;,</span><br><span class="line">    Granularity: aws.String(granularity),</span><br><span class="line">    GroupBy: []*costexplorer.GroupDefinition&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Type: aws.String(<span class="string">&quot;DIMENSION&quot;</span>),</span><br><span class="line">            Key:  aws.String(<span class="string">&quot;SERVICE&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Metrics: aws.StringSlice(metrics),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>GoSDKの<a href="https://docs.aws.amazon.com/sdk-for-go/api/service/costexplorer/">ドキュメント</a>も必要な場合は参照ください。</p><h2 id="円グラフ作成"><a href="#円グラフ作成" class="headerlink" title="円グラフ作成"></a>円グラフ作成</h2><p>GetCostAndUsageAPIで取得できたAWS各サービスごとの利用料金を用いて円グラフを作成します。今回はGo言語で実装したいという条件があったので、<a href="https://github.com/wcharczuk/go-chart">go-chart</a>を用いて作成しました。基本的には<a href="https://github.com/wcharczuk/go-chart/blob/master/examples/pie_chart/main.go">サンプル</a>のコード参考にし、全体に占める割合が少ないサービスはOthersとしてまとめました。また、今回はLambda上で画像を生成し、Slackに送信している関係上、一度pngファイルに書き出すなどせず、バッファに画像データを書き込んで送信する形をとりました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values []chart.Value</span><br><span class="line">others := chart.Value&#123;</span><br><span class="line">    Label: <span class="string">&quot;Others&quot;</span>,</span><br><span class="line">    Value: <span class="number">0.0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// グラフデータの作成</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> results &#123;</span><br><span class="line">    <span class="comment">// 全体に占める割合が1.0%未満のサービスはOthersにまとめる</span></span><br><span class="line">    <span class="keyword">if</span> v.Ratio &lt; <span class="number">1.0</span> &#123;</span><br><span class="line">        others.Value += v.Cost</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    values = <span class="built_in">append</span>(values, chart.Value&#123;</span><br><span class="line">        Value: v.Cost,</span><br><span class="line">        Label: v.Name,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">values = <span class="built_in">append</span>(values, others)</span><br><span class="line"></span><br><span class="line"><span class="comment">// グラフの作成</span></span><br><span class="line">pie := chart.PieChart&#123;</span><br><span class="line">    Width:  <span class="number">512</span>,</span><br><span class="line">    Height: <span class="number">512</span>,</span><br><span class="line">    Values: values,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// バッファに画像データを書き込む</span></span><br><span class="line">buffer := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">err := pie.Render(chart.PNG, buffer)</span><br></pre></td></tr></table></figure><h3 id="GetMetricsWidgetImage-API"><a href="#GetMetricsWidgetImage-API" class="headerlink" title="GetMetricsWidgetImage API"></a>GetMetricsWidgetImage API</h3><p>はじめ、円グラフを作成しようと探していた際に<a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/APIReference/API_GetMetricWidgetImage.html">GetMetricsWidgetImage</a>というAPIを知りました。このAPIを利用して前日との利用料の差額を出している記事なども見つけましたが、このAPIは利用料金の円グラフ化はできるのですが、<strong>対象となるデータはCloudWatchで監視できるリソースのみ</strong>であり、GetCostAndUsageAPIで取得できる全てのデータを対象とすることはできなかったため採用を見送りました。</p><p>私自身、初めはグラフ作成に必要なデータを送れば円グラフを作成して返してくれるAPIだと思っていたのですが、上述の通り、Cloudwatchの監視メトリクスをグラフ化するためのAPIであり、汎用的にグラフ作成に用いるAPIではありませんでした。</p><h2 id="Slack連携"><a href="#Slack連携" class="headerlink" title="Slack連携"></a>Slack連携</h2><p>次に、上記で取得した各サービスの利用料金と円グラフをSlackに連携する方法について紹介します。<br>開発当初Webhookを用いてテキストのみをSlack連携していたところに円グラフを後から追加したため、今回のサービスではWebhookとfiles.uploadの両方を用いていますが、Bot Tokenに適切なScopeの設定をすることで自作のSlackApp1つで、テキストの投稿・円グラフのアップロードの両方を実現可能かと思います。</p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>Slackに対して通知する代表的な手段として<a href="https://slack.com/intl/ja-jp/help/articles/115005265063-Slack-%E3%81%A7%E3%81%AE-Incoming-Webhook-%E3%81%AE%E5%88%A9%E7%94%A8">Incoming Webhook</a>があります。今回のシステムではこちらを利用して、各サービスごとの使用量を箇条書きで通知しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">endpoint := SLACKENDPOINT</span><br><span class="line"></span><br><span class="line">body := <span class="keyword">struct</span> &#123;</span><br><span class="line">    Text <span class="keyword">string</span> <span class="string">`json:&quot;text&quot;`</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    Text: fmt.Sprintf(<span class="string">&quot;*Monthly Report*\n %v&quot;</span>, cost),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonString, err := json.Marshal(body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(http.MethodPost, endpoint, bytes.NewBuffer(jsonString))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">_, err = http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure><h3 id="files-upload"><a href="#files-upload" class="headerlink" title="files.upload"></a>files.upload</h3><p>Webhookではファイル自体のアップロードはできないため、files.uploadを用いてLambda内で生成した円グラフの画像をSlackにアップロードしています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api := slack.New(SLACKAPITOKEN)</span><br><span class="line"></span><br><span class="line">_, err := api.UploadFile(</span><br><span class="line">    slack.FileUploadParameters&#123;</span><br><span class="line">        Reader:   b,</span><br><span class="line">        Filename: <span class="string">&quot;output.png&quot;</span>,</span><br><span class="line">        Channels: []<span class="keyword">string</span>&#123;SLACKCHANNEL&#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>AWSのAPIを用いて月々の使用量を取得し、Slackに通知する仕組みの紹介をしてきました。</p><p>円グラフを作成して各サービスの割合を出し、各サービスのコスト比重を見返すことは今後のAWS利用の効率化などの考察の一助となると思いますので、興味がある方はぜひこの機会にSlackでAWS利用料金をチェックする仕組みを組んでみてください。</p><p>最後に今回のサービスで利用しているコードの全文を載せておきます。最後まで読んでいただきありがとうございました。</p><h2 id="コード全文"><a href="#コード全文" class="headerlink" title="コード全文"></a>コード全文</h2><p>全文：<a href="https://github.com/furiko/aws-cost-notify-to-slack">今回のソースコード</a></p><p><strong>環境変数</strong> について<br>４つ利用しています。実行前に事前に準備をお願いします。</p><ul><li>SLACK_ENDPOINT: Webhookの投稿先URLです</li><li>SLACK_API_TOKEN: files.uploadで用いるToken文字列です</li><li>SLACK_CHANNEL: Slackの投稿先チャンネルです</li><li>AWS_ACCOUNT: Slackに投稿される箇条書き文字列の冒頭にある<code>AWS Account:</code>に付与する値です</li></ul><p>Lambdaで実行する場合は各自事前にLambdaの準備とコードのデプロイをお願いします。</p><p>Lambdaではなくローカル環境で実行する場合は、main関数内の<code>lambda.Start(Handle)</code>を<code>Handle(context.Background())</code>に書き換えて実行してください。また、<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>は各自設定をお願いします。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Slack" scheme="https://future-architect.github.io/tags/Slack/"/>
    
  </entry>
  
  <entry>
    <title>トップゲート×フューチャー LT大会登壇レポート</title>
    <link href="https://future-architect.github.io/articles/20211014a/"/>
    <id>https://future-architect.github.io/articles/20211014a/</id>
    <published>2021-10-13T15:00:00.000Z</published>
    <updated>2021-10-14T04:04:45.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG所属の鈴木です。この度縁あって、2021年9月14日に株式会社トップゲート様とフューチャーで共同開催された、GCPをテーマにしたLT大会に登壇しました。</p><p>簡単にLT大会の内容や、登壇した感想をまとめてみたいと思います。</p><h1 id="今回のLT大会について"><a href="#今回のLT大会について" class="headerlink" title="今回のLT大会について"></a>今回のLT大会について</h1><p>トップゲート様が定期開催している初心者向け勉強会である、Beginner’s Labにフューチャーも参加させていただく形で今回のLT大会は開催されました。テーマはGCPということで、普段GCPを触っているなかで得た知見やTips、便利ツールや苦労話を紹介し合う会となりました。</p><p>トップゲート様とフューチャーで3名ずつ、「先鋒」「中堅」「大将」という体でキャリアの短さ順に発表するとのことで、私はフューチャーの先鋒でした。私は新人研修後インフラチームにアサインされてからGCPをずっと触り続けているのですが、クラウド未経験ということもあって日々の業務で色々とハマっており、その苦労も盛り込めたらな～という気持ちでLTに臨みました。</p><img src="/images/20211014a/image.png" alt="登壇の様子" width="1200" height="513" loading="lazy"><h1 id="LTの紹介"><a href="#LTの紹介" class="headerlink" title="LTの紹介"></a>LTの紹介</h1><h3 id="Flutter-×-ML-Kitで笑顔度の分析をしてみた"><a href="#Flutter-×-ML-Kitで笑顔度の分析をしてみた" class="headerlink" title="Flutter × ML Kitで笑顔度の分析をしてみた"></a>Flutter × ML Kitで笑顔度の分析をしてみた</h3><p>トップゲート青木様の発表です。モバイル向け機械学習SDKである<a href="https://developers.google.com/ml-kit">ML Kit</a>を用いた、<a href="https://future-architect.github.io/articles/20210510a/">Flutter</a>による顔認識・笑顔度分析アプリの実装を紹介してくれました。ML Kitではオフラインでも動作する高速 なAI推論機能を手軽に実装できます。</p><h3 id="死活監視を自前で頑張って実装した話"><a href="#死活監視を自前で頑張って実装した話" class="headerlink" title="死活監視を自前で頑張って実装した話"></a>死活監視を自前で頑張って実装した話</h3><p>当社から鈴木の発表です。このトークでは、外部IPアドレスが付与されていないGCEインスタンスを外形監視する仕組みがマネージドで見つからず、Cloud Functionを使って監視を実現したエピソードを紹介しました。監視のアラート実装はログメトリクスを使って試行錯誤したのですが、実はその間<a href="https://cloud.google.com/blog/ja/products/operations/create-logs-alerts-preview">Googleでマネージドなログアラート機能</a>が実装されていたオチで、「あの苦労は一体…」という気分もお届けしました。</p><script async class="speakerdeck-embed" data-id="98f9c63325be4014a84cfb5a1ce9e875" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h3 id="Hibernateでらくらく-Cloud-Spanner"><a href="#Hibernateでらくらく-Cloud-Spanner" class="headerlink" title="Hibernateでらくらく Cloud Spanner"></a>Hibernateでらくらく Cloud Spanner</h3><p>トップゲート田中様の発表です。HibernateはJava系言語で利用できるオープンソースのORマッパーですが、Cloud SpannerのSQL方言に即した形でSQLを生成をしてくれる<a href="https://github.com/GoogleCloudPlatform/google-cloud-spanner-hibernate">Google Cloud Spanner Dialect for Hibernate ORM</a>の紹介・デモを発表してくれました。とかく性能面が話題になるCloud Spannerですが、周辺ツールの拡充による「使いやすさ」も着実に進歩しているようです。</p><h3 id="あなたの顧客、2段階認証出来てますか？-顧客のGCP環境に2段階認証を導入した話"><a href="#あなたの顧客、2段階認証出来てますか？-顧客のGCP環境に2段階認証を導入した話" class="headerlink" title="あなたの顧客、2段階認証出来てますか？ ~ 顧客のGCP環境に2段階認証を導入した話 ~"></a>あなたの顧客、2段階認証出来てますか？ ~ 顧客のGCP環境に2段階認証を導入した話 ~</h3><p>当社から柳澤の発表です。GCP環境で2段階認証を利用する場合の解説や落とし穴など実例を交えて解説してくれました。なお、「結局最後はGoogle側で対応(マネージドサービス化)」されたというオチは私とかぶっていました。</p><script async class="speakerdeck-embed" data-id="2f5d243ff7e3474295de83fc728fc5ee" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h3 id="VPC-SCでインフラを多層的に守る"><a href="#VPC-SCでインフラを多層的に守る" class="headerlink" title="VPC SCでインフラを多層的に守る"></a>VPC SCでインフラを多層的に守る</h3><p>トップゲート山川様の発表です。本トークでは、GCPリソースの防御の考え方として、Cloud IAMやファイアウォールでアクセス管理・権限管理をすることに加え、<a href="https://cloud.google.com/vpc-service-controls">VPC Service Controls</a>を使用した機密性の確保の大切さを語っていただきました。</p><h3 id="Cloud-Spannerに抱く不安とその対処法"><a href="#Cloud-Spannerに抱く不安とその対処法" class="headerlink" title="Cloud Spannerに抱く不安とその対処法"></a>Cloud Spannerに抱く不安とその対処法</h3><p>フューチャー齋場の発表です。まさかのトップゲート田中様とCloud Spannerかぶりをしてしまったのですが、それだけCloud Spannerの「銀の弾丸」感ある性能が話題になっているということだと思います。このトークでは、Cloud Spannerを採用したアーキテクチャを顧客へ提案する際に、「本当にそんなうまくいくの？」という不安をひとつづつクリアにしていったときのノウハウを共有してくれました。</p><script async class="speakerdeck-embed" data-id="1fdc2c8b3271489695859e397fd9031a" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h1 id="登壇した感想"><a href="#登壇した感想" class="headerlink" title="登壇した感想"></a>登壇した感想</h1><p>ML KitやHibernateのようなツールを知ることができて単純に学びがあったほか、GCPを導入していく過程での「あるあるハマりポイント」だったり「あのサービスって実際どうなの？」のような皆が抱えるモヤモヤがシェアされていて、私のような若手でも共感しかない大会でした。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="LT" scheme="https://future-architect.github.io/tags/LT/"/>
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="合同勉強会" scheme="https://future-architect.github.io/tags/%E5%90%88%E5%90%8C%E5%8B%89%E5%BC%B7%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>AWS Certified Advanced Networking - Specialty合格体験記</title>
    <link href="https://future-architect.github.io/articles/20211013b/"/>
    <id>https://future-architect.github.io/articles/20211013b/</id>
    <published>2021-10-12T15:00:01.000Z</published>
    <updated>2021-10-23T06:38:37.678Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です。</p><p>来たる11月13日に<a href="https://gocon.jp/2021autumn/">Go Conference 2021 Autumn</a>に、技術ブログでもお馴染みの澁川さん、辻さんと共に登壇させていただくことになりました。</p><p>楽しい発表になるように頑張ります。</p><p>宣伝を挟みましたが、AWS Certified Advanced Networking - Specialtyに合格しましたので、今回も合格体験記を書きます。</p><h1 id="AWS-Certified-Advanced-Networking-Specialtyとは"><a href="#AWS-Certified-Advanced-Networking-Specialtyとは" class="headerlink" title="AWS Certified Advanced Networking - Specialtyとは"></a>AWS Certified Advanced Networking - Specialtyとは</h1><img src="/images/20211013b/image.png" alt="合格バッチ" width="600" height="600" loading="lazy"><p>その名の通り高度なネットワーク知識に特化した試験です。<br>オンプレミスとのハイブリッドクラウド、Direct Connect接続、複数社のVPCの合体技といった様々な前提条件ありきのセキュアな通信、ベストプラクティスの知識が求められます。</p><p>AWS Certified Security - Specialtyと比べると、他の試験では出題されない要素が多めです。<br>前提条件が複雑なため、問題の要点を読み解く難易度はいくつかSolutions Architect - Professionalに匹敵する問題があります。<br>簡単な問題もこの試験でのみ出てくるものが多く、覚えればすぐに解けるものの、見覚えが無いと手も足も出ないような問題が出題される傾向がありました。</p><h1 id="学習方法"><a href="#学習方法" class="headerlink" title="学習方法"></a>学習方法</h1><p>今回も<a href="https://aws.koiwaclub.com/">aws.koiwaclub.com</a>で合格できました。<br>あまりにも初見の情報が多く、また初見の場合一切推測できないものが多いため保険としてudemyの教材も買ってみましたが、終わってみた所感としては必要なかったかなと感じました。</p><p>下記の内容を一通り理解する必要があります。</p><h4 id="複雑なネットワーキング"><a href="#複雑なネットワーキング" class="headerlink" title="複雑なネットワーキング"></a>複雑なネットワーキング</h4><ul><li>AWS Direct Connect(様々な前提条件、観点での設問が沢山出ます)</li><li>VPN</li><li>VPCピアリング</li><li>AWS Transit Gateway</li></ul><h4 id="セキュアな通信"><a href="#セキュアな通信" class="headerlink" title="セキュアな通信"></a>セキュアな通信</h4><ul><li>AWS WAF</li><li>侵入防止システム (IPS)</li><li>DDoS 保護</li><li>VPCフローログ</li></ul><h4 id="グローバル、低遅延なネットワーキング"><a href="#グローバル、低遅延なネットワーキング" class="headerlink" title="グローバル、低遅延なネットワーキング"></a>グローバル、低遅延なネットワーキング</h4><ul><li>Amazon Route 53</li><li>Amazon CloudFront</li><li>Lambda@Edge</li></ul><h4 id="ハイパフォーマンスコンピューティング"><a href="#ハイパフォーマンスコンピューティング" class="headerlink" title="ハイパフォーマンスコンピューティング"></a>ハイパフォーマンスコンピューティング</h4><p>分散処理基板等の用途でEC2インスタンスを利用する際の下記のような前提知識が出題されます。</p><ul><li>プレイスメントグループ</li><li>拡張ネットワーキング</li><li>ジャンボフレーム</li><li>Elastic Network Interface</li><li>HVM AMI</li></ul><h4 id="その他基礎知識"><a href="#その他基礎知識" class="headerlink" title="その他基礎知識"></a>その他基礎知識</h4><ul><li>パブリックサブネット、プライベートサブネット</li><li>NACL、セキュリティグループ</li><li>インターネットゲートウェイ、NATゲートウェイ</li><li>ALB、CLB、NLBなどロードバランサーの使い分け</li><li>CIDR、サブネット、IPアドレスなどの基礎知識</li><li>Wireshark、SquidなどAWSに限らないネットワーク関連のツールの知識</li></ul><p>例えばEC2インスタンスのセキュリティグループの設定で169.254.169.254、ポート80番のアウトバウンドが塞がっているとインスタンスのメタデータにアクセスできず、IAMロールの取得に失敗する事などマニアックな問題が数多く出題されます。</p><p>参考: <a href="https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/WindowsGuide/instancedata-data-retrieval.html">https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/WindowsGuide/instancedata-data-retrieval.html</a></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>一通り頭に詰め終わってからの本番は一時間かからない程度で済みましたが、初見の段階では問題の意味を理解する事すらできず、学習の辛さはトップレベルでした。</p><p>一発で合格できて良かったです。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;来たる11月13日に&lt;a href=&quot;https://gocon.jp/2021autumn/&quot;&gt;Go Conference 2021</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Network" scheme="https://future-architect.github.io/tags/Network/"/>
    
    <category term="合格記" scheme="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>【合格記】Google Cloud Professional Data Engineer認定資格を振り返る</title>
    <link href="https://future-architect.github.io/articles/20211013a/"/>
    <id>https://future-architect.github.io/articles/20211013a/</id>
    <published>2021-10-12T15:00:00.000Z</published>
    <updated>2021-10-13T03:41:12.501Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211013a/follow-learning-path_2x.png" alt="" width="476" height="274" title="学習イメージ" loading="lazy"><p>こんにちは、TIGの玉木です。先日<a href="https://cloud.google.com/certification/data-engineer?hl=ja">Professional Data Engineer認定資格</a>を取得しました。この記事ではその振り返りをします。</p><h2 id="筆者について、受験のモチベーション"><a href="#筆者について、受験のモチベーション" class="headerlink" title="筆者について、受験のモチベーション"></a>筆者について、受験のモチベーション</h2><p>新卒から3年半ほど機械学習モデリングを行っており、ここ半年はAWSでサーバーサイドの実装を主に担当しています。業務でGCPを扱ったことはありませんが、社内で「みんなで資格とっていきましょう！」のような機運があり、以前から機械学習とも関係があるデータエンジニアリングに興味があったため、今回Professional Data Engineer認定資格を受けることにしました。</p><h2 id="出題範囲"><a href="#出題範囲" class="headerlink" title="出題範囲"></a>出題範囲</h2><p>以下公式サイトの<a href="https://cloud.google.com/certification/guides/data-engineer?hl=ja">認定試験ガイド</a>からのサマリです。</p><ol><li>データ処理システムの設計</li><li>データ処理システムの構築と運用化</li><li>機械学習モデルの運用化</li><li>ソリューションの品質保証</li></ol><p>1, 2は近い内容なのかなと思います。例えばバッチ/ストリーミング処理をする場合、どのようにデータを受け取り、どのように変換し、どのように保存するか、などが理解している必要があると思います。</p><p>3は機械学習に関する出題です。学習済みモデルとはなんだっけ？分類問題、回帰問題の違いってなんだっけ？うまく学習できていないときどうするんだっけ？のようなことが理解できている必要があると思います。自分には機械学習のバックグラウンドがあったため、機械学習の問題に関しては楽できました。</p><p>4はセキュリティやモニタリングに関する問題が出ます。自分はセキュリティ周りの問題が苦手で苦労しました。</p><h2 id="やった勉強"><a href="#やった勉強" class="headerlink" title="やった勉強"></a>やった勉強</h2><p>使用した教材は以下3つです。</p><ul><li>coursera: <a href="https://ja.coursera.org/professional-certificates/gcp-data-engineering-jp">Google Cloud 認定の準備: クラウドデータエンジニア プロフェッショナル認定証 日本版 プロフェッショナル認定</a></li><li><a href="https://gihyo.jp/book/2021/978-4-297-11948-5">Google Cloudではじめる実践データエンジニアリング入門</a></li><li><a href="https://www.shoeisha.co.jp/book/detail/9784798158839">スケーラブルデータサイエンス データエンジニアのための実践Google Cloud Platform</a></li></ul><p>最初に取り組んだのはcourseraの<a href="https://ja.coursera.org/professional-certificates/gcp-data-engineering-jp">Google Cloud 認定の準備: クラウドデータエンジニア プロフェッショナル認定証 日本版 プロフェッショナル認定</a>です。結構な量があり、終えるのに根気が要ります。また、よくスキルバッチキャンペーンといったcourseraの授業が1ヶ月ただになるキャンペーンをGoogle Cloudが行っているので、タイミングが合えばその機会に取り組むのをおすすめします。</p><p>ここで出題範囲の内容を6〜7割カバーできます。コース1から5でデータパイプラインの設計実装を学んで、コース6の最後で模擬試験を行う、といった授業になります。自分はこの模擬試験があまりできなくて結構焦った思い出があります。先述の「自分はセキュリティ周りの問題が苦手で苦労しました。」のように、自分の苦手分野がわかるので、コース6の模擬試験、もしくは<a href="https://cloud.google.com/certification/sample-questions/data-engineer?hl=ja">公式サイトの模擬試験</a>をある程度勉強した後に受けてみるのをおすすめします。</p><p>個人的にcourseraには非常にお世話になっているのですが、動画コンテンツであるため、復習がしづらく、本に比べて学習が疲れると思っています。そこでいくつか本を買いました。</p><p>次に取り組んだのは<a href="https://gihyo.jp/book/2021/978-4-297-11948-5">Google Cloudではじめる実践データエンジニアリング入門</a>という今年の2月に出た本です。試験勉強という観点では、実際の問題に近い問題をたくさん解く方が手っ取り早いかもしれませんが、業務に役立てるという観点ではこの本を一通り試したのは非常によかったです。データ基盤とは何か？GCPでデータ基盤作るにはどうすればいいか？といったことが書かれています。BigQueryの内部アーキテクチャ、クエリ最適化といった話や、権限管理の話が自分にとって特に参考になりました。好みの問題があると思うのですが、動画コンテンツが苦手な方は、最初のデータ基盤周りのインプットはこちらの方が楽かなと思います。</p><p>次に取り組んだのは<a href="https://www.shoeisha.co.jp/book/detail/9784798158839">スケーラブルデータサイエンス データエンジニアのための実践Google Cloud Platform</a>です。原著は先程紹介したcourseraのコース1の先生が書かれた本で、Google Cloudではじめる実践データエンジニアリング入門に比べてケーススタディに沿ったハンズオン部分が多めといった印象です。courseraの授業やGoogle Cloudではじめる実践データエンジニアリング入門と重複する内容もありますが、少し違ったケーススタディで再度手を動かしたい方におすすめです。</p><h2 id="受けた感想"><a href="#受けた感想" class="headerlink" title="受けた感想"></a>受けた感想</h2><p>自宅のネット環境が不安定なので、渋谷のテストセンターで試験を受けてきました。快適に受けられたので自宅のネット環境に不安がある方にはおすすめです。</p><p>テスト終了後、合格という文字が画面に出て、テストの2日後に正式にデジタル認定書のリンクが書かれたメールが届きました。</p><p>まだ業務でGCPを使ったデータ基盤構築をしてはいないのですが、実際にそのような業務にあたることがあればスムーズに入れるんじゃないかなぐらいの知識を得たかな、と思っています。自分のように機械学習のバックグラウンドがある方は、結構取り組みやすい分野だとも思います。難易度もそこまで高すぎるわけでもないので、これからデータ基盤周りのことを学びたい方には、勉強のきっかけとしておすすめの資格試験だと思います。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Professional Data Engineer認定資格を取得するにあたって取り組んだことを紹介しました。これからProfessional Data Engineer認定資格を受けてみようかなと考えている方に参考になれば幸いです。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211013a/follow-learning-path_2x.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;274&quot; title=&quot;学習イメージ&quot;</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="GCP" scheme="https://future-architect.github.io/tags/GCP/"/>
    
    <category term="合格記" scheme="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/"/>
    
    <category term="データエンジニアリング" scheme="https://future-architect.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0/"/>
    
  </entry>
  
  <entry>
    <title>S3でクロスアカウントアクセスする時に気をつけるポイント</title>
    <link href="https://future-architect.github.io/articles/20211012a/"/>
    <id>https://future-architect.github.io/articles/20211012a/</id>
    <published>2021-10-11T15:00:00.000Z</published>
    <updated>2021-10-23T06:38:39.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG/DXユニット 2020年新卒の渡辺です。</p><p>Amazon S3を利用したファイル連携を行う際、アカウント内に閉じた利用であれば特段問題ない場合でも、システム間連携となるとクロスアカウントが発生し、目的とした操作をするためには然るべき設定が必要になることがあります。</p><p>今回は、自アカウント（アカウントA）のS3バケットに対して他アカウント（アカウントB）から書き込みを行い、アカウントAから当該ファイルを参照する際に注意する設定について紹介していきます。</p><p>必要な設定は以下の2つです。</p><ul><li>バケットポリシーの設定</li><li>オブジェクト所有者の変更</li></ul><img src="/images/20211012a/image.png" alt="アカウントAのS3バケットへアカウントBからアクセスする様子" width="1200" height="431" loading="lazy"><h2 id="バケットポリシーの設定"><a href="#バケットポリシーの設定" class="headerlink" title="バケットポリシーの設定"></a>バケットポリシーの設定</h2><p>クロスアカウントアクセスを許可する設定として<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/cross-account-access-s3/">公式</a>では、それぞれバケットポリシー、ACL、AssumeRoleを用いた3つの方法が紹介されていいます。</p><p>今回はバケットポリシーを利用する方法を記載します。lambdaなどから利用する分には標準的で、多用される方法かと思います。リソースベースポリシーをサポートしていないAWSサービスを利用する際などは残りの方法を検討ください。</p><p>書き込み先であるアカウントAのS3バケットに設定するバケットポリシーの例は以下の通りです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Principal&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;AWS&quot;</span>: <span class="string">&quot;arn:aws:iam::123456789012:root&quot;</span></span><br><span class="line">           &#125;,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:PutObject&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::my-bucket/*&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;StringEquals&quot;</span>: &#123;</span><br><span class="line">                   <span class="attr">&quot;s3:x-amz-acl&quot;</span>: <span class="string">&quot;bucket-owner-full-control&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>アカウントBに対して、アカウントAのS3バケット（<code>my-bucket</code>）への<code>PutObject</code>権限を付与しています。</p><p><code>Principal</code>にはアカウントBのIDを設定してください。IAMユーザーを指定する場合は、末尾の<code>root</code>を<code>user:userName</code>の形式に変更し、ユーザ名を設定してください。</p><p>また例のように<code>Condition</code>を設定することで、オブジェクトのACLが<code>bucket-owner-full-control</code>（後述）に<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/s3-require-object-ownership/">設定されている場合のみアップロードできる</a>ようになります。<code>bucket-owner-full-control</code>が付与されていない書き込みはエラーとなるため、誤った書き込み自体を防ぐことが可能になります。</p><p>バケットポリシーの設定は以上ですが、アカウントBのユーザー権限が制限されていて、当該バケットへの<code>PutObject</code>が許可されていない場合は、ユーザーへのIAMポリシーの追加が必要になるので忘れずに設定しましょう。</p><h2 id="オブジェクト所有者の変更"><a href="#オブジェクト所有者の変更" class="headerlink" title="オブジェクト所有者の変更"></a>オブジェクト所有者の変更</h2><p>バケットポリシーの設定により、アカウントBからアカウントAのS3バケットへの書き込みは可能になりました。しかし、単純に書き込むだけでは、<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/s3-bucket-owner-access/">書き込んだファイルがアカウントAから読めない</a>という問題が発生します。</p><p>なぜなら、各オブジェクトにはそれぞれ所有者が決まっており、デフォルトでは書き出しを行なったアカウント（今回の場合はアカウントB）が所有者に設定されるためです。</p><p>現在の所有者は、オブジェクトの[プロパティ]から確認することができます。</p><img src="/images/20211012a/image_2.png" alt="マネジメントコンソールからオブジェクトの所有者を確認" width="1200" height="444" loading="lazy"><p>アカウントAからオブジェクトを見るためには、まずS3バケットの[アクセス許可]にある[オブジェクト所有者]を<code>希望するバケット所有者</code>に変更します。 この設定により、アカウントBから書き込みを行う際に、オブジェクト所有者を変更することが可能になります。</p><img src="/images/20211012a/image_3.png" alt="オブジェクトの所有者を確認" width="828" height="475" loading="lazy"><p>上記設定を行なった上で、アカウントBから書き込む際に<code>bucket-owner-full-control</code>を付与することで、所有者をアカウントAに変更することができます。CLIから付与する例は以下の通りです（プログラムから書き出す際も同様に付与する必要があります。付与する方法は各言語の<code>aws-sdk</code>リファレンスを参照ください）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws s3 cp sample.txt s3://my-bucket --acl bucket-owner-full-control</span><br></pre></td></tr></table></figure><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今回は、S3でクロスアカウントアクセスをする際に注意する設定について紹介しました。</p><p>特にオブジェクト所有者の変更（<code>bucket-owner-full-control</code>の付与）は忘れやすく、「普段プログラムから書き込んでいるが、急遽CLIから書き込んでみたらエラーになり焦る」ということが発生しないように覚えておくといいと思います。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG/DXユニット 2020年新卒の渡辺です。&lt;/p&gt;
&lt;p&gt;Amazon</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="S3" scheme="https://future-architect.github.io/tags/S3/"/>
    
    <category term="クロスアカウント" scheme="https://future-architect.github.io/tags/%E3%82%AF%E3%83%AD%E3%82%B9%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88/"/>
    
  </entry>
  
  <entry>
    <title>AWS Glueで複雑な処理を開発するときのTips</title>
    <link href="https://future-architect.github.io/articles/20211011a/"/>
    <id>https://future-architect.github.io/articles/20211011a/</id>
    <published>2021-10-10T15:00:00.000Z</published>
    <updated>2021-10-10T02:21:52.463Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211011a/glue_python_spark.png" alt="" width="790" height="260" loading="lazy"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。TIGの藤田です。</p><p><a href="/articles/20210927b/">Python連載</a> の8日目として、PySparkを使用したGlueジョブ開発のお話をします。</p><p>ETLツールとして使用されるAWS Glueですが、業務バッチで行うような複雑な処理も実行できます。また、処理はGlueジョブとして、Apache Spark分散・並列処理のジョブフローに簡単に乗せることができます！</p><p>特に複雑な処理は、やや割高な開発エンドポイントは使用せず、ローカル端末で、しっかり開発・テストを行いたいですよね。そのためのローカル開発Tipsをご紹介します。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol><li><a href="#Glue%E3%82%B8%E3%83%A7%E3%83%96%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%A8%E5%AE%9F%E8%A1%8C%E6%A6%82%E8%A6%81">Glueジョブの開発と実行概要</a></li><li><a href="#Tip1-%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89">Tip1: ローカル環境構築</a></li><li><a href="#Tip2-pyspark-sparksql%E9%96%8B%E7%99%BA">Tip2: PySpark, SparkSQL開発</a></li><li><a href="#Tip3-%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88-pytest">Tip3: 単体テスト(pytest)</a></li><li><a href="#Tip4-%E3%83%87%E3%83%BC%E3%82%BF%E3%82%AB%E3%82%BF%E3%83%AD%E3%82%B0%E3%81%A9%E3%81%86%E3%81%99%E3%82%8B%E5%95%8F%E9%A1%8C">Tip4: データカタログどうする問題</a></li></ol><h2 id="Glueジョブの開発と実行概要"><a href="#Glueジョブの開発と実行概要" class="headerlink" title="Glueジョブの開発と実行概要"></a>Glueジョブの開発と実行概要</h2><p>ローカル開発の前に、AWS Glueでのジョブ実行方法を簡単にお話します。複雑な処理をSparkジョブで実行するには、以下4ステップでOKです。</p><p>１）ジョブスクリプトを作成、S3に配置<br>２）ジョブ実行定義<br>３）「ワークフロー」によるジョブフロー定義<br>４）AWS Athenaを使った実行結果確認</p><p>３）のジョブフロー定義については、規模や構成によって他の方法を検討する余地が大きいですが、Glueの「ワークフロー」でも、以下のような機能は用意されています。</p><p>・画面GUIでのジョブフロー定義<br>・ジョブの並列実行、分岐、待合せ<br>・オンディマンド、スケジュール、EventBridgeイベントによるトリガ実行<br>・画面からの実行状態、結果、エラー確認、リトライ実行</p><p>４）について、<a href="https://docs.aws.amazon.com/ja_jp/athena/latest/ug/what-is.html">Athena</a>は、標準的なSQLを使用してS3のデータを直接分析できるサービスです。Athenaのクエリ実行には、AWS Glueデータカタログ（DatabaseやTable）の登録が必要ですが、これはAthenaのクエリエディタにDDLを実行すると簡単に行えます。（Glueのデータカタログ定義はTerraform等でも行えるので運用上は他の方法でもよいと思います。）</p><h2 id="Tip1-ローカル環境構築"><a href="#Tip1-ローカル環境構築" class="headerlink" title="Tip1: ローカル環境構築"></a>Tip1: ローカル環境構築</h2><p><a href="https://aws.amazon.com/jp/blogs/big-data/developing-aws-glue-etl-jobs-locally-using-a-container/">AWS公式にGlueコンテナが配布</a>されて、docker-composeによる環境構築が容易になりました。ローカル環境構築の詳細は、<a href="/articles/20210521a/">AWS Glueの開発環境の構築(2021)</a>を参照ください。</p><h2 id="Tip2-PySpark-SparkSQL開発"><a href="#Tip2-PySpark-SparkSQL開発" class="headerlink" title="Tip2: PySpark, SparkSQL開発"></a>Tip2: PySpark, SparkSQL開発</h2><p>Glueでは、3つのジョブタイプ、Python shell, Spark streaming, Spark script （Python, Scala）が選択できますが、今回はSpark script（PySpark, SparkSQL）を採用しました。<a href="https://spark.apache.org/docs/latest/api/python/index.html">PySpark</a>は、<a href="http://spark.apache.org/">Apache Spark</a>をPythonで呼出すライブラリです。<a href="https://spark.apache.org/sql/">SparkSQL</a>は、Apache Sparkのモジュールの1つで、SQLとDataFrameによる構造化データの処理を可能にします。</p><p>複雑な業務処理の実装にも以下のメリットがありました。</p><ul><li>構造化データ（Table）をメモリ上のDataFrameに取込み効率的に加工できる。</li><li>データカタログ（Table定義）があれば、プログラム上データ取込用のモデル定義を別につくる必要がない。</li><li>SparkSQLにより、複数ファイル（Table）の結合を含む、<a href="https://databricks.com/blog/2016/07/26/introducing-apache-spark-2-0.html">標準的なSQLによる操作が可能</a>。</li><li>SQL関数に含まれないPythonの関数やライブラリを使いたい場合にも、ユーザー定義関数 （UDF）を使えば、DataFrameの構造を維持したまま、特定のカラムに対してのみ処理を実行できる。</li></ul><p>以下、2ファイル(2 Tables)を結合してユーザー定義関数処理をするスクリプト例です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"><span class="keyword">from</span> awsglue.utils <span class="keyword">import</span> getResolvedOptions</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> DecimalType</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, ROUND_FLOOR, ROUND_HALF_UP, ROUND_CEILING</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round_fraction</span>(<span class="params">target: Decimal, meth: <span class="built_in">str</span>, pos: <span class="built_in">str</span></span>):</span></span><br><span class="line">    p = &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: <span class="string">&quot;1.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: <span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>: <span class="string">&quot;0.01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4&quot;</span>: <span class="string">&quot;0.001&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: ROUND_FLOOR,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: ROUND_HALF_UP,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>: ROUND_CEILING,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pos <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> meth == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> pos == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    <span class="keyword">return</span> target.quantize(Decimal(p[pos]), rounding=methods[meth])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">udf_round_fraction = F.udf(round_fraction, DecimalType(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_sample</span>(<span class="params">glueContext, spark, input_dir, output_dir</span>):</span></span><br><span class="line">    data = [<span class="string">&quot;calc_source&quot;</span>, <span class="string">&quot;attributes&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        p = <span class="string">f&quot;s3://<span class="subst">&#123;input_dir&#125;</span>/<span class="subst">&#123;d&#125;</span>/&quot;</span></span><br><span class="line">        <span class="comment"># Sample to convert DynamicFrame to DataFrame then create temporary view</span></span><br><span class="line">        glueContext.create_dynamic_frame.from_options(</span><br><span class="line">            connection_type=<span class="string">&quot;s3&quot;</span>,</span><br><span class="line">            connection_options=&#123;<span class="string">&quot;paths&quot;</span>: [p]&#125;,</span><br><span class="line">            <span class="built_in">format</span>=<span class="string">&quot;parquet&quot;</span>,</span><br><span class="line">        ).toDF().createOrReplaceTempView(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SQL sample to join two tables</span></span><br><span class="line">    wk_main = spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SELECT</span></span><br><span class="line"><span class="string">            src.id</span></span><br><span class="line"><span class="string">        ,src.number1</span></span><br><span class="line"><span class="string">        ,src.number2</span></span><br><span class="line"><span class="string">        ,src.position</span></span><br><span class="line"><span class="string">        ,src.method</span></span><br><span class="line"><span class="string">        ,src.group</span></span><br><span class="line"><span class="string">        ,att.attribute1</span></span><br><span class="line"><span class="string">        FROM</span></span><br><span class="line"><span class="string">            calc_sourcesrc</span></span><br><span class="line"><span class="string">        INNER JOIN</span></span><br><span class="line"><span class="string">            attributesatt</span></span><br><span class="line"><span class="string">        ON</span></span><br><span class="line"><span class="string">            src.group=att.group</span></span><br><span class="line"><span class="string">        WHERE</span></span><br><span class="line"><span class="string">            src.number1ISNOT NULL</span></span><br><span class="line"><span class="string">        ANDsrc.number2ISNOT NULL</span></span><br><span class="line"><span class="string">        ANDsrc.number2&lt;&gt;0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># UDF sample to calculate fractions</span></span><br><span class="line">    wk_main = wk_main.withColumn(</span><br><span class="line">        <span class="string">&quot;calc_result&quot;</span>,</span><br><span class="line">        udf_round_fraction(</span><br><span class="line">            F.col(<span class="string">&quot;number1&quot;</span>) / F.col(<span class="string">&quot;number2&quot;</span>),</span><br><span class="line">            F.col(<span class="string">&quot;method&quot;</span>),</span><br><span class="line">            F.col(<span class="string">&quot;position&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wk_main.write.mode(<span class="string">&quot;overwrite&quot;</span>).<span class="built_in">format</span>(<span class="string">&quot;parquet&quot;</span>).save(<span class="string">f&quot;s3://<span class="subst">&#123;output_dir&#125;</span>/sample_out/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    args = getResolvedOptions(sys.argv, [<span class="string">&quot;input_dir&quot;</span>, <span class="string">&quot;output_dir&quot;</span>])</span><br><span class="line">    glueContext = GlueContext(SparkContext.getOrCreate())</span><br><span class="line">    spark = glueContext.spark_session</span><br><span class="line">    <span class="comment"># Exec</span></span><br><span class="line">    exec_sample(glueContext, spark, args[<span class="string">&quot;input_dir&quot;</span>], args[<span class="string">&quot;output_dir&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Tip3-単体テスト-pytest"><a href="#Tip3-単体テスト-pytest" class="headerlink" title="Tip3: 単体テスト(pytest)"></a>Tip3: 単体テスト(pytest)</h2><p>ローカル環境での、PySparkスクリプトの単体テストは<a href="https://github.com/pytest-dev/pytest/">pytest</a>で可能です。方法は<a href="/articles/20191206/">AWS Glueの単体テスト環境の構築手順</a>を参照ください。実行結果のアサーションをファイル単位で行う場合は、DataFrameを比較できるツール（<a href="https://github.com/MrPowers/chispa">chispa</a>など）を利用すると便利です。</p><h2 id="Tip4-データカタログどうする問題"><a href="#Tip4-データカタログどうする問題" class="headerlink" title="Tip4: データカタログどうする問題"></a>Tip4: データカタログどうする問題</h2><p>データカタログは、データのファイルシステムをDatabaseとTableのように定義して管理する<a href="https://hive.apache.org/index.html">Hive</a>メタストア同様の機能を担っています。</p><p>データカタログは、上記Glueコンテナのディフォルト設定では呼出すことができず、CSVファイルを読込む際にデータ型定義ができない課題がありました。</p><p>CSVファイルをDataFrameに読込む際に、schema定義をかいてやることはできますが、ローカル環境でしか使わないコードを、対象データのカラムすべてに対して書くのは嬉しくありません。AWS環境のGlueデータカタログの定義と二重管理にもなります。そこで、2パタンの解決策をご紹介します。</p><ul><li>Tip4-1. AWS環境に接続してGlueデータカタログを使用する</li><li>Tip4-2. CSVではなく、Parquetファイルを使う</li></ul><h3 id="Tip4-1-AWS環境に接続してGlueデータカタログを使用する"><a href="#Tip4-1-AWS環境に接続してGlueデータカタログを使用する" class="headerlink" title="Tip4-1. AWS環境に接続してGlueデータカタログを使用する"></a>Tip4-1. AWS環境に接続してGlueデータカタログを使用する</h3><p>AWSアカウントの使える状態であれば、AWS環境のS3からGlueデータカタログを使用してファイルを読込むのが楽です。ローカル環境のGlueコンテナ内から、以下のようなコードが実行できます。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glueContext = GlueContext(SparkContext.getOrCreate())</span><br><span class="line">df = glueContext.create_dynamic_frame.from_catalog(</span><br><span class="line">    database=<span class="string">&quot;sampledb&quot;</span>,</span><br><span class="line">    table_name=<span class="string">&quot;departuredelays&quot;</span>,</span><br><span class="line">    push_down_predicate=<span class="string">&quot;(any==&#x27;sample&#x27;)&quot;</span>,</span><br><span class="line">).toDF()</span><br><span class="line"></span><br><span class="line">df.write.mode(<span class="string">&quot;overwrite&quot;</span>).<span class="built_in">format</span>(<span class="string">&quot;parquet&quot;</span>).save(</span><br><span class="line">    <span class="string">&quot;s3://bucket_name/departuredelays_out/any=sample/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>このスクリプト実行のためには、DatabaseとTable定義を予めGlueデータカタログに登録しておく必要があります。Athenaから登録するには以下のようなDDLを使用します。読込みファイルがCSVの場合です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE sampledb</span><br><span class="line">  LOCATION <span class="string">&#x27;s3://bucket_name/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> sampledb.departuredelays (</span><br><span class="line">  `<span class="type">date</span>` string,</span><br><span class="line">  `delay` <span class="type">int</span>,</span><br><span class="line">  `distance` <span class="type">int</span>,</span><br><span class="line">  `origin` string,</span><br><span class="line">  `destination` string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  `<span class="keyword">any</span>` string)</span><br><span class="line"><span class="type">ROW</span> FORMAT SERDE</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">&#x27;separatorChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;escapeChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;quoteChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;s3://bucket_name/departuredelays&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;has_encrypted_data&#x27;</span><span class="operator">=</span><span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;skip.header.line.count&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">  )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>おまけですが、出力結果をAthenaから確認するためには、出力ディレクトリのTable定義を登録します。今回出力ファイルはParquetなので、DDLは以下のようになります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> sampledb.departuredelays_out (</span><br><span class="line">  `<span class="type">date</span>` string,</span><br><span class="line">  `delay` <span class="type">int</span>,</span><br><span class="line">  `distance` <span class="type">int</span>,</span><br><span class="line">  `origin` string,</span><br><span class="line">  `destination` string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  `<span class="keyword">any</span>` string)</span><br><span class="line"><span class="type">ROW</span> FORMAT SERDE</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe&#x27;</span></span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat&#x27;</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;s3://bucket_name/departuredelays_out&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;has_encrypted_data&#x27;</span><span class="operator">=</span><span class="string">&#x27;false&#x27;</span></span><br><span class="line">  )</span><br><span class="line">;</span><br></pre></td></tr></table></figure></br></br><h3 id="Tip4-2-CSVではなく、Parquetファイルを使う"><a href="#Tip4-2-CSVではなく、Parquetファイルを使う" class="headerlink" title="Tip4-2. CSVではなく、Parquetファイルを使う"></a>Tip4-2. CSVではなく、Parquetファイルを使う</h3><p>AWS環境の使えない状態でも、ファイルをParquetフォーマットで作成できれば、型の保存された状態で読込ができます。Parquetは、CSVよりも保存性や読書き性能の面で有利です（<a href="https://databricks.com/jp/glossary/what-is-parquet">Apache Parquetについて</a>）。</p><p>Parquetファイルは直接開いて中が確認できないですが、上記のようにAthenaで確認できますし、ローカル環境でも、Jupyter Notebook上でDataFrameに読込んでschema表示・データ表示できます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>AWS Glueで複雑な処理を開発するときのTipsをご紹介しました。複雑なロジック開発とテストにAWS Glue環境を用いるのは費用面で不利なので、ぜひローカル環境を活用したいところです。特にファイルIOについては、ローカル環境とAWS環境で同じコードで処理できるようにするのがポイントだと思います。Glueジョブ開発の一助になれば幸いです。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li><a href="/articles/20211006a/">AWS Glue Data CatalogでCSVを扱う - フューチャー技術ブログ</a><ul><li>AWS環境で、Glueデータカタログを使ってCSVファイルを扱う方法が紹介されています。</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211011a/glue_python_spark.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;260&quot; loading=&quot;lazy&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot;</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Python" scheme="https://future-architect.github.io/tags/Python/"/>
    
    <category term="Glue" scheme="https://future-architect.github.io/tags/Glue/"/>
    
    <category term="Athena" scheme="https://future-architect.github.io/tags/Athena/"/>
    
    <category term="PySpark" scheme="https://future-architect.github.io/tags/PySpark/"/>
    
    <category term="SparkSQL" scheme="https://future-architect.github.io/tags/SparkSQL/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft Learnを使用したスキル向上チャレンジ</title>
    <link href="https://future-architect.github.io/articles/20211008b/"/>
    <id>https://future-architect.github.io/articles/20211008b/</id>
    <published>2021-10-07T15:00:01.000Z</published>
    <updated>2021-10-09T15:38:22.671Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの川村英之です。</p><p>みなさん、Azureの勉強をどうやっていますか？<br>本を買う、Webで情報収集、有料のセミナーなど様々な方法がありますが、<a href="https://docs.microsoft.com/ja-jp/learn/">Microsoft Learn</a>はご存じでしょうか？</p><p>私事ですが、このサイトを利用することでAzureの知識を身につけ、資格取得にもつなげることができました。</p><p>当ドキュメントはそんなMicrosoft Learn（以下MS Learn）の概要と利用方法、サイトを活用したイベント開催などをご紹介しようと思います。</p><h1 id="MS-Learnとは"><a href="#MS-Learnとは" class="headerlink" title="MS Learnとは"></a>MS Learnとは</h1><p>Microsoft LearnはMicrosoftが提供する、無料で利用できる学習用Webサイトです。ただドキュメントを参照するだけでなく、時限的なサンドボックス環境も提供され実際のAzure環境を操作しながら学ぶこともできます。元々はMicrosoftの社内用教育ドキュメントだったというもので、これを一般に公開したそうです。また、この手のサイトにある英語を機械翻訳したままの読みづらいサイトではなく、日本語ローカライズにも力が入っておりドキュメントの読みやすさも一定のレベルを誇っています。</p><p>＜MS Learnトップページ＞<br><img src="/images/20211008b/mslearn01.jpg" alt="MS Learnトップページ" width="1200" height="1205" loading="lazy"></p><p>Azure以外にもMicrosoft365、GitHUB、.Net、Office365などのMirosoft製品について学ぶこともでき、各モジュール（学習コンテンツ）を連携させたラーニングパスを使用することで、体系だった学習を行うこともできます。（例：資格取得向けのラーニングパスを使用し受験前の学習を行う）</p><p>＜ラーニングパスの例＞<br><img src="/images/20211008b/mslearn02.jpg" alt="ラーニングパスの画面" width="1200" height="1204" loading="lazy"></p><p>各モジュールを実施すると経験値がたまり、経験値が一定の数値に達するとレベルアップするというゲーム的要素もあります。こちらは後述するクラウドスキルチャレンジでも利用します。</p><h1 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h1><p>アカウントを作りMS Learnにログインしたら<a href="https://docs.microsoft.com/ja-jp/learn/browse/">ドキュメントの検索ページ</a>に行きます。そこから、学習したいコンテンツを検索し学習を行う形になります。学習したいポイントがピンポイントかつ明確な場合はモジュール単位、一つのテーマを体系だてて学びたい時はラーニングパス単位で学習を行うのが良いと思います。</p><p>＜AZ-104での検索例＞<br><img src="/images/20211008b/mslearn03.jpg" alt="AZ-104の検索結果" width="1200" height="805" loading="lazy"></p><p>演習の中でサンドボックスを使用する場合は、サンドボックスを有効化した上でAzure Portalにアクセスし仮想マシンを作成したり、学習ページからAzure CLIを実行してWebサーバを構築したりと実際のAzureを操作しながら学習を進めることができます。</p><p>＜サンドボックスを使用したドキュメント例＞<br><img src="/images/20211008b/mslearn04.jpg" alt="サンドボックスを使用したドキュメント例" width="999" height="1494" loading="lazy"></p><p>各ページのコンテンツを学習して、次ページに遷移すると経験値が加算されます。ラーニングパスを全て学習し終えるとボーナスポイントも加算されてレベルアップが早くなります。</p><h1 id="クラウドスキルチャレンジ"><a href="#クラウドスキルチャレンジ" class="headerlink" title="クラウドスキルチャレンジ"></a>クラウドスキルチャレンジ</h1><p>フューチャーでは定期的にMS Learnを利用したクラウドスキルチャレンジというイベントを開催し、イベント期間で積み上げた経験値を使って勝敗を競い合うイベントを行っています。</p><p>このイベントは申請を行えばどなたでも開催できるイベントで、会社内、会社間でもイベント開催が可能となっております。状況により一部制約はありますが、「期間中に積み上げた経験値で競う方式」、「事前に定義された特定のカリキュラムのクリア数を競う方式」の２つの方式にそれぞれ個人戦、チーム戦といったルールを組み合わせての開催が可能です。</p><p>＜クラウドスキルチャレンジ（画像のイベントは経験値＆チーム戦）＞<br><img src="/images/20211008b/mslearn06.jpg" alt="クラウドスキルチャレンジ 2021秋のトップページ" width="1200" height="1123" loading="lazy"></p><p>クラウドスキルチャレンジを開催したい、開催に興味がある方はMicrosoftの事務局（<a href="mailto:&#109;&#115;&#x6a;&#x70;&#99;&#115;&#99;&#64;&#x6d;&#105;&#99;&#x72;&#111;&#115;&#111;&#x66;&#x74;&#x2e;&#99;&#111;&#109;">&#109;&#115;&#x6a;&#x70;&#99;&#115;&#99;&#64;&#x6d;&#105;&#99;&#x72;&#111;&#115;&#111;&#x66;&#x74;&#x2e;&#99;&#111;&#109;</a>）にコンタクトをとることで、イベントについての説明を聞いたり、開催についての調整を行うことができます。</p><h1 id="終わりに"><a href="#終わりに" class="headerlink" title="終わりに"></a>終わりに</h1><p>誰でも無料で利用でき、サンドボックス環境で実際の環境を操作することもでき、経験値・レベル制によって自分の学習状況積み上げができるMS Learn。</p><p>クラウドスキルチャレンジと組み合わせることで、楽しみながら学習も行える素晴らしいサービスですので皆様も活用してはいかがでしょうか。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;TIGの川村英之です。&lt;/p&gt;
&lt;p&gt;みなさん、Azureの勉強をどうやっていますか？&lt;br&gt;本を買う、Webで情報収集、有料のセミナーなど様々な方法がありますが、&lt;a</summary>
        
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="Azure" scheme="https://future-architect.github.io/tags/Azure/"/>
    
    <category term="Microsoft" scheme="https://future-architect.github.io/tags/Microsoft/"/>
    
    <category term="MicrosoftLearn" scheme="https://future-architect.github.io/tags/MicrosoftLearn/"/>
    
    <category term="スキルアップ" scheme="https://future-architect.github.io/tags/%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97/"/>
    
    <category term="クラウドスキルチャレンジ" scheme="https://future-architect.github.io/tags/%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B9%E3%82%AD%E3%83%AB%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn 1.0 リリース！更新内容を一部紹介します。</title>
    <link href="https://future-architect.github.io/articles/20211008a/"/>
    <id>https://future-architect.github.io/articles/20211008a/</id>
    <published>2021-10-07T15:00:00.000Z</published>
    <updated>2021-10-08T01:25:51.402Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、TIG所属の玉木です。この記事は<a href="/articles/20210927b/">Python連載</a>の7本目の記事になります。</p><p>2021年9月24日にscikit-learn 1.0がリリースされました。私が大学院生のころ、scikit-learnのサンプルを動かすところから機械学習を勉強したので、ついに1.0かとなんだか感慨深い気持ちがあります(<a href="/articles/20210511a/">この記事</a>で紹介しているPython 機械学習プログラミングです)。本記事ではリリースから少し時間が経ってしまいましたが、<a href="https://scikit-learn.org/stable/auto_examples/release_highlights/plot_release_highlights_1_0_0.html">リリースハイライト</a>、<a href="https://scikit-learn.org/stable/whats_new/v1.0.html">チェンジログ</a>から、個人的に気になった以下の4つの内容を紹介しようと思います。</p><ol><li>キーワード引数の強制</li><li>pandasのデータフレームからの特徴量名のサポート</li><li>新しいplot用のクラス追加</li><li>StratifiedGroupKFoldの追加</li></ol><h2 id="1-キーワード引数の強制"><a href="#1-キーワード引数の強制" class="headerlink" title="1. キーワード引数の強制"></a>1. キーワード引数の強制</h2><p>scikit-learnの機械学習のモデルのクラス、メソッドは、多くの入力パラメータを持ちます。</p><p>以前のscikit-learnでは以下のようにクラスをインスタンスすることができました。以下<a href="https://scikit-learn.org/stable/auto_examples/release_highlights/plot_release_highlights_1_0_0.html">リリースハイライト</a>からの引用です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">est = HistGradientBoostingRegressor(<span class="string">&quot;squared_error&quot;</span>, <span class="number">0.1</span>, <span class="number">100</span>, <span class="number">31</span>, <span class="literal">None</span>,</span><br><span class="line">    <span class="number">20</span>, <span class="number">0.0</span>, <span class="number">255</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">False</span>, <span class="string">&quot;auto&quot;</span>, <span class="string">&quot;loss&quot;</span>, <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">1e-7</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>上記は極端な例ですが、この記述の仕方だと、各位置の引数がどんな意味をもつかわからず、APIドキュメントを確認する必要があります。このような位置引数を用いた初期化はTypeErrorが発生するようになります。代わりに以下のようにキーワード引数を用いて初期化します。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">est = HistGradientBoostingRegressor(</span><br><span class="line">    loss=<span class="string">&quot;squared_error&quot;</span>,</span><br><span class="line">    learning_rate=<span class="number">0.1</span>,</span><br><span class="line">    max_iter=<span class="number">100</span>,</span><br><span class="line">    max_leaf_nodes=<span class="number">31</span>,</span><br><span class="line">    max_depth=<span class="literal">None</span>,</span><br><span class="line">    min_samples_leaf=<span class="number">20</span>,</span><br><span class="line">    l2_regularization=<span class="number">0.0</span>,</span><br><span class="line">    max_bins=<span class="number">255</span>,</span><br><span class="line">    categorical_features=<span class="literal">None</span>,</span><br><span class="line">    monotonic_cst=<span class="literal">None</span>,</span><br><span class="line">    warm_start=<span class="literal">False</span>,</span><br><span class="line">    early_stopping=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    scoring=<span class="string">&quot;loss&quot;</span>,</span><br><span class="line">    validation_fraction=<span class="number">0.1</span>,</span><br><span class="line">    n_iter_no_change=<span class="number">10</span>,</span><br><span class="line">    tol=<span class="number">1e-7</span>,</span><br><span class="line">    verbose=<span class="number">0</span>,</span><br><span class="line">    random_state=<span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>位置引数を用いた初期化に比べて、キーワード引数を持ちいた初期化の方が各引数の意味がわかり、非常に読みやすいです。すべての位置引数が禁止されるわけではないのですが、ライブラリの方で可読性が良くなるように書き方を強制してくれるのは嬉しい変更です。</p><h2 id="2-pandasのデータフレームからの特徴量名のサポート"><a href="#2-pandasのデータフレームからの特徴量名のサポート" class="headerlink" title="2. pandasのデータフレームからの特徴量名のサポート"></a>2. pandasのデータフレームからの特徴量名のサポート</h2><p>scikit-learnでは機械学習のためのデータ変換、前処理の機能が多くあります。例えばscikit-learnのpreprocessモジュールのOneHotEncoderを用いればカテゴリ変数を数値表現に変換でき、StandardScalerを用いれば、数値を標準化できます。</p><p>これまでは変換器の入力がpandasのデータフレームであっても、元の列名を保持できず、列名が欲しい場合は自分で列名を作って与える必要がありました。scikit-learn 1.0ではColumnTransformerのような変換器が列名を保持するようになり、get_feature_names_outメソッドを使うだけで簡単にデータ変換後の列名も取得できるようになりました。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder, StandardScaler</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">X = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&quot;category_name&quot;</span>: [<span class="string">&quot;Men/T-shirts&quot;</span>, <span class="string">&quot;Women/T-shirts&quot;</span>, <span class="string">&quot;Women/T-shirts&quot;</span>],</span><br><span class="line">    <span class="string">&quot;brand_name&quot;</span>: [<span class="string">&quot;Nike&quot;</span>, <span class="string">&quot;adidas&quot;</span>, <span class="string">&quot;PUMA&quot;</span>],</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Xは以下のようなデータフレームになります。</p><img src="/images/20211008a/X_origin.png" alt="Xのデータフレーム" width="591" height="262" loading="lazy"><p>ColumnTransformerを用いて、Xのカテゴリ変数に対してはone-hot encoding、量的変数に対しては標準化を行います。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preprocessor = ColumnTransformer(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;numerical&quot;</span>, StandardScaler(), [<span class="string">&quot;price&quot;</span>]),</span><br><span class="line">        (<span class="string">&quot;categorical&quot;</span>, OneHotEncoder(), [<span class="string">&quot;category_name&quot;</span>, <span class="string">&quot;brand_name&quot;</span>]),</span><br><span class="line">    ],</span><br><span class="line">    verbose_feature_names_out=<span class="literal">False</span>,</span><br><span class="line">).fit(X)</span><br><span class="line"></span><br><span class="line">preprocessor.get_feature_names_out()</span><br></pre></td></tr></table></figure><p>preprocessor.get_feature_names_out()の出力は以下のようになります。列名が保持されているだけでなく、変換後の特徴量に対しても列名がつけられていることがわかります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;category_name_Men/T-shirts&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;category_name_Women/T-shirts&#x27;</span>, <span class="string">&#x27;brand_name_Nike&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;brand_name_PUMA&#x27;</span>, <span class="string">&#x27;brand_name_adidas&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>今回追加されたget_feature_names_out()はscikit-learnでデータ変換を行い、pandasのデータフレームに再度変換したい場合などに便利です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(preprocessor.transform(X), columns=preprocessor.get_feature_names_out())</span><br></pre></td></tr></table></figure><p>以下の画像のように変換後のデータを簡単にデータフレームに戻すことができます。<br><img src="/images/20211008a/scikit.png" alt="データフレームに戻した表現" width="1200" height="161" loading="lazy"></p><p>pandasのget_dummiesメソッドを使っても同様のone-hot encodingは可能です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(X)</span><br></pre></td></tr></table></figure><p>以下get_dummiesの出力です。<br><img src="/images/20211008a/pandas.png" alt="get_dummies出力結果の表" width="1200" height="162" loading="lazy"></p><p>ほぼ同じデータフレームが得られました。今回のように数値変換も同時にscikit-learnで行いたい場合などには、scikit-learnの変換器を通してget_feature_names_out()を使うのがいいのかなと思います。</p><h2 id="3-新しいplot用のクラス追加"><a href="#3-新しいplot用のクラス追加" class="headerlink" title="3. 新しいplot用のクラス追加"></a>3. 新しいplot用のクラス追加</h2><p>これまで混合行列やROC曲線を描画したいときは、sklearn.metricsモジュールのplot_confusion_matrixやplot_roc_curveが使えましたが、scikit-lean 1.0からは非推奨になり、1.2では削除の予定とのことです。代わりにConfusionMatrixDisplay、PrecisionRecallDisplayといったクラスが追加されました。元のplot_*関数はestimatorが引数に必要だったのですが、from_predictionsメソッドを使うことにより、ラベルと予測した値を渡せば描画ができるようになりました。</p><p>以下<a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ConfusionMatrixDisplay.html">APIドキュメント</a>からサンプルコードの引用です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> ConfusionMatrixDisplay</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">X, y = make_classification(random_state=<span class="number">0</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">clf = SVC(random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">SVC(random_state=<span class="number">0</span>)</span><br><span class="line">y_pred = clf.predict(X_test)</span><br><span class="line">ConfusionMatrixDisplay.from_predictions(y_test, y_pred)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>描画される混合行列は以下になります。<br><img src="/images/20211008a/confusion_matrix.png" alt="描画される混合行列のマトリクス図" width="306" height="266" loading="lazy"></p><h2 id="4-StratifiedGroupKFoldの追加"><a href="#4-StratifiedGroupKFoldの追加" class="headerlink" title="4. StratifiedGroupKFoldの追加"></a>4. StratifiedGroupKFoldの追加</h2><p>機械学習のモデルの評価において、交差検証における検証データの作り方は非常に重要です。例として、以下のKaggle State Farm Distracted Driver Detectionに参加したスライドが参考になります。</p><p><a href="https://speakerdeck.com/iwiwi/kaggle-state-farm-distracted-driver-detection?slide=22">https://speakerdeck.com/iwiwi/kaggle-state-farm-distracted-driver-detection?slide=22</a></p><p>このスライドでは検証データに同じドライバーのデータを使っていたために、学習データの汎化性能を正しく評価できなかった、学習データと検証データ間に同じドライバーのデータを含めないようにしたら正しく評価できるようになった、と報告しています。</p><p>このようにデータの分割の手法は重要なのですが、今回追加されたStratifiedGroupKFoldは、そのデータ分割の手法のうちの１つです。StratifiedGroupKFoldはStratifiedKFoldとGroupKFoldの２つの機能をあわせたデータの分割方法です。StratifiedKFoldは各セブセットのクラスの比率が維持されるようにデータを分割します。特にクラスの分布が均等でない場合に有効です。</p><p>GroupKFoldは、各セブセット間に同じグループが含まれないように分割します。先程の例のように、同じドライバーを含めてしまうと不当に高くモデルの性能を評価してしまう、といったことを防ぎます。この２つの特徴をどちらも同時に使いたいときがあるのですが、これまでscikit-learnにはこの機能はなく、自分で実装する必要がありました。scikit-learn 1.0からは簡単に使えるようになりました。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>本記事ではscikit-learn 1.0に追加された以下の機能を簡単に紹介しました。</p><ol><li>キーワード引数の強制</li><li>pandasのデータフレームからの特徴量名のサポート</li><li>新しいplot用のクラス追加</li><li>StratifiedGroupKFoldの追加</li></ol><p>普段scikit-learnを使っている方の参考になれば幸いです。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;こんにちは、TIG所属の玉木です。この記事は&lt;a href=&quot;/articles/20210927b/&quot;&gt;Python連載&lt;/a&gt;の7本目の記事になります。&lt;/p&gt;
&lt;p&gt;2021年9月24日にscikit-learn</summary>
        
      
    
    
    
    <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
    <category term="Python" scheme="https://future-architect.github.io/tags/Python/"/>
    
    <category term="機械学習" scheme="https://future-architect.github.io/tags/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/"/>
    
    <category term="pandas" scheme="https://future-architect.github.io/tags/pandas/"/>
    
    <category term="scikit-learn" scheme="https://future-architect.github.io/tags/scikit-learn/"/>
    
  </entry>
  
  <entry>
    <title>pandas 1.0以降での変更点を一部紹介します</title>
    <link href="https://future-architect.github.io/articles/20211007b/"/>
    <id>https://future-architect.github.io/articles/20211007b/</id>
    <published>2021-10-06T15:00:01.000Z</published>
    <updated>2021-10-07T03:54:37.436Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20211007b/1080x360.png" alt="" width="1080" height="360"><p>SAIGの小橋昌明です。業務ではずっとPythonを書いています。</p><p>今回は <a href="/articles/20210927b/">Python連載</a> の6日目です。</p><p>Pythonを使ってデータ分析をする上で無くてはならないのがpandasです。<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/index.html">リリースノート</a>を見てみると、メジャーアップデートによる1.0.0 がリリースされたのが2020年の1月で、現時点での最新は1.3.3です。</p><p>ただ、1.0以降の機能で私自身が使ってるものは何だろうかと考えてみると、<code>query</code>関数のエスケープシーケンスだけしか使っていない気がします。DataFrameから条件を指定してデータを抽出する<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html">query関数</a>は、列名に記号を含んでいたりすると上手く動かないことがありますが、v1.0以降はbacktick記号 (` ` )で囲むと動くようになりました。リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#other">こちら</a>。</p><p>しかし上記は新しい機能のごく一部にすぎません。せっかくバージョンアップされているのに、機能を使わないのはちょっともったいない……</p><p>今回、pandas 1.0以降の変更点を調べたので、2つ紹介します。</p><p>なお、1.0以降の最も大きい機能追加はpd.NAが導入されたことだと思います。が、これに関しては<a href="https://qiita.com/hkzm/items/52195729e9b00ae88789">pandas 1.2.0+ での pd.NA の特徴</a>という記事に非常に詳しく書かれているので、本記事では述べません。</p><h2 id="重複したラベルを許容しないオプション指定-v1-2～"><a href="#重複したラベルを許容しないオプション指定-v1-2～" class="headerlink" title="重複したラベルを許容しないオプション指定(v1.2～)"></a>重複したラベルを許容しないオプション指定(v1.2～)</h2><p>※試験的な機能（Experimental Feature）</p><p>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.2.0.html#optionally-disallow-duplicate-labels">こちら</a>、User Guide内の説明は<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/duplicates.html#disallowing-duplicate-labels">こちら</a>です。<br>このセクションのサンプルコードは全て、執筆時点の最新であるpandas 1.3.3を用いています。</p><p>pandasのindexやcolumnには重複したラベルを付けることができます。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>v1.2以降では、<code>set_flags</code>関数を用いて、ラベル重複を許容しないようにすることができます。重複していた場合は<code>DuplicateLabelError</code>というエラーが上がります。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]).set_flags(allows_duplicate_labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">DuplicateLabelError: Index has duplicates.</span><br><span class="line">      positions</span><br><span class="line">label</span><br><span class="line">a        [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>ラベルに重複があるかどうかを調べるだけならば、<code>is_unique</code>関数を使えばよいです。こちらは1.0よりも前からある機能です。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]).index.is_unique</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="https://sinhrks.hatenablog.com/entry/2015/07/11/223124">ラベルが重複していると処理時間が長くなってしまう</a>ので、<code>concat</code>などでDataFrameを作った後はラベルを振り直した方が良いのでしょう。</p><p>さて、<code>allows_duplicate_labels</code> の値は操作を通じて伝播（propagate）していきます。<br>ただ試験的な機能につき、伝播しない操作も多く存在するため注意しましょう、とドキュメントには書いてあります。</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.2.0.html#optionally-disallow-duplicate-labels">リリースノート</a>にある例です。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = (</span><br><span class="line">    pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">      .set_flags(allows_duplicate_labels=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重複ラベルが発生する操作</span></span><br><span class="line">a.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">DuplicateLabelError: Index has duplicates.</span><br><span class="line">      positions</span><br><span class="line">label</span><br><span class="line">a        [<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>新しいSeriesを作る<code>reindex</code>関数の返り値にも、<code>allows_duplicate_labels=False</code>が伝播して設定されています。</p><p>では、試しに<code>merge</code>関数の例をやってみましょう。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_B&#x27;</span> : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">&#125;)</span><br><span class="line">df1 = df1.set_flags(allows_duplicate_labels=<span class="literal">False</span>) <span class="comment"># set_flags()関数は新たなDataFrameを返すので、再度代入する必要がある</span></span><br><span class="line">df1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_B</span><br><span class="line"><span class="number">0</span>   foo     <span class="number">10</span></span><br><span class="line"><span class="number">1</span>   bar     <span class="number">20</span></span><br><span class="line"><span class="number">2</span>   baz     <span class="number">30</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_C&#x27;</span> : [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">&#125;, index=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br><span class="line">df2</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_C</span><br><span class="line"><span class="number">1</span>   foo    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>   foo    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>   bar    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>col_Aを基準に<code>merge</code>すると、結果のDataFrameのindexは新たに0から振り直されるので、重複は発生しません。したがって、indexを基準に<code>merge</code>します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1.merge(df2, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A_x  col_B col_A_y  col_C</span><br><span class="line"><span class="number">1</span>     bar     <span class="number">20</span>     foo    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>     bar     <span class="number">20</span>     foo    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>     baz     <span class="number">30</span>     bar    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>エラーが発生せずに、重複ラベルを含むDataFrameが作れてしまいました。<code>allows_duplicate_labels</code>の値を確認します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp = df1.merge(df2, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">temp.flags.allows_duplicate_labels</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>どうやら、<code>merge</code>をすると<code>allows_duplicate_labels</code>の値は伝播されないようです。まだ挙動には注意が必要そうですね。</p><h2 id="存在しないラベルに対する-locの挙動（v1-0～、v1-1～）"><a href="#存在しないラベルに対する-locの挙動（v1-0～、v1-1～）" class="headerlink" title="存在しないラベルに対する.locの挙動（v1.0～、v1.1～）"></a>存在しないラベルに対する.locの挙動（v1.0～、v1.1～）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_B&#x27;</span> : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">    <span class="string">&#x27;col_C&#x27;</span> : [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">&#125;)</span><br><span class="line">df1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_B  col_C</span><br><span class="line"><span class="number">0</span>   foo     <span class="number">10</span>    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>   bar     <span class="number">20</span>    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>   baz     <span class="number">30</span>    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>ここで、<code>.loc</code>関数で複数の行を指定し、その中に存在しない行名が入っている場合の挙動を示します。<br>まずはpandas 1.0.0より前の挙動から。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 0.25.3</span></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">FutureWarning:</span><br><span class="line">Passing <span class="built_in">list</span>-likes to .loc <span class="keyword">or</span> [] <span class="keyword">with</span> <span class="built_in">any</span> missing label will <span class="keyword">raise</span></span><br><span class="line">KeyError <span class="keyword">in</span> the future, you can use .reindex() <span class="keyword">as</span> an alternative.</span><br><span class="line"></span><br><span class="line">    col_A  col_B  col_C</span><br><span class="line"><span class="number">1</span>     bar   <span class="number">20.0</span>    <span class="number">0.2</span></span><br><span class="line"><span class="number">999</span>   NaN    NaN    NaN</span><br></pre></td></tr></table></figure><p>将来的にはエラーになるよという旨の<code>FutureWarning</code>が出ます。また、存在しないindexの分は<code>NaN</code>が要素に入ります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 0.25.3</span></span><br><span class="line">df1.loc[:, [<span class="string">&#x27;col_A&#x27;</span>, <span class="string">&#x27;col-C&#x27;</span>]] <span class="comment"># 列名を間違えた場合</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col-C</span><br><span class="line"><span class="number">0</span>   foo    NaN</span><br><span class="line"><span class="number">1</span>   bar    NaN</span><br><span class="line"><span class="number">2</span>   baz    NaN</span><br></pre></td></tr></table></figure><p>列を指定するときにうっかり列名を間違えたりすると、全要素が<code>NaN</code>の列が新たに作られたDataFrameが返ってきます。<br>実際のデータ分析ではDataFrameを表示しないでしょうから、分析を進めるとしばらく後で思わぬエラーに遭遇して戸惑うかもしれません。</p><p>この挙動は1.0以降で変更されました。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 1.0.0</span></span><br><span class="line"></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">&#x27;Passing list-likes to .loc or [] with any missing labels is no longer supported, see https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#deprecate-loc-reindex-listlike&#x27;</span></span><br></pre></td></tr></table></figure><p>1.0以降では存在しない行名が含まれている場合、<code>KeyError</code>が上がります。<br>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#removal-of-prior-version-deprecations-changes">こちら</a>です。<br>（「列名を間違えた場合」の例でも全く同じエラーになるので、こちらは割愛します）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 1.3.3 = 最新版</span></span><br><span class="line"></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">&#x27;[999] not in index&#x27;</span></span><br></pre></td></tr></table></figure><p>さらに1.1以降では、エラーメッセージが分かりやすくなりました。どのラベルが存在しないかを表示してくれます<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。<br>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.1.0.html#keyerrors-raised-by-loc-specify-missing-labels">こちら</a>です。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>1.0.0 メジャーアップデート後のpandasの、新しい機能や変更点を紹介しました。Experimental Featureもあり、使う際には注意も必要ですが、必要に応じて活用していけると良いですね。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">調べていたら1.2.3と最新1.3.3との間でKeyErrorのメッセージが少し違っていることにも気づいたのですが、あまりにもマニアックなので脚注に書くだけに留めておきます。いつ変更されたんだろう?</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;img src=&quot;/images/20211007b/1080x360.png&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;360&quot;&gt;

&lt;p&gt;SAIGの小橋昌明です。業務ではずっとPythonを書いています。&lt;/p&gt;
&lt;p&gt;今回は &lt;a</summary>
        
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Python" scheme="https://future-architect.github.io/tags/Python/"/>
    
    <category term="pandas" scheme="https://future-architect.github.io/tags/pandas/"/>
    
  </entry>
  
</feed>
