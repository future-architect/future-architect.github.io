<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2021-06-10T03:03:58.522Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AWS APIGateway Custom Authorizer入門</title>
    <link href="https://future-architect.github.io/articles/20210610a/"/>
    <id>https://future-architect.github.io/articles/20210610a/</id>
    <published>2021-06-09T15:00:00.000Z</published>
    <updated>2021-06-10T03:03:58.522Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIG/DXユニットのLEEです。フューチャーではここ数年、主に認証認可関係の設計や開発などを担当しております。</p><p>今回は流行りの認証プロトコルであるOpenID ConnectとOAuth2.0におけるAuthorizerについて話そうと思います。</p><h1 id="Authorizerとは"><a href="#Authorizerとは" class="headerlink" title="Authorizerとは"></a>Authorizerとは</h1><p><img src="/images/20210610a/custom-auth-workflow.png" alt="&quot;カスタムオーソライザの動作フロー&quot;"></p><p><a href="https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Authorizer</a>とはAWS APIGatewayにある機能の一つで、外からAPIサーバに送られてくるリクエストを検証することにより、アクセスを制御する機能です。OAuth2.0のプロトコルにおいては、AuthorizerはJWTなどTokenを検証することで、APIサーバ、つまり <code>ResourceServer</code> を保護する役割を持っています。</p><p>OSSのAPIGatewayであるKongを触ったことがある方ならば、<a href="https://docs.konghq.com/hub/kong-inc/jwt/">JWT Plugin</a>とほぼ同じ立ち位置のものと思って構いません。</p><h1 id="なぜ使うのか"><a href="#なぜ使うのか" class="headerlink" title="なぜ使うのか"></a>なぜ使うのか</h1><p>SinglePageApplicationやモバイルアプリなど、ClientになるFront-endがサーバと分離されたシステム構成の場合、<code>Client (RelyingParty)</code> と <code>APIサーバ (ResourceServer)</code> を両方セキュアにする必要があります。</p><p><code>RelyingParty</code> の場合、KeycloakやAuth0など認証基盤が提供するライブラリや、OIDCに準拠したライブラリを使えば割と簡単にセキュアにすることが可能です。</p><p>一方、<code>ResourceServer</code> にはAuthorizerを実装する必要があります。Authorizerはサーバの内部のMiddleware層などに実装することも可能ですが、複数のAPIサーバが存在してて、一つのAPIGatewayでEndpointを集中管理する場合にAuthorizerをLambdaとして一本実装することにより、開発やデプロイなどにメリットをもたらすことができます。</p><p>この度はそのAuthorizerを実装するにあたって、いくつか考慮すべきポイントについて触れて行こうと思います。</p><h1 id="Authorizer設定"><a href="#Authorizer設定" class="headerlink" title="Authorizer設定"></a>Authorizer設定</h1><h2 id="タイプ"><a href="#タイプ" class="headerlink" title="タイプ"></a>タイプ</h2><p>今回はCognitoではなく、KeycloakやAuth0など外部の認証基盤を想定しています。<br>AuthorizerをLambda関数で実装することにより、認証認可制御をもっと自由にカスタムすることができます。</p><h2 id="Lambdaイベントペイロード"><a href="#Lambdaイベントペイロード" class="headerlink" title="Lambdaイベントペイロード"></a>Lambdaイベントペイロード</h2><p>Lambda関数の引数となるEventの入力値には2パターン存在します。</p><ul><li><strong>Tokenタイプ</strong>は簡単にTokenとmethodArnのみが取得可能で、Tokenを検証しその(JWTならば)PayloadとmethodArnのパスを対照するなどで認可を制御することが可能になります。</li><li><strong>Requestタイプ</strong>はAPIGatewayのプロキシ統合のリクエストと同じものを引数として受けられます。TokenとmethodArnはもちろん、他のHeaderやQueryString、Bodyなどすべてのリクエストの中身が取得できるため、もう少し自由な認可要件が必要なときに使うこともできます。</li></ul><h2 id="トークンの検証"><a href="#トークンの検証" class="headerlink" title="トークンの検証"></a>トークンの検証</h2><p>Tokenの中身を検証する前に正規表現により簡単にチェックすることができます。一般的にTokenとしてJWTを使う場合は<code>^Bearer [-_0-9a-zA-Z.]+$</code>のように設定します。<br>この正規表現にマッチしない場合、AuthorizerはLambdaまでリクエストを送らず401を返します。</p><h2 id="認可のキャッシュ"><a href="#認可のキャッシュ" class="headerlink" title="認可のキャッシュ"></a>認可のキャッシュ</h2><p>AuthorizerはAPIリクエストが送られるとき毎回必ずTokenを検証するので、その負荷を減らすためにキャッシングも可能です。<br>しかし、この機能には大きな問題があり、キャシングの単位がTokenそのものではなく、Tokenのソースであるヘッダー名(<code>Authorization</code>など)になっています。あるユーザが一度認可したあとならば、他のユーザがそのキャッシュを使い回すことができてしまうため、基本無効にするしかないと思います。</p><h1 id="Lambdaの実装"><a href="#Lambdaの実装" class="headerlink" title="Lambdaの実装"></a>Lambdaの実装</h1><p>Lambda実装の流れは大きく分けて</p><ol><li>まず、Tokenを検証し<strong>認証</strong>する</li><li>検証したTokenのPayloadとアクセスしようとするリソースの情報(methodArnなど)を対照し<strong>認可</strong>する</li></ol><p>の2つの段階になるかと思います。</p><h2 id="入出力"><a href="#入出力" class="headerlink" title="入出力"></a>入出力</h2><p>Goで実装する場合メインハンドラー関数は以下のような形になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(e events.APIGatewayCustomAuthorizerRequest)</span> <span class="params">(*events.APIGatewayCustomAuthorizerResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Tokenタイプイベントペイロード</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(e events.APIGatewayCustomAuthorizerRequestTypeRequest)</span> <span class="params">(*events.APIGatewayCustomAuthorizerResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Requestタイプイベントペイロード</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/aws/aws-lambda-go">aws-lambda-go</a>には、すでにCustomAuthorizerのための入出力構造体が用意されているため大変便利です。<br>出力の戻り値としてはAWS IAMのようなAWSPolicyDocumentを使い返します(詳細後述)。</p><h3 id="出力パターン"><a href="#出力パターン" class="headerlink" title="出力パターン"></a>出力パターン</h3><p>Lambda関数の出力(戻り値)により、以下のようにAPIに送られてきたリクエストを制御することができます。</p><table><thead><tr><th>出力パターン</th><th>動作</th><th>HTTP Status</th><th>Response Body</th></tr></thead><tbody><tr><td>Policy：Allow</td><td>アクセス許可</td><td>後続のAPIレスポンスによる</td><td>後続のAPIレスポンスによる</td></tr><tr><td>Policy：Deny</td><td>認可失敗</td><td>403 Forbidden</td><td><code>&#123;&quot;message&quot;: &quot;User is not authorized to access this resource with an explicit deny&quot;&#125;</code></td></tr><tr><td>Error：Unauthorized</td><td>認証失敗</td><td>401 Unauthorized</td><td><code>&#123;&quot;message&quot;: &quot;Unauthorized&quot;&#125;</code></td></tr><tr><td>その他のError</td><td>エラー</td><td>500 Internal Server Error</td><td><code>&#123;&quot;message&quot;: &quot;Internal Server Error&quot;&#125;</code></td></tr></tbody></table><p><em>特記事項として、エラーを返すにしてもエラーメッセージを<code>Unauthorized</code> (大文字<code>U</code>に注意)にすることにより401を返すことができます。</em></p><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>認可制御のために前提として、まずは認証が必要になります。一般的にはJWTを検証することになり、JWTのライブラリを使えば簡単ですが、検証のための<strong>公開鍵取得方法</strong>には2パターンがあるかと思われます。</p><h3 id="静的に公開鍵を保持する"><a href="#静的に公開鍵を保持する" class="headerlink" title="静的に公開鍵を保持する"></a>静的に公開鍵を保持する</h3><p>公開鍵をLambdaの環境変数やDynamoDB、S3などを使い静的に保持する方法です。<br>実装は簡単で構造もシンプルですが、鍵のローテションをどうするか考える必要が将来的に出てきます。</p><h3 id="公開鍵を動的に取得する"><a href="#公開鍵を動的に取得する" class="headerlink" title="公開鍵を動的に取得する"></a>公開鍵を動的に取得する</h3><p>認証基盤が公開している公開鍵エンドポイントから鍵を取得する方法です。<br>公開鍵エンドポイントは一般的に認証基盤側が<a href="https://openid-foundation-japan.github.io/rfc7517.ja.html">JSON Web Key(JWK)</a>により定義し、以下のような形で公開しています。</p><ul><li><a href="https://keycloak-documentation.openstandia.jp/master/ja_JP/securing_apps/index.html#_certificate_endpoint">Keycloak証明書エンドポイント</a></li><li><a href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets">Auth0 JSON Web Key Sets</a></li></ul><p>この方法は鍵のローテションを気にせずに済みますが、APIリクエストのたびに認証基盤への外部リクエストが発生するので、遅延・負荷を軽減するための効率的なキャッシング戦略を立てる必要があります。</p><h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><p>APIリクエストのToken検証が完了し認証ができたら、次はそのユーザーがリクエストしたエンドポイントにアクセス可能かをチェックする認可処理が必要になります。</p><p>認可、アクセスコントロールはJWTのClaimsの値に入っているユーザの属性やロールとAPIエンドポイントのパスなどを対照することにより制御することが可能です。</p><p>ロジックについては認証基盤の設定やそのシステムの固有の考え方などによりRole-BasedAccessControl、Attribute-BasedAccessControlなど、様々なやり方があります。こういったロジックは自由度の高い領域なのでここでは参考程度にKeycloakやAuth0などで想定しているアクセスコントロールについてのリンクだけを貼っておきます。</p><ul><li><a href="https://keycloak-documentation.openstandia.jp/master/ja_JP/authorization_services/">Keycloak Authorization Services Guide</a></li><li><a href="https://auth0.com/docs/authorization">Auth0 Authorization</a></li></ul><h3 id="認可の出力"><a href="#認可の出力" class="headerlink" title="認可の出力"></a>認可の出力</h3><p>認可ロジックによりユーザのアクセス可否が決まったら、Authorizerは以下のようなJSONで認可処理が完了したことをAPIGatewayに返します。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;principalId&quot;</span>: <span class="string">&quot;yyyyyyyy&quot;</span>, <span class="comment">// The principal user identification associated with the token sent by the client.</span></span><br><span class="line">  <span class="attr">&quot;policyDocument&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;Action&quot;</span>: <span class="string">&quot;execute-api:Invoke&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow|Deny&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Resource&quot;</span>: <span class="string">&quot;arn:aws:execute-api:&#123;regionId&#125;:&#123;accountId&#125;:&#123;apiId&#125;/&#123;stage&#125;/&#123;httpVerb&#125;/[&#123;resource&#125;/[&#123;child-resources&#125;]]&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;context&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;stringKey&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;numberKey&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;booleanKey&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;usageIdentifierKey&quot;</span>: <span class="string">&quot;&#123;api-key&#125;&quot;</span> <span class="comment">// Optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Policy-Document"><a href="#Policy-Document" class="headerlink" title="Policy Document"></a>Policy Document</h4><p>IAMのものと同じ形式で、アクセスを許可するか拒否するかを明示的に表現します。</p><p>AuthorizerはAPIGateway上で動くものなので<code>&quot;Action&quot;: &quot;execute-api:Invoke&quot;</code>は固定になります。<br><code>Resource</code>はLambda関数の引数で受けた<code>methodArn</code>をそのまま返すで問題ありません。</p><h4 id="Principal-ID"><a href="#Principal-ID" class="headerlink" title="Principal ID"></a>Principal ID</h4><p>APIリクエストしたユーザが誰なのかを表現します。リクエストしたユーザを一意に識別するための値であり、実際のAPIロジックを決める後続のLambda関数などに渡すことができ、ユーザによるレスポンスの出し分けなどを可能にします。</p><p>一般的にはJWTの<a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2"><code>sub</code> (Subject) Claim</a>をそのまま使うことになります。</p><h4 id="Authorizer-Context"><a href="#Authorizer-Context" class="headerlink" title="Authorizer Context"></a>Authorizer Context</h4><p>Principal IDと同じように後続のLambda関数などに渡すことができる任意の値です(Principal IDもContextの一部)。APIのレスポンスを出し分けするために必要な任意の情報をKey-Value形式でセットすることが可能です。一見Mapオブジェクトにも見えますが、ValueとしてはNumber・String・BooleanのみでObjectやArrayなどの入れ子構造は使えません。</p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>Authorizerの実装、最初はわからないことだらけで難しく感じるかもしれませんが、単機能の関数であるため、一度実装してしまったらテンプレートのように様々なAPIに使い回すことも可能かと思います。</p><p>以下は自分が実装の際に一番参考になったサンプルコードのリンクを置いて締めたいと思います。</p><ul><li><a href="https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints">Amazon API Gateway - Custom Authorizer Blueprints for AWS Lambda</a></li><li><a href="https://github.com/aws/aws-lambda-go/blob/master/events/README_ApiGatewayCustomAuthorizer.md">AWS Lambda for Go - Authorizer Sample Function</a></li><li><a href="https://auth0.com/docs/quickstart/backend/golang/01-authorization">Auth0 Backend/API Go: Authorization</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。TIG/DXユニットのLEEです。フューチャーではここ数年、主に認証認可関係の設計や開発などを担当しております。&lt;/p&gt;
&lt;p&gt;今回は流行りの認証プロトコルであるOpenID ConnectとOAuth2.0におけるAuthorizerについて話そうと思います。</summary>
      
    
    
    
    <category term="認証認可" scheme="https://future-architect.github.io/categories/%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>Vuls開発中に出会ったGORMあれこれ</title>
    <link href="https://future-architect.github.io/articles/20210609a/"/>
    <id>https://future-architect.github.io/articles/20210609a/</id>
    <published>2021-06-08T15:00:00.000Z</published>
    <updated>2021-06-09T03:29:47.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vuls開発中に出会ったGORMあれこれ"><a href="#Vuls開発中に出会ったGORMあれこれ" class="headerlink" title="Vuls開発中に出会ったGORMあれこれ"></a>Vuls開発中に出会ったGORMあれこれ</h1><p>はじめまして、中岡(<a href="https://twitter.com/MaineK00n">@MaineK00n</a>)と申します。</p><p>2021年6月の現在はフューチャー発OSSの<a href="https://github.com/future-architect/vuls">Vuls</a>開発をメインに、CSIG<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>でアルバイトをしています。</p><h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul><li>ORM(Object-relational mapping)を触るときは発行されるクエリが意図したものか確認する</li><li>推測するな、計測せよ</li></ul><h1 id="GORMを触る、Vuls-1202"><a href="#GORMを触る、Vuls-1202" class="headerlink" title="GORMを触る、Vuls#1202"></a>GORMを触る、Vuls#1202</h1><p>本題に入る前に、Vulsのスキャンについて簡単に説明します。</p><p>Vulsでは、以下のようにsqlite3などの形式で保存されたVulnerability DBからCVE情報を集めて、スキャン先の脆弱性を解析しています。</p><p>FYI: Vulsのスキャンアーキテクチャは<a href="https://vuls.io/docs/en/architecture-fast-deep.html">こちら</a>に詳しく書かれています。</p><p><img src="/images/20210609a/vuls-arch.png"></p><p>Reference: <a href="https://github.com/future-architect/vuls">future-architect/vuls</a></p><p>さて，GORMを触るきっかけは、このPR(<a href="https://github.com/future-architect/Vuls/pull/1202">Vuls#1202</a>)です。このPRは、VulsでDebianをスキャンしたとき、CVE情報のベースをOVALからDebian Security Trackerへ変更しようというものです。実装してみると、変更前はスキャン時間の90%ileが3.37sだったのですが、変更後は11.15sまで増加してしまいました。</p><p>原因を調査すると、Vulsと連携してDebian Security Trackerの情報を取り扱うgost(<a href="https://github.com/knqyf263/gost">knqyf263/gost</a>)にあることが分かりました。詳しくは、追加された機能(<a href="https://github.com/knqyf263/gost/pull/47">gost#47</a>)によってDBに保存したDebianに関するCVE情報を取得する部分が増加したことでした。</p><p>パフォーマンスを改善しなければ、この機能は導入できないということになりました。そのため、EXPLAINしてINDEXを確認したりなどをして、解決策を色々探していました</p><p>その中で、2020年8月にGORM 2.0がリリースされていることを思い出しました。Release Noteによると、GORM v2はフルスクラッチされており、パフォーマンスが改善されているそうなのです。</p><p>まず、私はGORM v2をサポートして、どれくらい改善するかを検証することにしました(<a href="https://github.com/knqyf263/gost/pull/60">gost#60</a>)。</p><h2 id="期待のGORM-v2、そのパフォーマンス"><a href="#期待のGORM-v2、そのパフォーマンス" class="headerlink" title="期待のGORM v2、そのパフォーマンス"></a>期待のGORM v2、そのパフォーマンス</h2><p>GORMをv1からv2にしたところ、発行されるクエリは大きく変わっていませんでした。<br>それでは、簡易なパフォーマンス測定をやってみることにします。</p><h3 id="検証-Package-expat"><a href="#検証-Package-expat" class="headerlink" title="検証(Package: expat)"></a>検証(Package: expat)</h3><p>Debian busterのPackage: expatに関するunfixed/fixedなCVE情報を検索することを100回繰り返して、レスポンスにかかる時間の90%ileを取ってみました。</p><ul><li>unfixed cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">4</td><td align="center">0.006682</td></tr><tr><td align="center">GORM v2</td><td align="center">4</td><td align="center">0.010948</td></tr></tbody></table><ul><li>fixed cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">46</td><td align="center">0.023047</td></tr><tr><td align="center">GORM v2</td><td align="center">46</td><td align="center">0.015868</td></tr></tbody></table><h3 id="検証-Package-linux"><a href="#検証-Package-linux" class="headerlink" title="検証(Package: linux)"></a>検証(Package: linux)</h3><p>もしかして発行されるクエリ数が少なすぎるかなと思って、Package: linuxに関するunfixed/fixedなCVE情報でも検証してみました。</p><p>すると、この場合はGORM v2にすることによるはっきりとしたパフォーマンスの向上が確認できました。</p><ul><li>unfixed cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">298</td><td align="center">0.035935</td></tr><tr><td align="center">GORM v2</td><td align="center">307</td><td align="center">0.027996</td></tr></tbody></table><ul><li>fixed cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">4930</td><td align="center">0.43754</td></tr><tr><td align="center">GORM v2</td><td align="center">4945</td><td align="center">0.298629</td></tr></tbody></table><p>ちなみに、GORM v2をサポートした状態でのVulsによるスキャン時間は11.5sから9.17sになりました。<br>まだまだ高速化が必要です😢</p><h2 id="さらなる高速化に向けて"><a href="#さらなる高速化に向けて" class="headerlink" title="さらなる高速化に向けて"></a>さらなる高速化に向けて</h2><p>発行されるクエリのうち、ボトルネックになっていたのはJOIN句が入ったこのクエリです。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    debian_cve_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">`debian_releases`</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">        debian_packages</span><br><span class="line">    <span class="keyword">on</span>  debian_releases.debian_package_id = debian_packages.id</span><br><span class="line">    <span class="keyword">AND</span> debian_packages.package_name = <span class="string">&quot;expat&quot;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="string">`debian_releases`</span>.<span class="string">`product_name`</span> = <span class="string">&quot;buster&quot;</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`debian_releases`</span>.<span class="string">`status`</span> = <span class="string">&quot;open&quot;</span>;</span><br></pre></td></tr></table></figure><p>JOIN句を使わずに同様の検索が出来ないかを考え、クエリをチューニングしました(<a href="https://github.com/knqyf263/gost/pull/61">gost#61</a>)。<br>クエリチューニング版では、以下のように、JOIN句をやめ、シンプルに<code>debian_packages</code>から<code>debian_cve_id</code> を求め、軽いクエリを多く実行することにしました。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    debian_cve_id</span><br><span class="line"><span class="deletion">- FROM</span></span><br><span class="line"><span class="deletion">-     `debian_releases`</span></span><br><span class="line"><span class="deletion">-     join</span></span><br><span class="line"><span class="deletion">-         debian_packages</span></span><br><span class="line"><span class="deletion">-     on  debian_releases.debian_package_id = debian_packages.id</span></span><br><span class="line"><span class="deletion">-     AND debian_packages.package_name = &quot;expat&quot;</span></span><br><span class="line"><span class="deletion">- WHERE</span></span><br><span class="line"><span class="deletion">-     `debian_releases`.`product_name` = &quot;buster&quot;</span></span><br><span class="line"><span class="deletion">- AND `debian_releases`.`status` = &quot;open&quot;;</span></span><br><span class="line"><span class="addition">+ FROM</span></span><br><span class="line"><span class="addition">+     `debian_packages`</span></span><br><span class="line"><span class="addition">+ WHERE</span></span><br><span class="line"><span class="addition">+     package_name = &quot;expat&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="検証-クエリチューニング"><a href="#検証-クエリチューニング" class="headerlink" title="検証(クエリチューニング)"></a>検証(クエリチューニング)</h3><p>先程と同様に、Debian busterにあるPackage: expat、linuxに関するunfixed/fixedなCVE情報を検索することを100回繰り返して、レスポンスにかかる時間の90%ileでクエリチューニングの効果を評価したいと思います。</p><ul><li>expat unfixes cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">4</td><td align="center">0.006682</td></tr><tr><td align="center">GORM v2</td><td align="center">4</td><td align="center">0.010948</td></tr><tr><td align="center">GORM v2 + query tuning</td><td align="center">49</td><td align="center">0.003467</td></tr></tbody></table><ul><li>expat fixes cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">46</td><td align="center">0.023047</td></tr><tr><td align="center">GORM v2</td><td align="center">46</td><td align="center">0.015868</td></tr><tr><td align="center">GORM v2 + query tuning</td><td align="center">49</td><td align="center">0.003759</td></tr></tbody></table><ul><li>linux unfixes cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">298</td><td align="center">0.035935</td></tr><tr><td align="center">GORM v2</td><td align="center">307</td><td align="center">0.027996</td></tr><tr><td align="center">GORM v2 + query tuning</td><td align="center">5287</td><td align="center">0.267383</td></tr></tbody></table><ul><li>linux fixes cves</li></ul><table><thead><tr><th align="center"></th><th align="center">発行クエリ数</th><th align="center">90%ile</th></tr></thead><tbody><tr><td align="center">GORM v1</td><td align="center">4930</td><td align="center">0.43754</td></tr><tr><td align="center">GORM v2</td><td align="center">4945</td><td align="center">0.298629</td></tr><tr><td align="center">GORM v2 + query tuning</td><td align="center">5287</td><td align="center">0.280019</td></tr></tbody></table><p>結果としては、クエリチューニングをすることで、発行されるクエリ数は増えていますが、linux unfixed cvesの場合以外、高速化できているように見えます。</p><p>執筆時(2021/05/27)では、gostにおいて、CVE情報を検索可能なDebianのパッケージは3059件あり、それらのパッケージに対してfixed/unfixesなCVE情報を検索したとき、発行されるクエリ数はどのように分布するのかを調べてみました。<br>すると、ほとんどの検索の場合、0-499個のクエリしか発行しないことが分かりました。<br>つまり、linux unfixes cvesの場合のように、<code>GORM v2 + query tuning</code>のクエリ数だけがとても増加して、検索にかかる時間が大きくなる事象によるロスより、それ以外の場合による高速化が大きく現れやすいということです。</p><p><img src="/images/20210609a/query_count.png"></p><p>これが、Vulsのスキャン時間にどれくらいの影響を与えるかを、スキャン時間の90%ileで見てみます。<br>スキャン先のDebianにはパッケージが218個インストールされています。<br>参考に、追加機能が導入されてないVuls v0.15.10も追加しました。<br>結果より、GORM v1, GORM v2の時点では、機能を導入に対するトレードオフとしては見合わなかったのですが、クエリチューニングをすることによって、追加機能がないものより高速にスキャンできるようになりました🎉</p><table><thead><tr><th align="center">baseline(Vuls v0.15.10)</th><th align="center">GORM v1</th><th align="center">GORM v2</th><th align="center">GORM v2 + query tuning</th></tr></thead><tbody><tr><td align="center">3.37</td><td align="center">11.5</td><td align="center">9.17</td><td align="center">2.49</td></tr></tbody></table><h1 id="Gost、Ubuntuサポートをする"><a href="#Gost、Ubuntuサポートをする" class="headerlink" title="Gost、Ubuntuサポートをする"></a>Gost、Ubuntuサポートをする</h1><p>gostはUbuntuをサポートしていなかったので(TODOにはあった)、ついでと思ってUbuntuのサポートをしました(<a href="https://github.com/knqyf263/gost/pull/62">gost#62</a>)。</p><p>これをもとにして、VulsでUbuntuをスキャンするときにgostからのCVE情報が追加される予定です(<a href="https://github.com/future-architect/Vuls/pull/1243">Vuls#1243</a>)。</p><p>執筆時点（2021/05/27）では、gostでGORM v2をサポートするPRはまだMergeされてませんので、最初はDebianでのクエリチューニングを基にして、GORM v1で対応しました。gostの対応はサクッと終わったので、続いてVulsとの連携を実装しました。</p><p>さて、Vulsとの連携も実装できたので、Vulsのスキャン先を用意します。スキャン先として用意したUbuntu環境にインストールされているパッケージは2662個です。</p><p>この環境に対してVulsでスキャンをすると、スキャン時間が5m38sと遅い……(機能導入前であれば2sぐらい)</p><p>そこで、他のPRでGORM v2をサポートするので、Ubuntuサポート版もGORM v2に対応しました。</p><p>さて、GORM v2にしたときのVulsのスキャン速度は……？</p><p><strong>7s</strong></p><p>約48倍も速くなりました！！！一応、実際に発行されるクエリを見てみましたが、発行されるクエリに差分は、ほぼありませんでした。</p><p>約48倍も速くなった要因は、スキャン先にインストールされているパッケージ数がDebianの場合よりも多く、GORM v2にアップデートすることによるパフォーマンスの向上が顕著に現れたと考えています。</p><h2 id="GORM-v1とGORM-v2におけるPreloadの挙動"><a href="#GORM-v1とGORM-v2におけるPreloadの挙動" class="headerlink" title="GORM v1とGORM v2におけるPreloadの挙動"></a>GORM v1とGORM v2におけるPreloadの挙動</h2><p>さて、GORM v1で実装していて、テストをしていると、Debianの場合はRDBとRedisでレスポンスを比較して、差分は出ないのですが、UbuntuではあるパッケージにGETリクエストを投げたときのレスポンスがRDBとRedisで異なることに気が付きました。</p><p>とりあえず、Preloadの順番を変更すると、レスポンスが正しく返ってきました。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    err := r.conn.</span><br><span class="line"><span class="deletion">-           Preload(&quot;Patches.ReleasePatches&quot;, &quot;release_name = ? AND status IN (?)&quot;, codeName, fixStatus).</span></span><br><span class="line">        Preload(&quot;Patches&quot;, &quot;package_name = ?&quot;, pkgName).</span><br><span class="line"><span class="addition">+        Preload(&quot;Patches.ReleasePatches&quot;, &quot;release_name = ? AND status IN (?)&quot;, codeName, fixStatus).</span></span><br><span class="line">        Where(&amp;models.UbuntuCVE&#123;ID: res.UbuntuCveID&#125;).</span><br><span class="line">        First(&amp;cve).Error</span><br></pre></td></tr></table></figure><p>そして、GORM v2にアップデートした後、GORM v1のときに変更したPreloadの順番ってGORM v2でも同様の挙動をするのかが気になりました🤔</p><p>Preloadを調整したcommitをrevertして、レスポンスをチェックすると、アレレ？ちゃんと正しいレスポンスが返ってきていました……</p><p>しかし、どうして正しいレスポンスが返ってくるようになったのでしょうか。</p><p>私、気になります！</p><p>そこで、Preload調整前のGORM v1とPreload調整後のGORM v1、Preload調整後のGORM v2、Preload調整をrevertしたGORM v2の4つが発行するクエリの一部を比較しました。</p><p>結果としては、今回の場合、GORM v1においては、Preloadの順を変更すると、<code>WHERE IN</code>に影響を及ぼすようです。GORM v2になると、Preloadの順番に左右されない挙動をしていました。</p><ul><li>GORM v1, Preload調整前</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">&quot;ubuntu_release_patches&quot;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (<span class="string">&quot;ubuntu_patch_id&quot;</span> <span class="keyword">IN</span>(<span class="number">133652</span>, <span class="number">133653</span>)) <span class="comment">-- Preloadの順番がここに影響する</span></span><br><span class="line"><span class="keyword">AND</span> (</span><br><span class="line">        release_name = <span class="string">&#x27;focal&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">status</span> <span class="keyword">IN</span>(<span class="string">&#x27;needed&#x27;</span>, <span class="string">&#x27;pending&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="string">&quot;ubuntu_release_patches&quot;</span>.<span class="string">&quot;id&quot;</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><ul><li>GORM v1, Preload調整後</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">&quot;ubuntu_release_patches&quot;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (<span class="string">&quot;ubuntu_patch_id&quot;</span> <span class="keyword">IN</span>(<span class="number">133653</span>))</span><br><span class="line"><span class="keyword">AND</span> (</span><br><span class="line">        release_name = <span class="string">&#x27;focal&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">status</span> <span class="keyword">IN</span>(<span class="string">&#x27;needed&#x27;</span>, <span class="string">&#x27;pending&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="string">&quot;ubuntu_release_patches&quot;</span>.<span class="string">&quot;id&quot;</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><ul><li>GORM v2, Preload調整後</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">`ubuntu_release_patches`</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="string">`ubuntu_release_patches`</span>.<span class="string">`ubuntu_patch_id`</span> = <span class="number">133653</span></span><br><span class="line"><span class="keyword">AND</span> (</span><br><span class="line">        release_name = <span class="string">&quot;focal&quot;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">status</span> <span class="keyword">IN</span>(<span class="string">&quot;needed&quot;</span>, <span class="string">&quot;pending&quot;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><ul><li>GORM v2, revert Preload調整</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">`ubuntu_release_patches`</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="string">`ubuntu_release_patches`</span>.<span class="string">`ubuntu_patch_id`</span> = <span class="number">133653</span></span><br><span class="line"><span class="keyword">AND</span> (</span><br><span class="line">        release_name = <span class="string">&quot;focal&quot;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">status</span> <span class="keyword">IN</span>(<span class="string">&quot;needed&quot;</span>, <span class="string">&quot;pending&quot;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>自戒の念を込めて。</p><p>ORMを使うのはいいですが、ちゃんと意図したクエリ、レスポンスになっているかはちゃんと確認したほうが良いです。</p><p>そして、パフォーマンスの改善をするときは、ちゃんとボトルネックを色々な角度から測定して、トータルで改善することを確認してから実行すると良いでしょう。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">CSIG(CyberSecurityInnovationGroup)は、セキュリティ関連のコンサルティングや実装などを行っています</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vuls開発中に出会ったGORMあれこれ&quot;&gt;&lt;a href=&quot;#Vuls開発中に出会ったGORMあれこれ&quot; class=&quot;headerlink&quot; title=&quot;Vuls開発中に出会ったGORMあれこれ&quot;&gt;&lt;/a&gt;Vuls開発中に出会ったGORMあれこれ&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Vuls" scheme="https://future-architect.github.io/tags/Vuls/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="ORM" scheme="https://future-architect.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #9「オンコール通知も全自動で! AWS + Datadog + PagerDuty で作る運用監視基盤」</title>
    <link href="https://future-architect.github.io/articles/20210608a/"/>
    <id>https://future-architect.github.io/articles/20210608a/</id>
    <published>2021-06-07T15:00:00.000Z</published>
    <updated>2021-06-08T01:16:35.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、TIGの木村です。先日2021/4/21(水)に <a href="https://future.connpass.com/event/209778/">Future Tech Night #9 ～運用で後悔しないためのAWS設計術～</a> を開催しました。</p><p>私は <strong>「オンコール通知も全自動で! AWS + Datadog + PagerDuty で作る運用監視基盤」</strong> というテーマでお話しました。</p><p>同イベントにて発表された村瀬さんの <a href="/articles/20210527a/">レポートはこちら</a> になります。</p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>監視 に関連するOSSやSaaSが乱立する昨今、Futureではとある案件で DatadogとPagerDutyをフル活用した運用監視基盤を一から構築しました。運用監視基盤に求められた要件とその設計、システム(AWS)からDatadog/PagerDutyへの具体的な連携アーキテクチャ、運用してみての嬉しみ/辛み等を惜しみなくお話しました。</p><p>その中から発表内容を一部抜粋して紹介いたします。</p><h2 id="監視基盤要件と設計"><a href="#監視基盤要件と設計" class="headerlink" title="監視基盤要件と設計"></a>監視基盤要件と設計</h2><img src="/images/20210608a/image.png" alt="運用監視基盤要件" width="1200" height="402" loading="lazy"><img src="/images/20210608a/image_2.png" alt="Why Datadog" width="1200" height="565" loading="lazy"><img src="/images/20210608a/image_3.png" alt="Why PagerDurty" width="1200" height="586" loading="lazy"><h2 id="システム構成"><a href="#システム構成" class="headerlink" title="システム構成"></a>システム構成</h2><img src="/images/20210608a/image_4.png" alt="Metrics -> Datadog" width="1200" height="639" loading="lazy"><img src="/images/20210608a/image_5.png" alt="Log -> Datadog" width="1200" height="477" loading="lazy"><img src="/images/20210608a/image_6.png" alt="Datadog -> 通知先サービス" width="1200" height="491" loading="lazy"><h2 id="ここが素敵-辛い-Datadog-PagerDuty"><a href="#ここが素敵-辛い-Datadog-PagerDuty" class="headerlink" title="ここが素敵/辛い Datadog/PagerDuty"></a>ここが素敵/辛い Datadog/PagerDuty</h2><img src="/images/20210608a/image_7.png" alt="Datadog" width="1200" height="492" loading="lazy"><img src="/images/20210608a/image_8.png" alt="PagerDuty" width="120" height="285" loading="lazy"><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>ご参加いただいた方々、ありがとうございました。</p><p>本編ではもう少しDatadog, PagerDutyでできること/できないことを厚めに紹介できればよかったかな、と反省はありますが、少しでもお役に立てたなら幸いです。</p><p>FutureではFuture Tech Nightの他にも様々なイベントを開催しております。今後も皆様のご参加をお待ちしております。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、TIGの木村です。先日2021/4/21(水)に &lt;a href=&quot;https://future.connpas</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="保守運用" scheme="https://future-architect.github.io/tags/%E4%BF%9D%E5%AE%88%E9%81%8B%E7%94%A8/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>AWS Certified Solutions Architect - Professional合格体験記</title>
    <link href="https://future-architect.github.io/articles/20210607a/"/>
    <id>https://future-architect.github.io/articles/20210607a/</id>
    <published>2021-06-06T15:00:00.000Z</published>
    <updated>2021-06-07T01:33:48.633Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です。</p><p>先日AWS Certified Solutions Architect - Professionalを受験し合格できました。</p><p>合格までの学習方法を共有します。</p><img src="/images/20210607a/image.png" alt="aws certified solutions architect icon" width="600" height="600"><h1 id="AWS-Certified-Solutions-Architect-Professionalとは"><a href="#AWS-Certified-Solutions-Architect-Professionalとは" class="headerlink" title="AWS Certified Solutions Architect - Professionalとは"></a>AWS Certified Solutions Architect - Professionalとは</h1><p>AWSには資格試験が11種類存在します(AWS 認定 Alexa スキルビルダー – 専門知識が2021年3月をもって終了したため11種類になりました)</p><p>その中でもシステムのアーキテクチャ選定、ベストプラクティスの設計に関わる試験がソリューションアーキテクトです。</p><p>ソリューションアーキテクトにはアソシエイト資格とプロフェッショナル資格があり、プロフェッショナルは上位の資格にあたります。</p><p>公式ページは<a href="https://aws.amazon.com/jp/certification/certified-solutions-architect-professional/">こちら</a>です。</p><p>上位資格だけあって、問題文の意味を理解する事すら苦労するようなレベルの問題が多く集まっています。</p><h1 id="合格までの道筋"><a href="#合格までの道筋" class="headerlink" title="合格までの道筋"></a>合格までの道筋</h1><p><a href="https://d1.awsstatic.com/ja_JP/training-and-certification/docs-sa-pro/AWS-Certified-Solutions-Architect-Professional_Exam-Guide.pdf">試験ガイド</a>に従いホワイトペーパーを読み進めていくのが正攻法ですが、私は有料コンテンツをひたすら購入して消化していく方針で勉強しました。</p><p>残念ながら試験には一度落ちてしまいました、心が折れかけましたが、どうにか信用できる教材を捜索し、再チャレンジする自信を取り戻すことができました。</p><p>以降はコンテンツのレビューになります。</p><h1 id="書籍AWS認定ソリューションアーキテクト‐プロフェッショナル"><a href="#書籍AWS認定ソリューションアーキテクト‐プロフェッショナル" class="headerlink" title="書籍AWS認定ソリューションアーキテクト‐プロフェッショナル"></a>書籍AWS認定ソリューションアーキテクト‐プロフェッショナル</h1><p>リックテレコムから<a href="https://books.google.co.jp/books/about/AWS%E8%AA%8D%E5%AE%9A%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD.html?id=gqOWzQEACAAJ&source=kp_book_description&redir_esc=y">書籍</a>が出ています。</p><p>プロフェッショナル資格では執筆時点での唯一の書籍での教材です。</p><p>教材の内容は、2020年発売で最新の情報もしっかりカバーされています。本の内容は素晴らしいものでした。</p><p>しかし、試験の難易度が圧倒的に高く、また出題範囲が広いため、後述のUdemyの教材と巻末の問題集だけを丸暗記して臨んだ結果落ちてしまいました。</p><p>今思えば各章の内容を隅々まで丸暗記すればこれ一冊で合格できたかもしれません。</p><h1 id="Udemy教材"><a href="#Udemy教材" class="headerlink" title="Udemy教材"></a>Udemy教材</h1><p>資格試験の問題集を学習サイトのUdemyで購入することが可能です。</p><p><a href="https://www.udemy.com/course/aws-solutions-architect-professional-practice-exams-amazon/">こちらの問題集</a>が最も高評価です。</p><p>英語版ですがブラウザで翻訳しながら利用すれば英語が読めない方でも概ね差し支えなく利用できます。</p><p>こちらも問題の質は決して悪くないのですが、全てを90%以上解けるようになるまで覚えても落ちました。</p><p>問題の難易度が高いため、大まかなキーワードだけ丸暗記するようなレベル感では合格できません。</p><p>細かい言い回しが変わっても根拠をもって正解を選べるようしっかりインプットすることが重要です。</p><h1 id="学習サイト-aws-koiwaclub-com"><a href="#学習サイト-aws-koiwaclub-com" class="headerlink" title="学習サイト aws.koiwaclub.com"></a>学習サイト aws.koiwaclub.com</h1><p><a href="https://aws.koiwaclub.com/">AWS WEB問題集で学習しよう</a>というタイトルのページです。</p><p>前述の通り試験に落ちた私は藁にも縋る思いでこのサイトの有料会員になりました。</p><p>問題のコンテンツはとても質の高いものでした、7問ずつ繰り返して覚えていくスタイルの勉強法で覚えていく形になります。</p><p>最終的に正答率がユーザーランキング30位くらいになるまで繰り返しました。</p><p>元々750点のボーダーラインに対し680点までは取れていたのですが、詰めの甘い部分をこのサイトで補う事で合格できました。最終的なスコアは840点でした。</p><h1 id="3つの教材比較"><a href="#3つの教材比較" class="headerlink" title="3つの教材比較"></a>3つの教材比較</h1><p>いずれの教材も質が高く、とにかく圧倒的な試験の難易度に敗北する印象でした。</p><p>3つの教材にそれぞれほぼ完全に一致している問題がいくつか載っていて、そのまま本番に出る程度には信頼できる品質です。</p><p>本当に100%頭に詰めることができればいずれか一つのコンテンツで合格することができると思います。</p><p>合格した今振り返ると書籍とaws.koiwaclub.comだけで良かったかなと感じています。</p><h1 id="今なら落ちても安心"><a href="#今なら落ちても安心" class="headerlink" title="今なら落ちても安心"></a>今なら落ちても安心</h1><p>2021年5月1日から2021年7月31日まで、オンラインでの受験で、一回落ちても無料で再受験できるキャンペーンが実施されています。</p><p>詳しくは<a href="https://pages.awscloud.com/Global_TrainCert_Japan_Online_Proctoringja.html">公式ページ</a>をご確認ください。</p><p>まず本を買って受験してみて、落ちたらaws.koiwaclub.comに登録してリベンジするといった流れで安心して受験できます。この機会にぜひチャレンジしてみてはいかがでしょうか。</p><p>なおオンライン受験では不正対策のため、カメラで部屋の様子を一通り試験監督の方に確認していただく必要があります、動かしやすい外付けのWebカメラがある状態での受験をお勧めします。</p><p>あと部屋を綺麗にしてから受験しましょう(自戒)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;先日AWS Certified Solutions Architect - Professionalを受験し合格できました。&lt;/p&gt;
&lt;p&gt;合格までの学習方法を共有します。&lt;/p&gt;
&lt;img src=&quot;/images/20210607a</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="合格記" scheme="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>続・サーバーレス検索エンジン：巨大な静的ファイルを扱うケースについて考える</title>
    <link href="https://future-architect.github.io/articles/20210604a/"/>
    <id>https://future-architect.github.io/articles/20210604a/</id>
    <published>2021-06-03T15:00:00.000Z</published>
    <updated>2021-06-04T05:08:13.450Z</updated>
    
    <content type="html"><![CDATA[<p>TIGのDXユニットの渋川です。<a href="https://future-architect.github.io/articles/20210531a/">Serverless連載2021</a>の最後の記事になります。sam周りとかLambdaの挙動については<a href="https://twitter.com/r_rudi">@r_rudi</a>さんに色々教えていただきました。ありがとうございます。</p><p>巨大な学習済みの機械学習モデルとか、検索用インデックスをデプロイする場合に、どうやってデプロイするか、というのは色々選択肢があります。以前、ちょびっとだけ「どうやってデプロイしましょうかね」というのを悩んだ時期があったのですが、今回、こんな方式が考えられるんじゃないか、というのを改めて調べてリストアップしてみました。</p><p>それぞれの容量は2021年6月現在の数値ですので、最新情報は各々リンク先を確認してみてください。AzureとかAlibaba Cloudとかは仕事柄扱うチャンスが今のところないので調べてないですが、もし調べた方はぜひ教えてください。</p><table><thead><tr><th align="center">クラウドベンダー</th><th align="center">サーバーレス方式</th><th align="center">ストレージ</th><th align="center">容量</th><th align="center">バンドル</th><th align="center">ファイルアクセス</th><th align="center">その他</th></tr></thead><tbody><tr><td align="center">GCP</td><td align="center">Cloud Run</td><td align="center">コンテナイメージにバンドル</td><td align="center">5TB(<a href="https://cloud.google.com/storage/quotas">Cloud Storage</a>に準ずる)</td><td align="center">YES</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GCP</td><td align="center">GKE Knative</td><td align="center">Cloud Storage</td><td align="center">5TB(<a href="https://cloud.google.com/storage/quotas">Cloud Storage</a>参照)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GCP</td><td align="center">GKE Knative</td><td align="center">Persistent Volume</td><td align="center">16TB-60TB(<a href="https://cloud.google.com/filestore/docs/limits">File Store</a>), 16TB(<a href="https://cloud.google.com/architecture/partners/netapp-cloud-volumes/resource-limits-quotas">Cloud Volumes</a>)</td><td align="center"></td><td align="center">YES</td><td align="center">Auto Pilotでは使えず</td></tr><tr><td align="center">AWS</td><td align="center">Lambda</td><td align="center">標準ランタイム(レイヤー)</td><td align="center">展開後250MB</td><td align="center">YES(レイヤーは後付け可)</td><td align="center"></td><td align="center">専用実装が必要</td></tr><tr><td align="center">AWS</td><td align="center">Lambda</td><td align="center">コンテナイメージにバンドル</td><td align="center">10GB</td><td align="center">YES</td><td align="center"></td><td align="center">専用実装が必要</td></tr><tr><td align="center">AWS</td><td align="center">Lambda</td><td align="center">EFS</td><td align="center">48TB(<a href="https://docs.aws.amazon.com/ja_jp/efs/latest/ug/limits.html">EFS</a>)</td><td align="center"></td><td align="center">YES</td><td align="center"></td></tr><tr><td align="center">AWS</td><td align="center">App Runner</td><td align="center">コンテナ</td><td align="center"><a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">ECR</a>次第？</td><td align="center"></td><td align="center"></td><td align="center">実行時間制限など情報なし</td></tr><tr><td align="center">AWS</td><td align="center">Lambda/App Runner</td><td align="center">S3</td><td align="center"><a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#limits_s3">5TB</a></td><td align="center"></td><td align="center"></td><td align="center">5GB以上は分割アップロードでめんどい</td></tr></tbody></table><p>大きくは外部ストレージサービス利用と、アプリケーションにバンドルしてしまう方式と2つにわかれます。バンドルはデータだけ更新ができないデメリットはありますが、お手軽です。Lambdaはレイヤーを使えば実行プログラムに対して後から追加とかできますが、容量制限が厳しめです。</p><p>オブジェクトストレージは比較的お手軽ですが、読み込みしたいライブラリがローカルのファイルシステム前提の場合は使えません。サーバーレスの方式によっては、一度ローカルのファイルシステムに書き出してから利用とかも可能ではありますが、Cloud Runでは8GB（ただし、おそらくtmpfsで書けば書くほどメモリを消費)、Lambdaでは500MBと容量に制限があります。</p><p>より巨大な学習済みデータを扱う場合はマネージドNFSサービス系のものを使うのが最終形でしょう。ファイルのサイズ制限もほぼ限界値ですし、ローカルファイルになるのでどんなランタイムでもファイルが利用できます。Cloud Run大好きなのでGKEのKnative + Persistent Volumeを試そうかと思ったのですが、期待の簡易起動のAutopilotではCloud Run相当（Knative)が使えず、いろいろ面倒そう。がんばって試しても良かったのですが、こんな面倒なのはそのうち簡略化されると期待して、強い意志を持ってスルーすることにしました。Dockerのボリュームなみに簡単になって欲しい。</p><p>とりあえず手元のケースでは10GBを超えるようなものはいまのところなかったので、　Lambdaコンテナの10GB制限で十分そうです。ということで、本エントリーではお手軽なLambdaのコンテナランタイムを試してみようと思います。</p><h1 id="Lambda-コンテナ"><a href="#Lambda-コンテナ" class="headerlink" title="Lambda + コンテナ"></a>Lambda + コンテナ</h1><p>2020/12/1にLambdaがコンテナをサポートしました。今までは特定の言語ランタイムのみが便利に利用可能（いちおうカスタムランタイムもできる)でした。Lambdaのコンテナも特定のベースイメージもしくはランタイムをインストールしたイメージを作って利用なので、自由度という点では今までとそこまで変わるわけではありませんが、10GBまで可能になればできることは大きく増えます。楽しみですね。</p><table><thead><tr><th align="center">言語</th><th align="center">イメージ</th></tr></thead><tbody><tr><td align="center">Node.js</td><td align="center"><a href="https://gallery.ecr.aws/lambda/nodejs">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-nodejs">DockerHub</a></td></tr><tr><td align="center">Python</td><td align="center"><a href="https://gallery.ecr.aws/lambda/python">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-python">DockerHub</a></td></tr><tr><td align="center">Java</td><td align="center"><a href="https://gallery.ecr.aws/lambda/java">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-java">DockerHub</a></td></tr><tr><td align="center">Go</td><td align="center"><a href="https://gallery.ecr.aws/lambda/go">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-go">DockerHub</a></td></tr><tr><td align="center">.Net</td><td align="center"><a href="https://gallery.ecr.aws/lambda/dotnet">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-dotnet">DockerHub</a></td></tr><tr><td align="center">Ruby</td><td align="center"><a href="https://gallery.ecr.aws/lambda/ruby">ECR</a>, <a href="https://hub.docker.com/r/amazon/aws-lambda-ruby">DockerHub</a></td></tr></tbody></table><p>コンテナになったとはいえ、コードはLambdaの流儀で作る必要があります。GCP Cloud RunやAWS AppRunnerのようにポータブルなどこでも動かせるウェブアプリケーションを実装するのを期待する人がいるかもしれませんが（僕です！）、残念ながらそうではなく、Lambda用のハンドラを定義してあげる必要があります。こんな形です。詳しくは当ブログの<a href="https://future-architect.github.io/articles/20200326/#Lambda%E3%81%AE%E9%96%A2%E6%95%B0%E3%82%BF%E3%82%A4%E3%83%97">Serverless連載2: AWS Lambda×Goの開発TipsのLambdaの関数タイプ</a>を参照ください。</p><p>ミニマムなのはこんな形です。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/events&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(request events.APIGatewayProxyRequest)</span> <span class="params">(events.APIGatewayProxyResponse, error)</span></span> &#123;</span><br><span class="line">log.Println(request.Path, request.PathParameters, request.Headers, request.HTTPMethod)</span><br><span class="line"><span class="keyword">return</span> events.APIGatewayProxyResponse&#123;Body: <span class="string">`&#123;&quot;hello&quot;: &quot;world&quot;&#125;`</span>, StatusCode: <span class="number">200</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(Handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これをDockerfileでビルドします。マルチステージビルドしています。あんまり明示的に書くことはないかもですが、M1 Macでビルドすることを考えてGOARCH=amd64を明示しています。最終的なpublic.ecr.aws/lambda/goはlinux/amd64しかないのですが、マルチステージビルドのGoイメージは複数アーキテクチャ対応なのでamd64バイナリができるようにしなければなりません。新しく入ったBuildKitの機能である<a href="https://docs.docker.com/buildx/working-with-buildx/">buildx</a>を利用して、docker buildx –platform=linux/amd64でビルドしてもいいのですが、buildxでamd64にするよりも、↓を使った方がちょっと大きいアプリケーションで10倍ぐらい高速（200秒超と20秒)だったので、こちらの方が良いでしょう。</p><p>あとは、最終的なアプリケーションを<code>LAMBDA_TASK_ROOT</code>という環境変数の場所に置くのがポイントですね。</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-buster as builder</span><br><span class="line"><span class="keyword">ENV</span> GOPATH=</span><br><span class="line"><span class="keyword">ENV</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="keyword">ENV</span> GOOS=linux</span><br><span class="line"><span class="keyword">ENV</span> GOARCH=amd64</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /work</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build -trimpath -o main</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> public.ecr.aws/lambda/go</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /work/main <span class="variable">$&#123;LAMBDA_TASK_ROOT&#125;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;main&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET http://localhost:9000</span><br></pre></td></tr></table></figure><p>このDockerイメージはLambda専用なので、いくつか決まり事があります。</p><p>Lambda用のエージェントがイメージのエントリーポイントにいて、そいつが8080ポートで動作していますので、次のようにポートをマッピングして起動します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t lambda-test .</span><br><span class="line">$ docker run -p 9000:8080 --rm -it lambda-test</span><br></pre></td></tr></table></figure><p>起動すると、<code>/2015-03-31/functions/function/invocations</code>というパスにトリガーとなるエンドポイントが用意されます。2015年3月31日ってなんやねん、と思われるかもしれませんが、このパス決めうちなので仕方がないのです。追加のパスを投げることもできません。諦めてください。次のコマンドで起動します。<code>-d &#39;&#123;&#125;&#39;</code>は必須です。外すとエラーになります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET http://localhost:9000/2015-03-31/<span class="built_in">functions</span>/<span class="keyword">function</span>/invocations -d <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;statusCode&quot;</span>:200,<span class="string">&quot;headers&quot;</span>:null,<span class="string">&quot;multiValueHeaders&quot;</span>:null,<span class="string">&quot;body&quot;</span>:<span class="string">&quot;&#123;\&quot;hello\&quot;: \&quot;world\&quot;&#125;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>これでテストできますよーとドキュメントにはありますが、半分本当で半分嘘です。というのも、実際にウェブサービスとして起動するには　API Gatewayをトリガーに設定して起動します。これがHTTPリクエストをJSONに変換してからlambdaに渡します。このDockerイメージは変換後のJSONを期待しています。本番で次のようにボディとしてJSONを渡したいとします。</p><p>パスが固定という説明をしましたが、ローカルではクエリーパラメータを付与してもダメでした。AWS上のLambdaは大丈夫です。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com -d &#x27;&#123;&quot;hello&quot;: &quot;world&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>ローカルでテストするときは、ボディを文字列化し、それをbodyキーに入れたJSONを作って投げる必要があります。このあたりを自動でやってくれるプロキシがあると良さそう。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com -XGET http://localhost:9000/2015-03-31/functions/function/invocations &#x27;&#123;body: &quot;&#123;\&quot;hello\&quot;: \&quot;world\&quot;&#125;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>samコマンドを使えば、このAPI Gatewayが生成するJSONをローカルで作ってくれるのでテストに使えます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sam <span class="built_in">local</span> generate-event apigateway aws-proxy --path hoo/ --body hooo</span><br></pre></td></tr></table></figure><h1 id="検索エンジンをLambdaコンテナにする"><a href="#検索エンジンをLambdaコンテナにする" class="headerlink" title="検索エンジンをLambdaコンテナにする"></a>検索エンジンをLambdaコンテナにする</h1><img src="/images/20210604a/watertower.jpg" alt="wartertower" width="640" height="427" loading="lazy"><p>ちょっと実践的なサンプルを作ってみました。以前作った<a href="https://future-architect.github.io/articles/20200327/">サーバーレス用の検索エンジンwatertower</a>を改造して、ローカルのインデックスファイルの読み書きに対応しました。今回使ったサンプルは66kB程度の小さいデータファイルですが、心の中でこれが1万倍の大きさだったと想定してお読みいただければと思います。</p><p><a href="https://github.com/future-architect/watertower">https://github.com/future-architect/watertower</a></p><p>サーバーレス用ということで、<a href="https://gocloud.dev/">GoCloud.dev</a>のdocstoreをストレージに使い、DynamoDBなどのサーバーレス用途で便利なバックエンドを利用する実装にしていました。このdocstoreのバックエンドのうち、memdocstoreはオプションを設定するとローカルファイルに読み書きします。しかし、終了時に強制書き出ししてしまうので、将来的にNFSで共有するときに不便になる気がして、別に実装しました。思ったより大掛かりになってしまったので、今にして思えばdocstoreのローカルファイル拡張として実装した方がよかったように思いました。また、時間があればFlatbuffersにしたかったですね。巨大インデックスでもパースする箇所を最小にできれば起動時間は短くなりますからね。ここは本題ではないのでまあ軽く。</p><p>まあ、ローカルに持ったインデックスでの検索なら<a href="https://github.com/tantivy-search/tantivy">tantivy</a>使うのも良いと思います。Rust製で高速らしいです。日中韓のトークナイザも付属。</p><p>今回は静的なインデックスを作るCLIツールも用意しました。ソースは特定のスキーマで書かれたJSONファイル群です。それがフォルダにまとめて格納されているという想定でそのフォルダをスキャンしてインデックスを作っていきます。ちょうど、サンプルコードの中にHTTPのステータスコードの解説ドキュメントがいたのでこれをインデックス化して利用します。</p><p><a href="https://github.com/future-architect/watertower/tree/master/samples/httpstatus/documents">https://github.com/future-architect/watertower/tree/master/samples/httpstatus/documents</a></p><p>Dockerfileの中では、検索用のプログラムのビルドと、インデックス作成用のCLIツールをビルドし、後者の方ではインデックスファイルの作成まで行っています。最後のデプロイ用のイメージは検索プログラムとインデックスファイルを同一のフォルダに置いて完成です。</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile.aws-lambda</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-buster as builder</span><br><span class="line"><span class="keyword">ENV</span> GOPATH=</span><br><span class="line"><span class="keyword">ENV</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="keyword">ENV</span> GOOS=linux</span><br><span class="line"><span class="keyword">ENV</span> GOARCH=amd64</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /work</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> cmd/watertower-aws-lambda ./cmd/watertower-aws-lambda</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> *.go .</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nlp nlp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> webapi webapi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> cmd/watertower-aws-lambda &amp;&amp; go build -trimpath</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-buster as indexer</span><br><span class="line"><span class="keyword">ENV</span> GOPATH=</span><br><span class="line"><span class="keyword">ENV</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="keyword">ENV</span> GOOS=linux</span><br><span class="line"><span class="keyword">ENV</span> GOARCH=amd64</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /work</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> cmd/watertower-cli ./cmd/watertower-cli</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> *.go .</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nlp nlp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> cmd/watertower-cli &amp;&amp; go build -trimpath</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> samples/httpstatus/documents samples/httpstatus/documents</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cmd/watertower-cli/watertower-cli create-index samples/httpstatus/documents</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> amazon/aws-lambda-go</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /work/cmd/watertower-aws-lambda/watertower-aws-lambda <span class="variable">$&#123;LAMBDA_TASK_ROOT&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=indexer /work/watertower.idx <span class="variable">$&#123;LAMBDA_TASK_ROOT&#125;</span></span></span><br><span class="line"><span class="keyword">ENV</span> DEFAULT_LANGUAGE=en</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;watertower-aws-lambda&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>検索用プログラムは前述のサンプルを膨らませたぐらいで、冗長なので省略します。以下のところでコードは見られます。</p><p><a href="https://github.com/future-architect/watertower/tree/master/cmd/watertower-aws-lambda">https://github.com/future-architect/watertower/tree/master/cmd/watertower-aws-lambda</a></p><p>ローカルでビルド＆実行し（前述のコマンドと一緒です）、試してみます。bodyというキーにリクエストを入れないといけないところは要注意。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET http://localhost:9000/2015-03-31/<span class="built_in">functions</span>/<span class="keyword">function</span>/invocations -d <span class="string">&#x27;&#123;&quot;body&quot;: &quot;&#123;\&quot;query\&quot;: \&quot;body\&quot;&#125;&quot;&#125;&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;statusCode&quot;</span>:200,</span><br><span class="line">    <span class="string">&quot;headers&quot;</span>:null,</span><br><span class="line">    <span class="string">&quot;multiValueHeaders&quot;</span>:null,</span><br><span class="line">    <span class="string">&quot;body&quot;</span>: <span class="string">&quot;&#123;\&quot;count\&quot;:1,\&quot;result\&quot;:[&#123;\&quot;unique_key\&quot;:\&quot;200\&quot;,\&quot;lang\&quot;:\&quot;en\&quot;,\&quot;title\&quot;:\&quot;200 OK\&quot;,...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="AWSで動作させてみる"><a href="#AWSで動作させてみる" class="headerlink" title="AWSで動作させてみる"></a>AWSで動作させてみる</h1><p>まずはECRのリポジトリを作ります。lambda-testというリポジトリを作りました。右上に「プッシュコマンドを表示」という便利機能があります。イメージのアップロードはこのコマンドをそのままコピペして実行すればおしまいです。簡単ですね。aws configureで認証だけはしておく必要があります。</p><img src="/images/20210604a/スクリーンショット_2021-06-03_11.17.jpg" alt="プッシュコマンド" width="1200" height="1010" loading="lazy"><p>次にLambdaを作成します。最初の作成オプションで「コンテナイメージ」を選択し、その後、コンテナイメージURIでは先ほどアップロードしたイメージを選択します。現在は別のアカウントのイメージの選択はできないそうです。ステージングと本番でアカウントを分けている場合には両方にイメージをアップロードする必要があるとのことです。</p><img src="/images/20210604a/スクリーンショット_2021-06-04_1.17.jpg" alt="Lambda作成" width="1200" height="830" loading="lazy"><p>次にトリガーとしてAPI Gatewayを追加します。</p><img src="/images/20210604a/スクリーンショット_2021-06-03_23.27.jpg" alt="API Gateway追加" width="1200" height="801" loading="lazy"><p>API GatewayのところにURLが書かれているので、ここにアクセスします。本番環境用にクエリーパラメータを受け取って検索キーとして使う様に実装したので、クエリーを付与します。無事一件ドキュメントがマッチして帰ってきました。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XGET <span class="string">&quot;https://xxxxxxxx.execute-api.ap-northeast-1.amazonaws.com/default/docker-test?query=body&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;count&quot;</span>:1,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;unique_key&quot;</span>:<span class="string">&quot;200&quot;</span>,<span class="string">&quot;lang&quot;</span>:<span class="string">&quot;en&quot;</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;200 OK&quot;</span>,<span class="string">&quot;updated_at&quot;</span>:<span class="string">&quot;0001-01-01T00:00:00Z&quot;</span>,<span class="string">&quot;tags&quot;</span>:[<span class="string">&quot;200&quot;</span>],</span><br><span class="line">      <span class="string">&quot;content&quot;</span>:<span class="string">&quot;The request has succeeded. The meaning of the success depends...</span></span><br></pre></td></tr></table></figure><h1 id="App-Runnerはどうか？"><a href="#App-Runnerはどうか？" class="headerlink" title="App Runnerはどうか？"></a>App Runnerはどうか？</h1><p>Cloud RunのAWS版という感じをひしひしと感じるのがApp Runnerです。Google I/O直前という発表タイミングも含めて、王者にのみ許されるミート戦略（ランチェスター戦略）そのものですね。PORT環境変数を渡すからこのポートを開いてね、というところまでそっくりです。ただし、まだ公開された直後で、実行時間制限やSLAなどは情報が掲載されていません。</p><p>Lambdaコンテナを今回作ってみて、やはりハンドラを専用に作らなければならないとか、ローカルと本番のAWSで動作が違うのでその吸収とか、やたら面倒でした。App Runnerがそれを解決して、ローカルでもクラウドでも同じように動いてくれるのが実現されたら良いな、と思います。</p><p>今後どうなっていくかはまだわかりませんがロードマップがありますので、欲しい機能とかはぼちぼち書いてみると良いようです。「Lambdaとか名乗っているのにcommon-lispとかのサポート薄いのが許せない」というのも、中の人的には「要望があれば・・・」という噂を聞きました。どしどし要望を上げると良いかと思います。</p><p><a href="https://github.com/aws/apprunner-roadmap/issues">https://github.com/aws/apprunner-roadmap/issues</a></p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>サーバーレスで巨大ファイルを扱う方法について考察しました。実際にストレージを検討するときは、データの容量だけではなく、読み込みのスループットの速度、スループット向上のための追加課金、ストレージの場所（リージョンやゾーンごとにファイルを用意する/リージョン間転送料金発生の有無）など、さまざまな要件を検討しなければなりません。また、アプリケーションによってはモデルの更新がリアルタイムに頻繁に行われるかどうか、というのもあります。</p><p>今回のケースは、インデックス更新の頻度が少なく、容量が比較的小さいテキストの学習モデル（というか検索インデックス）という条件においては最適だとは思いますが、インデックスを動的に追加していくような場合は向きません。アプリケーションの特性によって最適解は変わってきます。アーキテクトとしての腕の見せ所でしょう。</p><p>NFS利用のケースは、もっともっと簡単になって欲しいですね。Dockerのボリュームマウントぐらいの気軽さで、読み込み専用と読み書き両用が気軽に選べて・・・となったら素敵だなと思います。</p><p>なお、ローカルのテストがしにくい点は要注意です。最初はswaggerを用意してあった実装済みのサーバー版を動かせばいいや、と思っていたのですが、実際にテストしたら動かず、最終的にLambdaコンテナ用に別にアプリケーションを作りました。クエリーとかボディはなんとかなりそうですが、パスを変更できないのはかなり厳しい。このブログの記事、さっさと仕上げようと思ったのですが、検索エンジン自体の改造に1週間、Lambdaのローカルとの互換性の調査だけで3日ぐらい溶けた気がします。</p><p>コンテナ化に対応したことで、利用できるファイルサイズが250MBから10GBと、Lambdaができることは増えました。ですが、今後、App Runnerの改善や、コンテナのファイルシステムサポートが充実したらさらにいいな、というのが感想ですね。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://future-architect.github.io/articles/20200327/">Goでサーバーレス用の検索エンジンwatertowerを作ってみました</a></li><li><a href="https://future-architect.github.io/articles/20210318/">GKE Autopilotを触ってみた</a></li><li><a href="https://qiita.com/shibukawa/items/878c5fe8ec09935fccd2">最速という噂のFlatbuffersの速度のヒミツと、導入方法の紹介(Go)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TIGのDXユニットの渋川です。&lt;a href=&quot;https://future-architect.github.io/articles/20210531a/&quot;&gt;Serverless連載2021&lt;/a&gt;の最後の記事になります。sam周りとかLambdaの挙動については&lt;a </summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Docker" scheme="https://future-architect.github.io/tags/Docker/"/>
    
    <category term="Serverless" scheme="https://future-architect.github.io/tags/Serverless/"/>
    
    <category term="MLOps" scheme="https://future-architect.github.io/tags/MLOps/"/>
    
  </entry>
  
  <entry>
    <title>静的解析によるInvalidなAWS Lambda関数シグネチャの検知</title>
    <link href="https://future-architect.github.io/articles/20210603a/"/>
    <id>https://future-architect.github.io/articles/20210603a/</id>
    <published>2021-06-02T15:00:00.000Z</published>
    <updated>2021-06-03T02:02:47.567Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210603a/business-4576778_640.jpg" alt="640" width="412" height=""><p>TIGの辻 (<a href="https://twitter.com/d_tutuz">@d_tutuz</a>)です。</p><p>本記事では<a href="https://aws.amazon.com/jp/lambda/">AWS Lambda</a>の関数シグネチャを静的解析することで、より安全にAWS Lambdaを実装する方法を紹介します。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>早速ですがAWS LambdaのアプリケーションをGoの<a href="https://github.com/aws/aws-lambda-go/tree/v1.23.0">SDK</a>を用いて開発するときに、関数のハンドラは以下のシグネチャでなくてはなりません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(TIn)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="params">(TOut, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context, TIn)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context)</span> <span class="params">(TOut, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context, TIn)</span> <span class="params">(TOut, error)</span></span></span><br></pre></td></tr></table></figure><p>関数を実行するときは <a href="https://pkg.go.dev/github.com/aws/aws-lambda-go@v1.23.0/lambda#Start"><code>lambda.Start</code></a> や <a href="https://pkg.go.dev/github.com/aws/aws-lambda-go@v1.23.0/lambda#StartHandlerWithContext"><code>lambda.StartWithContext</code></a> の引数として関数ハンドラを渡すことで、開発者が実装した関数ハンドラが実行されます。</p><p>以下はAWS LambdaをGoで実装するときの <code>main</code> パッケージの実装例です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(Handle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// アプリケーションのロジックなど</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interface-型であるハンドラ"><a href="#interface-型であるハンドラ" class="headerlink" title="interface{} 型であるハンドラ"></a><code>interface&#123;&#125;</code> 型であるハンドラ</h3><p>ところで <code>lambda.Start</code> 関数の引数であるハンドラは <code>interface&#123;&#125;</code> 型 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(handler <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p><code>interface&#123;&#125;</code> 型として扱うため、以下の <code>HandleInvalid</code> のようにハンドラの関数シグネチャが、うっかり有効でないシグネチャになっていたとしてもビルド自体は成功します。有効でない関数シグネチャを引数に渡して実行するとどうなるのでしょうか？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(HandleInvalid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️戻り値が int であるのは無効なシグネチャ⚠️</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleInvalid</span><span class="params">(ctx context.Context)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答えは “実行時エラー” になります。AWSのコンソールから実行すると以下のようなエラーメッセージが出力されます。</p><p><img src="/images/20210603a/image.png"></p><h2 id="静的解析による関数シグネチャチェック"><a href="#静的解析による関数シグネチャチェック" class="headerlink" title="静的解析による関数シグネチャチェック"></a>静的解析による関数シグネチャチェック</h2><p>できることなら、有効でない関数シグネチャを早い段階で検知して、実行時エラーを防止したいですよね。</p><p>「静的解析」とはプログラムを実行せずにソースコードを解析することです。Goは静的解析のエコシステムが充実しており、静的解析でコードを検査して、不具合につながりそうなソースコードを検知することは一般的です。Go言語自体に備わっている <code>go vet</code> コマンドがありますし <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>、サードパーティによるツールですとGoの典型的なエラー処理のミスを検知する <a href="https://github.com/kisielk/errcheck"><code>errcheck</code></a> や静的解析のツールセットである <a href="https://staticcheck.io/"><code>staticcheck</code></a> などがあります。</p><h3 id="unmarshal-モジュールによる静的解析"><a href="#unmarshal-モジュールによる静的解析" class="headerlink" title="unmarshal モジュールによる静的解析"></a><code>unmarshal</code> モジュールによる静的解析</h3><p>静的解析の例として <code>go vet</code> コマンドを用いてJSONをGoの型にマッピングするときの実装ミスを静的解析でチェックしてみましょう。Go公式のツールである <code>go vet</code> コマンドを実行したときに呼び出される <code>unmarshal</code> モジュールを使って検知できます。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> GoでJSONを型にマッピングするときは <code>json.Unmarshal</code> (あるいは <code>(Decoder).Decode</code>)を使います。<code>json.Unmarshal</code> に渡す第2引数はポインタである必要がありますが、ポインタになっていない場合に <code>go vet</code> コマンドを使うと、ポインタになっていないことを検知できます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonStr = <span class="string">`&#123;&quot;name&quot;:&quot;gopher&quot;&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line"><span class="comment">// u はポインタ型 &amp;u として渡す必要がある！</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), u); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このとき <code>$ go vet ./...</code> とすると以下のように出力されます。第2引数がポインタではないことを教えてくれます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\main.go:17:26: call of Unmarshal passes non-pointer as second argument</span><br></pre></td></tr></table></figure><p>このように静的解析を行うことで、コードを実行せずに不具合につながるコードを早期に検知でき、品質向上に寄与します。</p><h3 id="自作ツールでAWS-Lambdaの関数シグネチャを静的解析"><a href="#自作ツールでAWS-Lambdaの関数シグネチャを静的解析" class="headerlink" title="自作ツールでAWS Lambdaの関数シグネチャを静的解析"></a>自作ツールでAWS Lambdaの関数シグネチャを静的解析</h3><p>JSONのマッピングの実装ミスを静的解析で検知した要領で、AWS Lambdaにおけるハンドラの関数シグネチャも静的解析を行い、有効でない関数シグネチャを検知することを試みます。筆者が調べたところ、既存のツールとして公開されているものはなかったため自作しました。</p><ul><li>静的解析ツールの自作</li></ul><p><a href="https://github.com/gostaticanalysis/skeleton"><code>gostaticanalysis/skeleton</code></a> を使うことで静的解析の雛形を生成でき、便利に静的解析ツールを作り始めることができます。また <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis"><code>golang.org/x/tools/go/analysis</code></a> モジュールなどを用いて、構文解析の解析結果である抽象構文木やソースコードの型の情報など、静的解析に必要な情報を扱うことができ、静的解析したい独自のロジックを実装できます。</p><p>自作したAWS Lambdaの関数シグネチャを静的解析ツールは以下です。</p><a href="https://github.com/d-tsuji/awslambdahandler"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/d-tsuji/awslambdahandler.png" width="460px"></a><p><code>d-tsuji/awslambdahandler</code> を使うと <code>Start</code> や <code>StartWithContext</code> の引数に渡す関数のシグネチャが正しくないコードを発見してくれます。</p><p>冒頭に紹介した、AWS Lambdaが実行時エラーになる以下のコードに対して、<code>awslambdahandler</code> で静的解析をしてみます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(HandleInvalid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️戻り値が int であるのは無効なシグネチャ⚠️</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleInvalid</span><span class="params">(ctx context.Context)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静的解析の実施</li></ul><p><code>awslambdahandler</code> を実行すると、以下のように有効でない関数シグネチャとして検知できます。AWS Lambdaにデプロイして実行せずとも、実行時にエラーになる関数シグネチャを静的解析で検知できました。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go vet -vettool=`<span class="built_in">which</span> awslambdahandler` main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:10:14: lambda handler of <span class="string">&quot;HandleInvalid&quot;</span> is invalid lambda signature, see https://pkg.go.dev/github.com/aws/aws-lambda-go/lambda<span class="comment">#Start</span></span><br></pre></td></tr></table></figure><ul><li><code>awslambdahandler</code> のインストール</li></ul><p>インストールは</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/d-tsuji/awslambdahandler/cmd/awslambdahandler@latest</span><br></pre></td></tr></table></figure><p>などとして簡単にできます。CI環境に組み込めば、日々のチーム開発でより安全にAWS Lambdaを実装できます。ぜひ使ってみてください。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>静的解析を実施することでバグにつながるコードを早い段階で検知できます。<a href="https://github.com/gostaticanalysis/skeleton"><code>gostaticanalysis/skeleton</code></a> や <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis"><code>golang.org/x/tools/go/analysis</code></a> を用いることで便利に静的解析ツールを自作できます。<code>awslambdahandler</code> を用いることでAWS Lambdaの関数シグネチャを静的解析でき、より安全にAWS Lambdaを実装できるようになりました。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><code>go vet</code> コマンドを知らなかったという方も、実は <code>go test</code> のときに <code>go vet</code> に含まれる一部の静的解析が実行されています。<a href="https://golang.org/pkg/cmd/go/internal/test/">https://golang.org/pkg/cmd/go/internal/test/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;"><a href="https://golang.org/cmd/vet/">https://golang.org/cmd/vet/</a> に含まれている <code>unmarshal</code> です。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">Go1.18から導入予定の<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">型パラメータを使ったジェネリクス</a>が浸透すれば、今後引数の型の扱いは変わっていく可能性はあるでしょう。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210603a/business-4576778_640.jpg&quot; alt=&quot;640&quot; width=&quot;412&quot; height=&quot;&quot;&gt;

&lt;p&gt;TIGの辻 (&lt;a href=&quot;https://twitter.com/d_tutuz&quot;&gt;@d_t</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="Linter" scheme="https://future-architect.github.io/tags/Linter/"/>
    
  </entry>
  
  <entry>
    <title>AWS LambdaにおけるGo Contextの取り扱い</title>
    <link href="https://future-architect.github.io/articles/20210602a/"/>
    <id>https://future-architect.github.io/articles/20210602a/</id>
    <published>2021-06-01T15:00:00.000Z</published>
    <updated>2021-06-04T01:12:06.351Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/articles/20210531a/">サーバーレス連載</a>の3記事目です</p><p>TIGの伊藤真彦です。</p><p>GoでLambdaにデプロイするコードを書くにあたり、<a href="https://github.com/aws/aws-lambda-go">aws-lambda-go</a>を利用できます。<br>その際のtips紹介記事です。</p><h1 id="AWS-LambdaにおけるGo-Contextの取り扱い"><a href="#AWS-LambdaにおけるGo-Contextの取り扱い" class="headerlink" title="AWS LambdaにおけるGo Contextの取り扱い"></a>AWS LambdaにおけるGo Contextの取り扱い</h1><img src="/images/20210602a/lambda-39473.png" alt="" width="300" height="310" loading="lazy"><p><a href="https://pixabay.com/ja/users/clker-free-vector-images-3736/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=39473">Clker-Free-Vector-Images</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=39473">Pixabay</a>からの画像</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello ƛ!&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Make the handler available for Remote Procedure Call by AWS Lambda</span></span><br><span class="line">lambda.Start(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/aws/aws-lambda-go">aws-lambda-go</a>ライブラリのREADMEに記載の通り、importして利用可能になった<code>aws-lambda-go/lambda</code>の<code>Start</code>関数の引数に、アプリケーションコードを記載した関数を渡す形で、<br>実行するための土台としてのアレコレを抽象化して、アプリケーションコードに注力することが可能になっています。</p><p><code>lambda.Start(func)</code>に渡せる引数<code>func</code>は<code>interface</code>型になっており、下記の複数種類の形式の関数を渡すことが可能になっています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(TIn)</span>, <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="params">(TOut, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context, TIn)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context)</span> <span class="params">(TOut, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(context.Context, TIn)</span> <span class="params">(TOut, error)</span></span></span><br></pre></td></tr></table></figure><p>引数として<code>context.Context</code>型を受け取るシグネチャの関数を用いることで、後続処理でcontextを受け取ることが可能です。</p><h2 id="LambdaContext型を利用する"><a href="#LambdaContext型を利用する" class="headerlink" title="LambdaContext型を利用する"></a>LambdaContext型を利用する</h2><p>contextというと後続のライブラリに受け渡すか、自前の実装によってタイムアウト等を管理するような用途が想定されます。<br>公式ドキュメントのサンプル実装は<a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/golang-context.html">こちら</a>です。<br>「context の呼び出し情報へのアクセス」の章に記載があるように、<code>lambda.Start(func)</code>で実装した関数が受け取る<code>context.Context</code>には、あらかじめいくつかの値が入っています。<br>これらの値をやり取りするために、aws-lambda-goには<a href="https://github.com/aws/aws-lambda-go/blob/master/lambdacontext/context.go">lambdacontextパッケージ</a>が用意されています。<br>これにより、<code>LambdaContext</code>構造体を用いることが可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaContext is the set of metadata that is passed for every Invoke.</span></span><br><span class="line"><span class="keyword">type</span> LambdaContext <span class="keyword">struct</span> &#123;</span><br><span class="line">AwsRequestID       <span class="keyword">string</span></span><br><span class="line">InvokedFunctionArn <span class="keyword">string</span></span><br><span class="line">Identity           CognitoIdentity</span><br><span class="line">ClientContext      ClientContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この構造体は、フィールド名の通り<code>AwsLambda</code>が実行された際の情報を持たせることが可能です。</p><h2 id="context-ContextからLambdaContext構造体を復元する"><a href="#context-ContextからLambdaContext構造体を復元する" class="headerlink" title="context.ContextからLambdaContext構造体を復元する"></a>context.ContextからLambdaContext構造体を復元する</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromContext returns the LambdaContext value stored in ctx, if any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromContext</span><span class="params">(ctx context.Context)</span> <span class="params">(*LambdaContext, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">lc, ok := ctx.Value(contextKey).(*LambdaContext)</span><br><span class="line"><span class="keyword">return</span> lc, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LambdaContext</code>構造体は、<code>context.Context</code>を引数に取り、<code>LambdaContext</code>構造体を返す関数<code>FromContext</code>でデータを生成できます。<br><code>FromContext</code>を用いたサンプルコードを書いてみました。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/aws/aws-lambda-go/lambdacontext&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloWithContext</span><span class="params">(ctx context.Context)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">lc, ok := lambdacontext.FromContext(ctx)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;aws_request_id: %v&quot;</span>, lc.AwsRequestID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello ƛ!&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Make the handler available for Remote Procedure Call by AWS Lambda</span></span><br><span class="line">lambda.Start(helloWithContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このような方法で、受け取ったcontextからライブラリがcontextに含めた情報を取得することが可能です。<br>実際の運用としては、ログ出力の際にprefixに<code>AwsRequestID</code>を出力するように開発しておき、<code>Amazon CloudWatch Logs</code>に送信されたログから、同一リクエストにおける一連のログ出力を抽出する際に役立てたりしています。</p><p>lambdaで開発したAPIの認証認可に<code>Amazon Cognito</code>を利用している場合は、<code>LambdaContext</code>構造体から<code>CognitoIdentityID</code>、<code>CognitoIdentityPoolID</code>を取得することができるようになっています。<br>新しい<code>context</code>に<code>LambdaContext</code>構造体の情報を詰める<code>func NewContext(parent context.Context, lc *LambdaContext)</code>も用意されています。<br>このような公式から提供されているユーティリティを見落とさず使いこなしていきたいですね。</p><p>なお、Goの実装でLambdaを起動する際に<code>context</code>に任意の値を保持して、リクエストのペイロードとして活用するような使い方はできません。<br>詳しくは過去記事<a href="https://future-architect.github.io/articles/20201112/">GoでLambdaからLambdaを呼び出すときに気をつけたいポイント6選</a>をご確認ください。<br>このようなGoでの実装経験、ハマりどころは<a href="https://future-architect.github.io/articles/20200326/">Serverless連載2: AWS Lambda×Goの開発Tips</a>など、<a href="https://future-architect.github.io/tags/Serverless%E9%80%A3%E8%BC%89/">昨年の連載</a>でも様々な記事が執筆されています。</p><p>この機会に合わせてお読みいただければ幸いです。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><ul><li>AWS lambdaをgoで実装する際にcontext.Contextを受け取るコードを実装できる</li><li>contextにはリクエストID等の情報が含まれている</li><li>contextの情報を扱うためのパッケージが用意されている</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/articles/20210531a/&quot;&gt;サーバーレス連載&lt;/a&gt;の3記事目です&lt;/p&gt;
&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;GoでLambdaにデプロイするコードを書くにあたり、&lt;a href=&quot;https://github.com/aws/a</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>15分の壁を超えて。Lambda分散実行術</title>
    <link href="https://future-architect.github.io/articles/20210601a/"/>
    <id>https://future-architect.github.io/articles/20210601a/</id>
    <published>2021-05-31T15:00:00.000Z</published>
    <updated>2021-06-02T02:24:58.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>の真野です。<a href="/articles/20210531a/">Serverless連載2021</a>の2日目です。</p><p>AWSで一度Lambdaを利用すると、その利便性から徐々に利用範囲が広がっていくことがよく観測されます。一度だけならと一度手を出すと、いつの間にかLambda以外で動かすことによるイベント連携の手間や、キャパシティプランニング、CI/CDパイプライン構築と運用監視の手間など、フルマネージド及び周辺システムのエコシステムの恩恵を得られなくてイライラする事も、身体に耐性がついてつい利用量が増えていくこともしばしばです。（例のサイクルの画像は割愛）。</p><p>本記事ではAWS Lambdaでのバッチ処理について検討します。</p><h1 id="AWS-Lambdaとバッチ処理との相性"><a href="#AWS-Lambdaとバッチ処理との相性" class="headerlink" title="AWS Lambdaとバッチ処理との相性"></a>AWS Lambdaとバッチ処理との相性</h1><p>そんなAWS Lambdaですが2021.06.01時点では実行時間に制約があり<a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">15分</a>です。過去、<a href="https://aws.amazon.com/jp/blogs/news/aws-lambda-timeout-15min/">5分から15分にアップデート</a>された経緯がありますが、今後も何かしらの制約は残るでしょう。</p><p>そのため、AWS Lambdaのサービス単体でバッチ処理を行うのは難しく、他のサービスあるいは、他のサービスと組み合わせてバッチ処理を実現することが多いです。</p><p>よく見るのは以下3つでしょうか。</p><ol><li>ECSで処理</li><li>AWS Batchで処理</li><li>Step FunctionsとLambdaを組み合わせ</li></ol><p>3つ目のStep Functionsは<a href="/articles/20200515/">過去にまとめた</a>ことがあります。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200515/index.html" data-iframely-url="//cdn.iframe.ly/Wg0IM8H?card=small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><p>今回はLambda中毒者らしく、1のECSや2のAWS Batchに頼らず、3のStep Functionsでもなく、LambdaとKinesisでバッチ処理を実現しようと思います。</p><h1 id="Scatter-Fanout-パターン"><a href="#Scatter-Fanout-パターン" class="headerlink" title="Scatter(Fanout)パターン"></a>Scatter(Fanout)パターン</h1><p>Enterprise Integration Patternで分散・集約するパターンをScatter-Gatherパターンと呼びますが、今回はこちらの分散する部分のみを利用します。GatherなしのScatterパターンとはあまり聞かないので、Fanoutパターンが正しいのかもです。タイトルでは15分の壁を超えてとありますが、個別のLambdaでその壁は超えられないので、複数のLambdaを並列で実行させることで、それら処理時間の合計で仮想的に超えることにします。</p><img src="/images/20210601a/BroadcastAggregate.gif" alt="Scatter Gatherパターン" width="377" height="226" loading="lazy"><p><a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html">https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html</a></p><p>何かしらの入力ソースを元に、Lambdaで分散数だけKinesisにジョブを示すメッセージを送信。後続のLambdaで処理を行う構成にします。最初のLambdaがScatterと呼ばれる分散の開始部分です。</p><img src="/images/20210601a/scatter.png" alt="LambdaでKinesisにPutする図" width="801" height="377" loading="lazy"><p>Gatherについては、DynamoDBのIncrement an Atomic Counterなどを利用しつつ実装するのかなと思います。同じ設計で実装するのであれば下記のような構成になるかなと思います。</p><img src="/images/20210601a/gather.png" alt="DynamoDBを管理テーブルに利用する図" width="1200" height="576" loading="lazy"><p>ただ、現実的にはスクラッチでGatherの作り込みを行うのではなく、Step FunctionsやManaged Workflows for Apache Airflowを利用することが大半だと思いますので、本記事では細かい設計・実装について触れていきません。</p><h1 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h1><p>バッチ処理対象のデータはDynamoDBにあることにします。あるテーブルをフルスキャンしてそのデータを駆動にして何かしら処理を加えると仮定します。</p><p>コードは<a href="https://github.com/ma91n/servlerless-batch-example/tree/master/scatterkinesis">こちら</a>にあげていますので、適時参照ください。</p><h2 id="Kinesis-Data-Streamに連携するペイロード"><a href="#Kinesis-Data-Streamに連携するペイロード" class="headerlink" title="Kinesis Data Streamに連携するペイロード"></a>Kinesis Data Streamに連携するペイロード</h2><p>Jobという名前のStructの形式で連携します。Totalに分散トータル数、Segに今の分散番号を指定する仕様にします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">Total <span class="keyword">int64</span> <span class="string">`json:&quot;total&quot;`</span></span><br><span class="line">Seg   <span class="keyword">int64</span> <span class="string">`json:&quot;seg&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>また、処理対象のDynamoDBには7000件弱のデータと登録しました。</p><h2 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h2><p>最初に処理対象のDynamoDBテーブルの件数を取得し、一定のしきい値単位になるように分散数を計算します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"><span class="keyword">var</span> kc = kinesis.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(Handle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">resp, err := db.ScanWithContext(ctx, &amp;dynamodb.ScanInput&#123;</span><br><span class="line">Select:    aws.String(dynamodb.SelectCount),</span><br><span class="line">TableName: aws.String(<span class="string">&quot;TestTable&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>(*resp.Count) &gt; <span class="number">1000</span> &#123;</span><br><span class="line">total = <span class="keyword">int</span>(*resp.Count) / <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;i=%d\n&quot;</span>, i)</span><br><span class="line">job := Job&#123;</span><br><span class="line">Total: <span class="keyword">int64</span>(total),</span><br><span class="line">Seg:   <span class="keyword">int64</span>(i),</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(job)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err = kc.PutRecordWithContext(ctx, &amp;kinesis.PutRecordInput&#123;</span><br><span class="line">StreamName:   aws.String(<span class="string">&quot;scatter&quot;</span>),</span><br><span class="line">PartitionKey: aws.String(fmt.Sprintf(<span class="string">&quot;partitionKey-%d&quot;</span>, i)),</span><br><span class="line">Data:         b,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>db.ScanWithContext</code> でテーブル件数を取得し、今回はしきい値を1000で分散トータル数を導出しています。<br>あとは、その数だけKinesis Data StreamにJobを送信します。</p><p>動かしてみると、以下のような結果がでると、無事KinesisにメッセージをPutできています。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">START RequestId: 9469393a-eba9-4a21-9e98-8a3fc7f2a3f5 Version: $LATEST</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;0</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;1</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;2</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;3</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;4</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;5</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 i&#x3D;6</span><br><span class="line">2021&#x2F;06&#x2F;01 03:45:44 done</span><br><span class="line">END RequestId: 9469393a-eba9-4a21-9e98-8a3fc7f2a3f5</span><br><span class="line">REPORT RequestId: 9469393a-eba9-4a21-9e98-8a3fc7f2a3f5Duration: 299.30 msBilled Duration: 300 msMemory Size: 512 MBMax Memory Used: 45 MBInit Duration: 118.30 ms</span><br></pre></td></tr></table></figure><h2 id="並列処理部分"><a href="#並列処理部分" class="headerlink" title="並列処理部分"></a>並列処理部分</h2><p>次は、Kinesisのメッセージトリガーで起動するLambdaです。分散処理で行うメインの処理を実装する部分です。<br>今回は、 <code>executeBizLogic</code> の中身では単純に指定された件数のカウントを取る内容にしています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lambda.Start(Handle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(ctx context.Context, e events.KinesisEvent)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> e.Records &#123;</span><br><span class="line"><span class="keyword">var</span> job Job</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(r.Kinesis.Data, &amp;job); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count, err := executeBizLogic(ctx, job.Total, job.Seg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;count: %v&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeBizLogic</span><span class="params">(ctx context.Context, total, seg <span class="keyword">int64</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">out, err := db.ScanWithContext(ctx, &amp;dynamodb.ScanInput&#123;</span><br><span class="line">TableName:     aws.String(<span class="string">&quot;TestTable&quot;</span>),</span><br><span class="line">TotalSegments: aws.Int64(total),</span><br><span class="line">Segment:       aws.Int64(seg),</span><br><span class="line">Select:        aws.String(dynamodb.SelectCount),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;db.ScanWithContext: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *out.Count, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>動かしてみると以下のようなログが出る想定です。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2021-06-01T12:45:46.143+09:00START RequestId: d44ecc4c-433c-481b-9051-435280c81900 Version: $LATEST</span><br><span class="line">2021-06-01T12:45:46.338+09:002021&#x2F;06&#x2F;01 03:45:46 count: 1016</span><br><span class="line">2021-06-01T12:45:46.339+09:00END RequestId: d44ecc4c-433c-481b-9051-435280c81900</span><br><span class="line">2021-06-01T12:45:46.339+09:00REPORT RequestId: d44ecc4c-433c-481b-9051-435280c81900 Duration: 195.60 ms Billed Duration: 196 ms Memory Size: 512 MB Max Memory Used: 44 MB Init Duration: 107.35 ms</span><br><span class="line">2021-06-01T12:45:46.391+09:00START RequestId: bd6839aa-bdb0-40f5-9455-a9a445035b4d Version: $LATEST</span><br><span class="line">2021-06-01T12:45:46.406+09:002021&#x2F;06&#x2F;01 03:45:46 count: 1085</span><br><span class="line">2021-06-01T12:45:46.406+09:00END RequestId: bd6839aa-bdb0-40f5-9455-a9a445035b4d</span><br><span class="line">2021-06-01T12:45:46.406+09:00REPORT RequestId: bd6839aa-bdb0-40f5-9455-a9a445035b4d Duration: 10.36 ms Billed Duration: 11 ms Memory Size: 512 MB Max Memory Used: 45 MB</span><br><span class="line">aa4f-30057e967514 Duration: 7.72 ms Billed Duration: 8 ms Memory Size: 512 MB Max Memory Used: 45 MB</span><br><span class="line">中略</span><br><span class="line">2021-06-01T12:45:46.611+09:00START RequestId: 5f9cec98-2434-4872-8de9-df605b3e339c Version: $LATEST</span><br><span class="line">2021-06-01T12:45:46.624+09:002021&#x2F;06&#x2F;01 03:45:46 count: 1072</span><br><span class="line">2021-06-01T12:45:46.625+09:00END RequestId: 5f9cec98-2434-4872-8de9-df605b3e339c</span><br><span class="line">2021-06-01T12:45:46.625+09:00REPORT RequestId: 5f9cec98-2434-4872-8de9-df605b3e339c Duration: 8.59 ms Billed Duration: 9 ms Memory Size: 512 MB Max M</span><br></pre></td></tr></table></figure><p>最初のLambdaでKinesisに呼び出した分だけ、後続のLambdaが起動していることがわかると思います。</p><h1 id="この実装の使い所"><a href="#この実装の使い所" class="headerlink" title="この実装の使い所"></a>この実装の使い所</h1><p>ジョブの依存関係が多くない場合で、かつECSやAWS Batchを導入せずカジュアルに分散実行したい時に試せるかと思います。</p><p>また、今回の例としては分散トータル数＋分散番号の処理モデルですが、処理対象のデータモデル次第では、ユーザIDの範囲をしていしたり、良い感じのカーディナリティになる業務コードを指定しても良いかなと思います。支社CDとか営業エリアCDとかです。</p><h1 id="リランについて"><a href="#リランについて" class="headerlink" title="リランについて"></a>リランについて</h1><p>後続のLambdaのある分散番号だけ障害が発生し、リカバリが必要になった場合の対応について説明します。</p><p>今回の実装では作り込んでいないんですが、例えばエラージョブキューを格納するDead Letter Queueを用意するのが一手です。ちょっとツールで利用する用途であれば、連携された連携情報を awscli で直接Kinesisにputするのも一手だと思います</p><h1 id="処理データの一貫性"><a href="#処理データの一貫性" class="headerlink" title="処理データの一貫性"></a>処理データの一貫性</h1><p>実行するLambdaが分割される関係上、利用するのがPostgreSQLのようなRDBであっても、バッチ処理全体の処理結果の一貫性を保つことはできません。そのため分散処理単位で登録してよいかが利用する上での大前提だと思います。</p><h1 id="実用上の話"><a href="#実用上の話" class="headerlink" title="実用上の話"></a>実用上の話</h1><p>この手の分散処理を1日に複数回実行し、かつある分散処理番号のみ失敗する場合を考慮すると、システム運用上の負荷が高まります。</p><p>そのため、実用に耐えうるためにはScatterのLambdaの起動のたびに一意な実行IDを取得し、それをキーに管理テーブルを用意することが多いと思います。それぞれが成功・失敗・処理中などのステータスを持つと役立つことが多いです。それぞれの処理件数や処理時間を格納すると嬉しいこともおおいでしょう。</p><p>一方でそこまでやるのであれば、Managed Workflows for Apache Airflowといったワークフローエンジンの導入も検討したほうが良いかもしれません。</p><p>また、分散しなくてもAWS BatchやECSで15分の制約を持たないサービスを選定したほうが良い場面は多分にあるので、程々に利用しましょう。</p><h1 id="インフラ上の注意"><a href="#インフラ上の注意" class="headerlink" title="インフラ上の注意"></a>インフラ上の注意</h1><p>並列処理Lambdaですが、Kinesisトリガーのバッチサイズは <code>1</code> が推奨です。これが10などにすると今回だとタイミングによっては1つのLambdaですべてメッセージを処理してしまう可能性があるからです。</p><p>また、 <code>シャードあたりの同時バッチ</code> で1シャードあたりの同時起動数を制御できます。デフォルトはおそらく1です。現状は1シャードあたり最大10までです。Kinesis Data Streamをジョブキューとして利用すると、だいたいシャードは1なので通常は同時起動数の制約がここで決まります。</p><p><a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/11/aws-lambda-supports-parallelization-factor-for-kinesis-and-dynamodb-event-sources/">https://aws.amazon.com/jp/about-aws/whats-new/2019/11/aws-lambda-supports-parallelization-factor-for-kinesis-and-dynamodb-event-sources/</a></p><p>通常は10並列で十分かと思いますが、もし上げたい場合はシャードを増やす対応です。多少費用が増えますが通常は誤差の範囲かと思います。</p><h1 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h1><p>AWS Lambda実行時間15分の壁は、当然ハードリミットなのでそれ単体では超えられないですが、Kinesis Data Streamsと組み合わせて、仮想的にコンピューティング時間の合計で15分を越えようという記事でした。</p><p>実用上はいくつか壁があるので、用法用量を守り正しく参考にしていただければ幸いです。</p><p>次は伊藤真彦さんの<a href="/articles/20210602a/">AWS LambdaにおけるGo Contextの取り扱い</a>です。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">Technology Innovation Group（TIG）は、「最先端、且つ先進的なテクノロジーのプロフェッショナル集団」、「プロジェクト品質と生産性の向上」、「自社サービス事業の立ち上げ」を主なミッションとする、技術部隊です。DXユニットとはデジタルトランスフォーメーションを推進するチームで、IoTやらMaaSなどのテクノロジーカットでビジネス転換を行います。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;TIG DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Serverless" scheme="https://future-architect.github.io/tags/Serverless/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="バッチ処理" scheme="https://future-architect.github.io/tags/%E3%83%90%E3%83%83%E3%83%81%E5%87%A6%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Kinesis+Lambda構成での、処理遅延を監視する</title>
    <link href="https://future-architect.github.io/articles/20210531b/"/>
    <id>https://future-architect.github.io/articles/20210531b/</id>
    <published>2021-05-30T15:00:01.000Z</published>
    <updated>2021-05-31T01:56:39.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャー棚井龍之介です。</p><p>本ブログでは、<a href="/articles/20210531a/">サーバレス連載</a>の第1日目として、「Kinesis+Lambda構成」でのメトリクス監視について取り上げます。</p><p><strong>データ流入量が徐々に増加する見込み</strong>のとき、各リソースのどのメトリクスを重点チェックすべきか。また、メトリクスがリソースの制限にぶつかった場合やアラート検知された場合にどのような対応アクションを取るべきか。KinesisやLambdaのリソース監視設定から得た知見を、本ブログに整理しました。</p><p>そもそもの「サーバレスって、何が便利なんだっけ？」から整理したい方は、<a href="https://aws.amazon.com/jp/builders-flash/202003/awsgeek-serverless/?awsf.filter-name=*all">AWS公式のグラレコ解説記事</a>をご覧ください。</p><h1 id="今回のサーバレス構成"><a href="#今回のサーバレス構成" class="headerlink" title="今回のサーバレス構成"></a>今回のサーバレス構成</h1><p>「Amazon Kinesis Data Streamでデータを受け、AWS Lambdaがコンシュームする構成」を本ブログで想定する環境とします。</p><p>AWS本家の<a href="https://aws.amazon.com/jp/serverless/patterns/serverless-pattern/">形で考えるサーバレス設計</a>でも「流入データの連続処理」として取り上げられおり、サーバレスという用語に馴染みのないエンジニアにもよく知られたデータフロー構成ではないでしょうか。</p><img src="/images/20210531b/Pattern-Streaming.7b2876deed217d21f4e4e326fe1535be25cb9603.png" alt="Kinesisで受けてLambdaからS3へ書き込む図" width="832" height="218" loading="lazy"><p>大量データの受信にはKinesisを使い、受信データのコンピュートはLambdaでやりくりする。この構成はシンプルで分かりやすく、かつ、各リソースをスケールしやすいため、データ連携やデータ保存などのあらゆるケースに応用が効く、ベーシックなインフラ構成だと思います。</p><p>どちらもフルマネージドサービスなため、管理運用コストはほとんとかからないのですが、こと「データ流入量がどんどん増える場合」にはその限りではありません。後続で説明するCloudWatchのメトリクス監視を設定し、通知やアラートを受けた場合にはリソースの拡張・スケーリング対応が必要となります。</p><h1 id="リソース監視の基本"><a href="#リソース監視の基本" class="headerlink" title="リソース監視の基本"></a>リソース監視の基本</h1><p>AWSリソースの監視には、<a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/cloudwatch_architecture.html">CloudWatch</a>を活用します。</p><p>Amazon CloudWatchを利用することにより、AWSリソースサービスの利用状況や、各サービスの出力する情報を<a href="https://wa3.i-3-i.info/word17778.html">モニタリング</a>できます。</p><p>各リソースの出力する情報は「メトリクス(Metrics)」としてAWSサービス内に集約されています。CloudWatchに追加設定を入れることで「このメトリクスが急上昇した場合には、社員にメールで通知して」や「あのメトリクスが80%を上回ったら、自動でリソースを増強して」などを登録し、緊急時のシステム対応に備えることができます。</p><img src="/images/20210531b/CW-Overview.png" alt="CloudWatchサービスの概念図" width="604" height="385" loading="lazy"><p>EC2やRDSの運用経験があれば、メトリクス監視は「当たり前に実施すべき」と言われても違和感は無いと思います。<br>しかし、システムの運用経験が「エンジニアになってこのかた、サーバレスのみ」だと、「フルマネージドサービスなのだから、メトリクスの監視設定はいらないよね。エラー監視は当然だとしても、リソース増強は全て自動でしょ」と勘違いしてしまうケースが見受けられます。</p><p>サーバレス構成だとしてもメトリクス監視は必須であり、それを怠ってしまうと「知らないうちに、システムの動きがおかしくなっている」状況になります。</p><p>筆者自身の経験では、Lambdaの代表的なメトリクス <strong>IteratorAge</strong> の監視が漏れたことにより「リアルタイム処理と謳っているが、実際のデータ連携には〇〇時間要する」というケースがありました。サービスの非機能要件を担保するためにも、メトリクス監視は徹底すべきです。</p><h1 id="監視メトリクス"><a href="#監視メトリクス" class="headerlink" title="監視メトリクス"></a>監視メトリクス</h1><p>Kinesis+Lambda構成の場合、<a href="https://docs.aws.amazon.com/ja_jp/wellarchitected/latest/serverless-applications-lens/welcome.html">最低でも以下のメトリクス</a>には監視・アラート通知設定を入れましょう。</p><table><thead><tr><th>#</th><th>AWSサービス名</th><th>メトリクス名</th><th>説明</th></tr></thead><tbody><tr><td>1</td><td>AWS Lambda</td><td>Errors</td><td>関数エラーが発生した呼び出しの数</td></tr><tr><td>2</td><td>AWS Lambda</td><td>Throttling</td><td>スロットリングされた呼び出しのリクエスト数</td></tr><tr><td>3</td><td>AWS Lambda</td><td>Duration</td><td>関数コードがイベントの処理に費やす時間</td></tr><tr><td>4</td><td>AWS Lambda</td><td>ConcurrentExecutions</td><td>イベントを処理している関数インスタンスの数</td></tr><tr><td>5</td><td>AWS Lambda</td><td>IteratorAge</td><td>あるデータをKinesisが受信してから、そのデータをLambdaに送信するまでの時間</td></tr><tr><td>6</td><td>Amazon Kinesis Date Stream</td><td>ReadProvisionedThroughputExceeded</td><td>データ取得要求が、Kinesisのスループット上限に達して調整が行われた</td></tr><tr><td>7</td><td>Amazon Kinesis Date Stream</td><td>WriteProvisionedThroughputExceeded</td><td>データ書き込みが、Kinesisのスループット上限に達して失敗した</td></tr><tr><td>8</td><td>Amazon Kinesis Date Stream</td><td>GetRecords.IteratorAgeMilliseconds</td><td>Kinesisにレコードが滞在した時間</td></tr><tr><td>9</td><td>Amazon Kinesis Date Stream</td><td>GetRecords.Success</td><td>Kinesisから正しく取得されたレコードの数</td></tr></tbody></table><p>これらのメトリクス監視を入れることで、Kinesis, Lambdaサーバレスリソースの「フルマネージドではない部分」までにも目が行き届くようになります。</p><h2 id="アラート通知が届いたら"><a href="#アラート通知が届いたら" class="headerlink" title="アラート通知が届いたら"></a>アラート通知が届いたら</h2><p>メトリクス監視を入れることで、リソースの負荷上昇をアラートで検知できるようになります。<br>基本的には「ボトルネックの特定 → 解決/緩和アクションの実施 → 継続監視 → アラートの未再発を確認し対応クローズ or 原因の再調査」の対応フローとなります。</p><p>エラーが発生した場合や、データが全く届かないケースであれば、原因の切り分けは容易だと思います。<br>しかし、「処理遅延」のような処理時間が徐々に長くなっているケースでは、関数内部ロジックの修正やリソースの増強が必要になります。</p><p>代表的なアクションとしては</p><ul><li>Lambda<ul><li>アプリケーションの内部ロジックを見直す<ul><li>別リソースとの接続時間を調べる</li><li>詳細調査のためにログ出力を追加する</li></ul></li><li>メモリを増強する</li><li>同時実行数の上限緩和を申請する</li><li>並列化系数を増やす</li></ul></li><li>Kinesis<ul><li>シャード数を増やす</li><li>データ保存期間を延長する</li></ul></li></ul><p>などが考えられます。</p><p>いずれにしても「<strong>ボトルネックの特定</strong>」が最優先であり、原因に対してピンポイントで対処すべきです。<br>アラート通知時に慌てないためにも、CloudWatchのコンソール画面に日頃から慣れておくことも大事です。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>サーバレス構成でのメトリクス監視について、入門的な内容として、Kinesis+Lambda構成にフォーカスして説明しました。フルマネージドサービスは基本的に「ほったらかし」でも大きな問題は発生しませんが、徐々に負荷が高まるケースでは「気づいたら、大変なことになっていた」という笑えない状況が発生しがちです。</p><p>面倒な作業はAWS側に任せられるとしても、最終的なサービス稼働監視は「利用者側の責務」と意識して、メトリクスの監視設定は必ず入れるようにしましょう。</p><p><a href="/articles/20210531a/">サーバレス連載</a>の第1日目でした。次は真野さんの「15分の壁を超えるLambda分散実行術」です</p><h2 id="参照記事"><a href="#参照記事" class="headerlink" title="参照記事"></a>参照記事</h2><ul><li><a href="https://aws.amazon.com/jp/builders-flash/202003/awsgeek-serverless/?awsf.filter-name=*all">サーバーレスって何が便利なの ? AWS でサーバーレスを構築するためのサービスをグラレコで解説</a></li><li><a href="https://aws.amazon.com/jp/serverless/patterns/serverless-pattern/">形で考えるサーバーレス設計</a></li><li><a href="https://wa3.i-3-i.info/word17778.html">モニタリング (monitoring)</a></li><li><a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/cloudwatch_architecture.html">Amazon CloudWatch の仕組み</a></li><li><a href="https://docs.aws.amazon.com/ja_jp/wellarchitected/latest/serverless-applications-lens/wellarchitected-serverless-applications-lens.pdf">サーバーレスアプリケーションレンズ - AWS Well-Architected フレームワーク</a></li><li><a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/monitoring-metrics.html">AWS Lambda 関数メトリクスの使用</a></li><li><a href="https://docs.aws.amazon.com/ja_jp/streams/latest/dev/monitoring-with-cloudwatch.html">Amazon CloudWatch を使用した Amazon Kinesis Data Streams サービスのモニタリング</a></li><li><a href="https://kashionki38.hatenablog.com/entry/2020/04/19/010009">Kinesis, Lambdaのボトルネック解析時の考慮点</a></li><li><a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/kinesis-data-streams-iteratorage-metric/">Kinesis Data Streams で IteratorAgeMilliseconds の値が増え続けるのはなぜですか?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;フューチャー棚井龍之介です。&lt;/p&gt;
&lt;p&gt;本ブログでは、&lt;a href=&quot;/articles/20210531a/&quot;&gt;サー</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="保守運用" scheme="https://future-architect.github.io/tags/%E4%BF%9D%E5%AE%88%E9%81%8B%E7%94%A8/"/>
    
    <category term="Serverless" scheme="https://future-architect.github.io/tags/Serverless/"/>
    
    <category term="Lambda" scheme="https://future-architect.github.io/tags/Lambda/"/>
    
    <category term="Kinesis" scheme="https://future-architect.github.io/tags/Kinesis/"/>
    
  </entry>
  
  <entry>
    <title>Serverless連載2021を始めます</title>
    <link href="https://future-architect.github.io/articles/20210531a/"/>
    <id>https://future-architect.github.io/articles/20210531a/</id>
    <published>2021-05-30T15:00:00.000Z</published>
    <updated>2021-06-02T02:25:08.889Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIGの<a href="https://twitter.com/kaedemalu">伊藤太斉</a>です。</p><p>2021年もServerless連載を開催します！</p><h2 id="サーバーレスについて"><a href="#サーバーレスについて" class="headerlink" title="サーバーレスについて"></a>サーバーレスについて</h2><img src="/images/20210531a/lightning-bolt-1203953_640.png" alt="" width="640" height="360" loading="lazy"><p>サーバーレスは、「サーバーが存在しない」ではなく「サーバーの管理を不要、もしくは極小化する」ことを主眼においた考え方です。</p><p>パブリッククラウドには必ずと言っていいほどFaaS（Function as a Service）が存在し、それらを一般的にサーバーレスサービスとして扱っています。代表的にはAWSのLambda、GCPのCloud Functionsなどが該当し、どんなシステムを構築する際にも目にするようになりました。</p><p>クラウドリフトにおいては従来Cronなどをジョブで回していたものをクラウドのレイヤに切り出して管理しやすくしたり、新規サービスを構築する場合では従来のようにIaaS中心の構成ではなく、サーバーレスアーキテクチャを検討、利用することも増えています。</p><p>フューチャーでも先日サーバーレスアーキテクチャを主とした案件の<a href="https://prtimes.jp/main/html/rd/p/000000465.000004374.html">プレスリリース</a>を展開しており、社内でも関心が高まり、浸潤しています。</p><p>そんなより盛り上がりを見せているサーバーレスについて連載として2021年も取り上げます。</p><h2 id="連載計画"><a href="#連載計画" class="headerlink" title="連載計画"></a>連載計画</h2><p>2021年の連載順は以下になっています！</p><p>掲載順や日付が変わることがありますが、ご了承ください。</p><table><thead><tr><th>日付</th><th>名前</th><th>タイトル</th></tr></thead><tbody><tr><td>5/31</td><td>棚井龍之介</td><td><a href="/articles/20210531b/">Kinesis+Lambda構成での、処理遅延を監視する</a></td></tr><tr><td>6/1</td><td>真野隼記</td><td><a href="/articles/20210601a/">15分の壁を超えて。Lambda分散実行術</a></td></tr><tr><td>6/2</td><td>伊藤真彦</td><td><a href="/articles/20210602a/">LambdaにおけるGo Contextの取り扱い</a></td></tr><tr><td>6/3</td><td>辻大志郎</td><td>静的解析によるInvalidなAWS Lambda関数シグネチャの検知</td></tr><tr><td>6/4</td><td>澁川喜規</td><td>続・サーバーレス検索エンジン</td></tr></tbody></table><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今やクラウドを使う時に必ずどこかで利用するといっても過言ではないサーバーレスのサービスですが、サーバーのことをある程度気にしない（=マネージドに寄せる）など管理を楽にするためにも今度もどんどん使っていきたいですね！</p><p>2020年の連載もぜひ見てください！</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200322/index.html" data-iframely-url="//cdn.iframe.ly/api/iframe?url=https%3A%2F%2Ffuture-architect.github.io%2Farticles%2F20200322%2F&key=42622142e53a4cc5ab36703bcee5415f"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。TIGの&lt;a href=&quot;https://twitter.com/kaedemalu&quot;&gt;伊藤太斉&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;2021年もServerless連載を開催します！&lt;/p&gt;
&lt;h2 id=&quot;サーバーレスについて&quot;&gt;&lt;a href=&quot;#サーバーレスにつ</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="Serverless" scheme="https://future-architect.github.io/tags/Serverless/"/>
    
  </entry>
  
  <entry>
    <title>Airflow Breeze を利用してローカルで Airflow を起動する</title>
    <link href="https://future-architect.github.io/articles/20210528a/"/>
    <id>https://future-architect.github.io/articles/20210528a/</id>
    <published>2021-05-27T15:00:00.000Z</published>
    <updated>2021-05-27T15:51:37.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>TIG の多賀です。</p><p>OSS として Airflow へ貢献するにあたり、ローカルでの実行やテストの環境整備が必要になります。また、 Airflow を利用するにあたってもローカルでの動作確認をしたいケースは多いかと思います。</p><p>Airflow では、 <code>Airflow Breeze</code> と呼ばれる環境が整備され、公式より提供されています。当記事では、 <code>Airflow Breeze</code> について概要を記載し、 Airflow への OSS 貢献の入り口となれば良いと考えています。</p><h2 id="Airflow-Breeze-とは"><a href="#Airflow-Breeze-とは" class="headerlink" title="Airflow Breeze とは"></a>Airflow Breeze とは</h2><p>Airflow Breeze とは、ローカルで Airflow を簡単に実行できるように整備された環境を指します。実態はコンテナベースで構築され、Docker Compose が利用されています。</p><img src="/images/20210528a/AirflowBreeze_logo.png" alt="Airflow Breezeロゴ" loading="lazy"><p><a href="https://github.com/apache/airflow/blob/master/images/AirflowBreeze_logo.png">airflow/AirflowBreeze_logo.png at master · apache/airflow</a></p><p>Airflow Breeze の環境を整備することで、Airflow が依存する外部コンポーネント(MySQL, Redis, etc..) を完全に含んだ環境を作成できます。<br>一方、リソースを結構使うため注意が必要です。</p><p>詳細はドキュメントととしてまとまっています。当記事ではピックアップした情報を記載します。<br><a href="https://github.com/apache/airflow/blob/master/BREEZE.rst">airflow/BREEZE.rst at master · apache/airflow</a></p><h3 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h3><p>以下環境で整備します。</p><ul><li>macOS Mojave 10.14.6</li><li>Docker version 20.10.6, build 370c289</li><li>docker-compose version 1.29.1, build c34c88b2</li><li>Airflow master branch (commit hash: 180df03482b07c18a57d20235ccdd1c3a12d9173)</li></ul><h3 id="Breeze-Install"><a href="#Breeze-Install" class="headerlink" title="Breeze Install"></a>Breeze Install</h3><p><code>getopt</code> と <code>gstat</code> が必要なため、インストールします。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gnu-getopt coreutils</span><br></pre></td></tr></table></figure><p><code>getopt</code> 向けに PATH を通します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/opt/gnu-getopt/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ getopt --version</span><br><span class="line">getopt from util-linux 2.36.2</span><br><span class="line"></span><br><span class="line">❯ gstat --version</span><br><span class="line"><span class="built_in">stat</span> (GNU coreutils) 8.32</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Written by Michael Meskes.</span><br></pre></td></tr></table></figure><p>つづいて、Airflow のリポジトリを clone します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/airflow.git</span><br></pre></td></tr></table></figure><p>clone した Airflow リポジトリへ移動して、Breeze をインストールして Airflow を 起動します。<br>( <code>./breeze</code> 内部は 長大な Shell Script になっています。)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze start-airflow</span><br></pre></td></tr></table></figure><p>ここから完了まで 10分程度待ちます。</p><p>完了すると、Airflow コンテナ内にログインした状態になります。</p><p>自動で tmux のセッションが開始され、以下のような画面が出てきます。</p><img src="/images/20210528a/スクリーンショット_2021-05-20_10.45.22.png" alt="tmuxの画面" loading="lazy"><p>各 Pane ごとに整理すると以下のようになります。</p><table><thead><tr><th>Pane 位置</th><th></th><th>実行コマンド</th></tr></thead><tbody><tr><td>左上</td><td>airflow コンテナシェルログイン</td><td>-</td></tr><tr><td>右上</td><td>airflow ui</td><td><code>cd /opt/airflow/airflow/www/; yarn install --frozen-lockfile; yarn dev</code></td></tr><tr><td>左下</td><td>airflow scheduler 実行</td><td><code>airflow scheduler</code></td></tr><tr><td>右下</td><td>airflow webserver 実行</td><td><code>airflow webserver</code></td></tr></tbody></table><p>Airflow の実行と tmux を終了したい場合は、 <code>airflow_stop</code> コマンドをコンテナ内で実行することで終了できます。<br>ブラウザで  <code>http://127.0.0.1:28080</code> へリクエストすると Airflow UI へアクセスできます。(ログインは ユーザー/パスワード 共に <code>admin</code> です。)</p><img src="/images/20210528a/スクリーンショット_2021-05-20_10.35.21.png" alt="Airflow管理画面" loading="lazy"><h3 id="Breeze-環境"><a href="#Breeze-環境" class="headerlink" title="Breeze 環境"></a>Breeze 環境</h3><p>環境変数 <code>AIRFLOW_HOME</code> は、 <code>/root/airflow</code> になっています。<br>ログイン後には、 環境変数 <code>AIRFLOW_SOURCE</code> である <code>/opt/airflow</code> 配下におり、こちらはローカル端末の Airflow ソースコードがコピーされています。(対象は <code>.dockerignore</code> で絞り込まれているので全ソースコードではないです。)</p><p>動作確認用に DAG ファイルを配置したい場合、ローカル端末の airflow 直下 <code>./files/dags</code> 以下に配置することで反映されます。コンテナ内の <code>AIRFLOW__CORE__DAGS_FOLDER</code> 環境変数がコンテナ内 <code>/files/dags</code>  を指しており、コンテナ内 <code>/files/dags</code> はローカル端末上の <code>./files/dags</code> をマウントしているためです。</p><p><a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#dags-folder">AIRFLOW__CORE__DAGS_FOLDER — Airflow Documentation</a></p><p>ファイルを配置してから Airflow UI への反映は5分程度ラグがあります。</p><img src="/images/20210528a/スクリーンショット_2021-05-20_11.13.08.png" alt="Airflow UI" loading="lazy"><p><strong>※ 補足</strong><br>UI 反映のラグを短くしたい場合は、 コンテナ内 <code>/root/airflow/airflow.cfg</code> の以下設定値を修正の上、airflow webserver/scheduler を再起動することで反映できます。<br>(※ ディレクトリの読み込み頻度を上げるほど、サーバー負荷は上がります。)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># デフォルトで 5分設定のためより短い秒数を指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often (in seconds) to scan the DAGs directory for new files. Default to 5 minutes.</span></span><br><span class="line">dag_dir_list_interval = 300</span><br></pre></td></tr></table></figure><h3 id="breeze-コマンド"><a href="#breeze-コマンド" class="headerlink" title="breeze コマンド"></a>breeze コマンド</h3><p>breeze コマンドにはいくつかのサブコマンドが用意されています。</p><p><code>コンテナ内シェルログイン</code><br>(※ airflow webserver/scheduler は起動しない)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze (shell)</span><br></pre></td></tr></table></figure><p><code>再起動</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze restart</span><br></pre></td></tr></table></figure><p><code>開始/停止</code><br>(※ airflow webserver/scheduler を起動する)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze start-airflow/stop</span><br></pre></td></tr></table></figure><p><code>イメージの削除</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze cleanup-image</span><br></pre></td></tr></table></figure><p>その他いろいろ用意されています。<br><a href="https://github.com/apache/airflow/blob/master/BREEZE.rst#airflow-breeze-syntax">airflow/BREEZE.rst at master · apache/airflow</a></p><h3 id="テスト実行"><a href="#テスト実行" class="headerlink" title="テスト実行"></a>テスト実行</h3><p>CI の環境としても利用されていることもあり、テストを実行することができます。</p><p>Airflow ではテストの種類としては以下3種類が定義されています。 (<a href="https://github.com/apache/airflow/blob/master/TESTING.rst#airflow-test-infrastructure">airflow/TESTING.rst at master · apache/airflow</a> より)</p><ul><li>Unit Tests<ul><li>単体テスト。追加の Integration は不要であり、Airflow 実行環境内で完結する。</li><li>ローカル仮想環境 or Breeze 環境下で実施</li></ul></li><li>Integration Tests<ul><li>結合テスト。外部 Integration を用意しテストを行う。Integration は実際のサービスを起動して実施する。(コンテナ利用)</li><li>Breeze 環境下で実施</li></ul></li><li>System Tests<ul><li>システムテスト。外部システムと連携して行うテスト</li><li>システム実行環境下(クラウド環境等) で実際に動かすテストを指す</li></ul></li></ul><p>ここでは、 Unit Tests と Integration Tests について詳細を記載します。</p><h4 id="Unit-Tests"><a href="#Unit-Tests" class="headerlink" title="Unit Tests"></a>Unit Tests</h4><p>Breeze 環境へログインして、 <code>pytest</code> を実行することでテスト可能です。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Breeze 環境へログイン</span></span><br><span class="line">❯ ./breeze shell</span><br><span class="line"></span><br><span class="line">root@b12df7904cd7:/opt/airflow<span class="comment"># pytest tests/core/test_core.py::TestCore::test_check_operators</span></span><br><span class="line">============================================================================== <span class="built_in">test</span> session starts ===============================================================================</span><br><span class="line">platform linux -- Python 3.6.13, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- /usr/<span class="built_in">local</span>/bin/python</span><br><span class="line">cachedir: .pytest_cache</span><br><span class="line">rootdir: /opt/airflow, configfile: pytest.ini</span><br><span class="line">plugins: forked-1.3.0, rerunfailures-9.1.1, xdist-2.2.1, flaky-3.7.0, celery-4.4.7, timeouts-1.2.1, cov-2.11.1, httpx-0.12.0, instafail-0.4.2, requests-mock-1.9.2</span><br><span class="line">setup timeout: 0.0s, execution timeout: 0.0s, teardown timeout: 0.0s</span><br><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">tests/core/test_core.py::TestCore::test_check_operators PASSED                                                                                                             [100%]</span><br><span class="line">========================================================================= 1 passed, 7 warnings <span class="keyword">in</span> 8.43s ==========================================================================</span><br></pre></td></tr></table></figure><h4 id="Integration-Test"><a href="#Integration-Test" class="headerlink" title="Integration Test"></a>Integration Test</h4><p>Breeze 環境はデフォルトでは、 Integration コンポーネントを起動しない設定になっており、該当の Integration Test もスキップされます。<br>Integration Test を実施したい場合は、Breeze 起動時にフラグを指定します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis 利用テスト準備</span></span><br><span class="line">./breeze --integration redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis コンテナも起動される</span></span><br><span class="line">❯ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                COMMAND                  CREATED          STATUS                    PORTS                                                                                      NAMES</span><br><span class="line">f9687f175fb7   apache/airflow:master-python3.6-ci   <span class="string">&quot;/usr/bin/dumb-init …&quot;</span>   30 seconds ago   Up 21 seconds             0.0.0.0:25555-&gt;5555/tcp, :::25555-&gt;5555/tcp, 0.0.0.0:28080-&gt;8080/tcp, :::28080-&gt;8080/tcp   docker-compose_airflow_run_748d17ffd2bd</span><br><span class="line">c3fe4b732d64   redis:5.0.1                          <span class="string">&quot;docker-entrypoint.s…&quot;</span>   41 seconds ago   Up 37 seconds (healthy)   0.0.0.0:26379-&gt;6379/tcp, :::26379-&gt;6379/tcp                                                docker-compose_redis_1</span><br></pre></td></tr></table></figure><p>テスト実行は、 <code>pytest</code> が利用されています。起動したコンテナ内で実行します。<br>Integration テスト実行のためには、 <code>--integration</code> パラメータで利用する Integration を指定します。内部的には <code>@pytest.mark.integration</code> アノテーションで制御されており、パラメータ指定した Integration テストを実行します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Breeze 環境へログイン</span></span><br><span class="line">❯ ./breeze shell</span><br><span class="line"></span><br><span class="line">root@319e81b37959:/opt/airflow<span class="comment"># pytest --tb=no --integration redis tests/providers/redis/hooks/</span></span><br><span class="line">__init__.py    test_redis.py</span><br><span class="line">root@319e81b37959:/opt/airflow<span class="comment"># pytest --tb=no --integration redis tests/providers/redis/hooks/test_redis.py::TestRedisHook::test_real_get_and_set</span></span><br><span class="line">============================================================================== <span class="built_in">test</span> session starts ===============================================================================</span><br><span class="line">platform linux -- Python 3.6.13, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- /usr/<span class="built_in">local</span>/bin/python</span><br><span class="line">cachedir: .pytest_cache</span><br><span class="line">rootdir: /opt/airflow, configfile: pytest.ini</span><br><span class="line">plugins: forked-1.3.0, rerunfailures-9.1.1, xdist-2.2.1, flaky-3.7.0, celery-4.4.7, timeouts-1.2.1, cov-2.11.1, httpx-0.12.0, instafail-0.4.2, requests-mock-1.9.2</span><br><span class="line">setup timeout: 0.0s, execution timeout: 0.0s, teardown timeout: 0.0s</span><br><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">tests/providers/redis/hooks/test_redis.py::TestRedisHook::test_real_get_and_set PASSED                                                                                     [100%]</span><br><span class="line"></span><br><span class="line">=============================================================================== 1 passed <span class="keyword">in</span> 1.34s ================================================================================</span><br></pre></td></tr></table></figure><h4 id="Kubernetes-Tests"><a href="#Kubernetes-Tests" class="headerlink" title="Kubernetes Tests"></a>Kubernetes Tests</h4><p>Integration Tests の一種である、Kubernetes 上での実行のテストも Breeze 上で実行することができます。(標準で整備されていることからも Kubernetes 上での実行が当たり前な世界が垣間見えますね。)<br>Kubernetes Cluster は <a href="https://kind.sigs.k8s.io/">Kind</a> を利用してローカル環境上に起動します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze kind-cluster start</span><br></pre></td></tr></table></figure><p>Cluster が起動したら、Airflow を Kubernetes へデプロイします。(少し待ちます)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze kind-cluster deploy</span><br></pre></td></tr></table></figure><p>デプロイが完了すると Airflow が Kubernetes 上で起動してます。<br><code>http://127.0.0.1:8080</code> へアクセスすると Airflow UI が確認できます。(※ ポートが Breeze と違うので注意してください。ユーザー/パスは <code>admin</code> です。)</p><img src="/images/20210528a/Pasted_image_20210520175955.png" alt="Airflow UI" loading="lazy"><p>テストを実行してみます。テストはローカル端末上で以下コマンドで実行できます。<br>(ローカル端末上に仮想環境が作成されます。コマンド内で <code>./scripts/ci/kubernetes/ci_run_kubernetes_tests.sh</code> (<a href="https://github.com/apache/airflow/blob/master/scripts/ci/kubernetes/ci_run_kubernetes_tests.sh">参照</a>)を実行しています。)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">❯ ./breeze kind-cluster <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">============================================================================== <span class="built_in">test</span> session starts ===============================================================================</span><br><span class="line">platform darwin -- Python 3.6.9, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- /Users/taga3041/.ghq/github.com/apache/airflow/.build/.kubernetes_venv/airflow-python-3.6-v1.20.2_host_python_3.6/bin/python3</span><br><span class="line">cachedir: .pytest_cache</span><br><span class="line">rootdir: /Users/taga3041/.ghq/github.com/apache/airflow, configfile: pytest.ini</span><br><span class="line">plugins: cov-2.11.1</span><br><span class="line">collected 53 items</span><br><span class="line"></span><br><span class="line">kubernetes_tests/test_kubernetes_executor.py::TestKubernetesExecutor::test_integration_run_dag PASSED                                                                      [  1%]</span><br><span class="line">kubernetes_tests/test_kubernetes_executor.py::TestKubernetesExecutor::test_integration_run_dag_with_scheduler_failure PASSED                                               [  3%]</span><br><span class="line">kubernetes_tests/test_kubernetes_pod_operator.py::TestKubernetesPodOperatorSystem::test_config_path_move PASSED                                                            [  5%]</span><br><span class="line">...</span><br><span class="line">kubernetes_tests/test_other_executors.py::TestCeleryAndLocalExecutor::test_integration_run_dag SKIPPED (Does not run on KubernetesExecutor)                                [ 98%]</span><br><span class="line">kubernetes_tests/test_other_executors.py::TestCeleryAndLocalExecutor::test_integration_run_dag_with_scheduler_failure SKIPPED (Does not run on KubernetesExecutor)         [100%]</span><br><span class="line"></span><br><span class="line">============================================================= 51 passed, 2 skipped, 4 warnings <span class="keyword">in</span> 404.65s (0:06:44) ==============================================================</span><br><span class="line">Exported logs <span class="keyword">for</span> cluster <span class="string">&quot;airflow-python-3.6-v1.20.2&quot;</span> to:</span><br><span class="line">/tmp/kind_logs_2021-05-20_0_0</span><br></pre></td></tr></table></figure><p>最後に Cluster を停止します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./breeze kind-cluster stop</span><br></pre></td></tr></table></figure><h2 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h2><p>Airflow にて提供されている、ローカル環境/テスト環境向けの Airflow Breeze について紹介しました。<code>./breeze</code> コマンドで諸々整備されていて便利ですが、様々なコンポーネントが関与しているため、動かすのに少し苦労しました(プロキシ周りがほとんどですが)。</p><p>それだけ複雑なテストケースが想定されていて、OSS でここまで管理されているのは改めてすごいなと思いました。</p><p>Airflow はクセが強いですが 最近(2020/12) バージョン 2.0 にアップデートされたりして、積極的に改善されており今後も注目な OSS だと思います。次は何かしらコントリビュートしたいです。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/apache/airflow/blob/master/BREEZE.rst#running-kubernetes-tests">airflow/BREEZE.rst at master · apache/airflow</a></li><li><a href="https://github.com/apache/airflow/blob/master/TESTING.rst#running-tests-with-kubernetes">airflow/TESTING.rst at master · apache/airflow</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;TIG の多賀です。&lt;/p&gt;
&lt;p&gt;OSS として Airflow へ貢献するにあたり、ローカルでの実行やテストの環境整備が必要になります。</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Airflow" scheme="https://future-architect.github.io/tags/Airflow/"/>
    
  </entry>
  
  <entry>
    <title>Future Tech Night #9 ～運用で後悔しないためのAWS設計術～　を開催しました。</title>
    <link href="https://future-architect.github.io/articles/20210527a/"/>
    <id>https://future-architect.github.io/articles/20210527a/</id>
    <published>2021-05-26T15:00:00.000Z</published>
    <updated>2021-05-27T01:16:44.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG村瀬です。</p><p>2021/4/21(水)に<a href="https://future.connpass.com/event/209778/">Future Tech Night #9 ～運用で後悔しないためのAWS設計術～</a>を開催しました。<br>私は、運用まで考慮したクラウドアーキテクチャ設計できていますか？というタイトルでお話させていただきました。</p><script async class="speakerdeck-embed" data-id="104031a6a5794ecaa26d0e160e660617" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h1 id="発表内容"><a href="#発表内容" class="headerlink" title="発表内容"></a>発表内容</h1><p>設計と異なり運用はサービスが終了するまでずっと続きます。</p><p>アーキテクトの中には設計フェーズまでしか関わらず、運用担当者の苦労を知らない人もいるのでは？と思い、運用にフォーカスした設計の話をしました。<br>目次は以下の通りです。</p><ul><li>会社紹介</li><li>システムが増加していっても耐えられる設計をしよう</li><li>インシデント発生から早期復旧のために</li><li>踏み台について</li><li>設定一つで自動的に削除しよう</li><li>まとめ</li></ul><p>視聴者に一つでも新発見があれば良いなと思い、AWSアカウント設計、監視ポイント、踏み台の取り扱いと大小様々なポイントを説明させていただきました。</p><h2 id="内容をチラ見せ"><a href="#内容をチラ見せ" class="headerlink" title="内容をチラ見せ"></a>内容をチラ見せ</h2><img src="/images/20210527a/p1.png" alt="AWSインフラの問題" width="956" height="536" loading="lazy"><img src="/images/20210527a/p2.png" alt="監視対象の図。LB,EC2,DB" width="959" height="539" loading="lazy"><p>気になるものがありましたら<a href="https://future.connpass.com/event/209778/presentation/">発表資料</a>も見てみてください。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>フューチャーでは大規模案件を取り扱うことが大半なのでアーキテクチャ設計をしっかり行わないと非機能要件が満たせずプロジェクトが破綻してしまいます。</p><p>未来を見通すのはなかなか難しいですが後になって大幅な設計見直しをしないで済むよう最初からハマりどころを押さえた上で設計をしましょう。また運用担当者に喜ばれるような設計を心掛けましょう。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG村瀬です。&lt;/p&gt;
&lt;p&gt;2021/4/21(水)に&lt;a href=&quot;https://future.con</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="保守運用" scheme="https://future-architect.github.io/tags/%E4%BF%9D%E5%AE%88%E9%81%8B%E7%94%A8/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>運用保守設計とは</title>
    <link href="https://future-architect.github.io/articles/20210526b/"/>
    <id>https://future-architect.github.io/articles/20210526b/</id>
    <published>2021-05-25T15:00:01.000Z</published>
    <updated>2021-05-26T06:49:04.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして、フューチャーインスペースの石崎です。</p><p>私の経歴ですが、約13年前IT業界へ異業種転職したところからスタート。新人開発者として某コンビニの開発PJにアサインされ、そのまま同PJの24h365d運用チーム立上げに携わり、運用保守フェーズを経験。以降は複数の運用保守設計や運用改善の案件に参画し、今に至ります。</p><p>運用保守設計のネタでブログを書いてみない？とお誘いを受けたのでチャレンジします。</p><p>読んだ方に運用保守設計の面白さや難しさが伝わったら嬉しいです。</p><h1 id="今回の内容"><a href="#今回の内容" class="headerlink" title="今回の内容"></a>今回の内容</h1><p>今回は運用保守設計がどういったものなのか、をイメージ出来る内容として以下をチョイスしました。</p><ol><li><a href="#%EF%BC%881%EF%BC%89%E9%81%8B%E7%94%A8%E4%BF%9D%E5%AE%88%E8%A8%AD%E8%A8%88%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%AA%E3%81%AE%E3%81%8B%EF%BC%9F">運用保守設計とは何なのか？</a></li><li><a href="#%EF%BC%882%EF%BC%89%E9%81%8B%E7%94%A8%E4%BF%9D%E5%AE%88%E8%A8%AD%E8%A8%88%E3%81%A7%E9%9D%A2%E7%99%BD%E3%81%84%E3%81%A8%E3%81%93%E3%82%8D">運用保守設計の面白いところ</a></li><li><a href="#%EF%BC%883%EF%BC%89%E9%81%8B%E7%94%A8%E4%BF%9D%E5%AE%88%E8%A8%AD%E8%A8%88%E3%81%AE%E9%9B%A3%E3%81%97%E3%81%84%E3%81%A8%E3%81%93%E3%82%8D">運用保守設計の難しいところ</a></li></ol><h1 id="（1）運用保守設計とは何なのか？"><a href="#（1）運用保守設計とは何なのか？" class="headerlink" title="（1）運用保守設計とは何なのか？"></a>（1）運用保守設計とは何なのか？</h1><img src="/images/20210526b/gears-5193383_640.png" alt="アイキャッチ" width="640" height="512" loading="lazy"><blockquote><p><a href="https://pixabay.com/ja/users/loginueve_ilustra-12954610/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5193383">Hugo Hercer</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5193383">Pixabay</a>からの画像</p></blockquote><p>凄く端的に言うと、システムが稼働した後のことを利用者(ユーザー)ではない視点で、あれやこれやと考えてどうするか決めていくことです。</p><p>システム開発設計が利用者視点で進んでいくのに対し、運用保守設計はシステム自体を動かす運用保守担当者の視点で進んでいきます。</p><p>例えば、車自体を作るのがシステム開発設計だとしたら、運用保守設計は、その車のメンテナンス方法を考えるような位置付けのイメージです。</p><p>そのため、システム開発プロジェクト中にはメンバーが業務要件やアプリ仕様を顧客と詰めているときに、運用保守設計の担当はシステムが動いた後のことを顧客と一緒に妄想しています。</p><ul><li>システムが停止した時はどれくらいで元の状態に復旧させる必要があるのか</li><li>こういったことが起きたときは誰に連絡すれば最適な対応が取れるのか</li></ul><p>…など様々な角度から設計します。</p><h2 id="運用保守設計の範囲"><a href="#運用保守設計の範囲" class="headerlink" title="運用保守設計の範囲"></a>運用保守設計の範囲</h2><p>基本的にはアプリケーションからインフラまで全てを設計範囲としています。<br>※システムはアプリやインフラなど複雑に絡み合いながら動くので、運用保守設計を行う場合は一気通貫で行うのが基本となっています。</p><p>そのため、運用保守設計のために読込みが必要なインプットはとても多いです。</p><p>アプリケーション仕様理解のために要件定義資料からアプリケーションの詳細設計書など、インフラ理解のために基盤設計書や、時にはソースやOSパラメータの確認も行います。</p><h1 id="（2）運用保守設計で面白いところ"><a href="#（2）運用保守設計で面白いところ" class="headerlink" title="（2）運用保守設計で面白いところ"></a>（2）運用保守設計で面白いところ</h1><p>各現場で担当されている方は色々あるとは思いますが、個人的には「運用保守設計の最適解」を自身で考えて設計できるところだと考えています。</p><p>最適解の定義から自身で考えロジックを作っていくのは大変ですが、とても面白いです。</p><p>リスクやコスト、メリット・デメリットなど前提を具体化して条件を整理し、システム稼働後を妄想して設計、更にそれを顧客やPJメンバーと議論。共感や否定されたところを整理しまた妄想して設計、と一つ一つ積み重ねて行きます。</p><p>キャリアパスとしても各種領域をシステムを動かす側から考える運用保守設計は、中堅やベテランになればこれまでのノウハウを生かすチャレンジの場として、キャリアが浅い時は色々な領域を知るための場としても、面白い領域だと個人的に思います。</p><p>自身で設計実装したものがシステムの稼働後にどうなるかも確認出来るので、全てが想定通りだった時はとても気持ち良いですよ。</p><h1 id="（3）運用保守設計の難しいところ"><a href="#（3）運用保守設計の難しいところ" class="headerlink" title="（3）運用保守設計の難しいところ"></a>（3）運用保守設計の難しいところ</h1><p>大きく2つあります、ここは各現場で運用保守設計を担当されている方も苦労されているところでしょう。</p><h2 id="3-1-実際に動かすのが人間の場合もあること"><a href="#3-1-実際に動かすのが人間の場合もあること" class="headerlink" title="3-1. 実際に動かすのが人間の場合もあること"></a>3-1. 実際に動かすのが人間の場合もあること</h2><p>運用保守設計したものを実際に動かすのが人間である場合もあること、です。</p><p>アプリケーションであれば、バクが無ければ基本的に実装通りに動きます。システムほど嘘をつかず信用できる奴はいない、とまで個人的には考えています。<br>※システムが想定と違う動きをしているときは、基本的に人間が勘違いしているか設計ミスしている。</p><p>しかし、人間が動かすとなると話が全然違ってきます。ドキュメントを読んだ人間の解釈は無限大で、読んだ人の経験や、時にはその時のメンタルやフィジカルの状況まで影響します。</p><p>アプリ開発を経験してきたか・インフラ開発を経験してきたか、様々な要因で解釈やアウトプットに差が出ます。メンタルの例を挙げると、大型休暇明けの人は休暇前よりも読み違いを起こしやすいということもあります。</p><p>そのため、そういった影響を受けない、たとえ受けたとしてもリカバリが可能な設計というものが重要で、運用保守設計の難しいところです。</p><h2 id="3-2-運用保守で回避、という判断に対する備え"><a href="#3-2-運用保守で回避、という判断に対する備え" class="headerlink" title="3-2. 運用保守で回避、という判断に対する備え"></a>3-2. 運用保守で回避、という判断に対する備え</h2><p>運用保守で回避、という判断に対する備えです。</p><p>システムが稼働した現場では「運用で回避」や「保守で対応」等、運用保守設計に無い想定外の業務が突発で発生することが多々あります。</p><p>運用保守で回避はシステムで問題が発生した時の最終手段です。運用や保守がなんとかしている間に、システム改修等を行うことで問題解決が図られます。</p><p>開発スキームでも各種施策が講じられていますが、運用保守設計としては、発生率の削減と想定外を無くす取り組みの2つ、でアプローチしています。</p><p>発生率の削減は、これまでの実績として、考慮漏れや実装不備、テスト漏れやアプリ不具合の影響で発生することが多いので、システム品質を高めるためにも、運用保守設計担当も積極的にシステム側（設計者や開発者）にフィードバックしています。</p><p>想定外を無くす取り組みは、開発⇒運用保守設計であった情報の流れを運用保守設計⇒開発の流れも作ることで相互チェックできる形にすることでアプローチしています。</p><h3 id="システム設計開発中の「運用保守で回避」"><a href="#システム設計開発中の「運用保守で回避」" class="headerlink" title="システム設計開発中の「運用保守で回避」"></a>システム設計開発中の「運用保守で回避」</h3><p>ちなみに、「運用保守で回避」はシステム設計開発中にも出てきますが、こちらは基本的に検討先延ばしワードなので、現場の「運用保守で回避」とは全く異なるものです。</p><p>システム設計開発中にこの文言が出て来たら、色々な意味でドキドキしつつも、サポートするようにしています。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>DevOpsやSRE、RPA等が出てきつつも、まだまだ色々な可能性を秘めている運用保守設計の領域、ぜひ一緒にやってみませんか？</p><p><a href="https://www.future.co.jp/recruit/">https://www.future.co.jp/recruit/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;はじめまして、フューチャーインスペースの石崎です。&lt;/p&gt;
&lt;p&gt;私の経歴ですが、約13年前IT業界へ異業種転職したところか</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="SRE" scheme="https://future-architect.github.io/tags/SRE/"/>
    
    <category term="保守運用" scheme="https://future-architect.github.io/tags/%E4%BF%9D%E5%AE%88%E9%81%8B%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Figmaで会社の名刺をUI風にリデザインしてみる</title>
    <link href="https://future-architect.github.io/articles/20210526a/"/>
    <id>https://future-architect.github.io/articles/20210526a/</id>
    <published>2021-05-25T15:00:00.000Z</published>
    <updated>2021-05-26T01:29:16.799Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210526a/image.png" alt="Figmaの名刺ワイヤーフレーム" width="1200" height="578" loading="lazy"><p>新しく参画したプロジェクトが今後Figmaを使ってプロトタイプを作るということで、最近Figmaのキャッチアップをしています。「実際に何かを作ってみる」より良いキャッチアップ方法は存在しないだろう、ということで早速チャレンジしてみました。キャッチアップのために思いついたチャレンジは２つ：</p><p>A. 架空のアプリを一からデザイン<br>B. 既に存在している何かの<strong>リデザイン</strong></p><p>この記事では「B. 既に存在している何かのリデザイン」の過程を紹介していきます。</p><h2 id="お題"><a href="#お題" class="headerlink" title="お題"></a>お題</h2><p>決めたお題は「会社の名刺のリデザイン」です。</p><p>これに決めた大きな理由は特にないですが、最近新しく名刺を発注した直後に所属の部署が変わったという残念な出来事もあり、「名刺をデジタル世界に持っていくとどうなるんだろう？」という疑問から展開することにしました。なお、フューチャーは標準の名刺デザインから現在は変えられないので、今回はあくまで<strong>想像で楽しむ用途</strong>です。</p><h2 id="デザイン"><a href="#デザイン" class="headerlink" title="デザイン"></a>デザイン</h2><p>ステークホルダーがいない架空のPJというせっかくの機会なので、採用したデザイン方針は「とりあえず好きなことをやってみる」です。テーマは2021年のUIトレンドの中から下記の2つをピックアップ：</p><h3 id="Minimalism"><a href="#Minimalism" class="headerlink" title="Minimalism"></a>Minimalism</h3><blockquote><p>完成度を追求するために、装飾的趣向を凝らすのではなく、むしろそれらを必要最小限まで省略する表現スタイル</p></blockquote><ul><li>ブリタニカ国際大百科事典 小項目事典</li></ul><p>なじみのある方も多いのではないでしょうか。<br>UIに限らず、様々な分野で近年流行っています。<br><img src="/images/20210526a/image_2.png" alt="ミニマリズムサンプル" width="496" height="279" loading="lazy"></p><blockquote><p>出典：<a href="https://www.shutterstock.com/image-illustration/interior-poster-mock-living-room-armchair-1730107024">Shutterstock</a></p></blockquote><h3 id="Glassmorphism"><a href="#Glassmorphism" class="headerlink" title="Glassmorphism"></a>Glassmorphism</h3><p>半透明のガラスを表現する手法です。</p><img src="/images/20210526a/image_3.png" alt="Glassmorphismサンプル" width="751" height="431" loading="lazy"><blockquote><p>出典：<a href="https://hype4.com/blog/glassmorphism">hype4</a></p></blockquote><p>昔から存在していたデザインですが、最近 macOS Big Sur や Windows Fluent Design System に使われたこともあり、注目を集めているようです。</p><img src="/images/20210526a/image_4.png" alt="macOS Big Surイメージ" width="800" height="600" loading="lazy"><blockquote><p>出典：<a href="https://www.sketchappsources.com/free-source/4488-macos-big-sur-control-center-sketch-freebie-resource.html">Sketch App Sources</a></p></blockquote><img src="/images/20210526a/image_5.png" alt="Windows Fluent Design Systemイメージ" width="800" height="450" loading="lazy"><blockquote><p>出典：<a href="https://docs.microsoft.com/en-us/windows/uwp/design/style/acrylic">Microsoft</a></p></blockquote><h1 id="では本番へ"><a href="#では本番へ" class="headerlink" title="では本番へ"></a>では本番へ</h1><p>難しいことは考えず、ノープランでまずは名刺を作ってみます！</p><h2 id="背景を作る"><a href="#背景を作る" class="headerlink" title="背景を作る"></a>背景を作る</h2><p>Frameを新しく作成。</p><img src="/images/20210526a/image_6.png" alt="FigmaのFrame" width="1200" height="767" loading="lazy"><p>光を表現するために、少しグラデーションを左上からかけます。<br>Figmaでは右側のデザインメニューの<strong>Fill</strong>からグラデーションの種類を選択できます。今回は「<strong>Linear</strong>」を採用。</p><img src="/images/20210526a/image_7.png" alt="FigmaのLinear" width="1200" height="766" loading="lazy"><h2 id="カードを作る"><a href="#カードを作る" class="headerlink" title="カードを作る"></a>カードを作る</h2><p>名刺となる長方形を作成します。<br>角は近年のモバイルアプリのデザインを連想させるような丸いものにします。<br>（長方形をダブルクリックすると角に<strong>Radius</strong>を調整できる丸い点が表示されます）</p><img src="/images/20210526a/image_8.png" alt="Figmaで長方形を作る" width="1200" height="761" loading="lazy"><p>ガラス感を出すためにカードの背景色の透明度を上げた後、上記で背景にグラデーションをかけたように、カードにも透明な白のグラデーションをかけます。グラデーションをA点からB点へとかける際、AとBの透明度を別々にすることで少し奥行きを表現します。</p><img src="/images/20210526a/image_9.png" alt="Figmaで背景を透明にする" width="1200" height="761" loading="lazy"><p><strong>Stroke</strong>から枠線を追加し、こちらも上記のようなグラデーションをかけます。</p><p>厚みが出て、ガラスっぽくなってきましたね！</p><img src="/images/20210526a/image_10.png" alt="Figmaで背景を透明にするためにStrokeを追加" width="1200" height="578" loading="lazy"><p>ここで一旦名刺の中身を作る作業に移ります。<br>名刺の内容はminimalismを極めるために、必要最低限の下記に絞りました：</p><ul><li>フューチャーのロゴ</li><li>氏名</li><li>役職</li><li>その他の情報は1つのQRコードに預けることにします</li></ul><p>ではレイアウトを作ります。</p><p>クールなフューチャーのロゴは上中央で主張するとして、氏名、役職とQRコードは下のエリアを共有させます。Figmaでは<strong>Frame</strong>毎にレイアウトが作れるようですので、カード全体を2rowsに分けた後、下のrowを更に2columnsと2rows(margin 20px)に分けます。右側の<strong>Layout grid</strong>メニューからレイアウトを追加していきます。</p><img src="/images/20210526a/image_11.png" alt="Layout gridメニュー" width="1200" height="717" loading="lazy"><p>レイアウトに沿ってロゴ、テキストとQRコードを追加していった結果がこちら。</p><img src="/images/20210526a/image_12.png" alt="ロゴ、テキスト、QRコードを追加した図" width="1200" height="766" loading="lazy"><p>ここでも、minimalismを極めるためにカラーは白一色にしました。ちなみに、本来QRコードを読み込むとTelやMailの詳細情報にアクセスできるコンセプトですが、このモックアップのQRコードにはフューチャーのホームページを仕込みました。</p><h2 id="ブラッシュアップ"><a href="#ブラッシュアップ" class="headerlink" title="ブラッシュアップ"></a>ブラッシュアップ</h2><p>さて、これだと少し寂しいですので、プレゼンテーションを少しブラッシュアップしていきます。<br>より透明感を引き立たせるために、まずは背景とカードの間にオブジェクトを配置します。ここではフューチャーのロゴの一部を流用します。</p><img src="/images/20210526a/image_13.png" alt="ブラッシュアップ" width="1200" height="763" loading="lazy"><p>最後に、右側のデザインメニューより<strong>Background blur</strong>の<strong>Effects</strong>を長方形にかけることでカードが半透明であることを表現。</p><img src="/images/20210526a/image_14.png" alt="Effectsの長方形" width="1200" height="763" loading="lazy"><p>これで名刺は完成です！</p><img src="/images/20210526a/image_15.png" alt="完成した名刺" width="1200" height="730" loading="lazy"><p>…で、どうこの名刺を活用できるようにするかですが、<br>UIのトレンドをモチーフに作成しただけあって、さすがに実世界でこんなビジュアルの名刺、恥ずかしくて渡せないですよね。</p><p>ということでこのデジタル名刺を活かすための簡単なアプリのモックアップも作ってみました。</p><img src="/images/20210526a/image_16.png" alt="完成した名刺のちょっと斜め" width="1125" height="730" loading="lazy"><img src="/images/20210526a/iMac_-_2.png" alt="完成した名刺の正面" width="1019" height="774" loading="lazy"><p>使い方はLINEが採用していた「ふるふる機能」のような感覚で、お互いに向かってスワイプすることで名刺を交換。</p><img src="/images/20210526a/ezgif.com-gif-maker.gif" alt="ふるふる機能" width="462" height="894" loading="lazy"><blockquote><p>出典（プロフィール写真部）：<a href="https://www.shutterstock.com/image-photo/teenager-asian-woman-feeling-happy-smiling-1545395876">Shutterstock</a></p></blockquote><p>また、自分の名刺をメール等のアプリに連携することでリモートの相手とも名刺交換できるというコンセプト。コンタクトレス化やリモート化が必須となっていくこのご時世、良いかもですね！</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>…と、最後は少し強引にまとめてしまいましたが、今回のキャッチアップチャレンジを通して何より感じたのはFigmaでデザインとプロトタイプをする楽しさです。必要最低限のツールが分かりやすく整理され、作ることに集中できる環境が整っていると感じました。また、プロトタイプもスピーディーにプレビューでき、ストレスなくデザインやアニメーションの微調整ができるのも嬉しかったです。</p><p>そしてFigmaの一番の良さは、「無料である」ことと「ブラウザーで使える」ということだと考えます。これだけリッチで誰でもすぐにハードルなしに使えるツール、素晴らしいですね。</p><p>ちなみに冒頭で触れたチャレンジ「A. 架空のアプリを一からデザイン」ではアーティストが自分の音楽の売上を一括管理出来る架空のアプリを作ってみました。</p><img src="/images/20210526a/image_17.png" alt="架空のアプリを一からデザイン" width="1200" height="648" loading="lazy"><blockquote><p>出典（プロフィール写真部）：<a href="https://open.spotify.com/artist/5ObBtv5VunwwhQaXXnUrsM">Spotify (KennyHoopla)</a></p></blockquote><p>今後プロジェクトでFigmaを使ってUX/UI設計するのが楽しみです！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210526a/image.png&quot; alt=&quot;Figmaの名刺ワイヤーフレーム&quot; width=&quot;1200&quot; height=&quot;578&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;新しく参画したプロジェクトが今後Figmaを使ってプロトタイプを</summary>
      
    
    
    
    <category term="Design" scheme="https://future-architect.github.io/categories/Design/"/>
    
    
    <category term="UI/UX" scheme="https://future-architect.github.io/tags/UI-UX/"/>
    
    <category term="Figma" scheme="https://future-architect.github.io/tags/Figma/"/>
    
  </entry>
  
  <entry>
    <title>VS Code / プラグインを活用したDraw.ioの便利な使い方</title>
    <link href="https://future-architect.github.io/articles/20210525b/"/>
    <id>https://future-architect.github.io/articles/20210525b/</id>
    <published>2021-05-24T15:00:01.000Z</published>
    <updated>2021-05-25T01:58:42.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p><a href="https://www.diagrams.net/">Draｗ.io（Diagrams.net）</a>はとても便利ですが、VScodeやプラグインと組み合わせるとさらに便利になります。</p><p>特に便利と感じた機能を紹介します。</p><h1 id="VS-Code-プラグイン"><a href="#VS-Code-プラグイン" class="headerlink" title="VS Code プラグイン"></a>VS Code プラグイン</h1><p>ここ数年、GitHubでドキュメント（Markdown）を管理するケースが増えており、Markdownに埋め込む編集可能な図として、Draｗ.ioのメタ情報を埋め込んだ画像を利用しています。</p><p>当初、ブラウザ（もしくはデスクトップ版）を利用していたのですが、こちらのプランを利用すると、VSCodeから直接png/svgをDraｗ.ioで表示・編集・画像保存が可能となり、とても便利です。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio">https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio</a></p><img src="/images/20210525b/vscode.gif" alt="VS Codeでdraw.ioを編集する動画" width="720" height="480" loading="lazy"><h1 id="Draw-io-プラグイン"><a href="#Draw-io-プラグイン" class="headerlink" title="Draｗ.io プラグイン"></a>Draｗ.io プラグイン</h1><p><a href="https://drawio-app.com/?s=plugin">公式</a>でもブログでサラッと紹介してあるのみですが、メニューから、<code>拡張 &gt; プラグイン</code>で追加可能です。</p><p>網羅性はありませんが、使ってみたプラグインを幾つか紹介します。urlからも追加できるようなので、探してみると可能性が広がりそうです。</p><img src="/images/20210525b/plugin.gif" alt="draw.ioのプラグインを追加する動画" width="720" height="480" loading="lazy"><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>DDLからDraｗ.ioのERDを作れます。</p><p>凄く便利！と思うのですが、リレーション貼れなかったりあと1歩な感じです。</p><p><a href="https://drawio-app.com/sql-plugin/">https://drawio-app.com/sql-plugin/</a></p><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>Draｗ.ioに含まれるTextを一括でExportできます。どこかで使えそうですね。</p><p><a href="https://drawio-app.com/text-plugin/">https://drawio-app.com/text-plugin/</a></p><h2 id="anim"><a href="#anim" class="headerlink" title="anim"></a>anim</h2><p>オブジェクトにアニメーションを付けられます。巨大なオブジェクトにアニメーションをつけるのはかなり労力を使いそうです。</p><img src="/images/20210525b/anim.gif" alt="draw.ioでオブジェクトにアニメーションを追加する動画" width="720" height="480" loading="lazy"><h2 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h2><p>こちらもアニメーションですが、線が動きます。面白いです。</p><p><a href="https://drawio-app.com/connector-styles-and-animations-in-draw-io/">https://drawio-app.com/connector-styles-and-animations-in-draw-io/</a></p><img src="/images/20210525b/flow.gif" alt="draw.ioで矢印の線が流れるアニメーション" width="720" height="480" loading="lazy"><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>オブジェクトにタグを付けて、表示非表示を切り替えられます。レイヤーでよいのではないでしょうか？</p><img src="/images/20210525b/tags.gif" alt="draw.ioでタグでオブジェクトの表示制御する動画" width="720" height="480" loading="lazy"><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>右上にオブジェクトのプロパティが表示されます。邪魔です。</p><img src="/images/20210525b/props.gif" alt="draw.ioでオブジェクトの左上にプロパティが表示される動画" width="720" height="480" loading="lazy"><h1 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h1><p>Draｗ.io単品でも無料でここまで使えるものかと驚きます。改めて可能性を感じました。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.diagrams.net/&quot;&gt;Draｗ.io（Diagrams.net）&lt;/a&gt;はとても便利ですが</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="draw.io" scheme="https://future-architect.github.io/tags/draw-io/"/>
    
    <category term="VSCode" scheme="https://future-architect.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Goの構造体の使われ方の設計</title>
    <link href="https://future-architect.github.io/articles/20210525a/"/>
    <id>https://future-architect.github.io/articles/20210525a/</id>
    <published>2021-05-24T15:00:00.000Z</published>
    <updated>2021-05-26T13:21:02.802Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210525a/carbon_go_code.png" alt="carbonで出力したGoコード" width="700" height="511" loading="lazy"><p>Goで構造体を設計する場合、オブジェクト指向的な「型ごとの責務の分担」以外に、「どのように使われるものか」を考える必要があります。</p><ul><li>ポインタで扱うのか？値として扱うのか？両方許可するのか？</li><li>値として扱える場合にimmutable（変更不可能）なオブジェクトとするのか、mutable（変更可能）なオブジェクトとするのか</li><li>値として扱える場合にゼロ値での動作を補償するかどうか</li></ul><p>他の言語で言うと、C#の構造体とクラスの違い、C++のデフォルトコンストラクタあたりに頭を悩ませたことがある人にはおなじみかもしれませんが、Goでもいくつか考慮が必要になります。</p><h1 id="ポインタ型として扱う必要があるケース"><a href="#ポインタ型として扱う必要があるケース" class="headerlink" title="ポインタ型として扱う必要があるケース"></a>ポインタ型として扱う必要があるケース</h1><p>まず最初に決断できる方針としては、ポインタ型でのみ扱うかどうかです。</p><p>内部にスライスやmap、ポインタなどの参照型な要素を持っていれば、基本的にポインタ型でのみ扱う構造体になります。これらの要素を持っていた場合、コピーしてしまうと、複数のインスタンスが、これらのフィールドのインスタンスを共有することになります。自分だけの要素だと思っていたのに変更が他のインスタンスにも影響を与えてしまう、となってしまいます。</p><p>標準ライブラリだと、ロック状態がコピーされて変なエラーになってしまうsync.Mutexや、内部に可変長なバッファを含むbig.Intなどが該当します。これらの構造体は利用コード内ではポインタ型で取扱います。 <code>sync.Mutex</code> にはないですが、インスタンスを作成してポインタ型を返すファクトリー関数を用意すると良いでしょう。</p><p>Goの文法を使った構造体のコピーを防ぐ方法としては<a href="https://github.com/golang/go/issues/8005#issuecomment-190753527">go vetに警告させる方法があるとissueにはある</a>のですが、<a href="https://play.golang.org/p/wGiv-2VpYHK">手元でこの方法を試したところうまく動いておらず</a>・・・</p><p><strong>5/26追記</strong></p><p><a href="https://twitter.com/orisano/status/1397022250381938689">@orisano</a>さんより、型のベースが構造体で、Unlockメソッドも定義されていることが条件と教えていただきました。</p><p>実行時に防ぐ方法としては、このような実装を見かけたことはないのですが、作成したときのポインタ値を保持しておいて、メソッドを呼び出したときにエラーを出す方法があります。C言語などにあるassert機能がGoにはないので、実行時にコストがかかってしまう問題はありますが確実に発見できます。パッケージプライベートなフィールドに格納し、ファクトリー関数で設定することで確実にチェックできます。また、<code>nil</code> と比較すればファクトリー関数を使わないで初期化したケースも拾えるでしょう。</p><p><strong>5/26追記</strong></p><p><a href="https://twitter.com/athos0220/status/1397076574118182918">@athos0220</a>さんより、strings.Builderの中でポインタ値を保持してコピーを検知する手法が実際に使われていると教えていただきました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ポインタとしてのみ利用する構造体</span></span><br><span class="line"><span class="keyword">type</span> NoCopyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">self  *NoCopyStruct</span><br><span class="line">Value *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初期化時にポインタを保持しておく</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNoCopyStruct</span><span class="params">(value <span class="keyword">string</span>)</span> *<span class="title">NoCopyStruct</span></span> &#123;</span><br><span class="line">r := &amp;NoCopyStruct&#123;</span><br><span class="line">Value: &amp;value,</span><br><span class="line">&#125;</span><br><span class="line">r.self = r</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// メソッドの中でチェック</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NoCopyStruct)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != n.self &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;should not copy NoCopyStruct instance without Copy() method&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *n.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ポインタ型として扱う場合は、明示的に値を取り出してコピーをするという組み込み文法では問題がおきるため、コピーが必要な場合は明示的なCopy()メソッドを用意すべきです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 明示的なコピー用メソッド</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NoCopyStruct)</span> <span class="title">Copy</span><span class="params">()</span> *<span class="title">NoCopyStruct</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str = *n.Value</span><br><span class="line">p2 := &amp;NoCopyStruct&#123;</span><br><span class="line">Value: &amp;str,</span><br><span class="line">&#125;</span><br><span class="line">p2.self = p2</span><br><span class="line"><span class="keyword">return</span> p2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ユーザーにどうしてもポインタとして扱わせたい場合は、実装をprivateにして、インタフェースだけを公開する方法もあります。</p><h1 id="値として扱える場合"><a href="#値として扱える場合" class="headerlink" title="値として扱える場合"></a>値として扱える場合</h1><p>値として扱う場合は、インスタンス全体のコピーが行われることになります。代入したり、引数として渡すたびにコピーされます。ポインタの場合はコピーがされません。</p><p>ポインタ型として扱う必要があるケースの裏となりますが、値として扱う場合、ポインタ、mapやスライスなどをメンバーに持たせられません。持つこと自体は文法上エラーになりませんが、わかりにくいバグを誘発します。</p><p>値の方が実装の制約が強くかかりますが、メリットもあります。インスタンスを作ってその関数のライフサイクルの中でのみ消費される場合、スタックメモリ上にインスタンスが確保されます。スタックメモリは言語のランタイムやOSに問い合わせてメモリを確保するヒープメモリと異なり、メモリ割り当てのコストがほぼゼロです  <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>値で扱える構造体はポインタで扱っても問題ありません。ポインタにnilを入れることで無効な値であることが表現できます。値でも「<code>IsZero()</code>」メソッドを用意することで同じことを表現することもあります。どちらで設計するかはチームごとに方向性を決めましょう。</p><h1 id="mutableな構造体とimmutableな構造体"><a href="#mutableな構造体とimmutableな構造体" class="headerlink" title="mutableな構造体とimmutableな構造体"></a>mutableな構造体とimmutableな構造体</h1><p>mutableな構造体は、フィールドの変更を行うメソッドは、フィールドを直接書き換えます。古典的なオブジェクト指向プログラミングなコードとなります。変更するメソッドはレシーバーをポインタ型にします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MutableMoney <span class="keyword">struct</span> &#123;</span><br><span class="line">currency Currency</span><br><span class="line">amount   *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MutableMoney)</span> <span class="title">Currency</span><span class="params">()</span> <span class="title">Currency</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.currency</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutableMoney)</span> <span class="title">SetCurrency</span><span class="params">(c Currency)</span></span> &#123;</span><br><span class="line">m.currency = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>近年、関数型言語からエッセンスを借りてきて普及しているのが「immutable」にする設計です。Goでもtime.Timeはimmutableです。immutableな構造体は、フィールドの変更を行うメソッドを呼び出すと、その変更を加えた新しいインスタンスを返します。レシーバーを変更することがないため、レシーバーは常に値型で問題ありません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ImmutableMoney <span class="keyword">struct</span> &#123;</span><br><span class="line">currency Currency</span><br><span class="line">amount   *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im ImmutableMoney)</span> <span class="title">Currency</span><span class="params">()</span> <span class="title">Currency</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> im.currency</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im ImmutableMoney)</span> <span class="title">SetCurrency</span><span class="params">(c Currency)</span> <span class="title">ImmutableMoney</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ImmutableMoney&#123;</span><br><span class="line">currency: c,</span><br><span class="line">amount:   im.amount,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使われ方も異なります。immutableな型は変更を加えるメソッドではコピーを返すため、必ず返り値を変数に入れたり、他の関数に渡したり、返り値を利用するコードとなります。</p><p>mutableにするか、immutableにするかの指標は、ポインタ型にするか値にするかの指標と似ています。ポインタ型でなければならないケースは、内部にコピー不可能なもの（利用途中のチャネルなど）やコピーコストの大きな複合型を持っているため、immutableにすることは難しいでしょう。immutableは値との相性は良いです。ただ、値として扱うものをmutableにすることは可能です。</p><p>どちらで表現できるものをどちらにするかはアーキテクトの腕に見せ所ですが、Goの場合はエンティティと呼ばれるような構造体はmutableが良いでしょう。関数型にかぶれると全部immutableにしたくなりますが、time.Timeのようなほぼプリミティブみたいなデータでのみ利用した方がGoの標準ライブラリなど、Goのエコシステムと粒度が合わせやすいでしょう <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><h1 id="ゼロ値の動作を補償するかどうか"><a href="#ゼロ値の動作を補償するかどうか" class="headerlink" title="ゼロ値の動作を補償するかどうか"></a>ゼロ値の動作を補償するかどうか</h1><p>構造体の各フィールドは、初期化しないとゼロ値になります。構造体を未初期化で定義すればすべてのフィールドがゼロ値になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    name   <span class="keyword">string</span></span><br><span class="line">    depth  <span class="keyword">int</span></span><br><span class="line">    parent *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms.nameは空文字列、depthはゼロ、parentはnil</span></span><br><span class="line"><span class="keyword">var</span> n Node</span><br></pre></td></tr></table></figure><p>このときにも全部の機能が有効に動作することを補償するかどうかも決める必要があります。特に値として扱うケースではこれを考慮する必要性が高くなるでしょう。</p><p>ステータス的な属性があるなら、ゼロ値で未初期化状態、デフォルト状態にします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  DefaultStatus Status = <span class="literal">iota</span> <span class="comment">// iota+1にするのがよくあるイディオムだが、デフォルト値0が大切に</span></span><br><span class="line">  ActiveStatus</span><br><span class="line">  CloseStatus</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>ポインタや複合型などがフィールドにあれば、実行時にnilチェックをして初期化するコードを入れる方法も考えられます。しかし、おそらくゼロ値構造体インスタンスが頻繁に使われると思われる値で扱う構造体の場合、そもそもこれらの型のフィールドはあまり持っていないと思うので、考慮する必要はないでしょう。</p><p>ゼロ値での動作を補償しない、あるいはポインタとして扱う前提の構造体であれば、ファクトリー関数以外の動作を補償しない手もあります。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>オブジェクト指向設計的には「型を作る」の一言ですが、Goでは利用する場面や内部の状態に応じて実装方法にいくつかのバリエーションがあります。</p><ul><li>ポインタで扱うのを想定するか、値で扱うのを想定するか</li><li>immutableなAPIセットを用意するか、mutableなAPIセットを用意するか</li><li>ゼロ値の動作を補償するかどうか</li></ul><p>Goにはどちらのスタイルであるか、スタイル違いで使ったときにエラーにする仕組みがない（あるいは弱い）ため、利用者に設計方針を伝えるためにExampleテストやREADMEなどで使い方を例示しましょう。</p><p>色々紹介しましたが、困ったらまずは「ポインタで扱う前提」「mutableなAPIセットを提供」「特定のファクトリー関数でのみ動作（ゼロ値動作を保証しない）」がいちばんお手軽なので問題ありません。値で扱う、プラスアルファでimmutableにする手法がミートするのはケースとしてはやや狭くなります。上手くハマればメモリ確保が軽くなったり、不具合が減るでしょう。ゼロ値での動作は値で扱うケースでは補償してあげる方が便利なことが多いでしょう。</p><p>ここで説明しなかった観点にはパフォーマンスもあります。ポインタを使った方が確かにパフォーマンスは良かったりしますが、かなり巨大な構造体にならないかぎりはそれが問題になることはほとんどありません。早すぎる最適化よりは、最適な使われ方を模索した方が良いでしょう。</p><p>この手の「自由度がある」ことで利用側で考慮が必要なケースは、制約を加える言語機能がないから必要になっていると言えます。とはいえ「制約を与える（≒引き算をする）」ことがうまくやり切れる人は、単純に機能を追加する人よりは少なく、制約が緩ければ誤った利用方法を抑制できず、制約が厳し過ぎれば、元のコードをそのまま使うのをあきらめ、vendoringの上カスタマイズされて実装が枝分かれしてしまうことになります。個人的には制約のための言語機能がない言語設計も一つの合理的な帰結だと思っています。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">Goはスタックメモリがなくなりそうになるとスタックを延長する処理が走ります。そのときだけコストが発生します。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">JavaScriptのReactやReduxのような、immutableなオブジェクトを作る前提のフレームワークが登場しない限り</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210525a/carbon_go_code.png&quot; alt=&quot;carbonで出力したGoコード&quot; width=&quot;700&quot; height=&quot;511&quot; loading=&quot;lazy&quot;&gt;

&lt;p&gt;Goで構造体を設計する場合、オブジェクト指向的な</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="設計" scheme="https://future-architect.github.io/tags/%E8%A8%AD%E8%A8%88/"/>
    
  </entry>
  
  <entry>
    <title>ユーザーストーリーマッピングで始める要求整理</title>
    <link href="https://future-architect.github.io/articles/20210524a/"/>
    <id>https://future-architect.github.io/articles/20210524a/</id>
    <published>2021-05-23T15:00:00.000Z</published>
    <updated>2021-05-26T13:11:00.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DXユニット  <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 真野です。元々バックエンド開発を中心にしていますが、ここ3,4年でいくつかのユーザーストーリーマッピング作成に関わるなど、プロダクトオーナー的な視点も求められることが増えてきました。</p><p>アジャイルで仮説検証を繰り返しながらソフトウェア開発を行っていると、全体感が見えにくくなることが多々あるかと思います。特に開発タスクをプロダクトバックログのチケットで管理していると、そのチケットの背景にあたる、その機能が、「だれが」、「どういったユースケースで使用して」、「何を解決するか」といった認識が薄くなりがちです。</p><p>そんな時にユーザーストーリーマップがあると、全体像の認識をチーム全体で共有できて便利です。ユーザーストーリーマップは視覚的にわかりやすく、特殊な構造もしていないため共通理解しやすいことがポイントです。</p><p>また、ユーザーストーリーマップはこれから何を作ろうかという要求定義の段階でも有効に感じます。この記事では要求の整理と理解のためにユーザーストーリーマップを使ってみたときの気がついた点や振り返りをまとめました。</p><h2 id="ユーザーストーリーマップ"><a href="#ユーザーストーリーマップ" class="headerlink" title="ユーザーストーリーマップ"></a>ユーザーストーリーマップ</h2><p><a href="https://www.oreilly.co.jp/books/9784873117324/">O’Reilly Japan - ユーザーストーリーマッピング</a>には…</p><p><strong>ストーリーマップを作ると、ユーザーとそのエクスペリエンスに意識を集中でき、より良い会話を交わすことができ、最終的には良い製品が生まれる。</strong></p><p>…と書かれていました。<strong>ビジョンを共有し、会話を交わし、良いアイデアをプロダクトに追加するため</strong>のものです。</p><p>以下のような構造をしています。</p><ul><li>バックボーンと呼ばれる左から右に流れるアクティビティを書く<ul><li>アクティビティは動詞で書くことを推奨とのこと</li><li>図ではバックボーンは2段で書いていますが、別に1、2段でも良いらしく、最初は1段で書いて多くなったら2段にして分類分けなど柔軟な運用も可<ul><li>それぞれのレベルに名前が欲しいところですが、書籍によるとまだ無いとのこと</li></ul></li></ul></li><li>バックボーンを書いたら、アクティビティの詳細を書いていく<ul><li>機能と呼ぶことが経験上多いです</li></ul></li></ul><img src="/images/20210524a/ユーザーストーリーマップ例.png" alt="ユーザーストーリーマップ例" width="1200" height="502" loading="lazy"><p>後で少し触れますが、複数のペルソナを扱う場合は、当然ユーザーストーリーマップも分割することを視野に入れたほうが良いです。特に分割についてはルールが無いようなので、見にくくなったら、ユースケースやペルソナ単位で分割を検討するとよいでしょう。</p><img src="/images/20210524a/ユーザーストーリー2.png" alt="ユーザーストーリー分割例" width="451" height="534" loading="lazy"><p>ユーザーストーリーマッピング全体のお作法として、裏で実現するシステムの動作は考えず、どのようにユーザのアクションが移り変わっていくかに注力します。プロダクトは何ができるべきか、しないべきかの議論に集中できます。</p><h2 id="ユーザーストーリーマッピングでできないこと"><a href="#ユーザーストーリーマッピングでできないこと" class="headerlink" title="ユーザーストーリーマッピングでできないこと"></a>ユーザーストーリーマッピングでできないこと</h2><ul><li>あくまで要求を整理し議論を活発化させるためのもの、優先度付けするためのものである<ul><li>要件定義ではないので、細かな仕様整理には使えない<ul><li>当然、画面表示項目や、入力バリデーション規則などは定義できない</li></ul></li></ul></li></ul><p>システム開発のフェーズで言えば、基本設計より前のことしかできません。</p><p>どういった画面イメージになるか、画面遷移になるかも決めることはできません。ユーザーストーリーマップを元にワイヤーフレームを作ることが多いと思います。</p><h2 id="機能一覧との比較"><a href="#機能一覧との比較" class="headerlink" title="機能一覧との比較"></a>機能一覧との比較</h2><p>どういったスコープで開発するとか、最低限の機能群（MVP）は何かという時に、開発側で言えば”機能一覧”とか”画面一覧”を作りたいという気持ちがあるかなと思います。これはこれで間違っていないと思うのですが、機能ベースを出発点にすると実際に作り上げたものに設計仕様の漏れが発生しがちです。</p><ul><li>ユーザーの特定のアクション（業務）が定義した機能だと実現できないことがある<ul><li>考慮漏れといえばそうですが、機能を起点にするとユーザの利用イメージが希薄になりがちです</li></ul></li><li>開発側が想定していない使われ方をしている<ul><li>その利用方法であればもっと別の実現方法があったのでは？と生産的な議論をするタイミングを逃す</li></ul></li></ul><p>最終的には機能一覧などを作成したり、プロダクトバックログがそれに当たるなどになることは良いと思います。それを作る前に、だれのためにどういったことができると良いかといった、何を作るかの点にフォーカスを当てて、チーム全体の認識を揃えるための時間をとるべきです。</p><h2 id="業務フロー図を作ることとの違い"><a href="#業務フロー図を作ることとの違い" class="headerlink" title="業務フロー図を作ることとの違い"></a>業務フロー図を作ることとの違い</h2><p>ユーザーストーリーマッピングは業務フローの整理と近い部分も多いとは思います。しかしユーザーストーリーもある程度のフローを表現できますが、フローは分岐できません。代わりにユーザの各動作を実現するための、機能の優先度を表現できるようにしたものがユーザーストーリーです。リリース1,2でどの機能まで提供するんだ、といったことも直感的にわかりやすいです。業務フロー図は複数のアクターによる業務のやり取りが発生するときには非常に視認性が高く表現できるため、そういった場面ではぜひ作成したい成果物です。</p><p>ある程度、業務フローが複雑なものはユーザーストーリーだけではなく、業務フロー図も作成することで補完すると良いかなと思います。</p><p>＜業務フロー図のイメージ図＞</p><img src="/images/20210524a/業務フロー図.png" alt="ユーザーストーリー分割例" width="848" height="662" loading="lazy"><h2 id="ツール"><a href="#ツール" class="headerlink" title="ツール"></a>ツール</h2><p>昨今の情勢だとホワイトボードに付箋をペタペタ貼るのは難しく <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>、リモートかつ共同で使えるサービスを利用しましょう。</p><ul><li><a href="https://miro.com/">Miro</a><ul><li><del>まず、Miroを見ろってみんな言うんですよね</del></li><li>コピーすると子要素が紐付いてくるので注意</li><li>たまに変な挙動するのでリロードすると良い</li></ul></li><li><a href="https://lucidspark.com/ja/create/user-story-tool">Lucidspark</a></li><li>draw.io<ul><li>共同編集を諦めるのであれば選択肢にあがるかもしれません。人数が少なければVS CodeでLive Shareしながら同時編集もできます</li></ul></li></ul><h2 id="やってみた振り返りまとめ"><a href="#やってみた振り返りまとめ" class="headerlink" title="やってみた振り返りまとめ"></a>やってみた振り返りまとめ</h2><p>何回かトライしてみた振り返りを記載します。周囲でやったことある人の意見も入っています。協力：徳田さんありがとう！</p><ul><li>登場人物（ペルソナ）を洗い出した方が良い<ul><li>企画・製造・マーケなどの部門。マネージャ・メンバーなどの役職</li><li>ユーザーがどんな流れでプロダクトを利用するかを検討するのに、ユーザの種別が複数存在すると議論が混乱します。なるべく初期に洗い出すべきだとおもいます</li></ul></li><li>ユーザーストーリーは左から右に行うが、粒度が合わなくなってくることも<ul><li>別の時間軸（日次で行うこととか、週次処理で行うこととか）は別のカテゴリにする良い<ul><li>例えば、部門・部署統合や、ECサイトの商品カテゴリ統合による業務変更などは日々のストーリーに混ぜると粒度が別すぎて混乱する</li></ul></li><li>定常・非定常という業務分類の是非<ul><li>ユーザが定常・非定常を意識しているなら良いが、そうではないならストーリーの分類としては不適なことがある</li><li>非定常業務でもユーザストーリーに入れて自然であれば入れてしまうのも手。本当にイレギュラーな業務であれば混乱するので分ける<ul><li>在庫が切れた時だけ行うアクティビティは、随時発生だがメインのストーリーに入れても良いこともある</li></ul></li></ul></li></ul></li><li>ストーリーがだんだん横に長くなる問題がある<ul><li>ある程度は仕方ないが、あまりにも長い場合にはユースケースごとへの分離も検討</li><li>複数のペルソナを混ぜると横に長くなりがちなので、違和感がなければストーリーを分離した方が良かった<ul><li>議論中に「製造部門の人が利用するイメージでした」といった話になると面倒だった</li><li>一緒にする場合は、ペルソナがわかるアイコンを貼るテクニックもあるらしい。製造部門だと🏭とか、マーケだと🛒とか絵文字を使うと親しみやすいかも</li></ul></li></ul></li><li>既存プロダクトがあるとその画面遷移などに引きずられがち<ul><li>ユーザのアクティビティという視点を意識する。既存画面や機能はいったん頭の片隅に置く</li></ul></li><li>複数のペルソナがいるとアクティビティに依存関係がでる<ul><li>特に承認フローがあると、線でつなぎたくなるがぐっと我慢する。それはあるユーザのストーリーではない</li></ul></li><li>ストーリー上は異なる利用シーンだが、明らかに機能が重複した時<ul><li>機能は重複しても良い。定常、非定常業務で明らかに利用タイミングが異なるが、機能上は同じマスタメンテナンスでも、ストーリーとしては別なので重複して配備する</li></ul></li><li>一番下のタスクの粒度<ul><li>Backlog開発チケット粒度になる想定</li></ul></li></ul><h2 id="ユーザーストーリーマップを元にした議論を有意義にするコツ"><a href="#ユーザーストーリーマップを元にした議論を有意義にするコツ" class="headerlink" title="ユーザーストーリーマップを元にした議論を有意義にするコツ"></a>ユーザーストーリーマップを元にした議論を有意義にするコツ</h2><p>対象ドメインによって色々コツがありそうですが、一例を上げてみます。</p><ul><li>モバイル・PCなどの利用形態を変えてイメージしてみる<ul><li>通勤中などのスキマ時間で利用するか、集中して利用するものか、プッシュされてから利用するものなのかを考えるのも良い</li></ul></li><li>複数のペルソナが存在する時、そのアクティビティは別のペルソナに移譲したほうが良いでは？と考える<ul><li>特に業務系システムの場合</li></ul></li></ul><h2 id="ユーザーストーリーをもっと有意義に活かすコツ"><a href="#ユーザーストーリーをもっと有意義に活かすコツ" class="headerlink" title="ユーザーストーリーをもっと有意義に活かすコツ"></a>ユーザーストーリーをもっと有意義に活かすコツ</h2><p>主流なストーリーから外れたアクティビティもあるはずです。先程の部門統合ユースケースのような特殊例です。こちらは、どういったケースでこれらが発生するか補足したほうが共通理解が進むと思います。主流は見ればわかりますが、特殊例はどういったイベントがトリガーとなって発生するかが自明でない場合が多いからです。</p><ul><li>例1）カスタマーサービスから製品不良の連絡があれば、対象のロットを回収する</li><li>例2）売上分析から連絡があり、部門長の承認が降りれば商品カテゴリを変更する</li></ul><p>..といったことを備考に残すと、プロダクトに対する理解がチーム全体で深まります。</p><h2 id="ユーザーストーリーマップを作った後"><a href="#ユーザーストーリーマップを作った後" class="headerlink" title="ユーザーストーリーマップを作った後"></a>ユーザーストーリーマップを作った後</h2><p>ワイヤーフレームや<a href="https://signalvnoise.com/posts/1926-a-shorthand-for-designing-ui-flows">UI Flows</a>を書くことが多いと思います。私は我慢できずdraw.ioとかGoogle Jamboardでワイヤーフレームを書いてイメージをすり合わせることが多いです。主要画面の機能のイメージが付いたら、個別の設計に入っていきます。</p><p>ユーザーストーリーマッピングでは確実に議論できていないだろうことはたくさんあるので、設計しながらトピックを上げていくと良いでしょう。</p><ul><li>認証・認可・表示制御周り</li><li>表示項目・制御項目</li><li>検索要件、一括登録系の要件</li><li>MVP時点での業務運用・システム運用定義</li><li>非機能要件<ul><li>性能、可用性、機密データの暗号化、データ保持期間、監視設計、etc.</li></ul></li></ul><p>ワイヤーフレームでざっとイメージを固めた後に、UI/UX設計する場合はFigmaを活用すると良いかなと思います。</p><ul><li><a href="/articles/20200318/">【Figma】を使ってチームでUI/UX設計するといいこと</a></li></ul><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>ユーザーストーリーマップを使ってみて気がついた点を色々まとめました。要求定義として本気で使おうとすると完璧に作ろうとしてしまうかもしれません。作って終わりではなく今後もメンテナンスし続けるのが大事なので、作り込みすぎないのがコツかもしれません。</p><p>共通認識のための資料としては優秀なので、議論のスタートとしてぜひ活用したいですね！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://qiita.com/Koki_jp/items/6aebc73bedd0a932dcb8">Qiita - 簡単！楽しい！5分でわかるユーザーストーリーマッピング(User Story Mapping)</a></li><li><a href="https://www.oreilly.co.jp/books/9784873117324/">O’Reilly Japan - ユーザーストーリーマッピング</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">Technology Innovation Group（TIG）は、「最先端、且つ先進的なテクノロジーのプロフェッショナル集団」、「プロジェクト品質と生産性の向上」、「自社サービス事業の立ち上げ」を主なミッションとする、技術部隊です。DXユニットとはデジタルトランスフォーメーションを推進するチームで、IoTやらMaaSなどのテクノロジーカットでビジネス転換を行います。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">この情勢じゃなくてもセキュリティ的にアウトだったかもしれません。</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;TIG DXユニット  &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1</summary>
      
    
    
    
    <category term="Business" scheme="https://future-architect.github.io/categories/Business/"/>
    
    
    <category term="ドキュメント" scheme="https://future-architect.github.io/tags/%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88/"/>
    
    <category term="チーム開発" scheme="https://future-architect.github.io/tags/%E3%83%81%E3%83%BC%E3%83%A0%E9%96%8B%E7%99%BA/"/>
    
    <category term="ユーザーストーリーマッピング" scheme="https://future-architect.github.io/tags/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0/"/>
    
  </entry>
  
  <entry>
    <title>AWS Glueの開発環境の構築(2021)</title>
    <link href="https://future-architect.github.io/articles/20210521a/"/>
    <id>https://future-architect.github.io/articles/20210521a/</id>
    <published>2021-05-20T15:00:00.000Z</published>
    <updated>2021-05-23T05:06:27.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>AWS Glueの環境構築は過去の記事にあるのですが、公式のDockerイメージが案内されているので改めて、構築してみます。</p><ul><li>過去の類似する内容の記事<ul><li><a href="/articles/20191206/">AWS Glueの単体テスト環境の構築手順</a></li><li><a href="/articles/20191101/">AWS Glueの開発エンドポイントがそこそこお高いのでローカル開発環境を用意しました</a></li></ul></li></ul><p>なお、Glueの公式イメージでもJupyter Notebookは利用できるのですが、使い勝手を考慮し、Jupyterlabに差し替えています。</p><h1 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h1><ol><li><a href="#Dockerfile">Dockerfile作成</a></li><li><a href="#docker-compose-yml">docker-compose.yml作成</a></li><li><a href="#%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D%EF%BC%88%E6%BA%96%E5%82%99%EF%BC%89">動作確認</a></li></ol><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><code>PySpark</code>のオプションを設定しつつ、<code>gluepyspark</code>を実行していますが、<code>gluepyspark</code>が<code>PySpark</code>のwrapperになっているため、こちらの設定で問題なく動作しています。</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ベースとなる公式イメージ</span></span><br><span class="line"><span class="keyword">FROM</span> amazon/aws-glue-libs:glue_libs_1.<span class="number">0.0</span>_image_01</span><br><span class="line"></span><br><span class="line"><span class="comment"># jupyterlabインストール</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install jupyterlab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  起動スクリプト</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> jupyter_start.sh /home/jupyter</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 775 /home/jupyter/jupyter_start.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:/home/aws-glue-libs/bin/:/usr/share/maven/bin:$&#123;SPARK_HOME&#125;/bin/</span><br><span class="line"><span class="keyword">ENV</span> PYTHONPATH $PYTHONPATH:/home/jupyter/jupyter_default_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># PySparkからjupyter labを起動するためのオプション設定</span></span><br><span class="line"><span class="keyword">ENV</span> PYSPARK_DRIVER_PYTHON jupyter</span><br><span class="line"><span class="keyword">ENV</span> PYSPARK_DRIVER_PYTHON_OPTS <span class="string">&#x27; lab --allow-root --NotebookApp.token=&quot;&quot; --NotebookApp.password=&quot;&quot; --no-browser --ip=0.0.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dummy</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir ~/.aws</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> aws/config /root/.aws</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 600  ~/.aws/config</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> aws/credentials /root/.aws</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 600  ~/.aws/credentials</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dockerfileでコピーしているファイルです。</p><figure class="highlight shell"><figcaption><span>jupyter_start.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">/home/aws-glue-libs/bin/gluepyspark</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>.aws/config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[default]</span><br><span class="line">region &#x3D; ap-northeast-1</span><br><span class="line">output &#x3D; json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>.aws/credentials</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[default]</span><br><span class="line">aws_access_key_id &#x3D; xxx</span><br><span class="line">aws_secret_access_key &#x3D; xxx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h1><p><code>line10</code> で、jupyterlabのdefaultのWorkspaceにlocalをマウントしています。<br>S3(localstack)にアップロードするファイルやソースコードの同期を取ります。</p><figure class="highlight yml"><figcaption><span>docker-compsoe.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">glue.dev.summary:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">glue.dev</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">./Dockerfile</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># jupyterlabのdefaultのWorkspaceにlocalファイルをマウントします。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/home/jupyter/jupyter_default_dir</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># dummy configure</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_REGION=ap-northeast-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_OUTPUT=json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_ACCESS_KEY_ID=xxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_SECRET_ACCESS_KEY=xxx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># jupyterlabのポート</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8888</span><span class="string">:8888</span></span><br><span class="line">      <span class="comment"># spark uiのポート</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4040</span><span class="string">:4040</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">glue.dev.network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/home/jupyter/jupyter_start.sh</span></span><br><span class="line">  <span class="attr">glue.dev.s3.local:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">localstack/localstack:0.12.8</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVICES=s3</span></span><br><span class="line">      <span class="comment"># dummy configure</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_REGION=ap-northeast-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_DEFAULT_OUTPUT=json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_ACCESS_KEY_ID=xxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AWS_SECRET_ACCESS_KEY=xxx</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">glue.dev.network</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">glue.dev.network:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">glue.dev.network</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Docker-起動"><a href="#Docker-起動" class="headerlink" title="Docker 起動"></a>Docker 起動</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build</span><br></pre></td></tr></table></figure><h1 id="動作確認（準備）"><a href="#動作確認（準備）" class="headerlink" title="動作確認（準備）"></a>動作確認（準備）</h1><p>Glue/localstack(s3)を初期化し、dynamic frameで取り込んだファイルをdata frameに変換して、spark sqlを実行します。<br>こちらのスクリプトをjupyterlabで動かします。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"><span class="keyword">from</span> awsglue.job <span class="keyword">import</span> Job</span><br><span class="line"><span class="keyword">from</span> awsglue.dynamicframe <span class="keyword">import</span> DynamicFrame</span><br><span class="line"><span class="keyword">from</span> botocore.client <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line"><span class="comment"># glue Initialize</span></span><br><span class="line">os.environ[<span class="string">&quot;TEST_S3_ENDPOINT_URL&quot;</span>] = <span class="string">&quot;http://gule.dev.s3.local:4566&quot;</span></span><br><span class="line">glueContext = GlueContext(sc)</span><br><span class="line">spark = glueContext.spark_session</span><br><span class="line">job = Job(glueContext)</span><br><span class="line">job.init(<span class="string">&quot;JobName&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set S3 with localstack parameters</span></span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.endpoint&quot;</span>, <span class="string">&quot;http://gule.dev.s3.local:4566&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.path.style.access&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">sc._jsc.hadoopConfiguration().<span class="built_in">set</span>(<span class="string">&quot;fs.s3a.signing-algorithm&quot;</span>, <span class="string">&quot;S3SignerType&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># S3 init</span></span><br><span class="line">s3 = boto3.resource(</span><br><span class="line">    <span class="string">&quot;s3&quot;</span>,</span><br><span class="line">    endpoint_url=os.environ[<span class="string">&quot;TEST_S3_ENDPOINT_URL&quot;</span>],</span><br><span class="line">    region_name=<span class="string">&quot;ap-northeast-1&quot;</span>,</span><br><span class="line">    use_ssl=<span class="literal">False</span>,</span><br><span class="line">    config=Config(s3=&#123;<span class="string">&quot;addressing_style&quot;</span>: <span class="string">&quot;path&quot;</span>&#125;),</span><br><span class="line">)</span><br><span class="line">bucket_name = <span class="string">&quot;test-csv-bucket&quot;</span></span><br><span class="line">bucket = s3.Bucket(bucket_name)</span><br><span class="line">bucket.create(ACL=<span class="string">&quot;public-read-write&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get dynamic frame and data frame convert</span></span><br><span class="line">bucket.upload_file(<span class="string">&quot;tests/data/sample.json&quot;</span>, <span class="string">&quot;sample/sample.json&quot;</span>)</span><br><span class="line">p = <span class="string">&quot;s3://test-csv-bucket/sample/&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;input-tables&quot;</span>, <span class="string">f&quot;sample.json&quot;</span>)</span><br><span class="line">df = glueContext.create_dynamic_frame.from_options(</span><br><span class="line">    connection_type=<span class="string">&quot;s3&quot;</span>,</span><br><span class="line">    connection_options=&#123;<span class="string">&quot;paths&quot;</span>: [p]&#125;,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&quot;json&quot;</span>,</span><br><span class="line">).toDF()</span><br><span class="line">df.count()</span><br><span class="line">df.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># spark sql exec</span></span><br><span class="line">df.createOrReplaceTempView(<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">spark.sql(<span class="string">&quot;show tables&quot;</span>).show()</span><br><span class="line">spark.sql(<span class="string">&quot;select count(*) from sample&quot;</span>).show()</span><br><span class="line">spark.sql(<span class="string">&quot;select * from sample&quot;</span>).show()</span><br></pre></td></tr></table></figure><h1 id="動作確認"><a href="#動作確認" class="headerlink" title="動作確認"></a>動作確認</h1><p>ブラウザより、<code>http://localhost:8888</code> を実装し、jupyterlabで動かします。</p><p><code>docker-compose.yml</code> でマウントしたlocalストレージに<code>tests/data/sample.json</code>を用意して、実行してみます。<br>せっかくなので、処理ブロック単位に動かします。</p><img src="/images/20210521a/gluesample.gif" alt="jupyterlabでの操作動画" width="640" height="480" loading="lazy"><h1 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h1><p>ローカルでAWSに依存せず、GlueのAPIをインタラクティブに確認できるので、開発効率としては良いのではないでしょうか。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;AWS Glueの環境構築は過去の記事にあるのですが、公式のDockerイメージが案内されているので改めて、構築してみます。&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="Glue" scheme="https://future-architect.github.io/tags/Glue/"/>
    
    <category term="JupyterNotebook" scheme="https://future-architect.github.io/tags/JupyterNotebook/"/>
    
  </entry>
  
  <entry>
    <title>コンテナイメージ内の実行ファイルをupxで圧縮するべきか</title>
    <link href="https://future-architect.github.io/articles/20210520b/"/>
    <id>https://future-architect.github.io/articles/20210520b/</id>
    <published>2021-05-19T15:00:01.000Z</published>
    <updated>2021-05-26T11:59:56.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="コンテナイメージ内の実行ファイルをupxで圧縮するべきか"><a href="#コンテナイメージ内の実行ファイルをupxで圧縮するべきか" class="headerlink" title="コンテナイメージ内の実行ファイルをupxで圧縮するべきか"></a>コンテナイメージ内の実行ファイルをupxで圧縮するべきか</h1><p>福田（<a href="https://twitter.com/knqyf263">@knqyf263</a>）と申します。過去にフューチャー発OSSのVuls開発を手伝っていましたが、現在はフューチャーで働いているわけでもなく完全に部外者です。今回は社員の澁川さんの推薦もあり、ブログの寄稿をさせて頂くことになりました。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>その理由の前に少し背景を説明しますが、自分はTrivyというOSSの脆弱性スキャナーのメンテナをやっていまして先日Goバイナリの脆弱性検知をする機能をリリースしました。</p><iframe src="https://hatenablog-parts.com/embed?url=https%3A%2F%2Fknqyf263.hatenablog.com%2Fentry%2F2021%2F04%2F30%2F061147" style="border: 0; width: 100%; height: 190px;" allowfullscreen scrolling="no"></iframe><p>例えばコンテナイメージ内にGoでビルドしたバイナリを1つだけ置いている場合などにも検知が出来るためとても便利です（自画自賛）。stripなどでシンボルを落としていてもセクションヘッダにモジュール情報が残っているため検知は動作するのですが、upxでバイナリを圧縮している場合には動きません。</p><p>upxというのは実行ファイルを圧縮するためのツールで色々なOSのファイル形式に対応しており展開も高速なので広く使われています。多くのプラットフォームで内部的にLZMAを利用しており圧縮率もzip/gzipより高いと謳っています。</p><p><a href="hhttps://github.com/upx/upx/blob/8d42b12117130b944023335cc2b76072c145db4d/doc/upx.pod" alt="upx/upx"><img src="https://gh-card.dev/repos/upx/upx.svg" loading="lazy"></a></p><p>実行時にupxが自分で自分を展開してそのまま実行してくれるので、ユーザの方で一度展開してから実行するといった処理は必要ありません。単にバイナリのサイズが小さくなるイメージです。</p><p>実行ファイルのサイズが小さければダウンロードも速いですしいくつかの利点が得られるため、こういった圧縮ツールを使っている人も多いかと思います。ではコンテナイメージ内に置くような実行ファイルでも圧縮するべきかどうか、というのが今回のブログのネタです。</p><p>コンテナイメージのサイズは小さい方が良い、というのは聞いたことがある人が多いと思うので当然圧縮するべきだろうと思うかもしれませんが、コンテナイメージはレイヤー単位でgzipで圧縮されDocker Hubなどのコンテナレジストリに格納されます。単にイメージのサイズだけで考えるのではなく実際にpullする時にどう影響が出るのかについて考えるほうが良さそうであるというのは以前雑に述べていたりしました。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">自分もデバッグ大変になるの嫌なのであまりまとめないことが多いです。ただイメージサイズ変わらなくてもpullする時はlayer単位でtar.gzになるのでまとめると圧縮が効いてかなり小さくなるとかはありますかね。一方で並列度が上がる利点もありますが。<a href="https://t.co/KqEVsDwxDJ">https://t.co/KqEVsDwxDJ</a></p>&mdash; イスラエルいくべぇ (@knqyf263) <a href="https://twitter.com/knqyf263/status/1352123800784142336?ref_src=twsrc%5Etfw">January 21, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>というような雑談をSlackでしていたところ、フューチャー社員の渋川さん（ @shibu_jp ）からupxでサイズ小さくすることにどのぐらいの意味があるのか？という疑問が出ました。</p><img src="/images/20210520b/Slack___tsuda_knqyf263___Cyber_Security_Innovation_Group.png" alt="Slack___tsuda_knqyf263___Cyber_Security_Innovation_Group.png" loading="lazy"><p>ちなみに渋川さんはフューチャー技術ブログで数多くの素晴らしいブログを執筆されています。</p><ul><li><a href="/authors/%E6%BE%81%E5%B7%9D%E5%96%9C%E8%A6%8F/">澁川喜規 | フューチャー技術ブログ</a></li></ul><p>確かにレイヤーをgzipで圧縮したらupxによる圧縮と差はそこまで大きくならないんじゃないか、という気がしたので検証してみました。upxの方は圧縮したあとに再度gzipで圧縮することになるので二度目のgzip圧縮率はかなり低いと考えられます。渋川さんから出た疑問だったのでフューチャーのブログに載せようということで今回寄稿することになりました。</p><h1 id="検証（macho）"><a href="#検証（macho）" class="headerlink" title="検証（macho）"></a>検証（macho）</h1><p>upxは様々なOSの実行ファイル形式に対応していますが、自分はmacOSを使っているためまずmachoで試してみます。</p><h2 id="upxで圧縮しない場合"><a href="#upxで圧縮しない場合" class="headerlink" title="upxで圧縮しない場合"></a>upxで圧縮しない場合</h2><p>まずは普通にupxせずにDockerイメージを作ってみます。</p><h3 id="バイナリのビルド"><a href="#バイナリのビルド" class="headerlink" title="バイナリのビルド"></a>バイナリのビルド</h3><p>TrivyをmacOS上でビルドしてみます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o trivy cmd/trivy/main.go</span><br><span class="line">$ du -bh trivy</span><br><span class="line">41M     trivy</span><br></pre></td></tr></table></figure><p>バイナリのサイズは41MBでした。今回は <code>ldflags &#39;-w -s&#39;</code>などのオプションは付けていないためDWARFやシンボルテーブルは残っています。</p><h3 id="イメージのbuild-push"><a href="#イメージのbuild-push" class="headerlink" title="イメージのbuild/push"></a>イメージのbuild/push</h3><p>レジストリに置いたらどのぐらいのサイズなのか？というのは実際にpushしてしまうほうが早いと思うので、buildしてレジストリにpushします。まずビルドします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t knqyf263/trivy:macho-nonupx .</span><br><span class="line">Sending build context to Docker daemon  49.69MB</span><br><span class="line">Step 1/5 : FROM alpine:3.13</span><br><span class="line"> ---&gt; 6dbb9cc54074</span><br><span class="line">Step 2/5 : RUN apk --no-cache add ca-certificates git</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 079d3d306dcd</span><br><span class="line">Step 3/5 : COPY trivy /usr/<span class="built_in">local</span>/bin/trivy</span><br><span class="line"> ---&gt; 98973bc45fe2</span><br><span class="line">Step 4/5 : COPY contrib/*.tpl contrib/</span><br><span class="line"> ---&gt; e09be4486dd5</span><br><span class="line">Step 5/5 : ENTRYPOINT [<span class="string">&quot;trivy&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9bc4e9b607c9</span><br><span class="line">Removing intermediate container 9bc4e9b607c9</span><br><span class="line"> ---&gt; 1be57dd63281</span><br><span class="line">Successfully built 1be57dd63281</span><br><span class="line">Successfully tagged knqyf263/trivy:macho-upx</span><br></pre></td></tr></table></figure><p>Step 3を見てもらえば分かりますが、単にホスト側にあるバイナリをCOPYで置いています。machoのバイナリをコピーしているせいで動かないのですがサイズの検証なので気にせず進めていきます。</p><p>そしてこのイメージをpushします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker push knqyf263/trivy:macho-nonupx</span><br><span class="line">The push refers to repository [docker.io/knqyf263/trivy]</span><br><span class="line">27289a563633: Pushed</span><br><span class="line">f8edd4bba8b2: Pushed</span><br><span class="line">464f5bb1fc11: Layer already exists</span><br><span class="line">b2d5eeeaba3a: Layer already exists</span><br><span class="line">macho-nonupx: digest: sha256:5fc7352ecd65e3f2eada6f251ef91c721c685d61046c2c948ebfabfec52f8582 size: 1159</span><br></pre></td></tr></table></figure><p>無事にpushできました。</p><h3 id="レイヤーサイズの確認"><a href="#レイヤーサイズの確認" class="headerlink" title="レイヤーサイズの確認"></a>レイヤーサイズの確認</h3><p>ではレジストリにあるレイヤーのサイズを確認してみます。craneというツールを使います。Googleのgo-containerregistryというライブラリに付随しているCLIツールになります。</p><p><a href="https://github.com/google/go-containerregistry/tree/main/cmd/crane">https://github.com/google/go-containerregistry/tree/main/cmd/crane</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ crane manifest knqyf263/trivy:macho-nonupx</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: 2,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: 2264,</span><br><span class="line">      <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:3b2add278b7f6df5e72f0d6592ece9cbb22c859fc01e6d8932e036d335f6074c&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;layers&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 2811969,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:540db60ca9383eac9e418f78490994d0af424aab7bf6d0e47ac8ed4e2e9bcbba&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 6664328,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:8e566f9a0cb95716b962ba9e17b0c0e3f1b970c51424032dcb7c660dce3d5ee6&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 18900731,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:cdcee5fd7ec2508ee27e439924a888be100e6f2cd08e8a9c89ee43911c2dd655&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 4052,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:cbcc716d57451836029ade124851f09b7474aee4ca711741086cd54194d73102&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下から二番目のレイヤーがバイナリを置いたレイヤーなので18.03MB（ <code>=18900731/(1024*1024)</code> )になっています。</p><h3 id="Docker-Hubで確認"><a href="#Docker-Hubで確認" class="headerlink" title="Docker Hubで確認"></a>Docker Hubで確認</h3><p>念のためDocker HubのUIでも確認します。</p><img src="/images/20210520b/Untitled.png" alt="Docker HubのUI" loading="lazy"><p>確かに18.03MBになっています。一応リンクも貼っておきます。</p><p><a href="https://hub.docker.com/layers/knqyf263/trivy/macho-nonupx/images/sha256-5fc7352ecd65e3f2eada6f251ef91c721c685d61046c2c948ebfabfec52f8582?context=repo">https://hub.docker.com/layers/knqyf263/trivy/macho-nonupx/images/sha256-5fc7352ecd65e3f2eada6f251ef91c721c685d61046c2c948ebfabfec52f8582?context=repo</a></p><h3 id="サイズ比較"><a href="#サイズ比較" class="headerlink" title="サイズ比較"></a>サイズ比較</h3><p>ということで上記の結果をまとめると以下のようになります。</p><ul><li>バイナリのサイズ：41MB</li><li>レイヤーのサイズ：18.03MB</li></ul><p>バイナリのサイズは41MBもあったのにレイヤーに置いてgzipすると18MBまで減っています。</p><h2 id="upxで圧縮する場合"><a href="#upxで圧縮する場合" class="headerlink" title="upxで圧縮する場合"></a>upxで圧縮する場合</h2><p>先程ビルドしたバイナリがあるのでこれをupxで圧縮します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ upx ./trivy</span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">  42502160 -&gt;  19062800   44.85%   macho/amd64   trivy</span><br><span class="line"></span><br><span class="line">Packed 1 file.</span><br></pre></td></tr></table></figure><p>upxは圧縮レベルが1から10まであり、512 KiB以下だと8が使われて大きいサイズだと7が使われるようです。10も試してみたのですが（厳密には <code>--best</code>）、今回の検証ではあまりサイズが変わらなかったのでとりあえず7の結果について書いています。</p><p>上のupxの出力で19MBぐらいになってサイズが44.85%になったと書いてあります。念のため確認しておきます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ du -h trivy</span><br><span class="line">19M     trivy</span><br></pre></td></tr></table></figure><p>やはり19MBです。</p><h3 id="イメージのbuild-push-1"><a href="#イメージのbuild-push-1" class="headerlink" title="イメージのbuild/push"></a>イメージのbuild/push</h3><p>ここは先程と同様にイメージのbuild/pushをします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t knqyf263/trivy:macho-upx .</span><br><span class="line">$ docker push knqyf263/trivy:macho-upx</span><br><span class="line">The push refers to repository [docker.io/knqyf263/trivy]</span><br><span class="line">d2fb9e0dd8ea: Pushed</span><br><span class="line">d9a3ad8f3256: Pushed</span><br><span class="line">464f5bb1fc11: Layer already exists</span><br><span class="line">b2d5eeeaba3a: Layer already exists</span><br><span class="line">macho-upx: digest: sha256:de09d822301411eb563b0e1b6fd014a0b1017eac941bb62e7bc159012b4732de size: 1159</span><br></pre></td></tr></table></figure><h3 id="レイヤーサイズの確認-1"><a href="#レイヤーサイズの確認-1" class="headerlink" title="レイヤーサイズの確認"></a>レイヤーサイズの確認</h3><p>先程同様に確認します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ ./crane manifest knqyf263/trivy:macho-upx</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: 2,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: 2267,</span><br><span class="line">      <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:ea6eb68a192d77914019c840ab46e9e56ea69f8aa8eef27befbaca5a623bbb39&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;layers&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 2811969,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:540db60ca9383eac9e418f78490994d0af424aab7bf6d0e47ac8ed4e2e9bcbba&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 6664328,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:8e566f9a0cb95716b962ba9e17b0c0e3f1b970c51424032dcb7c660dce3d5ee6&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 18719684,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:d1471d88b38fce964464adabe62c9e2819cf66c62d0683567b9fcc090de76055&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 4080,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:2fe2f7d7b9e2e83ce09db2a8599908864a8d9d3433bcfb8dce7aed35138ca3f4&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今回は17.85MBになっています。</p><h3 id="Docker-Hubで確認-1"><a href="#Docker-Hubで確認-1" class="headerlink" title="Docker Hubで確認"></a>Docker Hubで確認</h3><p>やはりサイズは17.85MBです。</p><img src="/images/20210520b/Untitled1.png" alt="Docker HubのUI" loading="lazy"><p><a href="https://hub.docker.com/layers/knqyf263/trivy/macho-upx/images/sha256-de09d822301411eb563b0e1b6fd014a0b1017eac941bb62e7bc159012b4732de?context=repo">https://hub.docker.com/layers/knqyf263/trivy/macho-upx/images/sha256-de09d822301411eb563b0e1b6fd014a0b1017eac941bb62e7bc159012b4732de?context=repo</a></p><h3 id="サイズ比較-1"><a href="#サイズ比較-1" class="headerlink" title="サイズ比較"></a>サイズ比較</h3><p>上記の結果をまとめると以下になります。</p><ul><li>バイナリサイズ：19MB</li><li>レイヤーサイズ：17.85MB</li></ul><h2 id="サイズ比較まとめ"><a href="#サイズ比較まとめ" class="headerlink" title="サイズ比較まとめ"></a>サイズ比較まとめ</h2><p>ではupxによって圧縮した場合としない場合のサイズを比べてみます。</p><ul><li>upx圧縮しない場合<ul><li>バイナリサイズ：41MB</li><li>レイヤーサイズ：18.03MB</li></ul></li><li>upx圧縮した場合<ul><li>バイナリサイズ：19MB</li><li>レイヤーサイズ：17.85MB</li></ul></li></ul><p>ということで差は0.18MB程度になりました。予想通り、upxによる圧縮はレイヤー圧縮と比較して著しく効果があるわけではなさそうです。ELFでも検証してみます。</p><h1 id="検証（ELF）"><a href="#検証（ELF）" class="headerlink" title="検証（ELF）"></a>検証（ELF）</h1><p>Linuxでコンテナイメージを使うケースが大多数だと思うので、ELF形式の場合の検証もしてみます。</p><h2 id="upxで圧縮しない場合-1"><a href="#upxで圧縮しない場合-1" class="headerlink" title="upxで圧縮しない場合"></a>upxで圧縮しない場合</h2><h3 id="バイナリのビルド-1"><a href="#バイナリのビルド-1" class="headerlink" title="バイナリのビルド"></a>バイナリのビルド</h3><p>linux/amd64向けにビルドします。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ GOOS=linux GOARCH=amd64 go build -o trivy cmd/trivy/main.go</span><br><span class="line">$ du -h trivy</span><br><span class="line">41M     trivy</span><br></pre></td></tr></table></figure><p>machoの時と同じく41MBでした。</p><h3 id="Docker-Hubで確認-2"><a href="#Docker-Hubで確認-2" class="headerlink" title="Docker Hubで確認"></a>Docker Hubで確認</h3><p>machoの時と同じくイメージをbuild/pushし、今回は直接Docker Hubで確認してみます。</p><img src="/images/20210520b/Untitled2.png" alt="Docker HubのUI" loading="lazy"><p>18.25MBでした。</p><p><a href="https://hub.docker.com/layers/knqyf263/trivy/elf-nonupx/images/sha256-cea16479687eaa610bf0bfec96e415f791aea1ca19e7e26fa6240ed5a8448b75?context=repo">https://hub.docker.com/layers/knqyf263/trivy/elf-nonupx/images/sha256-cea16479687eaa610bf0bfec96e415f791aea1ca19e7e26fa6240ed5a8448b75?context=repo</a></p><h2 id="サイズ比較-2"><a href="#サイズ比較-2" class="headerlink" title="サイズ比較"></a>サイズ比較</h2><ul><li>バイナリのサイズ：41MB</li><li>レイヤーのサイズ：18.25MB</li></ul><h2 id="upxで圧縮する場合-1"><a href="#upxで圧縮する場合-1" class="headerlink" title="upxで圧縮する場合"></a>upxで圧縮する場合</h2><h3 id="バイナリのビルド-2"><a href="#バイナリのビルド-2" class="headerlink" title="バイナリのビルド"></a>バイナリのビルド</h3><p>upxで圧縮します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ upx ./trivy</span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">  42878967 -&gt;  20087380   46.85%   linux/amd64   trivy</span><br><span class="line"></span><br><span class="line">Packed 1 file.</span><br><span class="line">$ du -h ./trivy</span><br><span class="line">20M     ./trivy</span><br></pre></td></tr></table></figure><p>20MBになりました。</p><h3 id="Docker-Hubで確認-3"><a href="#Docker-Hubで確認-3" class="headerlink" title="Docker Hubで確認"></a>Docker Hubで確認</h3><p>18.64MBでした。</p><img src="/images/20210520b/Untitled3.png" alt="Docker HubのUI" loading="lazy"><h3 id="サイズ比較-3"><a href="#サイズ比較-3" class="headerlink" title="サイズ比較"></a>サイズ比較</h3><p>ELFバイナリをupxした場合のサイズ比較は以下になります。</p><ul><li>バイナリのサイズ：20MB</li><li>レイヤーのサイズ：18.64MB</li></ul><h2 id="サイズ比較まとめ-1"><a href="#サイズ比較まとめ-1" class="headerlink" title="サイズ比較まとめ"></a>サイズ比較まとめ</h2><ul><li>upx圧縮しない場合<ul><li>バイナリサイズ：41MB</li><li>レイヤーサイズ：18.25MB</li></ul></li><li>upx圧縮した場合<ul><li>バイナリサイズ：20MB</li><li>レイヤーサイズ：18.64MB</li></ul></li></ul><p>恐ろしいことが起きています。サイズが逆転しました。upx圧縮した場合のほうが、0.39MBもレイヤーサイズが増えています。先程machoで削減したのが0.18MBだったことを考えるとかなり増えている印象です。</p><p>upxは内部でLZMAを使っておりgzipよりも圧縮率が高いことを謳っているので、なぜこんな事が起きるのかと思いますがupxは実行ファイル形式を保つために展開プログラムもバイナリに埋め込んでいるため、単純なgzipと比較すると大きくなってしまうことがあるのかもしれません。レイヤーは丸ごとgzipされ展開されてから利用される前提で、upxは実行ファイルのまま圧縮して実行時に展開する想定なので戦っている土俵が違う感じがあります。レイヤーgzipの場合は展開プログラムはレイヤーの外にあります。実行時に展開できる形でgzipを使うとupxに劣るという意味で、gzipよりも圧縮率が高いと言っているのかもしれません。あくまで推測なので厳密なところは分かっていません。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>今回はupxで圧縮した実行ファイルをコンテナイメージに置いた場合のサイズ削減率について検証しました。元からコンテナイメージはレイヤー単位でgzip圧縮されるため、upxで圧縮してもそこまで大きなサイズの削減は得られませんでした。</p><p>これはもちろんプラットフォームやアーキテクチャによっても異なると思いますしプロジェクトによっても異なります。TrivyのELFの例では増えてしまいましたが、フューチャーが提供しているVulsというOSSではELFでも0.1MB程度サイズが小さくなりました。stripしたりldflagsを付けたりすることで結果が変わってくる可能性もあります。</p><p>レイヤーに他のバイナリが存在したらgzipがさらに有利になる可能性もありますし、Goのバイナリ以外は検証していないのでupxの方が有利になる可能性もあります。</p><p>サイズの比較だけをしてきましたが、upxは当然実行時の展開コストもあります。以下は古いCPUにおける値なので今はもっと速いと思いますが、それでもバイナリが大きくなれば展開コストはある程度大きくなってきます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- very fast decompression: about 10 MiB&#x2F;sec on an ancient Pentium 133,</span><br><span class="line">    about 200 MiB&#x2F;sec on an Athlon XP 2000+.</span><br></pre></td></tr></table></figure><p>他にもイメージビルド時に圧縮の時間もかかるためCI/CDの時間は増加します。 <code>--best</code> をつけるとTrivyの41MBのELF実行ファイルをupxで圧縮するのに5分かかりました。イメージビルドの時間を5分増加させて0.1MBの削減だった場合にそれが見合っているのかどうかは考える必要があると思います。5分増加させた挙げ句にサイズも増えていると最悪です。</p><p>そもそもupxの導入にかかるコストもあります。Dockerfileを修正したりCI/CDの設定をしたりが必要になってきます。</p><p>今回のブログでは必ずupxするべきだ、絶対にupxするべきではない、ということは言っていません。ただ盲目的にupxで圧縮しておけば良いわけではないことを知ってもらえればと思い書いています。もし本当にイメージサイズを削減したいならきちんと検証して比較することをおすすめします。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;コンテナイメージ内の実行ファイルをupxで圧縮するべきか&quot;&gt;&lt;a href=&quot;#コンテナイメージ内の実行ファイルをupxで圧縮するべきか&quot; class=&quot;headerlink&quot; title=&quot;コンテナイメージ内の実行ファイルをupxで圧縮するべきか&quot;&gt;&lt;/a&gt;コン</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Docker" scheme="https://future-architect.github.io/tags/Docker/"/>
    
    <category term="コンテナビルド" scheme="https://future-architect.github.io/tags/%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%83%93%E3%83%AB%E3%83%89/"/>
    
    <category term="upx" scheme="https://future-architect.github.io/tags/upx/"/>
    
    <category term="外部寄稿" scheme="https://future-architect.github.io/tags/%E5%A4%96%E9%83%A8%E5%AF%84%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title>エンジニアが持っておくと幸せになれるビジネス視点</title>
    <link href="https://future-architect.github.io/articles/20210520a/"/>
    <id>https://future-architect.github.io/articles/20210520a/</id>
    <published>2021-05-19T15:00:00.000Z</published>
    <updated>2021-05-25T16:13:28.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本エントリーの目的"><a href="#本エントリーの目的" class="headerlink" title="本エントリーの目的"></a>本エントリーの目的</h1><p>もしあなたがテックリード（または志している）エンジニアであれば、きっとこんな風に感じた経験があるのではないでしょうか。</p><p>「世界にはイカした新技術（しかもオープンなのに！）がこんなにたくさんあるのに、なぜどれだけ主張しても採用が叶わないのだろう」と。</p><p>それが原因で上司と衝突したり、あるいはその場を去るきっかけになった方もいるかもしれません。</p><p>そんな悩めるエンジニアが、ここぞという時に突破するための大切な「ビジネス視点」の話をします。</p><p>システム導入プロジェクトでなされる様々な意思決定のツボを知ることで、一段高い視座での技術的リーダーシップ発揮へ役立てていただければ幸いです。</p><h2 id="なぜエンジニアにビジネス視点が必要か"><a href="#なぜエンジニアにビジネス視点が必要か" class="headerlink" title="なぜエンジニアにビジネス視点が必要か"></a>なぜエンジニアにビジネス視点が必要か</h2><p>答えはシンプルです。趣味や学術研究領域のエンジニアでない限り、我々は基本的に「ビジネスの世界でエンジニアリングを生業としている」からです。</p><p>平たく言うと、お給料をもらっているエンジニアであれば、そのお金の元をたどれば必ず何らかの事業活動（＝ビジネス）があるはずなのです。</p><p>ビジネス視点を持てば、事業活動が見えてくる。そうすれば、エンジニア自身の立ち振る舞いにも何らか活かせるような気がしますよね。</p><p>ここでいう「ビジネス視点」とは、一言でいうと何か。<br>それは「経済合理性」です。</p><h2 id="ビジネスで重視される「経済合理性」とは"><a href="#ビジネスで重視される「経済合理性」とは" class="headerlink" title="ビジネスで重視される「経済合理性」とは"></a>ビジネスで重視される「経済合理性」とは</h2><p>さて、ビジネス視点を紐解いていきましょう。</p><p>企業のシステム導入プロジェクトではよく「IT投資」という表現を使います。割となんとなく見過ごしがちなのですが、この「投資」という言葉が重要です。</p><p>そう。企業にとって、システム導入は「投資」なのです。</p><p>個人でいえば、株や不動産を買って資産を増やす、あれです。<br>資本を投じ、リスクを取って、リターンを期待する、あれです。</p><p>企業も一緒です。</p><p>資金や人的リソースを投じ、様々なリスクを取って、何らかのリターンを期待する。その期待できるリターンが投入資本やリスクよりも大きいからこそ、構想したプロジェクト企画に対して経営者がGOを出すのです。</p><p>この関係性は、分かりやすく式で表現することができます。</p><p>　<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="27.175ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 12011.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">リ</text><text data-variant="normal" transform="translate(900,0) scale(1,-1)" font-size="884px" font-family="serif">タ</text><text data-variant="normal" transform="translate(1800,0) scale(1,-1)" font-size="884px" font-family="serif">ー</text><text data-variant="normal" transform="translate(2700,0) scale(1,-1)" font-size="884px" font-family="serif">ン</text><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z" transform="translate(3600,0)"></path><text data-variant="normal" transform="translate(4378,0) scale(1,-1)" font-size="884px" font-family="serif">投</text><text data-variant="normal" transform="translate(5278,0) scale(1,-1)" font-size="884px" font-family="serif">入</text><text data-variant="normal" transform="translate(6178,0) scale(1,-1)" font-size="884px" font-family="serif">資</text><text data-variant="normal" transform="translate(7078,0) scale(1,-1)" font-size="884px" font-family="serif">本</text></g><g data-mml-node="mo" transform="translate(8255.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(9311.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">リ</text><text data-variant="normal" transform="translate(900,0) scale(1,-1)" font-size="884px" font-family="serif">ス</text><text data-variant="normal" transform="translate(1800,0) scale(1,-1)" font-size="884px" font-family="serif">ク</text></g></g></g></svg></mjx-container></p><p>では、IT投資に期待される「リターン」とは何か。</p><p>ここにビジネスで重視される「経済合理性」がクッキリと表れてきます。</p><h2 id="IT投資に期待される５つのリターン"><a href="#IT投資に期待される５つのリターン" class="headerlink" title="IT投資に期待される５つのリターン"></a>IT投資に期待される５つのリターン</h2><p>次の図をご覧ください。</p><img src="/images/20210520a/5つのリターン.png" alt="1.売上を伸ばす、2.売上を下げない、3業務効率化、4.システムコスト削減、5.コンプライアンス・リスク対応" width="1572" height="882" loading="lazy"><p>「事業継続」というのは、「やらないとどうしようもない」投資なので、実施自体が投資の目的です。それ以外の４つは、「売上」を何とかするか、「コスト」を何とかするか。</p><p>すなわちたいていの場合、投資対効果というのは「利益の拡大」、すなわち「儲かるかどうか」が要点です。先述の式にあてはめれば、リスクを差っ引いても、投入資本よりも利益を拡大できることが、経済合理性がある、ということです。</p><p>これはビジネス視点では、非常に強い前提事項です。個人の投資に例えれば・・・説明不要ですよね。</p><p>さて、最初の疑問に戻りましょう。</p><p>「世界にはイカした新技術（しかもオープンなのに！）がこんなにたくさんあるのに、なぜどれだけ主張しても採用が叶わないのだろう」</p><h2 id="ビジネスサイドが新技術を採用しない主な理由と対策"><a href="#ビジネスサイドが新技術を採用しない主な理由と対策" class="headerlink" title="ビジネスサイドが新技術を採用しない主な理由と対策"></a>ビジネスサイドが新技術を採用しない主な理由と対策</h2><h3 id="【理由１】リターン起因：新技術を採用しても「別に儲からない」と思われているから"><a href="#【理由１】リターン起因：新技術を採用しても「別に儲からない」と思われているから" class="headerlink" title="【理由１】リターン起因：新技術を採用しても「別に儲からない」と思われているから"></a>【理由１】リターン起因：新技術を採用しても「別に儲からない」と思われているから</h3><p>極めて残念な帰結です。先に述べた「５つのリターン」に対し、候補技術の必要性・効能が伝わっていないということです。技術トレンドだけでは、ましてやロマンやムードだけでは、ビジネス判断は動かないのです。（逆に、技術トレンドやムードのみでされるような技術選定は、ビジネス視点で非常に危ういものということもできます）</p><p>この場合、候補技術が「売上」「コスト」観点でいかに寄与するか、ロジックを組み立てるのが有効です。</p><p>劇的に開発生産性が向上するのであれば分かりやすいですが、たいていの場合、新技術はキャッチアップコストがかかります。中長期のメンテナンスコスト効果、変化対応力向上（エコシステムの将来性含む）等を主軸に置くとよいでしょう。</p><p>なお、有償の開発プラットフォーム（SaaS、ローコード等）は逆の注意が必要です。短期的にコスト削減効果が大きくても、中長期踏まえてIT投資の目的に寄与するか・足枷にならないかどうか、保守運用観点で吟味しましょう。</p><h3 id="【理由２】リスク起因：新技術を採用すると「デリバリリスクが高まる」と思われているから"><a href="#【理由２】リスク起因：新技術を採用すると「デリバリリスクが高まる」と思われているから" class="headerlink" title="【理由２】リスク起因：新技術を採用すると「デリバリリスクが高まる」と思われているから"></a>【理由２】リスク起因：新技術を採用すると「デリバリリスクが高まる」と思われているから</h3><p>先ほどの式を思い出してください。</p><p>　<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="27.175ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 12011.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">リ</text><text data-variant="normal" transform="translate(900,0) scale(1,-1)" font-size="884px" font-family="serif">タ</text><text data-variant="normal" transform="translate(1800,0) scale(1,-1)" font-size="884px" font-family="serif">ー</text><text data-variant="normal" transform="translate(2700,0) scale(1,-1)" font-size="884px" font-family="serif">ン</text><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z" transform="translate(3600,0)"></path><text data-variant="normal" transform="translate(4378,0) scale(1,-1)" font-size="884px" font-family="serif">投</text><text data-variant="normal" transform="translate(5278,0) scale(1,-1)" font-size="884px" font-family="serif">入</text><text data-variant="normal" transform="translate(6178,0) scale(1,-1)" font-size="884px" font-family="serif">資</text><text data-variant="normal" transform="translate(7078,0) scale(1,-1)" font-size="884px" font-family="serif">本</text></g><g data-mml-node="mo" transform="translate(8255.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(9311.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">リ</text><text data-variant="normal" transform="translate(900,0) scale(1,-1)" font-size="884px" font-family="serif">ス</text><text data-variant="normal" transform="translate(1800,0) scale(1,-1)" font-size="884px" font-family="serif">ク</text></g></g></g></svg></mjx-container></p><p>技術選定には、リターンだけでなく、リスク観点も重要になります。経験済の方も多いのではと思いますが、一般的に、未経験の技術要素を含む場合、プロジェクトデリバリの難易度は高まります。そのため、ビジネスサイドは、社内外に実績豊富な技術採用をしやすい傾向があります。</p><p>新技術を提案する際には、入念に調査・準備をし、リスクヘッジとその説明に努めましょう。もちろん、「作って終わり」ではなく、保守運用観点のリスク対応も忘れずに。</p><p>実績づくりとして、スモールサクセスを積み重ねることも有効です。調査研究ネタをテックブログの記事にするのもイイですね。</p><h2 id="目的が大事"><a href="#目的が大事" class="headerlink" title="目的が大事"></a>目的が大事</h2><p>ここまで、技術選定を例に「経済合理性」というビジネス視点の役立て方を説明してきました。</p><p>さて、もう一つ大切な視点をお伝えして締めたいと思います。</p><p>それは、「技術＝手段」であり「目的が大事」ということです。</p><p>技術に生きるものとして、自ら手掛けるモノのクオリティにこだわるのは当然です。しかし、最初に述べた通り、あくまで「事業活動のための技術活用」です。</p><img src="/images/20210520a/問題解決のために大切なこと.png" alt="目的＞方針＞手段。方針策定の事実の関係図" width="1567" height="882" loading="lazy"><p>ビジネスに限らず、すべての活動において重要なのは「目的を見失わない」こと。目的を定め、必要な事実（ファクト）をしっかりと収集する。そして、「目的」と「手段」をつなぐために「方針」として言語化する。「方針」を明確にすると、「手段」の選択肢を比較検討し、その中から最適解を効率的に選ぶことができる。</p><p>テックリードは「目的」をしっかりと見据えつつ、「方針」を打ち出すことが重要な役割です。</p><p>「手段」としての技術の選択肢を追うだけではなく、「何のためのシステム開発なのか」を技術視点で語れることが重要と思います。「業務要件を決めてもってきて」と線引き・下請けするのではなく、「IT投資の目的に照らすとこの方針を取るべし」と仮説を立てることが成功のカギです。</p><p>スマートに目的達成できるエンジニア、ステキだと思います。</p><h2 id="余談：経済合理性の功罪"><a href="#余談：経済合理性の功罪" class="headerlink" title="余談：経済合理性の功罪"></a>余談：経済合理性の功罪</h2><p>ちなみに、あまり経済合理性ばかり追求しすぎるのも、中長期目線では考えものです。</p><p>組織開発・人材育成はメンバーのモチベーション・感性によるところが大きいこともあり、経済合理性ばかり追求するとうまくいかないといわれています。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今回は新技術の選定・採用検討を例に、なぜエンジニアにビジネス視点が必要か、「経済合理性」というビジネス視点の役立て方を紹介しました。そして、問題解決のためには「目的を見失わない」ことの重要性を述べました。</p><p>ちょっと毛色の違うエントリーでしたが、ここまで読んでいただき、ありがとうございました。日々の業務のどこかで役立てていただければ幸いです。</p><p>以上、「エンジニアが持っておくと幸せになれるビジネス視点」でした。「経済合理性」はビジネス視点のほんの一部に過ぎないので、ぜひ技術・ビジネスとシームレスに、興味関心を持ってみてください。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本エントリーの目的&quot;&gt;&lt;a href=&quot;#本エントリーの目的&quot; class=&quot;headerlink&quot; title=&quot;本エントリーの目的&quot;&gt;&lt;/a&gt;本エントリーの目的&lt;/h1&gt;&lt;p&gt;もしあなたがテックリード（または志している）エンジニアであれば、きっとこんな風に感じ</summary>
      
    
    
    
    <category term="Business" scheme="https://future-architect.github.io/categories/Business/"/>
    
    
    <category term="ビジネス" scheme="https://future-architect.github.io/tags/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9/"/>
    
  </entry>
  
</feed>
