<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>フューチャー技術ブログ</title>
  
  <subtitle>Future Tech Blog</subtitle>
  <link href="https://future-architect.github.io/atom.xml" rel="self"/>
  
  <link href="https://future-architect.github.io/"/>
  <updated>2021-05-10T03:36:56.501Z</updated>
  <id>https://future-architect.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart入門</title>
    <link href="https://future-architect.github.io/articles/20210510b/"/>
    <id>https://future-architect.github.io/articles/20210510b/</id>
    <published>2021-05-09T15:00:01.000Z</published>
    <updated>2021-05-10T03:36:56.501Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="/articles/20210510a/">Dart/Flutter連載</a>の1記事目です。</p><p>TIGの伊藤真彦です。</p><p>Dart/Flutter入門に参加します、DartといえばFlutterの話が必ずついてくるものですが、今回は連載1記事目として、敢えてプログラミング言語としてのDartに焦点を絞った記事にします。</p><h1 id="Dartとは"><a href="#Dartとは" class="headerlink" title="Dartとは"></a>Dartとは</h1><img src="/images/20210510b/logo_lockup_dart_horizontal.png" alt="dart horizontal logo" width="560" height="202"><p>DartはGoogleによって開発されたウェブ向けのプログラミング言語です、正式発表された時期は2011年です。</p><p>元々はJavaScriptの代替となることを目的に作られましたが、Javascriptのようにブラウザに統合される事なく今日まで至ります。JavaScriptの代替、という概念では競合にあたるTypeScriptが今ではGoogle社内の標準プログラミング言語として承認されています。</p><p>しかし、2018年にDart2として再起動、モバイルアプリケーション向けフレームワークである<code>Flutter</code>の基本ライブラリでDartが採用される事により、近年注目度が上昇しています。今iOS/Androidのクロスプラットフォームでのアプリケーション開発を行うならDartが熱い、という事ですね。</p><h1 id="技術的特徴"><a href="#技術的特徴" class="headerlink" title="技術的特徴"></a>技術的特徴</h1><p>Dartはクラスベースのオブジェクト指向言語です、単一継承のみがサポートされていますが、Mixinを利用することも可能です。</p><p>静的型付け言語としての型アノテーションが存在しつつも、dynamic型と呼ばれる特徴的な型により、動的型付け言語のようにも扱うことが可能です。上記の特徴により、大規模システムでも耐えられる堅牢さ、高パフォーマンスを維持しつつ、時には柔軟性を持つこともできる言語として設計されています。</p><p>JavaScriptトランスパイラにより、作成したコードをJavascriptに変換することが可能です。デバッグビルドでのみ動作する<code>assert</code>という構文があるのも特徴です。</p><h1 id="Dartのインストール"><a href="#Dartのインストール" class="headerlink" title="Dartのインストール"></a>Dartのインストール</h1><p><a href="https://dart.dev/get-dart">公式サイト</a>にOSごとのインストールの方法がまとめられています、MACでのインストールが一番簡単です。</p><p>インストールに成功したら<code>dart --version</code>コマンドでバージョンを確認できます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart --version</span><br><span class="line">Dart SDK version: 2.12.4 (stable) (Thu Apr 15 12:26:53 2021 +0200) on <span class="string">&quot;macos_x64&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Dartの実行"><a href="#Dartの実行" class="headerlink" title="Dartの実行"></a>Dartの実行</h1><p><code>dart ファイル名</code>で作成したDARTファイルを実行できます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>拡張子は<code>.dart</code>が一般的なようですが、dartコマンドに渡す分には他の拡張子でも読み込み、実行できました。</p><h1 id="Dartの基礎文法"><a href="#Dartの基礎文法" class="headerlink" title="Dartの基礎文法"></a>Dartの基礎文法</h1><p>基本的な文法を紹介する形でDartに触れてみます。</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dartはmain関数に実行したい処理を書く形式で単一ファイルでとして実行可能です。</p><h2 id="コマンドライン引数"><a href="#コマンドライン引数" class="headerlink" title="コマンドライン引数"></a>コマンドライン引数</h2><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ % dart hello.dart Dart</span><br><span class="line">Hello Dart!</span><br></pre></td></tr></table></figure><p>main関数に引数を持たせることでコマンドライン引数を受け取ることができます。</p><p>Goの<code>flag.Parse()</code>、Rubyの<code>ARGV</code>のようなコマンドライン引数を取り扱うための独自な手法が無い。引数の書き方が<code>型名 変数名</code>の順番である、などgoに慣れた状態で触れると異文化を感じます。文字列への変数展開はJavaScriptであれば``で囲った文字列である必要があるところを’’でも問題ないあたりも細かい作法が異なりますね。</p><h2 id="変数宣言"><a href="#変数宣言" class="headerlink" title="変数宣言"></a>変数宣言</h2><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = args[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;name&#125;</span>!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新しい変数は<code>var 変数名 = 値</code>の形式で宣言します。</p><figure class="highlight dart"><figcaption><span>main.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="built_in">String</span> name = args[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;name&#125;</span>!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>変数の型を明示的に指定することも可能です。</p><figure class="highlight dart"><figcaption><span>main.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">dynamic</span> obj = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + obj);</span><br><span class="line">    obj = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ dart main.dart</span><br><span class="line">2</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>特定の形を期待しない場合は<code>dynamic</code>を型アノテーションとして付けることができます。<br>どのような型でも再代入可能になる一方で、<code>dynamic obj = 1;</code>をそのまま<code>&quot;1&quot; + obj</code>でString型の文字列と結合することはできません。</p><p><a href="https://dart.dev/guides/language/effective-dart/style">スタイルガイド</a>によると、ローカル変数には型アノテーション無しの<code>var</code>を、公開APIの引数等で型アノテーションを書くようにするような用法が推奨されています。</p><h3 id="デフォルト値"><a href="#デフォルト値" class="headerlink" title="デフォルト値"></a>デフォルト値</h3><figure class="highlight dart"><figcaption><span>main.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">String</span> s;</span><br><span class="line">    s = <span class="string">&#x27;Hello Dart!&#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ % dart main.dart</span><br><span class="line">Hello Dart!</span><br></pre></td></tr></table></figure><p>値を決めずに変数を宣言することが可能です。</p><figure class="highlight dart"><figcaption><span>main.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">String</span> s;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dart main.dart</span><br><span class="line">main.dart:3:11: Error: Non-nullable variable <span class="string">&#x27;s&#x27;</span> must be assigned before it can be used.</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure><p>変数のデフォルト値はどのような型であってもnullです、nullを許容しない型の変数を代入しないまま参照するとコンパイルエラーが発生します。</p><h2 id="定数"><a href="#定数" class="headerlink" title="定数"></a>定数</h2><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">String</span> s = <span class="string">&quot;Hello Dart!&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>を先頭に付与することで定数として宣言することも可能です。<br>定数の値を変更しようとするとコンパイルエラー<code>Can&#39;t assign to the const variable</code>が発生します。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> s = <span class="string">&quot;Hello Dart!&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dartには<code>filal</code>という修飾子も存在します。<br>finalを使って宣言した変数を変更しようとするとコンパイルエラー<code>Can&#39;t assign to the final variable</code>が発生します。</p><p>使い方が似ていますが、<code>const</code>はコンパイル時に評価され、<code>final</code>は実行段階で評価されるという違いがあります。</p><p>例えばコンパイル段階で計算できない実行時の時刻を<code>const</code>で宣言することはできません。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="keyword">final</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このコードは正常に動作します。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constに置き換えると下記のエラーが発生します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Error compiling to JavaScript:</span><br><span class="line">Warning: Interpreting this as package URI, <span class="string">&#x27;package:dartpad_sample/main.dart&#x27;</span>.</span><br><span class="line">lib/main.dart:2:26:</span><br><span class="line">Error: Cannot invoke a non-<span class="string">&#x27;const&#x27;</span> constructor <span class="built_in">where</span> a const expression is expected.</span><br><span class="line">    const now = DateTime.now();</span><br><span class="line">                         ^^^</span><br><span class="line">Error: Compilation failed.</span><br></pre></td></tr></table></figure><p>このような多様な修飾子の存在はコンパイル速度のパフォーマンスチューニングに貢献しますが、若干難易度が高い印象ですね。</p><p>Dart 2.12から<code>late</code>修飾子も追加されています。</p><figure class="highlight dart"><figcaption><span>late.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">late</span> <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  description = <span class="string">&#x27;Feijoada!&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>late</code>修飾子には主に2つのメリットがあります。</p><ul><li>変数がnullを許容しない</li><li>変数を遅延評価することでパフォーマンスを改善する</li></ul><p>条件分岐によっては利用しない値を<code>late</code>修飾子付きで宣言するような使い方が期待できます。</p><h2 id="組み込み型"><a href="#組み込み型" class="headerlink" title="組み込み型"></a>組み込み型</h2><p>Dartには下記の組み込み型が用意されています。</p><ul><li>Numbers (int, double)</li><li>Strings (String)</li><li>Booleans (bool)</li><li>Lists (List, also known as arrays)</li><li>Sets (Set)</li><li>Maps (Map)</li><li>Runes (Runes; often replaced by the characters API)</li><li>Symbols (Symbol)</li><li>The value null (Null)</li></ul><p>特徴的なものは<code>List</code>、<code>Set</code>の違いでしょうか。<br><code>List</code>はお馴染みの配列であるのに対し、<code>Set</code>は重複した値を持たないコレクション型です。</p><p><code>String</code>型の変数はシングルクオート、またはダブルクオート文字列を作成することが可能です。<br>シングルクオートとダブルクオートでは特殊文字のエスケープのルールが異なります。</p><figure class="highlight dart"><figcaption><span>string.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>トリプルクオート</code>で複数行の文字列を書くことができるのが特徴的です。</p><figure class="highlight dart"><figcaption><span>string.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;&quot;&quot;This is also a</span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>Dartにおける<code>Symbol</code>はコンパイル時常数として扱われる、文字列から生成できるデータ型です。<br>コンパイル時に難読化なれないため、ライブラリのメタデータの整理などに利用されますが。<br>ユーザー目線ではほぼ使わないようです。</p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight dart"><figcaption><span>enum.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">   red,</span><br><span class="line">   blue,</span><br><span class="line">   green</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(Color.red);</span><br><span class="line">  <span class="built_in">print</span>(Color.green.index);</span><br><span class="line">  <span class="built_in">print</span>(Color.values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ dart enum.dart</span><br><span class="line">Color.red</span><br><span class="line">2</span><br><span class="line">[Color.red, Color.blue, Color.green]</span><br></pre></td></tr></table></figure><p>Dartではバージョン1.8からenumがサポートされています。<br>比較的素朴な仕組みで、インデックスを1から始めたり飛ばしたり、文字列に変換するような機能はありません。</p><h2 id="条件分岐"><a href="#条件分岐" class="headerlink" title="条件分岐"></a>条件分岐</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="string">&quot;Dart&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello Dart!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>] == <span class="string">&quot;Flutter&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Welcome Flutter!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if文は特に違和感のないシンプルなスタイルです。<br>JavaScriptでは比較演算子に<code>===</code>がありましたが、現在のDartでは存在しません。(初期のDartには存在していたようです)</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Dart&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart!&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Flutter&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Welcome Flutter!&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bye&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>switch文も存在します。<br>各case毎にbreak文を設置しないと次のcaseが実行される<code>fall through</code>形式でありつつ、case内部で何かを実行したのにbreakしないとコンパイルエラーが発生するという若干癖のある仕様になっています。</p><p>つまり下記のコードはbreakが存在しないためエラーになります。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Dart&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart!&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Flutter&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Welcome Flutter!&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bye&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.dart:3:5: Error: Switch <span class="keyword">case</span> may fall through to the next <span class="keyword">case</span>.</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Dart&#x27;</span>:</span><br></pre></td></tr></table></figure><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Dart&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Flutter&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bye&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空のケースのみ<code>fall through</code>することで複数条件のケース文を実現するような用途が想定されています。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Dart&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart!&#x27;</span>);</span><br><span class="line">    <span class="keyword">continue</span> bye;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Flutter&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello Flutter!&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    bye:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bye&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>何か処理を実行してから<code>fall through</code>することはラベルを利用することで実現できます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart Dart</span><br><span class="line">Hello Dart!</span><br><span class="line"><span class="built_in">bye</span></span><br></pre></td></tr></table></figure><h2 id="ループ処理"><a href="#ループ処理" class="headerlink" title="ループ処理"></a>ループ処理</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;args[i]&#125;</span>!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初期化文、条件式、後処理文の古典的なfor文が利用可能です。</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    args.forEach((<span class="built_in">String</span> arg)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;arg&#125;</span>!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forEach文でループを処理することも可能です。</p><h3 id="item-in-list"><a href="#item-in-list" class="headerlink" title="item in list"></a>item in list</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> arg <span class="keyword">in</span> args)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;arg&#125;</span>!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dartでは上記２種類に加えPython系のテイストを感じる書き方でもループを回すことが可能です。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= args.length)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;args[index]&#125;</span>!&#x27;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;args[index]&#125;</span>!&#x27;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(index &lt; args.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while文、do~while分も存在します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart Dart Flutter</span><br><span class="line">Hello Dart!</span><br><span class="line">Hello Flutter!</span><br></pre></td></tr></table></figure><h2 id="関数"><a href="#関数" class="headerlink" title="関数"></a>関数</h2><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  hello(<span class="string">&#x27;Dart&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> hello(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello <span class="subst">$&#123;name&#125;</span>!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>関数を定義、実行することが可能です。<br>関数および関数が受け取る引数の型アノテーションは<a href="https://dart.dev/guides/language/effective-dart/style">スタイルガイド</a>で推奨されていますが、必須ではありません。</p><h2 id="非同期処理"><a href="#非同期処理" class="headerlink" title="非同期処理"></a>非同期処理</h2><p>Dartは非同期処理をサポートしています。</p><figure class="highlight dart"><figcaption><span>async.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; asyncFunction() &#123;</span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;.value(<span class="string">&quot;it is Asynchronous processing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> resp = asyncFunction();</span><br><span class="line">  resp.then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart aync.dart</span><br><span class="line">it is Asynchronous processing</span><br></pre></td></tr></table></figure><p><code>Future&lt;型名&gt;</code>という型アサーションで非同期処理を定義できます。<br>Future社員としては使いこなすモチベーションが無駄に高まります。</p><figure class="highlight dart"><figcaption><span>async.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; asyncFunction() &#123;</span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;.value(<span class="string">&quot;it is Asynchronous processing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> resp = <span class="keyword">await</span> asyncFunction();</span><br><span class="line">  <span class="built_in">print</span>(resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javascriptのように、<code>async</code>、<code>await</code>の構文も利用可能です。</p><figure class="highlight dart"><figcaption><span>async.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> resp = <span class="keyword">await</span> <span class="keyword">new</span> Future(()&#123;</span><br><span class="line">    <span class="built_in">String</span> s = <span class="string">&#x27;it is Asynchronous processing&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記のように無名関数をそのまま書いていく事も可能です。</p><h2 id="クラス"><a href="#クラス" class="headerlink" title="クラス"></a>クラス</h2><p>Dartはオブジェクト指向言語であるため、クラスが存在します。</p><p>インスタンス変数、コンストラクタ、メソッドを指定して、クラスを定義することが可能です。Personクラスの定義の内部にPerson()を定義する形でコンストラクタを設定します。<br>コンストラクタの定義には様々なパターンが存在します。</p><p>常数コンストラクタ、ファクトリ・コンストラクタなど高度な定義方法もありますが、ひとまずは基礎的なクラス定義を紹介します。</p><h3 id="Generative-Constructors"><a href="#Generative-Constructors" class="headerlink" title="Generative Constructors"></a>Generative Constructors</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> Person();</span><br><span class="line">  yamada.name = <span class="string">&#x27;yamada&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">  Person()&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コンストラクタでは引数を受け取らず適当な初期値を入力し、インスタンス生成後にメンバ変数を指定するシンプルな方式です。</p><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> Person(<span class="string">&#x27;yamada&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello, My name is yamada</span><br></pre></td></tr></table></figure><p>コンストラクタに引数を定義し、初期化時に受け取る方式です。</p><h3 id="Automatic-field-initialization"><a href="#Automatic-field-initialization" class="headerlink" title="Automatic field initialization"></a>Automatic field initialization</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> Person(<span class="string">&#x27;yamada&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello, My name is yamada</span><br></pre></td></tr></table></figure><p>コンストラクタの記述をシンプルに定義可能な方式です。</p><h3 id="Named-Constructors"><a href="#Named-Constructors" class="headerlink" title="Named Constructors"></a>Named Constructors</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> Person.asConsultant(<span class="string">&#x27;yamada&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> job;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.job);</span><br><span class="line"></span><br><span class="line">  Person.asConsultant(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.job = <span class="string">&#x27;IT Consultant&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="keyword">this</span>.job&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello, My name is yamada, I am IT Consultant</span><br></pre></td></tr></table></figure><p>特定条件付きのコンストラクタを定義可能です。</p><h3 id="Redirecting-Constructors"><a href="#Redirecting-Constructors" class="headerlink" title="Redirecting Constructors"></a>Redirecting Constructors</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> Person.asConsultant(<span class="string">&#x27;yamada&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> job;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.job);</span><br><span class="line"></span><br><span class="line">  Person.asConsultant(<span class="built_in">String</span> name) : <span class="keyword">this</span>(name, <span class="string">&quot;IT Consultant&quot;</span>);</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="keyword">this</span>.job&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello, My name is yamada, I am IT Consultant</span><br></pre></td></tr></table></figure><p>他のコンストラクタの定義を再利用する方式です。</p><h3 id="クラスの継承"><a href="#クラスの継承" class="headerlink" title="クラスの継承"></a>クラスの継承</h3><figure class="highlight dart"><figcaption><span>hello.dart</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yamada = <span class="keyword">new</span> ITConsultant(<span class="string">&#x27;yamada&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(yamada.hello());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITConsultant</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  ITConsultant(<span class="built_in">String</span> name) : <span class="keyword">super</span>(name);</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, I am IT Consultant&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ dart hello.dart</span><br><span class="line">Hello, My name is yamada, I am IT Consultant</span><br></pre></td></tr></table></figure><p>他のオブジェクト指向言語同様クラスは継承することができます。</p><h2 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h2><p>一通り基礎部分をさらってみましたが、豊富な表現力と適度な硬さの両立を目指そうとしている印象を受けました。</p><p>その辺りの思想と肌感覚がマッチすればハマる言語かもしれません。</p><p>破壊的な変更により今では動かないシンタックスが検索結果の上位に散見しているので、学習障壁を高めてしまうかなと感じました。<br>今回の連載で有用な記事を増やして盛り上げていきたいですね。</p><p><a href="/articles/20210510a/">Dart/Flutter連載</a>の1記事目ででした。次は宮崎さんのSwaggerとの統合についてです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;/articles/20210510a/&quot;&gt;Dart/Flutter連載&lt;/a&gt;の1記事目です。&lt;/p&gt;
&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;Dart/Flutter入門に参加します、DartといえばFlutterの話が必ずついてくるもの</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Dart" scheme="https://future-architect.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Dart/Flutter連載始めます</title>
    <link href="https://future-architect.github.io/articles/20210510a/"/>
    <id>https://future-architect.github.io/articles/20210510a/</id>
    <published>2021-05-09T15:00:00.000Z</published>
    <updated>2021-05-10T03:33:16.579Z</updated>
    
    <content type="html"><![CDATA[<p>2021年3月に「Flutter 2.0」のリリースが発表されました！</p><p>そして、本ブログ初のDart/Flutterをテーマにした連載を行います。内容は次のようになっています。</p><table><thead><tr><th>公開日</th><th>執筆者</th><th>タイトル</th></tr></thead><tbody><tr><td>5月10日</td><td>伊藤真彦</td><td><a href="/articles/20210510b/">Dart入門</a></td></tr><tr><td>5月11日</td><td>宮崎将太</td><td>Swaggerとの統合ネタ</td></tr><tr><td>5月12日</td><td>澁川喜規</td><td>ケンオール</td></tr><tr><td>5月13日</td><td>鶴巻彩夏</td><td></td></tr><tr><td>5月14日</td><td>真野隼記</td><td>Dartネタ</td></tr><tr><td>5月17日</td><td>越島亮介</td><td>MaaSアプリ作ってみた</td></tr><tr><td>5月18日</td><td>村田靖拓</td><td></td></tr></tbody></table><p>本記事では、Flutterの概要についてお伝えします。</p><h2 id="Flutter-モバイル・Web・デスクトップ対応のフレームワーク"><a href="#Flutter-モバイル・Web・デスクトップ対応のフレームワーク" class="headerlink" title="Flutter = モバイル・Web・デスクトップ対応のフレームワーク"></a>Flutter = モバイル・Web・デスクトップ対応のフレームワーク</h2><img src="/images/20210510a/logo_lockup_flutter_horizontal.png" alt="flutter horizontal logo" width="700px" height="196px"><p>FlutterはGoogle製フレームワークで、単一のソースコードでモバイル・Web・デスクトップ対応可能なアプリケーションを開発することができます。言語はDartで、こちらもGoogle製です。</p><p>今までは、iOS/Androidの両OSに対応したモバイルアプリケーション開発機能のみが安定版として提供されていましたが、「Flutter 2.0」のリリースで、Webアプリケーション開発機能がベータ版から安定版となりました。</p><p>Windows/Mac/Linux対応のデスクトップアプケーション開発機能は現在ベータ版で、「early release flag付き」で安定版でも利用可能となっています。<a href="https://medium.com/flutter/whats-new-in-flutter-2-0-fe8e95ecc65">Flutterの技術ブログ</a>によると、 デスクトップアプリケーションについても今年後半に安定版がリリースされるようです。</p><p>弊社では、モバイルアプリケーション開発においてFlutterの採用事例があります。</p><p>今後はあらゆるプラットフォームで選択肢となる可能性があり、今後が楽しみです。</p><h2 id="Googleトレンドによる国内・海外での動向"><a href="#Googleトレンドによる国内・海外での動向" class="headerlink" title="Googleトレンドによる国内・海外での動向"></a>Googleトレンドによる国内・海外での動向</h2><p>Googleトレンドで、Flutterとモバイルやクロスプラットフォーム対応フレームワークについて「日本」と「すべての国」で比較してみました。Flutter 1.0がリリースされた2018年12月を始点としています。Googleトレンド上では、国内ではじわじわとFlutterの検索が増えており、海外ではすでに他の言語・フレームワークを超えてFlutterが盛り上がっているようです。</p><ul><li>日本<img src="/images/20210510a/flutter_google_treand_in_japan.png" alt="Flutter Google Trend in Japan" width="1191" height="564"></li><li>すべての国<img src="/images/20210510a/flutter_google_treand_in_global.png" alt="Flutter Google Trend in Globa" width="1178" height="560"></li></ul><h2 id="特徴"><a href="#特徴" class="headerlink" title="特徴"></a>特徴</h2><p>Flutterの特徴として、公式サイトでは以下の3つが挙げられています。</p><p><strong>特徴①： 「高速ホットリロード」と「豊富なウィジェット」による高速なアプリ開発体験</strong><br>開発時にコードの変更をすぐにエミュレータや実機に反映することができ、フラストレーションなく開発を行うことができます。また、ボタンやリスト、カード、モーダルなど予め豊富なUI部品が用意されているので、簡単に画面を構築することができます。</p><p>フロントエンド開発の経験があまりない私は、モバイルアプリケーションにはさらに高いハードルを感じていましたが、Flutterでスマホアプリの画面をスムーズに作ることができ、とても魅力を感じました。</p><p><strong>特徴②： 表現力豊かで柔軟なユーザインタフェース</strong><br>開発者はエンドユーザの体験に重点を置いた機能を素早く開発することができます。<br>Flutterの階層的なアーキテクチャーにより、複雑なUIにも対応することが可能で、<br>非常に高速なレンダリングと表現力豊かで柔軟なデザインを実現できます。</p><p><strong>特徴③: ネイティブなパフォーマンス</strong><br>Flutterのコードはマシンコードにコンパイルされ、ネイティブアプリ同等のパフォーマンスを提供します。Flutterの独自レンダリングの仕組みもパフォーマンスが高い理由の1つのようです。</p><p><strong>公式サイトのトップページで、Flutterのソースコードを動かしてみることができるので、ぜひ触って体感してみてください！</strong></p><h2 id="Fluter-2-0"><a href="#Fluter-2-0" class="headerlink" title="Fluter 2.0"></a>Fluter 2.0</h2><p>今年3月にリリースされた「Flutter 2.0」は様々なアップデートがありますが、特に下記の2つが大きなトピックだと思います。</p><p><strong>・Webアプリケーション開発機能が安定版となった</strong><br><strong>・デスクトップアプリケーション開発機能がearly release付きで安定版で使用可能になった</strong></p><p>また、Googleの<a href="https://developers.googleblog.com/2021/03/announcing-flutter-2.html">Flutter 2.0リリース記事</a>には、各企業と協力している取り組みにも言及されており、とても興味深いです。詳細が気になる方は、ぜひご確認ください。</p><p><strong>・Canonicalと連携したLinuxデスクトップアプリケーション開発機能のサポート</strong><br><strong>・Microsoftと連携したWindowsアプリケーション開発と折りたたみデバイス(Surface Duo等)アプリケーション開発のサポート</strong><br><strong>・トヨタが車載システムにFlutterを導入する計画を発表</strong></p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>Flutter 2.0がリリースされ、これから様々なプラットフォームで使われていくことが期待されます。</p><p>Flutter連載もぜひお楽しみください！</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210112/index.html" data-iframely-url="//cdn.iframe.ly/P7BPs3C?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021年3月に「Flutter 2.0」のリリースが発表されました！&lt;/p&gt;
&lt;p&gt;そして、本ブログ初のDart/Flutterをテーマにした連載を行います。内容は次のようになっています。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;公開日&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="インデックス" scheme="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/"/>
    
    <category term="Flutter" scheme="https://future-architect.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Goでバッチ登録するときのイディオム</title>
    <link href="https://future-architect.github.io/articles/20210430b/"/>
    <id>https://future-architect.github.io/articles/20210430b/</id>
    <published>2021-04-29T15:00:01.000Z</published>
    <updated>2021-05-09T11:59:58.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG DXユニット<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>真野です。</p><p>個人利用など、ごく小さなサービスなどでない限り、複数件のレコードを一括でデータストア層へ登録する必要は出てくると思います。この時1件ずつループ処理で登録するのではなく、効率性などの観点で各データストアが提供する一括登録の仕組みを利用すると思います。</p><p>RDBであればバルク（Bulk Insert）とかバッチ（Batch Insert）の登録手段が存在すると思います。PostgreSQLであればCopy句で、OracleであればSQL*Loaderを使ってCSVを直接読み込ませる方法があります。</p><p>この記事ではCSVなどの一括登録ではなく、Batch Insertの実装について触れていきます。タイトルはバッチ登録ですがバッチ検索でもバッチ削除でも同じように役立つ内容かと思います。</p><h2 id="バッチ登録を行う側で気をつけること"><a href="#バッチ登録を行う側で気をつけること" class="headerlink" title="バッチ登録を行う側で気をつけること"></a>バッチ登録を行う側で気をつけること</h2><p>例えばAWS DynamoDBであればバッチ登録（<a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">BatchWriteItem</a>）では1操作で最大25項目までしか対応していません<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。（RDBであればこうした分かりやすい数値的な上限はないかと思いますが、クライアントとDBサーバ側の主にメモリ資源を使いすぎないように、例えば1000件ずつなど小分けして登録することが多いかと思います）</p><p>つまり、DynamoDBであれば120件のデータをBatchWriteItemで登録するためには、最低でも5回（25件×4回＋20件×1回）の操作が必要です。</p><p>こうした、1操作で登録しきれない件数のバッチ登録（Batch Put）するときの実装方法ですが、書く人によって色々種類があることに気が付きました。すこし面白かったので本記事ではまとめます。データストアはDynamoDBを利用しますが、どのデータストアでも伝わる部分があると思います。DynamoDBって何か気になって先に進めない方は、富山さんの<a href="/articles/20200818/">【入門】私を苦しめたDynamoDB</a>記事がおすすめです。</p><p>コードは<a href="https://github.com/ma91n/go-batch-put-idioms">こちら</a>にまとめました。</p><h2 id="各イディオムで用いる共通部分"><a href="#各イディオムで用いる共通部分" class="headerlink" title="各イディオムで用いる共通部分"></a>各イディオムで用いる共通部分</h2><p>各イディオムに入る前に永続化に用いる関数を用意します。ローカルでも動かせるようにLocakStackを利用します。これの実装は本題じゃないので読み飛ばし推奨です。</p><ul><li><code>func BatchWrite(ctx context.Context, writes[]Forum) error</code></li></ul><details><summary>BatchWriteの実装についての詳細(※👈クリックで開く。読み飛ばしてもOK)</summary><div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalStackを用いるための初期化部分（読み飛ばしOK）</span></span><br><span class="line"><span class="keyword">var</span> dy = dynamodb.New(session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">Endpoint: aws.String(<span class="string">&quot;http://localhost:4566&quot;</span>),        <span class="comment">// LocalStack</span></span><br><span class="line">Region:   aws.String(endpoints.ApNortheast1RegionID), <span class="comment">// Tokyo Region</span></span><br><span class="line">&#125;)))</span><br></pre></td></tr></table></figure><p><code>dy</code> を用いて以下の永続化用の関数を用意します。25件以上であるときはエラーにしていること以外は、UnprocessedItemsの救済の為に少し処理を追加しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永続化関数（読み飛ばしOK）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BatchWrite</span><span class="params">(ctx context.Context, writes[]Forum)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(writes) &gt; <span class="number">25</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;batch write size is within 25 items&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items := <span class="built_in">make</span>([]*dynamodb.WriteRequest, <span class="number">0</span>, <span class="built_in">len</span>(writes))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> writes&#123;</span><br><span class="line">av, _ := dynamodbattribute.MarshalMap(v) <span class="comment">// エラーハンドリングは省略</span></span><br><span class="line">items = <span class="built_in">append</span>(items, &amp;dynamodb.WriteRequest&#123;</span><br><span class="line">PutRequest: &amp;dynamodb.PutRequest&#123;</span><br><span class="line">Item: av,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(items) &gt; <span class="number">0</span> &#123;</span><br><span class="line">out, err := dy.BatchWriteItemWithContext(ctx, &amp;dynamodb.BatchWriteItemInput&#123;</span><br><span class="line">RequestItems: <span class="keyword">map</span>[<span class="keyword">string</span>][]*dynamodb.WriteRequest&#123;</span><br><span class="line"><span class="string">&quot;forum&quot;</span>: items,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;batch write to %s: %w&quot;</span>, <span class="string">&quot;forum&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items = <span class="built_in">append</span>(items[:<span class="number">0</span>] , out.UnprocessedItems[<span class="string">&quot;forum&quot;</span>]...) <span class="comment">// スライスを初期化して未処理のitemsがあれば追加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>永続化対象の <code>Forum</code> テーブルを示すモデルですが、AWS SDK for Goのドキュメントに書いていた構造です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永続化対象のモデル（読み飛ばしOK）</span></span><br><span class="line"><span class="keyword">type</span> Forum <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span></span><br><span class="line">Category <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h2 id="①素朴なバッチ登録実装"><a href="#①素朴なバッチ登録実装" class="headerlink" title="①素朴なバッチ登録実装"></a>①素朴なバッチ登録実装</h2><p>本題のイディオムです。まずは素朴にループを回す実装です。何も考えずに実装すると多くの人が最初にこのコードを実装するのではないでしょうか？ <code>LoadForums</code> は<code>[]Forum</code>を返す、数百～数千件くらいのCSVを読み取るような処理をイメージください。</p><figure class="highlight go"><figcaption><span>素朴な実装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">loadForums := LoadForums() <span class="comment">// 数千件くらいのそこそこ大きいデータ</span></span><br><span class="line"></span><br><span class="line">batch := <span class="built_in">make</span>([]Forum, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> loadForums &#123;</span><br><span class="line"></span><br><span class="line">batch = <span class="built_in">append</span>(batch, v) <span class="comment">// 1行毎にスライスに追加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;= <span class="number">25</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := BatchWrite(ctx, batch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">batch = batch[:<span class="number">0</span>] <span class="comment">// スライスをクリア</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt; <span class="number">0</span> &#123;  <span class="comment">// 25の剰余が1~24の場合の救済</span></span><br><span class="line"><span class="keyword">if</span> err := BatchWrite(context.Background(), batch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初のfor文で1行ずつスライスに要素を追加し、指定件数（今回だと25件）になったタイミングで <code>BatchWrite</code> を呼び出し永続化します。最後の if文のブロックでは、1件以上かつ25件未満のケースを救済しています。</p><p>便宜上、素朴と表現しましたが、IteratorパターンのようにHasNext/NextしかAPIを公開されておらず次のレコードの有無がわからない場合はこういったアプローチを取るしか無い場合もあるので、利用シーンも少なからずあるかと思います。</p><h2 id="②すこし進化したバッチ登録"><a href="#②すこし進化したバッチ登録" class="headerlink" title="②すこし進化したバッチ登録"></a>②すこし進化したバッチ登録</h2><p>さきほど書いた素朴なコードですが、少し冗長な部分があります。for文とif文の<code>BatchWrite</code>呼び出し部分が重複しており冗長ですね。ここをスッキリさせたバージョンが次です。</p><figure class="highlight go"><figcaption><span>すこしスッキリさせた実装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx  := context.Background()</span><br><span class="line">forums := LoadForums()</span><br><span class="line"></span><br><span class="line">batch := <span class="built_in">make</span>([]Forum, <span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> forums &#123;</span><br><span class="line"></span><br><span class="line">batch = <span class="built_in">append</span>(batch, v) <span class="comment">// 1行枚にスライスに追加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;= <span class="number">25</span> || i == <span class="built_in">len</span>(forums) <span class="number">-1</span> &#123; <span class="comment">// 25個になったか、最終行の場合</span></span><br><span class="line"><span class="keyword">if</span> err := BatchWrite(ctx, batch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">batch = batch[:<span class="number">0</span>] <span class="comment">// スライスをクリア</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for文の中のif文で、<code>BatchWrite</code> を呼び出す条件を変えました。スライスが25件に達した時に加え、 <strong>最終行の場合にも</strong> 分岐を通すようにします。for文の後にあった <code>BatchWrite</code> の分岐を消せました。かなりスッキリです。</p><p>今回は、処理対象のレコードがすべてスライスになっている（メモリに読み込んでいる）状態ですが、これが巨大なCSVファイルを入力とするケースでは、1, 2の実装のように逐次的な処理をする必要があると思います。</p><h2 id="③少しエレガント実装"><a href="#③少しエレガント実装" class="headerlink" title="③少しエレガント実装"></a>③少しエレガント実装</h2><p>新規にスライスを宣言せず、読み取ったスライスから部分スライスを作成する実装です。少しトリッキーに見えるかもしれませんが、そんなに難しいことをしていないです。ポイントはループ変数 <code>i</code>　～ <code>i+25(end)</code> で部分スライスをループ毎に作るというアプローチでしょうか。</p><figure class="highlight go"><figcaption><span>スライスを新規に配置しないケース</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">forums := LoadForums()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(forums); i += <span class="number">25</span> &#123;</span><br><span class="line">end := i + <span class="number">25</span></span><br><span class="line"><span class="keyword">if</span> end &gt; <span class="built_in">len</span>(forums) &#123;</span><br><span class="line">end = <span class="built_in">len</span>(forums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := BatchWrite(ctx, forums[i:end]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>イメージしにくい方のために、バッチサイズを5、処理対象のレコード数が13での動作イメージを書きました。</p><p><img src="/images/20210430b/batch_slice.png"></p><p>もしも、最初から <code>BatchWrite</code> したいレコードがスライスの状態にある（メモリに載っている）のであれば、この実装方法が可読性もそこまで落ちず、かつ最も効率が良さそうです。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li>バッチ登録のイディオムはいくつかパターンがある</li><li>メモリに載っている場合は、③のように元のスライスからサブスライスを作る方法が良さそう</li><li>入力データが巨大な場合は、①、②のような逐次的な処理を入れる必要が出てきそう</li></ul><p>Goだとgoroutineとチャネルを利用してこうした複数チャンクに分割しつつ、並列にデータ登録することも容易にできそうですね。そのあたりも機会があれば書いていこうと思います。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Technology Innovation Group（TIG）は、「最先端、且つ先進的なテクノロジーのプロフェッショナル集団」、「プロジェクト品質と生産性の向上」、「自社サービス事業の立ち上げ」を主なミッションとする、技術部隊です。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;TIG DXユニット&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="DynamoDB" scheme="https://future-architect.github.io/tags/DynamoDB/"/>
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="バッチ処理" scheme="https://future-architect.github.io/tags/%E3%83%90%E3%83%83%E3%83%81%E5%87%A6%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Go Conference 2021 Springに登壇しました</title>
    <link href="https://future-architect.github.io/articles/20210430a/"/>
    <id>https://future-architect.github.io/articles/20210430a/</id>
    <published>2021-04-29T15:00:00.000Z</published>
    <updated>2021-04-30T03:59:00.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、辻です。先日開催されました <a href="https://gocon.jp/">Go Conference 2021 spring</a> にTIGから渋川、辻の計2名が登壇しました。</p><p><img src="/images/20210430a/logo_text.png"></p><blockquote><p>The Gopher character is based on the Go mascot designed by Renée French.</p></blockquote><p><a href="https://sendai.gocon.jp/">Go Conference’20 in Autumn</a>ではオンラインとオフラインのハイブリッドな構成でしたが、今回はGo Conference史上初となるフルオンラインでの開催となりました。今回のカンファレンスでは事前録画したビデオによる発表もサポートされていました。またオンラインでのリアルタイム登壇にあたって、リハーサルを始め手厚いサポートをいただき、安心して発表することができました。運営の皆様、ありがとうございました！</p><h3 id="実務で役立つTCPクライアントの作り方"><a href="#実務で役立つTCPクライアントの作り方" class="headerlink" title="実務で役立つTCPクライアントの作り方"></a>実務で役立つTCPクライアントの作り方</h3><p>発表資料は以下です。</p><script async class="speakerdeck-embed" data-id="340854fb6cf14990bfe4daa1d1c11efb" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><p>発表内容は、TCPクライアントを実装するときの考慮点をまとめたものです。普段HTTPなどを用いて通信するときはGoの標準ライブラリである <code>net/http</code> パッケージのAPIを使います。自前で <code>net</code> パッケージを使ってTCPクライアントを実装する必要はありません。しかし標準ライブラリではサポートされていないTCP上の独自のプロトコルで通信する必要がある場合や、通信したいプロトコルがOSSとして公開されているライブラリでは不足がある場合などは、自前でTCPクライアントを実装する必要があります。Go Conferenceの他のセッションでも、金融系のプロトコルである<a href="https://ja.wikipedia.org/wiki/ISO_8583">ISO8583</a>をTCPで扱っている例が紹介されており、実は身近なところで独自のTCPクライアントが必要になるかもしれません。</p><p>Goでは <code>net</code> パッケージを使うと簡単にTCPクライアントを実装できますが、プロダクションレディなTCPクライアントに仕上げていくにはいくつか考慮点があります。</p><ul><li>タイムアウト</li><li>コネクションプーリング</li><li>エラーハンドリング</li><li>リトライ</li></ul><p>といったポイントを紹介しています。</p><p>セッションを見ていただいた皆様、twitterでコメントくださった皆様、ありがとうございました！</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">Goでソケットを直接触る機会、ありそうでなかなかないのでこういった知識の復習大事 <a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw">#gocon</a> <a href="https://twitter.com/hashtag/goconA?src=hash&amp;ref_src=twsrc%5Etfw">#goconA</a></p>&mdash; castaneai (@castanea) <a href="https://twitter.com/castanea/status/1385837483384995841?ref_src=twsrc%5Etfw">April 24, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">コネクションプーリングしていてそのコネクションが悪くなっていることがあるって怖いね。<a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw">#gocon</a> <a href="https://twitter.com/hashtag/goconA?src=hash&amp;ref_src=twsrc%5Etfw">#goconA</a></p>&mdash; Kabo (@kabochapo) <a href="https://twitter.com/kabochapo/status/1385841331365310464?ref_src=twsrc%5Etfw">April 24, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">TCP面白かったです！！！<a href="https://twitter.com/hashtag/gocon?src=hash&amp;ref_src=twsrc%5Etfw">#gocon</a> <a href="https://twitter.com/hashtag/goconA?src=hash&amp;ref_src=twsrc%5Etfw">#goconA</a></p>&mdash; luccafort (@luccafort) <a href="https://twitter.com/luccafort/status/1385841179648872452?ref_src=twsrc%5Etfw">April 24, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、辻です。先日開催されました &lt;a href=&quot;https://gocon.jp/&quot;&gt;Go Conference </summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Cypress - 書きやすいテストの秘密と独自コマンドの実装</title>
    <link href="https://future-architect.github.io/articles/20210428d/"/>
    <id>https://future-architect.github.io/articles/20210428d/</id>
    <published>2021-04-27T15:00:04.000Z</published>
    <updated>2021-04-27T15:20:35.282Z</updated>
    
    <content type="html"><![CDATA[<p>@testing-library/cypressの存在を知らずに、それっぽいものを作ろうとしたときにいろいろ調査した記録です。Cypressにはテストコードが縦と横に短くなる工夫がされており、そのメカニズムにしたがった独自コマンドを実装するにはコツが必要です。</p><p>実装は次のところにありますが、@testing-library/cypressの方がメンテされているので、こちらは実際には使わないのをお勧めします。</p><p><a href="https://gitlab.com/osaki-lab/cypress-aria">https://gitlab.com/osaki-lab/cypress-aria</a></p><h1 id="Cypressのテストが縦横に短く書けるわけ"><a href="#Cypressのテストが縦横に短く書けるわけ" class="headerlink" title="Cypressのテストが縦横に短く書けるわけ"></a>Cypressのテストが縦横に短く書けるわけ</h1><p>CypressはWebDriver系(Selenium)やChrome DevTool Protocol系（Puppeteer)のツールとAPIの粒度が異なります。Seleniumはそもそもウェブサイトのタイトルに「Browser Automation Tool」とありますし、PuppeteerのAPIもそれに近いです。ソースコードに書かれているコードと、ブラウザ上で動作する挙動に違いはありません。</p><p>Cypressは一言で要素探索のAPI呼び出しといっても、検索とパターンマッチを裏で高速に繰り返します。デフォルトのタイムアウトは4秒で、その間、100mS間隔ぐらいでリクエストを繰り返します。これの何がよいかというと、最近のReactやVueやAngularといった仮想DOMやIncremental DOMなソリューションと相性が良い点です。</p><p>これらのフロントエンドでは、何かしらのボタン操作やその結果のAPIアクセスの結果で、非同期で画面が更新されます。いつ画面の更新処理が終わったのか通知が来るわけではありません。例えば、ウェブサーバーに問い合わせをして、その結果を受けて画面表示する場合、WebDriverやCDP系ツールでは自分でウェイトを置いて、0.1秒待つ、といったことをします。</p><p>Cypressは次のようなメソッドチェーンの命令になっており、<code>should(&quot;exist&quot;)</code>が成功するまでタイムアウト時間（デフォルト4秒）までの間、100mSぐらいことに<code>find(&quot;button.ok&quot;)</code>を繰り返します。<code>find()</code>の関数の呼び出し結果にこのDOM要素が入ってくるわけではなく、これらのAPIの裏で複雑な動きをします。そもそもJSなのに<code>await</code>を使わないで済むのはこれが実際の命令と一対一に対応していないからです。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.find(<span class="string">&quot;button.ok&quot;</span>).should(<span class="string">&quot;exist&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/20210428d/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-04-24_8.14.01.png"></p><p>明示的なwaitを書かずに済むことで、処理時間と成功率のトレードオフを考えなくても済むというメリットがあります。</p><p>まず、逐次処理のパターンではテストが失敗しないためには余裕を持った大きめの待ち時間をテストコードに書く必要があります。テストの時間を短くしようとして50パーセンタイルな時間を書けば50%は失敗するということです。そして、たいてい99パーセンタイルは50パーセンタイルよりも遥かに大きな値であることが往々にしてあります。</p><p>Cypressでは成功次第次の処理が実行されるため、毎回待ち時間の最大値で待つのに比べて、実行時間が短縮されますし、待ち時間が足りなくてテストがランダムに壊れるのを防ぐためにウェイトを調整するといった不毛な作業が減ります。また、待ち時間を忘れてテストが失敗するというわかりにくい不具合も減ります。</p><p>また、ウェイトを自分で入れる必要性があまりないのでコードが縦に短くなります。表示を待つだけならNightwatchでもSeleniumできますが、待つための余計なコードを書く必要がなく、クリックなどもすべてリトライしてくれるところがCypressの良いところです。また、逐次処理ではなく、期待する状態の宣言なので、<code>await</code>などがいらないので横も短くなります。</p><p>ただし、waitが100%不要になるかというと、部分的には必要です。例えばレビューの星の数を設定して数が変化するテストを書こうとしているとします。星の数が設定されて更新されるまでにタイムラグがあるとすると、find()は変更前の状態で早々にマッチしてしまうため、処理が先に進んでしまいます。この場合はエラーになってしまうので処理の完了を待つ<code>cy.wait()</code>が必要となります。</p><p>それ以外に、E2Eテストとして信頼できるテストが書けるための機能としては、きちんと人が操作できるかどうかをCSSや属性も見てチェックしてくれる点もポイントです。ブラウザの見た目の完全なシミュレートではないのですが、テストが成功したのに手動でテストしたらバグっている、みたいなことが減ります。</p><ul><li>要素がvisibleなのか？</li><li>disabledな要素を操作しようとしていないか？</li><li>readonlyがついているのにタイプしようとしてないか？　</li><li>親要素のスクロールとかoverflowとかで隠れていないか？</li><li>他の要素に隠されていないか？</li></ul><h1 id="Cypressのリトライポリシーに従ったコマンドの作り方"><a href="#Cypressのリトライポリシーに従ったコマンドの作り方" class="headerlink" title="Cypressのリトライポリシーに従ったコマンドの作り方"></a>Cypressのリトライポリシーに従ったコマンドの作り方</h1><p>同じ複雑なセレクターを何度も繰り返し書くのを楽にしてあげるだけであれば、コマンドを作って、その中で<code>cy.get()</code>や<code>cy.find()</code>を使ってあげればOKです。</p><p>しかし、AまたBを取得、みたいなケースではうまく書かないと、Aの取得でタイムアウト、Bの取得でもタイムアウトと2倍時間がかかって、リトライの挙動が他のコマンドと違う動きになってしまいます。リトライポリシーに準拠するには、Cypressの作法に従って書く必要があります。</p><p>公式ドキュメントにはここを参上にするように、と書かれていますがピンポイントで参考にするのはちょっと難しい実装でした。これだけ見ても実装方法がよくわからなかったのでこれを読み解いた＆モダンなTypeScriptの書き方を紹介していきます。</p><p><a href="https://github.com/cypress-io/cypress-xpath/pull/12/files">https://github.com/cypress-io/cypress-xpath/pull/12/files</a></p><p>ここで紹介する以外にもボタンなどさまざまな要素取得を実装したのがこちらのパッケージです。</p><p><a href="https://gitlab.com/osaki-lab/cypress-aria">https://gitlab.com/osaki-lab/cypress-aria</a></p><p>ただ、@testing-library/cypressというもっと前から開発されているパッケージがあるので、これを使う必要はありませんので、参考実装としてみていただければと思います。</p><h2 id="これから作るコマンドの要件"><a href="#これから作るコマンドの要件" class="headerlink" title="これから作るコマンドの要件"></a>これから作るコマンドの要件</h2><p>aria属性に従って要素取得を実装したときは、「aria-labelがあればそれを名前とする、aria-labelledbyがあれば、参照先のDOMのテキストを名前とする、親が<code>&lt;label&gt;</code>で<code>for=</code>で自分の要素のIDがついていたらそちらを名前とする、みたいなOR条件で要素を取得します。</p><p>まずはコマンドの枠組みです。ここに追加していきます。</p><figure class="highlight ts"><figcaption><span>index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;cypress&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">Cypress.Commands.add( <span class="comment">// ポイント1: コマンド登録</span></span><br><span class="line">    <span class="string">&#x27;ariaLink&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">prevSubject</span>: [<span class="string">&#x27;optional&#x27;</span>, <span class="string">&#x27;element&#x27;</span>, <span class="string">&#x27;document&#x27;</span>] &#125;,</span><br><span class="line">    aria</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ポイント2: asyncな関数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> <span class="title">ariaLink</span>(<span class="params">subject, selector, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resolveValue = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> value = なんらかの処理();</span><br><span class="line">        <span class="keyword">return</span> cy.verifyUpcomingAssertions(value, options, &#123;</span><br><span class="line">            onRetry: resolveValue, <span class="comment">// ポイント3: 自分自身をretry対象にしつつassetする関数を定義</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> resolveValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ポイントはコード中に書いた3箇所です。</p><h2 id="コマンドのコンテキスト"><a href="#コマンドのコンテキスト" class="headerlink" title="コマンドのコンテキスト"></a>コマンドのコンテキスト</h2><p>Cypress.Commands.addを呼び出すところはすでに紹介しました。名前と実際に呼び出される関数以外に実行コンテキストのオプションがあります。</p><p>prevSubjectはcy.の直後に呼ばれるべきか、他のコマンドで絞り込んだあとに呼ぶのか、どちらを想定しているのかという指定です。trueなら他のコマンドの後限定、falseなら先頭限定、’optional’なら両方です。また、element/document/windowで、他のコマンドの結果としてもらえる要素を設定できます。</p><p><code>cy.get</code>は<code>&#123;prevSubject: false&#125;</code>, <code>cy.find</code>は<code>&#123;prevSubject: true&#125;</code>ですね。</p><figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cypress.Commands.add(</span><br><span class="line">    <span class="string">&#x27;mycommand&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">prevSubject</span>: [<span class="string">&#x27;optional&#x27;</span>, <span class="string">&#x27;element&#x27;</span>, <span class="string">&#x27;document&#x27;</span>] &#125;,</span><br><span class="line">    mycommand</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="コンテキストの取得"><a href="#コンテキストの取得" class="headerlink" title="コンテキストの取得"></a>コンテキストの取得</h2><p>コマンドは次の形式をしています。前述のコンテキストの元になるのがsubjectです。selectorは1つの文字列です。追加のオプションはオブジェクトの形式で渡します。</p><figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mycommand</span>(<span class="params">subject, selector, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>前の設定でprevSubjectに”element”を渡したり、trueを設定した場合はsubjectからコンテキストを取り出します。コマンドの関数の先頭でcontextNodeを初期化します。要素探索を実装する場合はこのcontextNodeの中から探すようにしていけばOKです。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// コンテキストの取得</span></span><br><span class="line"><span class="keyword">let</span> contextNode;</span><br><span class="line"><span class="keyword">let</span> withinSubject = cy.state(<span class="string">&#x27;withinSubject&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (Cypress.dom.isElement(subject)) &#123;</span><br><span class="line">    contextNode = subject[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Cypress.dom.isDocument(subject)) &#123;</span><br><span class="line">    contextNode = subject;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (withinSubject) &#123;</span><br><span class="line">    contextNode = withinSubject[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    contextNode = cy.state(<span class="string">&#x27;window&#x27;</span>).document;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>コンテキストに対応しない（常にグローバルからの取得）であればここは書かなくても良いです。</p><h2 id="要素の取得"><a href="#要素の取得" class="headerlink" title="要素の取得"></a>要素の取得</h2><p>実際の要素の取得の処理はjQueryを使います。cy.find()やcy.get()は非同期なリトライ付きの取得でしたが、プリミティブな同期的な要素の取得はjQueryです。jQueryは動的なウェブサイトの作成ではいろいろネガティブな話も出てきていますが、DOMを変化させない、要素の取得に限定すればまだまだ便利です。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = Cypress.$(<span class="string">&#x27;a, *[role=&quot;link&quot;]&#x27;</span>, contextNode);</span><br><span class="line"><span class="keyword">if</span> (selector) &#123;</span><br><span class="line">    value = value.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self = Cypress.$(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aria-label属性で検索</span></span><br><span class="line">        <span class="keyword">if</span> (self.attr(<span class="string">&#x27;aria-label&#x27;</span>) === selector) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aria-labelledby属性で検索</span></span><br><span class="line">        <span class="keyword">const</span> labelledBy = self.attr(<span class="string">&#x27;aria-labelledby&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (labelledBy &amp;&amp; Cypress.$(<span class="string">`#<span class="subst">$&#123;labelledBy&#125;</span>`</span>).text() === selector) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// テキストを見て検索</span></span><br><span class="line">        <span class="keyword">if</span> (self.text().trim() === selector) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画像のalt属性を見て検索</span></span><br><span class="line">        <span class="keyword">const</span> images = self.find(<span class="string">`img[alt=&quot;<span class="subst">$&#123;selector&#125;</span>&quot;]`</span>);</span><br><span class="line">        <span class="keyword">return</span> images.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここでは、4パターンの検索を実行して返す実装になっています。一つのセレクターの一筆書きで書けないような複雑な検索処理が行えます。</p><p>上記のresolveValue()の中身は最終的にはこうなります。</p><figure class="highlight ts"><figcaption><span>resolveValue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// コンテキストの取得</span></span><br><span class="line"><span class="keyword">let</span> contextNode;</span><br><span class="line"><span class="keyword">let</span> withinSubject = cy.state(<span class="string">&#x27;withinSubject&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (Cypress.dom.isElement(subject)) &#123;</span><br><span class="line">    contextNode = subject[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Cypress.dom.isDocument(subject)) &#123;</span><br><span class="line">    contextNode = subject;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (withinSubject) &#123;</span><br><span class="line">    contextNode = withinSubject[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    contextNode = cy.state(<span class="string">&#x27;window&#x27;</span>).document;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQueryを使って要素を取得</span></span><br><span class="line"><span class="keyword">let</span> value = Cypress.$(<span class="string">&#x27;a, *[role=&quot;link&quot;]&#x27;</span>, contextNode);</span><br><span class="line"><span class="keyword">if</span> (selector) &#123;</span><br><span class="line">    value = value.filter(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> self = Cypress.$(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aria-label属性で検索</span></span><br><span class="line">        <span class="keyword">if</span> (self.attr(<span class="string">&#x27;aria-label&#x27;</span>) === selector) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aria-labelledby属性で検索</span></span><br><span class="line">        <span class="keyword">const</span> labelledBy = self.attr(<span class="string">&#x27;aria-labelledby&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (labelledBy &amp;&amp; Cypress.$(<span class="string">`#<span class="subst">$&#123;labelledBy&#125;</span>`</span>).text() === selector) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// テキストを見て検索</span></span><br><span class="line">        <span class="keyword">if</span> (self.text().trim() === selector) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画像のalt属性を見て検索</span></span><br><span class="line">        <span class="keyword">const</span> images = self.find(<span class="string">`img[alt=&quot;<span class="subst">$&#123;selector&#125;</span>&quot;]`</span>);</span><br><span class="line">        <span class="keyword">return</span> images.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cy.verifyUpcomingAssertions(value, options, &#123;</span><br><span class="line">    onRetry: resolveValue,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ログ出力"><a href="#ログ出力" class="headerlink" title="ログ出力"></a>ログ出力</h2><p>最後ですが、必要に応じて探索中の情報のログを出しておくと、TestRunnerで問題追跡がしやすくなりますなぜ見つからなかったのか、途中経過はマッチしていたが、この情報でマッチしなくなったとか。宣言的な書き方は、失敗した時のフィードバックが弱いのでこの手のログを出してあげるのは良いと思います。</p><p>ログの出力はCypress.logで行います。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功したらログを出す</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> resolveValue()</span><br><span class="line"><span class="keyword">if</span> (options.log !== <span class="literal">false</span>) &#123;</span><br><span class="line">    Cypress.log(&#123;</span><br><span class="line">        name: <span class="string">&#x27;aria&#x27;</span>,</span><br><span class="line">        message: selector,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Cypressの中身で、書きやすく効率の良いテストを実現する重要な要素であるリトライポリシーについて紹介し、そのリトライポリシーに従ったプラグインの書き方も紹介しました。</p><ul><li>逐次処理なら通常のAPIを列挙すればOK</li><li>取得のロジックはasyncな関数に納める</li><li>jQueryを使って要素を取得</li><li>cy.verifyUpcomingAssertions()にとってきた要素を渡して後段のアサーションを実行</li><li>cy.verifyUpcomingAssertions()にはこの関数自身をonRetryに渡す<br>リトライは繰り返し行われるが、ループを自分で書くのではなく、CypressのAPIにonRetryに渡すことで再起的にループが行われる</li><li>要素の探索する場所（コンテキスト）の処理をしたり、ログを出せば完璧</li></ul><h1 id="補足"><a href="#補足" class="headerlink" title="補足"></a>補足</h1><p>本記事は、<a href="https://future.connpass.com/event/208056/presentation/">Future Tech Night #8</a>というイベントでお話した内容を記事化したものです。<br>同イベントの他の発表も記事として投稿されてますので、ぜひご覧ください！</p><ul><li><a href="/articles/20210428a/">Cypress入門～初心者でも簡単にE2Eテストが作れる～</a></li><li><a href="/articles/20210428b/">Cypress - 設定編</a></li><li><a href="/articles/20210428c/">保守・拡張をしやすいカプセル化したCypress</a></li><li>Cypress - 書きやすいテストの秘密と独自コマンドの実装（この記事です）</li></ul><h1 id="関連記事"><a href="#関連記事" class="headerlink" title="関連記事"></a>関連記事</h1><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210226/index.html" data-iframely-url="//cdn.iframe.ly/ZMlnZ2M?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200115/index.html" data-iframely-url="//cdn.iframe.ly/uGST3JI?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@testing-library/cypressの存在を知らずに、それっぽいものを作ろうとしたときにいろいろ調査した記録です。Cypressにはテストコードが縦と横に短くなる工夫がされており、そのメカニズムにしたがった独自コマンドを実装するにはコツが必要です。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="E2Eテスト" scheme="https://future-architect.github.io/tags/E2E%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>保守・拡張をしやすいカプセル化したCypress</title>
    <link href="https://future-architect.github.io/articles/20210428c/"/>
    <id>https://future-architect.github.io/articles/20210428c/</id>
    <published>2021-04-27T15:00:03.000Z</published>
    <updated>2021-04-27T15:18:48.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一行まとめ"><a href="#一行まとめ" class="headerlink" title="一行まとめ"></a>一行まとめ</h1><p>壊れやすい上に読みにくくなりがちなE2Eテストは、cypressのCustom Commandsなどでカプセル化すると読みやすくなおしやすい。</p><h1 id="CypressでE2Eテスト"><a href="#CypressでE2Eテスト" class="headerlink" title="CypressでE2Eテスト"></a>CypressでE2Eテスト</h1><p><a href="https://future.connpass.com/event/208056/presentation/">Future Tech Night #8</a> というイベントで、E2EテストをCypressで快適に行う方法を紹介しました。文字起こし兼補足として投稿します。</p><p>同イベントの他の発表も記事として投稿されてますので、こちらもご覧いただければ。</p><ul><li><a href="/articles/20210428a/">Cypress入門～初心者でも簡単にE2Eテストが作れる～</a></li><li><a href="/articles/20210428b/">Cypress - 設定編</a></li><li>保守・拡張をしやすいカプセル化したCypress(この記事)</li><li><a href="/articles/20210428d/">Cypress - 書きやすいテストの秘密と独自コマンドの実装</a></li></ul><h1 id="E2Eテストは壊れやすい"><a href="#E2Eテストは壊れやすい" class="headerlink" title="E2Eテストは壊れやすい"></a>E2Eテストは壊れやすい</h1><p>まずはE2Eテストとユニットテストを比較して、それぞれの特長をみてみましょう。</p><p>ユニットテストは基本的に開発するときに部品単位でつくられて、リポジトリにpushする前にサクッと動かしてテスト通るか確認する、という使い方をします。</p><p>対して、E2Eテストは画面単位でつくられて、ユーザの視点から画面を叩いて動くかどうかを検証するという使い方をします。つまり、ユーザの視点から見て、あからさまにおかしいなと感じるバグが見つかりやすい。結果としてクレームや問い合わせが減りやすくなります。</p><p><img src="/images/20210428c/Slide_-_6.png"></p><p>しかしながら、E2Eテストは壊れやすいのも特徴。</p><p>ユニットテストと比べてカバーする範囲が大きくなるので、どこかに変更があるとすぐ動かなくなってしまいます。例えば日本語の説明文に変更があったとかinputのnameが変わったとか、ちょっとしたことですぐ動かなくなってしまいます。</p><p>そして、画面の要素をidとかclassとかのセレクタで指定するため、どのセレクタがどのボタンを押してるのか追っていく必要があり、後から見たときに直しにくいのも難点。そのため、E2Eテストをつくるときは壊れることを前提に作っていくことが大事になってきます。特アジャイル的な開発をしているなら、機能追加の度にどこか動かなくなるという気持ちでいきましょう。</p><h1 id="壊れたときに直しやすいように可読性をあげる"><a href="#壊れたときに直しやすいように可読性をあげる" class="headerlink" title="壊れたときに直しやすいように可読性をあげる"></a>壊れたときに直しやすいように可読性をあげる</h1><p>頻繁に壊れるということはコードを読み返すことも多くなるということ。壊れても直しやすいようにテストコードの可読性を上げていくことがメンテナンスを続けていくために大事になっていきます。</p><p>具体的な例としてToDoアプリを考えてみましょう。<br>Webアプリのチュートリアルによく出てくる、ToDoの追加と削除ができるページに対して Cypressでテストを行ってみます。<br><img src="/images/20210428c/image_10.png"></p><p>このToDoアプリに対して追加と削除が正常に動作しているか確認するE2Eテストを書いていきましょう。「Todo1」「Todo2」「Todo3」を追加して、2つ目を削除、残ってるTodoを確認する、というテストをCypressで実現すると以下のようになります。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;add 3 todo and delete middle todo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// todo1を追加</span></span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;todo1&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;todo1&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;&#123;enter&#125;&#x27;</span>, &#123; <span class="attr">delay</span>: <span class="number">100</span> &#125;);</span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// todo2を追加</span></span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;todo2&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;todo2&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;&#123;enter&#125;&#x27;</span>, &#123; <span class="attr">delay</span>: <span class="number">100</span> &#125;);</span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// todo3を追加</span></span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;todo3&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;todo3&#x27;</span>)</span><br><span class="line">     .type(<span class="string">&#x27;&#123;enter&#125;&#x27;</span>, &#123; <span class="attr">delay</span>: <span class="number">100</span> &#125;);</span><br><span class="line">   cy.get(<span class="string">&#x27;#new-todo&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2つ目を削除</span></span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item:nth(1)&#x27;</span>).contains(<span class="string">&#x27;DEL&#x27;</span>).click();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 残アイテムの確認</span></span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo1&#x27;</span>);</span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo2&#x27;</span>).should(<span class="string">&#x27;not.exist&#x27;</span>);</span><br><span class="line">   cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo3&#x27;</span>);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>Cypressを使ったことない、という方でも上のコードが何をしているかがなんとなくはわかってもらえるかなと。それくたいCypressの学習コストは低め。jQueryやCSSなどをかじっていてDOM要素を指定する知識があれば、Webアプリのベテランでなくてもすぐに書けるかなと思っています。</p><p>しかしながら、DOM要素を指定するためにセレクタを書いていくと、段々と読みにくいコードになっていきます。</p><p>例えば、動的に追加された要素やインポートした外部ライブラリのDOM要素を指定する際に、<code>nth</code> や <code>&gt;</code> などで掘っていって指定する複雑なセレクタが書かれがちになります。そうすると後で見返したときに、どこをどう直せばテストが通るようになるのか判断するために画面のDOMと見比べて追っていく必要が出てきます。</p><p>後で見返したときにわかりやすいように、テストコードの可読性をあげていきたい。</p><p>もちろん、コメントで 「ToDoを追加する」「ToDoを削除する」と書いて 分割してまとめておくのも見やすくする一つの案なのですが、Cypressの場合、Custom Commandsを使うと、分割して見やすくしたコードをカプセル化し、より読みやすいコードに仕立て上げることができます。</p><h1 id="Custom-Commands"><a href="#Custom-Commands" class="headerlink" title="Custom Commands"></a>Custom Commands</h1><p>Custom Commands、名前の通り自分でコマンドをつくれるという機能です。<br><a href="https://docs.cypress.io/api/cypress-api/custom-commands">https://docs.cypress.io/api/cypress-api/custom-commands</a></p><p>自分の欲しいコマンドを cy.containsやcy.getといったCypressに用意されているコマンドと同じように作ることができます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cypress.Commands.add(name, callbackFn)</span><br></pre></td></tr></table></figure><p>このCustom Commandsで上記のTodoアプリのテストを整理してみましょう。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;add 3 todo and delete middle todo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// todo1を追加</span></span><br><span class="line">  cy.addTodo(<span class="string">&#x27;todo1&#x27;</span>);</span><br><span class="line">  <span class="comment">// todo2を追加</span></span><br><span class="line">  cy.addTodo(<span class="string">&#x27;todo2&#x27;</span>);</span><br><span class="line">  <span class="comment">// todo3を追加</span></span><br><span class="line">  cy.addTodo(<span class="string">&#x27;todo3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2つ目を削除</span></span><br><span class="line">  cy.deleteTodo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 残アイテムの確認</span></span><br><span class="line">  cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo1&#x27;</span>);</span><br><span class="line">  cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo2&#x27;</span>).should(<span class="string">&#x27;not.exist&#x27;</span>);</span><br><span class="line">  cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(<span class="string">&#x27;todo3&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>「ToDoを追加する」「ToDoを削除する」とコメントした箇所をまとめてカスタムコマンドにしました。<br>後から見返しやすいコードになりましたね。</p><p>cy.addTodoとcy.deleteTodoの実態は以下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./cypress/support/commands.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODOの追加 cy.addTodo(&#x27;todo1&#x27;);</span></span><br><span class="line">Cypress.Commands.add(<span class="string">&#x27;addTodo&#x27;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  cy.get(<span class="string">&#x27;#new-todo&#x27;</span>)</span><br><span class="line">    .type(value).should(<span class="string">&#x27;have.value&#x27;</span>, value)</span><br><span class="line">    .type(<span class="string">&#x27;&#123;enter&#125;&#x27;</span>, &#123; <span class="attr">delay</span>: <span class="number">100</span> &#125;);</span><br><span class="line">  cy.get(<span class="string">&#x27;#new-todo&#x27;</span>).should(<span class="string">&#x27;have.value&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  cy.get(<span class="string">&#x27;.todo-item&#x27;</span>).contains(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODOの削除 cy.deleteTodo(0);</span></span><br><span class="line">Cypress.Commands.add(<span class="string">&#x27;deleteTodo&#x27;</span>, <span class="function">(<span class="params">nth</span>) =&gt;</span> &#123;</span><br><span class="line">  cy.get(<span class="string">`.todo-item:nth(<span class="subst">$&#123;nth&#125;</span>)`</span>).contains(<span class="string">&#x27;DEL&#x27;</span>).click();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>addTodoは共通部分をまとめたのですっきり書けるようになったパターン、deleteTodoは <code>todo-item:nth</code> という画面のDOMを追っていかないと何してるか理解しにくい部分にCustom Commandsとして名前をつけてあげることで後から読み返しやすくなるというパターンです。</p><p>ひとつCustom Commandsをつくるといろんな場所で似たような操作を簡単に書けるようになります。</p><p>お気づきの通り、このCustom CommandsはReactやVueといったコンポーネント指向のライブラリと相性抜群。</p><p>書くのも簡単になり、読むときも理解しやすい。同じ処理が別のspecファイルにあるというときもコピペせずに済む。そして、コンポーネントに変更があった場合もCustom Commandsだけ修正すればOK、という場面が増えます。</p><h1 id="デメリット"><a href="#デメリット" class="headerlink" title="デメリット"></a>デメリット</h1><p>もちろんデメリットもあります。</p><p>テストケースの書き方が不味く「ToDoを追加する」という段階でinputがdisabledでTodoが追加できなかった、といったエラーが出た場合、specファイルの中ではなく、カスタムコマンドを定義しているファイルの該当部分を出します。そのため、どのaddTodoでエラーが起きたのかわかりづらい、呼び出し元がわかりにくいということがときたまあります。</p><p>そういった場合は引数をユニークなものにしておくと一旦の解決策になります。おなじTodoを3つ作成するのではなく、「todo1」・「todo2」・「todo3」としておくと、どのtodoを作成するタイミングでエラーが起きたのかが把握しやすくなります。</p><p>また、Custom Commandsの数が増えてきた際に名前の衝突が起きる可能性が高まります。こちらはある程度の命名規則があれば回避できるかなと思っています。以前登録したCustom Commandsが見つけやすいように <code>cypress\support\commands.js</code> を分割するのも手です。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>E2Eテストは壊れやすい上に読みにくくなりがちなので、CypressのCustom Commandsを上手く利用して、書きやすく読みやすく直しやすいテストコードにしていきましょう。</p><p>とはいえ、Cypressをまだ触ったことないよという方は、ここまで考えずまずは使ってみてください。containsとclickだけ覚えればそこそこのテストが書けます。</p><p>Cypressをしばらく使ってテストコード見返すのが辛くなり始めたら、Custom Commandsで一連の流れを固めてカプセル化するなどして、後から見返しやすいコードにできないか検討してみてください。</p><p>続いて、 <a href="/articles/20210428d/">Cypress - 書きやすいテストの秘密と独自コマンドの実装</a> 記事を参照ください。</p><h1 id="関連記事"><a href="#関連記事" class="headerlink" title="関連記事"></a>関連記事</h1><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210226/index.html" data-iframely-url="//cdn.iframe.ly/ZMlnZ2M?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200115/index.html" data-iframely-url="//cdn.iframe.ly/uGST3JI?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一行まとめ&quot;&gt;&lt;a href=&quot;#一行まとめ&quot; class=&quot;headerlink&quot; title=&quot;一行まとめ&quot;&gt;&lt;/a&gt;一行まとめ&lt;/h1&gt;&lt;p&gt;壊れやすい上に読みにくくなりがちなE2Eテストは、cypressのCustom Commandsなどでカプセル化する</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="E2Eテスト" scheme="https://future-architect.github.io/tags/E2E%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>Cypress - 設定編</title>
    <link href="https://future-architect.github.io/articles/20210428b/"/>
    <id>https://future-architect.github.io/articles/20210428b/</id>
    <published>2021-04-27T15:00:02.000Z</published>
    <updated>2021-04-27T15:16:47.924Z</updated>
    
    <content type="html"><![CDATA[<p>Cypressの設定周りについて紹介します。</p><p>何も手を加えないデフォルトでも動作します。</p><h1 id="Cypressの設定"><a href="#Cypressの設定" class="headerlink" title="Cypressの設定"></a>Cypressの設定</h1><h2 id="フォルダ構成とTypeScript化"><a href="#フォルダ構成とTypeScript化" class="headerlink" title="フォルダ構成とTypeScript化"></a>フォルダ構成とTypeScript化</h2><p>まず、Cypressのデフォルトのフォルダ構成がこちらです。何も指定しないと、プロジェクトルートにcypressフォルダがあって、その中に関連ファイル（テストケース、プラグインなど）が置かれるのが基本パターンです。</p><figure class="highlight text"><figcaption><span>Cypressのフォルダ構成</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cypress</span><br><span class="line">├── fixtures</span><br><span class="line">│   └── users.json</span><br><span class="line">├── integration</span><br><span class="line">│   ├── textbox.html</span><br><span class="line">│   └── textbox.spec.js</span><br><span class="line">├── plugins</span><br><span class="line">│   └── index.js</span><br><span class="line">├── screenshots</span><br><span class="line">├── support</span><br><span class="line">│   ├── commands.js</span><br><span class="line">│   └── index.js</span><br><span class="line">└── videos</span><br></pre></td></tr></table></figure><p>Cypressは<code>npm install cypress</code>で必要なツールをまとめてインストールできます。</p><p>初回実行時にこの<code>cypress</code>フォルダと<code>cypress.json</code>が作られます。設定やテスト、ヘルパー関数などはこの雛形の中に書いていきます。</p><p>デフォルトで生成される設定ファイルはJavaScriptのコードですが、TypeScript化にも対応しています。TS化したいときは次のことを行います。</p><ul><li><code>npm i -D typescript @types/node</code></li><li><code>tsconfig.json</code>を作成</li></ul><p><code>tsconfig.json</code>は通常、プロジェクトのルートの<code>package.json</code>があるフォルダに置きますが、プロジェクトの<code>tsconfig.json</code>とは別にこのフォルダ内にCypress専用<code>tsconfig.json</code>を置くこともできます。</p><p>あとはこのフォルダ内部の<code>.js</code>を<code>.ts</code>に置換していけば型が書けます。</p><p>↓細かいところはこちらを参照してください。</p><p><a href="https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/fundamentals__typescript">https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/fundamentals__typescript</a></p><p>今時はみんなTypeScript使うでしょうし、この説明では全部TS化する前提で話を進めます。といってもJSのまま使うにはデフォルトのままで大丈夫なので、特に考慮することなくこのエントリーの説明を読み進めていけます。</p><h2 id="テストのカスタマイズポイント"><a href="#テストのカスタマイズポイント" class="headerlink" title="テストのカスタマイズポイント"></a>テストのカスタマイズポイント</h2><p>テスト時の動作のカスタマイズ項目は次のページに書かれています。動画の自動のキャプチャ機能や失敗時のスクリーンショット機能をオフにしたり、テストランナーでの実行時にテストファイルの変更を監視して自動テストを行う（watch）機能を無効にしたり、フォルダ位置を変えたりといったことが変更可能です。</p><p><a href="https://docs.cypress.io/guides/references/configuration">https://docs.cypress.io/guides/references/configuration</a></p><p>基本的に5種類のカスタマイズ方法があります。</p><ul><li>ルートのcypress.json</li><li>cypress.env.json</li><li>環境変数</li><li>CLIのオプション</li><li>cypress/plugins/index.ts</li></ul><p>現在のテストが読み込んでいる設定が、どの項目から読み込まれたのかはテストランナーのSettingsメニューで確認できます。</p><p><img src="/images/20210428b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-04-07_23.44.00.png"></p><p><code>env</code>の項目で設定した値は、テストコード中からアクセスできるため、テストのパラメータを外部から変更できるようにすることもできます。</p><h2 id="フォルダ構成の詳細"><a href="#フォルダ構成の詳細" class="headerlink" title="フォルダ構成の詳細"></a>フォルダ構成の詳細</h2><p>最初にデフォルトのフォルダ構成を紹介しました。それぞれのフォルダの役割は次の通りです。</p><ul><li>fixtures: テスト中で使いたいデータファイル置き場</li><li>integration: テストコード置き場</li><li>plugins: プラグインの登録や設定の変更</li><li>support: ちょっとしたコマンド追加など</li><li>videos: 実行中に記録された動画ファイル置き場</li><li>screenshots: 実行中に記録されたスクリーンショット置き場</li></ul><p>これらのフォルダは<code>cypress.json</code>でフォルダの位置を変えたりできます。また、最初に呼び出される設定ファイル（基本は<code>cypress/plugins/index.js</code>、このパスも変更できる)でフォルダ構成の変更もできます。</p><p>詳しくは設定の説明を読むと良いでしょう。</p><p><a href="https://docs.cypress.io/guides/references/configuration">https://docs.cypress.io/guides/references/configuration</a></p><h2 id="cypress-support-index-ts"><a href="#cypress-support-index-ts" class="headerlink" title="cypress/support/index.ts"></a>cypress/support/index.ts</h2><p>npm installしたプラグインのうち、ただコマンドを足すだけのシンプルなものを登録したり、自作のコマンドの登録をしたりする設定置き場です。コマンドはcommands.tsに書いて、このファイルにはimport文を書いて参照する方法が一般的なようです（という構成の設定がデフォルトで作られる）。</p><figure class="highlight ts"><figcaption><span>cypress/support/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@testing-library/cypress/add-commands&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@cypress/code-coverage/support&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./commands&quot;</span></span><br></pre></td></tr></table></figure><p>コマンドの作り方は後述します</p><h2 id="cypress-plugins-index-ts"><a href="#cypress-plugins-index-ts" class="headerlink" title="cypress/plugins/index.ts"></a>cypress/plugins/index.ts</h2><p>Cypress内部のイベントを受け取る必要のあるプラグインの初期化や、設定の上書きなどを行います。</p><figure class="highlight ts"><figcaption><span>cypress/plugins/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;cypress&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = (</span><br><span class="line">        on: Cypress.PluginEvents,</span><br><span class="line">        config: Cypress.PluginConfigOptions</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;@cypress/code-coverage/task&quot;</span>)(on, config)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        integrationFolder: <span class="string">&quot;cypress/specs&quot;</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最低限のcypress.jsonは空でもいいのですが、baseUrlだけ設定しておくと、cy.visit()とかcy.request()のパスにprefixとしてつくので、テストコードがポートやホスト名にハードコードされなくなります。ちょっと変更に強くなります。ローカルと、リモートのテストの両方で使う場合はbaseUrlを外から変えればいけるようになるので、基本的には設定しておくべきでしょう。npm run serveなどで起動するテストサーバーや、go runで起動するサーバーに向けておきます。</p><figure class="highlight json"><figcaption><span>cypress.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue-cliで自動生成すると、ちょっと違うフォルダに入ります。また、vue-cliで実行した場合は、npm run serveして、そのURLをcypressに渡すところまでやってくれるので便利です。</p><p>Cypressの設定は画面からみれます。どこで設定された値なのかが一目瞭然ですごく親切。</p><p>Cypressが起動時に読み込むファイルは次の通り</p><ol><li>cypress.jsonでフォルダの場所などを読み取り</li><li>pluginとsupportの読み込み(設定なければcypress/plugins/index.jsとcypress/support/index.jsなど)</li><li>テストケースの読み込み(設定なければcypress/integrations)</li><li>openモードでなければそのままテストを実行、openモードの場合はIDEを起動</li></ol><p>pluginsというフォルダ名ではあるものの、設定を変えたりします。次のサンプルはコードカバレッジを有効化しつつ、テストの置き場のフォルダを変更しています。WebPackの設定を変更したりするのはこちらです。</p><figure class="highlight ts"><figcaption><span>cypress/plugins/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;cypress&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">on: Cypress.PluginEvents, config: Cypress.PluginConfigOptions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;@cypress/code-coverage/task&quot;</span>)(on, config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        integrationFolder: <span class="string">&quot;cypress/specs&quot;</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>これら以外にも、環境変数で値を渡したり、コマンドライン引数で値を設定したりといった機能があります。</p><h2 id="Vue-js以外の実行の流れ"><a href="#Vue-js以外の実行の流れ" class="headerlink" title="Vue.js以外の実行の流れ"></a>Vue.js以外の実行の流れ</h2><p>基本的な流れは次の通りです。</p><ol><li>E2Eテスト対象のサーバーを起動します<br>ウェブサーバーやフロントエンドの開発サーバーが該当します。静的HTMLならホスティングもCypressだけでできます。4/6にリリースされた7.0ではStorybook的にReact/Vueコンポーネントのテストが<br>直接書ける</li><li><code>cypress run</code>でヘッドレス実行、あるいは、<code>cypress open</code>でGUI Test Runnerを起動してテストします。<br>cypress runでヘッドレス実行、あるいは、cypress openでGUI Test Runnerを起動してテストします。テストの中でcy.visit(“接続先URL”)で1で起動したテスト対象のページにアクセスします。cypress.jsonなどでbaseUrlを指定すれば、ここからの相対パスで次のようにテストをシンプルにできます。また、ローカル、stg環境など複数の環境でテストを再利用したい場合に便利です。</li></ol><ul><li><code>cy.visit(“http://localhost:3000/”)</code> # 愚直に書く</li><li><code>cy.visit(“/”)</code>                      # baseUrlからの相対パス</li></ul><figure class="highlight json"><figcaption><span>cypress.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-jsの実行の流れ"><a href="#Vue-jsの実行の流れ" class="headerlink" title="Vue.jsの実行の流れ"></a>Vue.jsの実行の流れ</h2><p>CypressをVue.jsのプロジェクトに導入するのは簡単です。</p><p>インストール時にE2Eを選択し、その後の選択でCypressを選択するとインストールされます。また、作成済みのプロジェクトであれば<code>vue add e2e-cypress</code>を実行すれば追加できます。</p><p>Vueの場合、テストはすべてtest/e2e以下に格納するようになっています。</p><p>実行すると開発サーバー実行と、それをbaseUrlに設定して起動するところまでvue-cli-serviceがやってくれます。</p><h2 id="CypressとJest"><a href="#CypressとJest" class="headerlink" title="CypressとJest"></a>CypressとJest</h2><p>Cypressはmocha + chaiベースでテストを書きます。ユニットテストで現在一番人気はJestですが、Jestとmocha, chaiでキーワードがいろいろ衝突します。特にchaiとJestのexpectが大きいです。全然違うなら問題ないのですが、似ているようで微妙にメソッドが違ったりと、微妙な差のため、「こちらは動くのに、こちらは全然動かない」という微妙な落とし穴位になりがちです。</p><p>公式サイトで紹介されている方法はプロジェクトのルートのtsconfig.jsonと、cypress/tsconfig.jsonを使い分けて回避する方法です。まずルートの方のプロジェクトですが、プロジェクトに必要な設定と、型に”jest”を入れておきます。また、<code>include</code>でCypress以外の設定も入れておきましょう。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">&#x27;@jest/globals&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>/tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;ES2015&quot;</span>, <span class="string">&quot;DOM&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;types&quot;</span>: [<span class="string">&quot;jest&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;src/*.ts&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [<span class="string">&quot;src/*.test.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>こちらはCypress側の設定です。<code>extends</code>で親フォルダの設定を読み込み、必要な箇所だけ追加します。ここではtypesに<code>cypress</code>を足しています。これで”jest”との衝突を防げます。</p><figure class="highlight json"><figcaption><span>/cypress/tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;../tsconfig.json&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;types&quot;</span>: [<span class="string">&quot;cypress&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;../node_modules/cypress&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./**/*.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CypressのMochaはGUIのテストにしか使ってはいけないわけではなく、単純なユニットテストに使っても良いといえば良いのですが、動画撮影機能とか失敗時のスクリーンショット機能のせいでシンプルなテストほどオーバーヘッドが大きい（全部オフにすれば普通になりますが）ですし、ふたつ使い分ける方が良いでしょう。</p><p>手元の環境ではJestとCypressのカバレッジを統合するのがうまくいかず、いっそのことCypressに寄せる、というのも考えたりはしたのですが、Node.js（というかElectron）の機能を使ったテストが実行できないなど、欠点もあって、それが受容できるかどうか次第ですね。</p><p>簡単に済ませるのであれば、<code>expect()</code>のmatcherの挙動が違うだけなので、cypressとjestを両方tsconfig.jsonに入れてしまって、明示的にimportしてあげれば2つ作らなくても対応可能です。仕事のプロジェクトではこれを書くようにしちゃっています。</p><h1 id="コマンドの作り方"><a href="#コマンドの作り方" class="headerlink" title="コマンドの作り方"></a>コマンドの作り方</h1><p>テストコードを書いていると、同じような命令が繰り返し登場することがあります。例えば、ログインを毎回行っている、特定のページに遷移する、データの登録を行ってデータがある前提のテストに備えるなどなど。</p><p>テストはなるべく構造化しないで、愚直に書いた方が良いことの方が多いのですが、準備コードが長くなりすぎるのもフォーカスがぼやけてしまってよくないです。その場合にテストコードを短くして見通しを改善する方法は主に2つあります。</p><ul><li>同一のファイルのテスト間ではbeforeEach()を使って実装をまとめる</li><li>ファイルを跨いだり、横断的に使う場合はカスタムコマンドを作成する</li></ul><p>ここでは後者の方法について軽く紹介します。ただし、短くしすぎて見にくくならないようにすることが大事です。テストコードの読解のためにたくさんの関数の中身を調べないといけない、というのはよくないテストコードです。多少冗長でも読みやすくて意味が把握しやすければ問題ありません。またこの独自コマンドを活用する方法はびろうさんが詳しく紹介してくれます。また、たんなる公開APIの列挙ではない、よりCypressの内部に突っ込んだ独自コマンドの実装方法も別のエントリーで紹介します。</p><p>追加コマンドの定義箇所はsupportフォルダ以下です。</p><p>npmインストールした追加のコマンドを増やすのは<code>support/index.ts</code>に書きます。プロジェクトで作成するコマンドはここから読み込まれる<code>command.ts</code>に入れておきます。</p><figure class="highlight ts"><figcaption><span>cypress/support/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@testing-library/cypress/add-commands&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@cypress/code-coverage/support&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./commands&quot;</span></span><br></pre></td></tr></table></figure><p>コマンドはログインだったり、一連の動作を連続実行するのに便利な仕組みです。中ではcypressのテストを書くための一般的なAPIを呼び出します。次のコマンドはログインを一発で行うコマンドを追加した例です。</p><figure class="highlight ts"><figcaption><span>cypress/support/commands.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cypress.Commands.add(<span class="string">&quot;login&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cy.visit(<span class="string">&quot;/&quot;</span>, &#123; <span class="attr">timeout</span>: <span class="number">10000</span> &#125;);</span><br><span class="line">  cy.url().should(<span class="string">&quot;match&quot;</span>, <span class="regexp">/auth/</span>);</span><br><span class="line">  cy.get(<span class="string">&quot;#user&quot;</span>).type(<span class="string">&quot;testuser1&quot;</span>);</span><br><span class="line">  cy.get(<span class="string">&quot;#passwd&quot;</span>).type(<span class="string">&quot;testuser1-password&quot;</span>);</span><br><span class="line">  cy.get(<span class="string">&quot;#login&quot;</span>).click();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>追加したコマンドは、cyオブジェクトの追加メソッドのように見えます。このままではTypeScriptから識別されず、TypeScriptのコンパイルでエラーになってしまいますし、コード補完もできませんので、型定義ファイルを用意します。</p><figure class="highlight ts"><figcaption><span>cypress/support/index.d.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;cypress&quot; /&gt;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Cypress &#123;</span><br><span class="line">  <span class="keyword">interface</span> Chainable &#123;</span><br><span class="line">    login();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Cypressの設定周りの構造と初期化周りの挙動と、コマンドの登録について簡単に紹介しました。</p><h1 id="補足"><a href="#補足" class="headerlink" title="補足"></a>補足</h1><p>本記事は、<a href="https://future.connpass.com/event/208056/presentation/">Future Tech Night #8</a>というイベントでお話した内容を記事化したものです。<br>同イベントの他の発表も記事として投稿されてますので、ぜひご覧ください！</p><ol><li><a href="/articles/20210428a/">Cypress入門～初心者でも簡単にE2Eテストが作れる～</a></li><li>Cypress - 設定編（この記事です）</li><li><a href="/articles/20210428c/">保守・拡張をしやすいカプセル化したCypress</a></li><li><a href="/articles/20210428d/">Cypress - 書きやすいテストの秘密と独自コマンドの実装</a></li></ol><h1 id="関連記事"><a href="#関連記事" class="headerlink" title="関連記事"></a>関連記事</h1><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210226/index.html" data-iframely-url="//cdn.iframe.ly/ZMlnZ2M?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200115/index.html" data-iframely-url="//cdn.iframe.ly/uGST3JI?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Cypressの設定周りについて紹介します。&lt;/p&gt;
&lt;p&gt;何も手を加えないデフォルトでも動作します。&lt;/p&gt;
&lt;h1 id=&quot;Cypressの設定&quot;&gt;&lt;a href=&quot;#Cypressの設定&quot; class=&quot;headerlink&quot; title=&quot;Cypressの設定&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="E2Eテスト" scheme="https://future-architect.github.io/tags/E2E%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>Cypress入門～初心者でも簡単にE2Eテストが作れる～</title>
    <link href="https://future-architect.github.io/articles/20210428a/"/>
    <id>https://future-architect.github.io/articles/20210428a/</id>
    <published>2021-04-27T15:00:01.000Z</published>
    <updated>2021-04-27T15:12:54.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。踊るエンジニア、木戸俊輔です。</p><p>2021年4月で社会人2年目になりましたが、総出社回数は3回です。コロナで外出できないのは残念ですが、自宅で安全に業務に取り組むことができる現代の環境には感謝ですね。</p><p>さて、皆さんは普段どのようにE2Eテストを行っていますか？忍耐強く手動でポチポチ画面を触って…というのはなかなかにしんどいですよね。自動化ツールを使って楽したいけど難しくてよくわからない、という方もいらっしゃると思います。</p><p>本記事では、テスト自動化ツールを全く使ったことのなかった私が、テスト自動化ツールである<a href="https://www.cypress.io/">Cypress</a>の導入から基本的な使い方までをご紹介していきます。</p><p>対象：</p><ul><li>Webサービスのテスト自動化に興味がある人</li><li>自動テスト初心者</li><li>Cypressを触ってみたい人</li></ul><h2 id="テストは大事"><a href="#テストは大事" class="headerlink" title="テストは大事"></a>テストは大事</h2><p>当たり前ですが、システムを納品/リリースする際、動作や性能のテストは必須です。もしテストが不十分だと、バグや想定外の挙動が発生し、</p><ul><li>システム納品先からの信頼消失</li><li>再開発のためにコスト増加</li><li>サービスの廃止</li></ul><p>などなど、恐ろしい事態に繋がる可能性があります。</p><h2 id="E2Eテストとは"><a href="#E2Eテストとは" class="headerlink" title="E2Eテストとは"></a>E2Eテストとは</h2><p>E2Eテストとは、「End To Endテスト」の略であり、ユーザが利用するのと同じようにシステム全体をテストします。</p><p>抜け漏れなくテストする必要があるため、かかる労力は膨大です。また、テスト者の未成熟などによりテストが正しく行われない可能性もあります。</p><p>Cypressを用いて自動化することで、コスト削減＆品質向上を狙います。</p><h1 id="Cypressとは"><a href="#Cypressとは" class="headerlink" title="Cypressとは"></a>Cypressとは</h1><p><a href="https://www.cypress.io/">Cypress</a>とはWebテスト用に構築されたJava Scriptライブラリです。</p><p><img src="/images/20210428a/image.png"></p><p>特徴として、以下のができます。</p><ul><li>単体テストからE2Eテストまで広く使える</li><li>テスト構築、実行、バグ検知まで全て行える</li><li>コマンドごとに画面のスナップショットを見返せる</li><li>テスト一連の様子をビデオとして保存できる</li><li>各種CIとの連携が可能である</li></ul><h2 id="インストール"><a href="#インストール" class="headerlink" title="インストール"></a>インストール</h2><p>Cypressによるテストを構築したいディレクトリ下で、以下のコマンドを実行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cypress</span><br></pre></td></tr></table></figure><p>これだけです。5~10分くらいで簡単にインストールできます。<br>（Java Scriptライブラリなので、node.jsはいれておいてください。）</p><h2 id="実行してみよう"><a href="#実行してみよう" class="headerlink" title="実行してみよう"></a>実行してみよう</h2><p>とりあえず実行してみましょう。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx cypress open</span><br></pre></td></tr></table></figure><p>を実行すると、Cypressの管理画面が開きます。また、インストールしてから1回目の実行時には、いくつかのサンプルテストを生成してくれます。</p><p><img src="/images/20210428a/image_2.png"></p><p>管理画面ではspecファイルごとにテストが並んでおり、実行したいファイルをクリックすると、記述されたテストが自動で実行されていきます。</p><p>試しに、サンプルテストの1つ、<code>actions.spec.js</code>を実行してみましょう。</p><p><img src="/images/20210428a/image_3.png"></p><p>画面右側で、Cypressが実際にどのようなWeb上操作を行っているかが確認できます。また、画面左側では、記述したテストの進行状況やチェック項目の可否が表示されています。失敗したテストがあれば、該当箇所をアラートで教えてくれます。</p><h2 id="Cypressの基本的な使い方"><a href="#Cypressの基本的な使い方" class="headerlink" title="Cypressの基本的な使い方"></a>Cypressの基本的な使い方</h2><p>Cypressではspecファイルにテストを記述していきます。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context(<span class="string">&#x27;カテゴリ名&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;シナリオ名1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    Cypressコマンドによる処理入力</span><br><span class="line">             ┋</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">&#x27;シナリオ名2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    Cypressコマンドによる処理入力</span><br><span class="line">             ┋</span><br><span class="line">  &#125;)</span><br><span class="line">             ┋</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CypressではWeb上でのアクションに相当する様々なコマンドが用意されています。</p><p>ここでは、よく使う基本的なコマンドをいくつか紹介します。</p><h3 id="Webサイトを訪れる"><a href="#Webサイトを訪れる" class="headerlink" title="Webサイトを訪れる"></a>Webサイトを訪れる</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.visit(<span class="string">&#x27;URL&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="DOMを取得する"><a href="#DOMを取得する" class="headerlink" title="DOMを取得する"></a>DOMを取得する</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cy.get(<span class="string">&#x27;DOMのタグ&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cy.contains(<span class="string">&#x27;探したい文字列&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>get()</code>と<code>contains()</code>どちらを使ってもDOMを取得することができます。</p><p><code>contains()</code>は、引数として与えた文字列を探してくれるので、非常に簡単に記述することができます。しかし、同画面上に対象の文字列が複数存在する場合や、表示される文字列が変更されうる場合には注意が必要です。</p><h3 id="DOMを操作する"><a href="#DOMを操作する" class="headerlink" title="DOMを操作する"></a>DOMを操作する</h3><p><code>get()</code>や<code>contains()</code>でDOMを取得し、DOMに対してコマンドを実行します。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cy.click()   <span class="comment">// クリック</span></span><br><span class="line"></span><br><span class="line">cy.type(<span class="string">&#x27;入力&#x27;</span>)    <span class="comment">// 文字入力</span></span><br></pre></td></tr></table></figure><p>例えば、「検索フォームに文字を打ち込んで検索する」操作は、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cy.get(<span class="string">&#x27;input[title=&quot;検索&quot;]&#x27;</span>).type(<span class="string">&#x27;Cypressの使い方&#x27;</span>);</span><br><span class="line">cy.contains(<span class="string">&#x27;Google 検索&#x27;</span>).click();</span><br></pre></td></tr></table></figure><p>などといった記述で実行することができます。</p><h3 id="チェックする"><a href="#チェックする" class="headerlink" title="チェックする"></a>チェックする</h3><p>画面の表示は適切か、ボタンはクリックできるか、といったテスト項目をCypressに確認させましょう。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cy.should(<span class="string">&#x27;テストタイプ&#x27;</span>)</span><br><span class="line">cy.should(<span class="string">&#x27;テストタイプ&#x27;</span>, 比較値)</span><br></pre></td></tr></table></figure><p>例：指定の文字列が表示されていることをチェックする</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.contains(<span class="string">&#x27;Gogle&#x27;</span>).should(<span class="string">&#x27;exist&#x27;</span>);</span><br></pre></td></tr></table></figure><p>テストが失敗していた場合はCypressが教えてくれます。<br><img src="/images/20210428a/image_4.png"></p><h2 id="テストの動画を保存する"><a href="#テストの動画を保存する" class="headerlink" title="テストの動画を保存する"></a>テストの動画を保存する</h2><p>CYpressでは、テスト実行中の画面の様子を動画として保存できます。</p><p>ユーザ登録を行うことで、過去の動画の見返しや他者との共有が可能です。</p><ol><li>Cypressを実行し、開いた管理画面の<code>Runs</code>タブからユーザ登録を行う。</li><li>Record Keyが発行される。表示されたコマンドでCypressを実行する。<br><img src="/images/20210428a/image_5.png"></li><li>管理画面の<code>Runs</code>タブに、テストシナリオごとの実行ビデオが表示される。各ビデオファイルごとに保存や共有が可能である。</li></ol><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>Cypressを用いたE2Eテストの基本的な実行&amp;管理方法を紹介しました。</p><p>画面操作を自動化するだけでなく、バグフィクス、エビデンスとしても役立てることができる優れものですが、私のような初心者でも簡単に構築出来ちゃいます。まだまだ紹介しきれていない機能もありますので、本記事の紹介で気軽にチャレンジしていただければ幸いです。</p><p>ぜひ快適なテストライフを！</p><h1 id="補足"><a href="#補足" class="headerlink" title="補足"></a>補足</h1><p>本記事は、<a href="https://future.connpass.com/event/208056/presentation/">Future Tech Night #8</a>というイベントでお話した内容を記事化したものです。<br>同イベントの他の発表も記事として投稿されてますので、ぜひご覧ください！</p><ul><li>Cypress入門～初心者でも簡単にE2Eテストが作れる～（この記事です）</li><li><a href="/articles/20210428b/">Cypress - 設定編</a></li><li><a href="/articles/20210428c/">保守・拡張をしやすいカプセル化したCypress</a></li><li><a href="/articles/20210428d/">Cypress - 書きやすいテストの秘密と独自コマンドの実装</a></li></ul><h1 id="関連記事"><a href="#関連記事" class="headerlink" title="関連記事"></a>関連記事</h1><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20210226/index.html" data-iframely-url="//cdn.iframe.ly/ZMlnZ2M?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200115/index.html" data-iframely-url="//cdn.iframe.ly/uGST3JI?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。踊るエンジニア、木戸俊輔です。&lt;/p&gt;
&lt;p&gt;2021年4月で社会人2年目になりましたが、総出社回数は3回です。</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="登壇レポート" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="JavaScript" scheme="https://future-architect.github.io/tags/JavaScript/"/>
    
    <category term="Cypress" scheme="https://future-architect.github.io/tags/Cypress/"/>
    
    <category term="E2Eテスト" scheme="https://future-architect.github.io/tags/E2E%E3%83%86%E3%82%B9%E3%83%88/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>GoにおけるAPIドキュメントベースのWeb API開発について登壇しました</title>
    <link href="https://future-architect.github.io/articles/20210427c/"/>
    <id>https://future-architect.github.io/articles/20210427c/</id>
    <published>2021-04-26T15:00:05.000Z</published>
    <updated>2021-04-27T14:54:17.634Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210427c/top.png"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG 多賀です。</p><p>2021/3/19(金)に <a href="https://future.connpass.com/event/206387/">【増枠】Future Tech Night #7 〜フューチャーの開発事例と共に学べるGo勉強会〜 - connpass</a> を開催しました。 私は、Goの Web API 開発にて、API ドキュメントベースで開発していることについて話しました。<br>なお、その他の登壇者の資料は <a href="https://future.connpass.com/event/206387/presentation/">こちら</a> に公開済みですので、興味があれば参照ください。</p><p>他の登壇者のレポートはこちらです。</p><ul><li><a href="/articles/20210427a/">Goのフラットパッケージについて登壇しました</a></li><li><a href="/articles/20210427b/">GoでDockerのAPIを叩いてみる</a></li></ul><h2 id="発表内容"><a href="#発表内容" class="headerlink" title="発表内容"></a>発表内容</h2><h3 id="API-ドキュメントベースで-Web-API-開発-go-swagger"><a href="#API-ドキュメントベースで-Web-API-開発-go-swagger" class="headerlink" title="API ドキュメントベースで Web API 開発 (go-swagger)"></a>API ドキュメントベースで Web API 開発 (go-swagger)</h3><iframe src="https://docs.google.com/presentation/d/1P1ntgrIZ_zYhlxQh8UjV1fBCIIObP-ZJPhm7Dn1yc04/embed?start=false&loop=false&delayms=3000" frameborder="0" width="100%" height="550" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><p>ブログで Go の Open API 関連ツールについていくつか記事を書いており、そのまとめ的な内容と実際に案件で使ってみての感想について話しています。</p><p>参考記事</p><ul><li><a href="https://future-architect.github.io/articles/20200701/">Go の Open API 3.0 のジェネレータ oapi-codegen を試してみた | フューチャー技術ブログ</a></li><li><a href="https://future-architect.github.io/articles/20200630/">go-swaggerを用いたWebアプリケーション開発Tips19選 | フューチャー技術ブログ</a></li><li><a href="https://future-architect.github.io/articles/20190814/">WAFとして go-swagger を選択してみた | フューチャー技術ブログ</a></li></ul><h3 id="質問内容"><a href="#質問内容" class="headerlink" title="質問内容"></a>質問内容</h3><h4 id="Q-Open-API-3-0が使えないことで問題などは生じないのですか？"><a href="#Q-Open-API-3-0が使えないことで問題などは生じないのですか？" class="headerlink" title="Q. Open API 3.0が使えないことで問題などは生じないのですか？"></a>Q. Open API 3.0が使えないことで問題などは生じないのですか？</h4><p>基本 Open API 2.0 で各種周辺ツール(他言語のクライアント生成、フロントエンドの表示等)の利用は問題なくできていました。Open API 2.0 と Open API 3.0 の変換ツール もありますので、ノックアウトになることはない認識です。</p><p><a href="https://mermade.org.uk/openapi-converter">Mermade Swagger 2.0 to OpenAPI 3.0.0 converter</a></p><h4 id="Q-go-swaggerを選ぶ際に、Open-API-2-0でも良いと判断するためのポイントなどがあれば教えてください"><a href="#Q-go-swaggerを選ぶ際に、Open-API-2-0でも良いと判断するためのポイントなどがあれば教えてください" class="headerlink" title="Q. go-swaggerを選ぶ際に、Open API 2.0でも良いと判断するためのポイントなどがあれば教えてください"></a>Q. go-swaggerを選ぶ際に、Open API 2.0でも良いと判断するためのポイントなどがあれば教えてください</h4><p>Open API 3.0 を利用しなければならない要件が他にないかの確認かと思います。 Open API を利用する場合、ドキュメントを書いて終わりではなく、周辺ツールや他の言語と組み合わせて使うようになることが多い印象です。<br>その際に、他で利用するツールが全て Open API 3.0 必須 で変換コストがかかることで全体のスピード感を損なうのであれば、go-swagger ではなく Open API 3.0 系のツールの利用が良いかと考えています。</p><h4 id="Q-go-swaggerがOpen-API-3-0に対応することはありそうでしょうか"><a href="#Q-go-swaggerがOpen-API-3-0に対応することはありそうでしょうか" class="headerlink" title="Q. go-swaggerがOpen API 3.0に対応することはありそうでしょうか?"></a>Q. go-swaggerがOpen API 3.0に対応することはありそうでしょうか?</h4><p>go-swagger は Open API 3.0 へ対応されない模様です。<br>以下 issue で言及されていました。</p><p><a href="https://github.com/go-swagger/go-swagger/issues/1122#issuecomment-323113089">https://github.com/go-swagger/go-swagger/issues/1122#issuecomment-323113089</a></p><h4 id="Q-go-swagger-のチームメンバーからの評判はどうですか？"><a href="#Q-go-swagger-のチームメンバーからの評判はどうですか？" class="headerlink" title="Q. go-swagger のチームメンバーからの評判はどうですか？"></a>Q. go-swagger のチームメンバーからの評判はどうですか？</h4><p>そこまで悪くはないかなという印象です。<br>他言語経験者で Go 初心者の方が開発する際に、コード生成で Handler 周りが出力されるので、細かい部分で詰まることなく開発できていたのかなと思っています。<br>go-swagger コマンドを開発端末で実行できるように、開発環境をしっかり事前に整備する必要はありました。go-swagger コマンドがうまくインストールできない等の問題は起きて、対応したりしてました。(ちなみに、公式からバイナリ落としてもらうが一番簡単な解決策でした）</p><h4 id="Q-WAF-Web-Application-Framework-よりもgo-swaggerのメリットが大きかったでしょうか？-私ははechoとgo-swaggerで悩んで結局echoにしました。"><a href="#Q-WAF-Web-Application-Framework-よりもgo-swaggerのメリットが大きかったでしょうか？-私ははechoとgo-swaggerで悩んで結局echoにしました。" class="headerlink" title="Q. WAF(Web Application Framework)よりもgo-swaggerのメリットが大きかったでしょうか？ 私ははechoとgo-swaggerで悩んで結局echoにしました。"></a>Q. WAF(Web Application Framework)よりもgo-swaggerのメリットが大きかったでしょうか？ 私ははechoとgo-swaggerで悩んで結局echoにしました。</h4><p>前提として、go-swagger も WAF としての機能は備えている認識です。<br>他のブログ記事に、以下の通り記載があり、私自身も同じ理解です。</p><blockquote><p>go-swaggerがWAF(Webアプリケーションフレームワーク）というのは直感では理解しにくいですが、go-swaggerで生成したサーバサイドのコードは、実質的にechoやginのように多くの機能を持ちます。 例えば、URLのルーティング、入力Validation、クエリパラメータ、フォーム、リクエストヘッダ、リクエストボディなどの 入力modelへのバインディング、HTTPレスポンスコード別のmodelの作成や、Middlewareの設定専用の関数など多くをサポートしていますし、固有のビジネスロジックを書くルールもgo-swaggerの生成したコードによって決められています。</p></blockquote><p>引用: <a href="https://future-architect.github.io/articles/20200630/">go-swaggerを用いたWebアプリケーション開発Tips19選 | フューチャー技術ブログ</a></p><p>あとは、考え方と優先度次第で決めることになるかと思います。</p><p>当発表では、「APIドキュメントファースト」ととして考えた結果、go-swagger を利用しているというスタンスになっています。ドキュメントと実装の乖離を防ぐというところに、重きを置いた選定を行い、実際に乖離しないメリットは享受できておりました。<br>他の WAF との比較はなんとも言えないですが、複数人でフロント・バックエンドを同時進行での開発であったことを考えるとメリットは大きかったかなと思います。</p><h3 id="発表で話していないこと"><a href="#発表で話していないこと" class="headerlink" title="発表で話していないこと"></a>発表で話していないこと</h3><ul><li>go-swagger 利用がベストの選択肢ではない<ul><li>今回の発表では、ドキュメントファーストを優先しての選定になっていますので、他の優先項目があればまた違う WAF の選定になったかと思います</li><li>個人的な好み的には、生成コードが薄く、中身が読みやすいライブラリのほうが好みです (<a href="https://github.com/go-chi/chi">go-chi/chi</a> とかですね)</li><li>ただ、ドキュメントが大事とは考えていて、他の WAF であまり考えられてなかったりするのが疑問だったりします。 Web API って使い手がいないと存在価値がないと思っていますので。</li></ul></li><li>go-swagger の生成コードは読める人がいたほうが良い<ul><li>細かい設定(タイムアウト等) を行う際に、生成コードを読んで設定することがありました。生成コードだからといって中身を知らないと思わぬ落とし穴にハマることがあるので、ご注意ください。</li></ul></li></ul><h2 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h2><p>案件でしっかり使った内容について、アウトプットできて良かったと思っています。</p><p>他の WAF を使っての開発案件もやって、利用後の比較もしてみたいですね。</p><p>発表をご視聴いただいた方、当記事を最後まで読んでいただいた方、ありがとうございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210427c/top.png&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;TIG 多賀です。&lt;/p&gt;
&lt;p&gt;2021/3</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇資料" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E8%B3%87%E6%96%99/"/>
    
    <category term="開催レポート" scheme="https://future-architect.github.io/tags/%E9%96%8B%E5%82%AC%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Swagger" scheme="https://future-architect.github.io/tags/Swagger/"/>
    
    <category term="OpenAPI" scheme="https://future-architect.github.io/tags/OpenAPI/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>GoでDockerのAPIを叩いてみる</title>
    <link href="https://future-architect.github.io/articles/20210427b/"/>
    <id>https://future-architect.github.io/articles/20210427b/</id>
    <published>2021-04-26T15:00:03.000Z</published>
    <updated>2021-04-26T08:44:58.754Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://future.connpass.com/event/206387/">Future Tech Night #7</a>で「GoでDockerのAPIを叩いてみる」という発表をしてきました。</p><p>他の登壇者のレポートはこちらです。</p><ul><li><a href="/articles/20210427a/">Goのフラットパッケージについて登壇しました</a></li><li><a href="/articles/20210427c/">GoにおけるAPIドキュメントベースのWeb API開発について登壇しました</a></li></ul><p>近年、コンテナの利用はますます増えています。実行環境としても、クラウドサービスでコンテナをホストするサービスは増えています。コンテナを動かすサービスもあれば、K8Sの利用も増えています。Kubernetesも最小のビルディングブロックはコンテナです。K8SのKnativeベースのGCP Cloud Runが僕の最近のお気に入りです。</p><p><img src="/images/20210427b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-03-18_23.43.23.png"></p><p>AWS Lambdaもコンテナを実行できるようになりました</p><ul><li><a href="https://www.publickey1.jp/blog/20/aws_lambdaaws_reinvent_2021.html">https://www.publickey1.jp/blog/20/aws_lambdaaws_reinvent_2021.html</a></li></ul><p>実行環境だけではなく、開発環境としても必要不可欠なツールになってきています。OSやバージョンが違っても同じ環境を再現できます。データベースなどのミドルウェアもOSにインストールすることなく、プロジェクトごとに個別の環境を作るのも簡単になりました。</p><p>そのコンテナのデファクトとなっているのがDockerです。Dockerはコンテナのオールインワンツールで、コンテナのビルドから実行までできますし、複数のコンテナを連携して動かす機能（オーケストレーション）もdocker-composeコマンドで提供されています。</p><p>コンテナ自体はDockerだけに限定されるされるものではありません。ビルドはdocker build以外にも、Bazelでも、Buildpacksでも、作成する手段は他にもあります。実行する部分はOCI Runtime Specificationという規格があり、Dockerもその1つです。</p><p>とはいえDockerは便利です。WindowsでもmacでもLinuxでもインストーラで環境が整うので、Dockerの環境構築でトラブル、という例は聞いたことがありません。Docker Hubでさまざまなイメージが1コマンドでダウンロードして起動できるのも良いですし、何よりも情報が多いというメリットがあります。</p><p><a href="https://qiita.com/shibukawa/items/797b7cbb7e530842e6f7">M1 Macの互換性情報のメモ</a>をQiitaに公開したときも感想として一番多かったのが、「Dockerが動くなら買おうかな」というものでした。このエントリーではDockerをもっと活用する方法について紹介します。</p><h1 id="Dockerの仕組み"><a href="#Dockerの仕組み" class="headerlink" title="Dockerの仕組み"></a>Dockerの仕組み</h1><p>Dockerをインストールして実際にサーバーなりを起動する場合、操作はdockerコマンドで行います。このdockerコマンドは単に命令を送るだけで、実態はWindowsなりLinuxなりmacOSで常駐プログラムとして実装されているサーバー(dockerd)が行います。</p><p><img src="/images/20210427b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-04-23_0.32.50.png"></p><p>Linuxはプロセスやファイルシステムを隔離してそのプロセスだけが動いているように見える状態で動きます。Linuxカーネルが持つ機能を使います。WindowsとmacはHyperVやHypervisor.FrameworkといったOSが持つ仮想PC機能を使い、Linuxを動かし、その中でLinuxカーネルの機能を使って動かします。コンテナごとに独立したOSが起動しているわけではなく、1つのLinuxの中で隔離機能を使って作った環境の中でそれぞれのプロセスが起動します。</p><p>コマンドからサーバーへのアクセスは、通常は/var/run/docker.sockというUnixドメインソケットを通じて動かします。これはHTTPサーバーがこのUDPの中で動いています。別ホストであればDOCKER_HOST環境変数を設定することでTCP/IPを使った連携ができます。</p><p>このサーバーにアクセスすると、コンテナを起動したり止めたりといったコンテナの操作ができます。また、このUDPはDockerのボリュームマウントを使ってコンテナの中に持ち込むことができます。そうすると、コンテナの中からあらゆるコンテナ操作ができる、特権コンテナのようなことも可能になります。</p><p>UDPベースのHTTPなので、curlコマンドでコンテナを操作できます。次のサンプルはhello-worldイメージを実行してそのログをコンソールに出力するコマンドです（CIDは最初のコマンド実行後に出力されるコンテナのIDが代入されているものとします)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl --unix-socket /var/run/docker.sock -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;Image&quot;: &quot;hello-world&quot;&#125;&#x27;</span> \</span><br><span class="line">  -X POST http://localhost/containers/create</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/<span class="variable">$&#123;CID&#125;</span>/start</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/<span class="variable">$&#123;CID&#125;</span>/<span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock <span class="string">&quot;http://localhost/containers/<span class="variable">$&#123;CID&#125;</span>/logs?stdout=1&quot;</span></span><br></pre></td></tr></table></figure><p>dockerコマンドなどはこの命令を自分で組み立てているわけではなく、GoやPythonのSDKを使って実装されています。このSDKを使うことでこれらの公式コマンドと同じことができます。</p><p><a href="https://docs.docker.com/engine/api/sdk/">https://docs.docker.com/engine/api/sdk/</a></p><p><img src="/images/20210427b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-03-18_23.20.12.png"></p><h1 id="Dockerのログビューアを作ってみる"><a href="#Dockerのログビューアを作ってみる" class="headerlink" title="Dockerのログビューアを作ってみる"></a>Dockerのログビューアを作ってみる</h1><p>近年のサービス開発では、オブザーバビリティが大事という機運が高まっています。ただ、数多くのSaaSなサービスはあるものの、手元で開発環境を用意するのは意外と面倒だったりします。オブザーバビリティでは次のような項目が技術要素として挙げられています。</p><ul><li>構造化ログ</li><li>トレーシング</li><li>メトリックス</li></ul><p>オブザーバビリティではこれらのルールに従ったログを出すアプリケーションと、それを閲覧するビューアが二人三脚で必要となります。とりあえず先頭の要素を実現するものを実装してみます。ログ出力は<a href="https://github.com/ymotongpoo/cloud-logging-configurations">JSONを出力する構造化ロガーが各言語にあったり</a>しますので、そのあたりを使って行区切りのJSON（JSONL）として出力したものをパースして色付けして出力します。</p><p>このブログの<a href="https://future-architect.github.io/articles/20201107/">フューチャーOSS推進タスクフォース始めます</a>の記事の中で、ログビューアというものがこっそり書かれていましたが、それがこれにあたります。</p><p><img src="/images/20210427b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-04-23_1.24.57.png"></p><p>最終的に出来上がったコードがこれです。</p><p><a href="https://gitlab.com/osaki-lab/secondsight">https://gitlab.com/osaki-lab/secondsight</a></p><p>アーキテクチャはこんな感じです。</p><p><img src="/images/20210427b/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2021-04-23_1.25.24.png"></p><h2 id="Docker-APIの利用"><a href="#Docker-APIの利用" class="headerlink" title="Docker APIの利用"></a>Docker APIの利用</h2><p>前述のドキュメントページのリファレンスなどをまず確認し、実行したい機能をまずは探します。dockerコマンドと必ずしも1:1になっているとは限らないので注意が必要です。ログビューアを作るには次のAPIを利用してみると良さそうです。</p><ul><li>コンテナのIDをリストアップ<br>   <a href="https://docs.docker.com/engine/api/v1.41/#operation/ContainerList">Containers - List Containers</a></li><li>コンテナの詳細情報を知る<br>   <a href="https://docs.docker.com/engine/api/v1.41/#operation/ContainerInspect">Containers - Inspect a Container</a></li><li>コンテナのイベント（起動とか停止）を取得<br>   <a href="https://docs.docker.com/engine/api/v1.41/#operation/SystemEvents">System - Monitor Events</a></li><li>コンテナのログを取得<br>   <a href="https://docs.docker.com/engine/api/v1.41/#operation/ContainerLogs">Containers - Get Container Logs</a></li><li>コンテナの消費リソースを取得<br>   <a href="https://docs.docker.com/engine/api/v1.41/#operation/ContainerStats">Containers - Get container stats based on resource usage</a></li></ul><p>なお、Docker SDKを網羅するサンプルコードとして、dockerコマンド自身があります。コードなんかを探索するとパラメータや返り値の加工方法が一発で理解できます。ためしに<code>ContainerStats()</code>などを検索してみてください。</p><p><a href="https://github.com/docker/cli">https://github.com/docker/cli</a></p><p>完成したのが次のプログラムです。半年ぐらい前に作って放置していたものを、発表の一週間前ぐらいからいじり初めてGoのコードをゼロから作り直して、動くようにしてみました（ので実践投入はまだ）。壮大な構想のために複雑化していたところをバサッと切り捨ててシンプルにしました。</p><p><img src="/images/20210427b/secondsight.gif"></p><p>なお、これの実装中に調べて書いたのが次のエントリーです。</p><ul><li><a href="https://future-architect.github.io/articles/20210408/">Go 1.16のembedとchiとSingle Page Application</a></li></ul><p>それ以外の実装部分の理解の助けになるエントリーもいくつもあります。</p><ul><li><a href="https://future-architect.github.io/articles/20210212/">Go 1.16のsignal.NotifyContext()</a></li><li><a href="https://future-architect.github.io/articles/20210208/">Go 1.16からリリースされたgo:embedとは</a></li><li><a href="https://future-architect.github.io/articles/20201111/">Parcel 2.0 beta.1を試す</a></li><li><a href="https://future-architect.github.io/articles/20200501/">TypeScriptでReactをやるときは、小さいアプリでもReduxを最初から使ってもいいかもねというお話</a></li></ul><p>他にも、サーバーレス連載などでDockerやCloud Runについて書いた記事も多数あります</p><p>軽く作ってみると、構造化ログが見えるのは便利です。色がつくとわかりやすいです。今後も、暇を見つけていろいろ機能を足していきたいです。フィルタや検索機能OpenCensus/OpenTelemetryのトレースログ、メトリクスの表示などです。ログ出力ライブラリによっていろいろクセがあったりするので、それぞれの出力をパースしてみやすくするのもいいですね。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>Dockerは今時な開発を支える重要なツールですが、Go SDKでいじってみるのは簡単でカスタマイズが可能です。実際にそれらを使うサンプルコードも紹介しました。クラウドサービスを使えば便利なものをローカルで気軽に実現するツールとかは作ってみるチャンスな予感（大手は投資しないだろうし）</p><p>今後、フューチャーでもいろいろOSSを作ったりしていきたいと思っています</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://future.connpass.com/event/206387/&quot;&gt;Future Tech Night #7&lt;/a&gt;で「GoでDockerのAPIを叩いてみる」という発表をしてきました。&lt;/p&gt;
&lt;p&gt;他の登壇者のレポートはこちらです。&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇資料" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E8%B3%87%E6%96%99/"/>
    
    <category term="開催レポート" scheme="https://future-architect.github.io/tags/%E9%96%8B%E5%82%AC%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Docker" scheme="https://future-architect.github.io/tags/Docker/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
    <category term="OSS推進タスクフォース" scheme="https://future-architect.github.io/tags/OSS%E6%8E%A8%E9%80%B2%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%95%E3%82%A9%E3%83%BC%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Goのフラットパッケージについて登壇しました</title>
    <link href="https://future-architect.github.io/articles/20210427a/"/>
    <id>https://future-architect.github.io/articles/20210427a/</id>
    <published>2021-04-26T15:00:00.000Z</published>
    <updated>2021-04-27T14:37:55.249Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210427a/building-5630441_640.jpg"><p><a href="https://pixabay.com/ja/users/rotekirsche20-18445331/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5630441">rotekirsche20</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5630441">Pixabay</a>からの画像</p><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG真野です。</p><p>2021/3/19(金)に<a href="https://future.connpass.com/event/206387/">Future Tech Night #7 〜フューチャーの開発事例と共に学べるGo勉強会〜</a> を開催しました。</p><p>トップバッターでGoの開発構成・アプリアーキテクチャについて話したので報告します。</p><p>なお、その他の登壇者の資料は<a href="https://future.connpass.com/event/206387/presentation/">こちら</a> に公開済み。他の登壇者のレポートはこちらです。</p><ul><li><a href="/articles/20210427b/">GoでDockerのAPIを叩いてみる</a></li><li><a href="/articles/20210427c/">GoにおけるAPIドキュメントベースのWeb API開発について登壇しました</a></li></ul><h1 id="発表内容：Goでフラットパッケージを導入してみて良かったこと、これから"><a href="#発表内容：Goでフラットパッケージを導入してみて良かったこと、これから" class="headerlink" title="発表内容：Goでフラットパッケージを導入してみて良かったこと、これから"></a>発表内容：Goでフラットパッケージを導入してみて良かったこと、これから</h1><iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTVNmDqauFzwlCeehGOrQK-l_CMQOZf2Hw1uFv12xDtXFPBF96k2M0XYOi4oRbh8UsQcfAf25HzV-UW/embed?start=false&loop=false&delayms=3000" frameborder="0" width="100%" height="550" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><p>フューチャー技術ブログで、<a href="/articles/20201109/">GoのWebアプリ開発でフラットパッケージにした話</a> という記事を公開した内容の改定版になります。なぜフラットパッケージに至ったかの経緯についてなるべく自分がたどった経路を細かに説明することを意識しました。</p><p>かなり挑戦的で大胆な設計だったとおもいますが、一定の賛同（？）をいただけて嬉しかったです。</p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">Repositoryパターンのメリット無くね？<br>モックにできる -&gt; 殆どの関心事がデータアクセスなんでそこモックにするのも...<br>データ層変更できる -&gt; やらねーよ<br><br>...分かる<br> <a href="https://twitter.com/hashtag/future_tech_night?src=hash&amp;ref_src=twsrc%5Etfw">#future_tech_night</a></p>&mdash; 脱脂綿/だっしー (@anchor_cable) <a href="https://twitter.com/anchor_cable/status/1372853753007640576?ref_src=twsrc%5Etfw">March 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">設計の理想論と現実論の塩梅の話で非常に良い<br> <a href="https://twitter.com/hashtag/future_tech_night?src=hash&amp;ref_src=twsrc%5Etfw">#future_tech_night</a></p>&mdash; 4月 (@karrybit) <a href="https://twitter.com/karrybit/status/1372854017550737411?ref_src=twsrc%5Etfw">March 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>発表資料でも記載の通り、何事もトレードオフがあると思いますが、フラットパッケージがハマる領域も少なからずあるかと思いますので、活用して頂けると嬉しいです。</p><h1 id="発表で話せなかったこと"><a href="#発表で話せなかったこと" class="headerlink" title="発表で話せなかったこと"></a>発表で話せなかったこと</h1><p>15分枠だと話せなかったことがいくつかあるので、補足しておきます。</p><ul><li>パッケージ構造がどうこうより、テストが大変です<ul><li>これは業務系システムの開発者だとけっこう同意してくれると思うのですが、カバレッジ・テスト密度やらをある程度指標に持って品質を見ていこうとすると、けっこうなテスト数、テストコード量になると思います<ul><li>スクロールをどれだけしても、Table Driven Tesingのテーブル宣言部分が終わらないとかザラです</li></ul></li><li>特に業務システム系だと、マスタデータの種類が多く、テストのデータパターンをかなり考える必要があります</li><li>モックでデータパターンを考えようが、実際のDBを使おうが正直大変さは同じですが、込み入ったデータを作るときは実際のDBを用いれたほうがいっそ楽だという視点もあるかなと思います</li></ul></li><li>大きくなると破綻しない？<ul><li>5~10人で1年以上開発を続けていますが、今のところは大丈夫です</li><li>正直複雑化するのはパッケージ構造ではなく、データパターンとか業務ロジックそのものなので、パッケージ構造だから破綻というのは現時点だと自分のチームだと想定しにくく、もし本当に巨大になるのであればリポジトリごと分けるので大丈夫かなと思います</li></ul></li><li>次にGoで新規開発するときもフラットパッケージにするか？<ul><li>規模感やドメインにもよりますが選択できるのであれば多分すると思います<ul><li>現実的には他の開発者の好みや考えもあると思うので、一つの意見として出すレベルかと思います</li></ul></li></ul></li><li>モデルにテストを寄せている話<ul><li>どうしても外部サービスに対して、テストケースや関数毎にデータ登録すると速度が遅くなります</li><li>handlerレベルのテストケースが肥大化しないために、なるべくmodelにロジックを寄せて、model単位でテストするようにしています<ul><li>modelは外界へのアクセスが基本的にないので、関数の引数・戻り値で検証可能。go-cmpで行っています</li></ul></li></ul></li></ul><h1 id="反省点"><a href="#反省点" class="headerlink" title="反省点"></a>反省点</h1><p>Zoomで開催していて質問をもらうスタイルでしたが、中にはTwitterでハッシュタグ付きでコメントしてくれた人もいました。私もよく行うスタイルですが完全に見逃していて、全部終わったあとに気が付きました。次回からはそちらも拾うようにします。</p><p>また、最後に座談会のような時間があったのですが、発表後の放心状態からうまく登壇者同士でワイワイ話すことができませんでした。今後は第三者のモデレータ？のような人を置くなどで改善したいと思います。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>聞き飽きた？感じもあるGoのパッケージですが、意外とフラットな構造でもいけるぞって発表でした。</p><p>フューチャーは2020年から社内の知見を発信して少しでも皆様のお役に建てるように、ブログだけではなく勉強会も積極的に開催していこうとしています。<a href="/articles/20210314/">こちら</a>の記事にあるように、年間の計画をたてています。ぜひウォッチしていただければです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210427a/building-5630441_640.jpg&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://pixabay.com/ja/users/rotekirsche20-18445331/?utm_source=link-att</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="登壇資料" scheme="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E8%B3%87%E6%96%99/"/>
    
    <category term="開催レポート" scheme="https://future-architect.github.io/tags/%E9%96%8B%E5%82%AC%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="TechNight" scheme="https://future-architect.github.io/tags/TechNight/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.16のembedとgo-swaggerを組み合わせてフルスタック自動生成フレームワークを作る</title>
    <link href="https://future-architect.github.io/articles/20210426b/"/>
    <id>https://future-architect.github.io/articles/20210426b/</id>
    <published>2021-04-25T15:00:01.000Z</published>
    <updated>2021-04-26T02:37:54.020Z</updated>
    
    <content type="html"><![CDATA[<p>TIGの伊藤真彦です。</p><p>渋川さんが投稿された</p><ul><li><a href="https://future-architect.github.io/articles/20210408/">Go 1.16のembedとchiとSingle Page Application</a></li><li><a href="https://future-architect.github.io/articles/20210409/">Go 1.16のgo:embedとNext.jsの相性が悪い問題と戦う</a><br>に近い研究記事です。</li></ul><h2 id="やりたいこと"><a href="#やりたいこと" class="headerlink" title="やりたいこと"></a>やりたいこと</h2><img src="/images/20210426b/go_vue_logo.png" class="img-middle-size"><p>私の最近の仕事はgo-swaggerによるバックエンドAPI開発です。本流はバックエンドですが、必要に応じてクラウドインフラを弄ったり、ちょっとしたフロントエンドアプリケーションを作ったりといった動き方で働いています。</p><p>ある時、go-swaggerで作ったバックエンドAPIの資産を使って、ちょっとした開発者向けアプリケーションを作りたくなりました。</p><p>ローカル環境でサーバーとフロントエンドアプリケーションを両方起動すると、サーバーが<code>localhost:3000</code> フロントエンドが<code>localhost:8080</code>を占拠してしまいます。また、フロントエンドとバックエンドのポートが異なることにより、フロントエンドからのリクエストを処理するためにはCORSの設定が必要になってしまいます。そして単純に2つのアプリケーションを起動するのが面倒だなと感じました。</p><p>そこで、go-swaggerが生成するものをハックして、フロントエンドの成果物と今まで作ってきたバックエンドAPIを同じポートで抱えつつ、APIを叩くクライアントサイドのコードもswagger.yamlから自動生成するようなアプリケーション開発に挑戦してみました。</p><h2 id="バックエンド開発"><a href="#バックエンド開発" class="headerlink" title="バックエンド開発"></a>バックエンド開発</h2><p>説明のために、まずはバックエンドの資産を作ります。</p><p>詳しい作り方、説明は<a href="https://future-architect.github.io/articles/20200824/">go-swaggerでhello world</a>をお読みください。</p><p>今回はこのようなディレクトリ構成でアプリケーションを作ります。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swagger.yaml</span><br><span class="line">server</span><br><span class="line">  ├─gen</span><br><span class="line">　└─get_greeting_handler.go</span><br></pre></td></tr></table></figure><figure class="highlight yml"><figcaption><span>swagger.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">swagger:</span> <span class="string">&#x27;2.0&#x27;</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Greeting</span> <span class="string">Server</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/hello:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">produces:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">text/plain</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">name</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">defaults</span> <span class="string">to</span> <span class="string">World</span> <span class="string">if</span> <span class="string">not</span> <span class="string">given</span></span><br><span class="line">      <span class="attr">operationId:</span> <span class="string">getGreeting</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">200:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">returns</span> <span class="string">a</span> <span class="string">greeting</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">              <span class="attr">description:</span> <span class="string">contains</span> <span class="string">the</span> <span class="string">actual</span> <span class="string">greeting</span> <span class="string">as</span> <span class="string">plain</span> <span class="string">text</span></span><br></pre></td></tr></table></figure><p><a href="https://future-architect.github.io/articles/20200824/">上記記事</a>と同じswagger.yamlを用意して、serverパッケージを生成します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger generate server -a factory -A factory -t server/gen -f ./ swagger.yaml</span><br></pre></td></tr></table></figure><p>get_greeting_handler.goはログ出力だけ少し追加しました。</p><figure class="highlight go"><figcaption><span>get_greeting_handler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGreeting</span><span class="params">(p factory.GetGreetingParams)</span> <span class="title">middleware</span>.<span class="title">Responder</span></span> &#123;</span><br><span class="line">payload := <span class="string">&quot;hello go&quot;</span></span><br><span class="line"><span class="keyword">if</span> p.Name != <span class="literal">nil</span> &#123;</span><br><span class="line">payload = *p.Name</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;GetGreeting is called, return %s\n&quot;</span>, payload)</span><br><span class="line"><span class="keyword">return</span> factory.NewGetGreetingOK().WithPayload(payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>localhost:3000/hello</code>でapiが動くことを確認します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> server</span><br><span class="line">go run .\gen\<span class="built_in">cmd</span>\factory-server\main.go --host <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> --port <span class="number">3000</span></span><br></pre></td></tr></table></figure><img src="/images/20210426b/image.png" style="border:solid 1px #000000"><h2 id="フロンエンド開発"><a href="#フロンエンド開発" class="headerlink" title="フロンエンド開発"></a>フロンエンド開発</h2><p>バックエンドの用意ができたら、上記のAPIを叩くためのサンプルアプリケーションを作ります。<br>まずはVue.jsでのHello Worldアプリケーションを生成します。<br>こちらも過去記事<a href="https://future-architect.github.io/articles/20210107/">Electronの使い方 Web開発の技術でデスクトップアプリを作ろう</a>で詳しく説明しています。</p><p>フロントエンドアプリケーションを下記の構成で生成します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swagger.yaml</span><br><span class="line">app</span><br><span class="line">  └─frontend</span><br><span class="line">server</span><br><span class="line">  ├─gen</span><br><span class="line">　└─get_greeting_handler.go</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">mkdir app</span><br><span class="line"><span class="built_in">cd</span> app</span><br><span class="line">vue create frontend</span><br></pre></td></tr></table></figure><p>アプリケーションを起動し、<code>localhost://8080</code>でフロントエンドアプリケーションが起動することを確認します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><img src="/images/20210426b/image_2.png" style="border:solid 1px #000000"><h2 id="フロントエンドにAPI-Clientを実装する"><a href="#フロントエンドにAPI-Clientを実装する" class="headerlink" title="フロントエンドにAPI Clientを実装する"></a>フロントエンドにAPI Clientを実装する</h2><p>作成したフロントエンドアプリケーション向けに、TypeScriptのAPIクライアントを自動生成します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> app</span><br><span class="line">npx -p @openapitools/openapi-generator-cli@cli-4.1.3 openapi-generator generate -g typescript-axios -i ../../swagger.yaml -o ./frontend/src/client-axios -p modelPropertyNaming=snake_case --enable-post-process-file</span><br></pre></td></tr></table></figure><p><code>/frontend/src/client-axios</code>ディレクトリにコードが生成されます。<br><code>.eslintignore</code>に追加するなど、linterの設定を適宜追加してエラーが起きないようにすることを推奨します。</p><p>生成したコードを利用するように<code>app\frontend\src\App.vue</code>を更新します。</p><figure class="highlight html"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Component, Vue &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; DefaultApi &#125; <span class="keyword">from</span> <span class="string">&#x27;./client-axios&#x27;</span></span></span><br><span class="line"></span><br><span class="line">@Component(&#123;&#125;)</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  message = <span class="string">&quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  mounted():<span class="keyword">void</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> api = <span class="keyword">new</span> DefaultApi().getGreeting(<span class="string">&quot;hello Vue + Go + OpenAPI&quot;</span>);</span></span><br><span class="line"><span class="javascript">    api.then(<span class="function">(<span class="params">resp: any</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.message = resp.data;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#2c3e50</span>;</span></span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>app\frontend\src\client-axios\base.ts</code>でAPIの接続先を設定できるので、任意のポート、パスに書き換えます。</p><p><img src="/images/20210426b/image_3.png"></p><p>このまま<code>npm run serve</code>でアプリケーションを起動すると、存在しないAPIにアクセスし、通信に失敗する状態になります。</p><img src="/images/20210426b/image_4.png" style="border:solid 1px #000000"><p><img src="/images/20210426b/image_5.png"></p><p>この状態のアプリケーションを、バックエンドAPIと繋ぎこみます。</p><h2 id="フロントエンドとバックエンドAPIを統合する"><a href="#フロントエンドとバックエンドAPIを統合する" class="headerlink" title="フロントエンドとバックエンドAPIを統合する"></a>フロントエンドとバックエンドAPIを統合する</h2><p>まずは作成したフロントエンドアプリケーションをビルドし、アセットファイルを準備します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> app/frontend</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><code>app\frontend\dist</code>ディレクトリに成果物一式が生成されます。</p><p>生成したファイルを<code>go:embed</code>で埋め込み起動するような<code>main.go</code>を下記の構成で作成します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swagger.yaml</span><br><span class="line">app</span><br><span class="line">  ├─frontend</span><br><span class="line">  └─main.go</span><br><span class="line">server</span><br><span class="line">  ├─gen</span><br><span class="line">　└─get_greeting_handler.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;embed&quot;</span></span><br><span class="line"><span class="string">&quot;io/fs&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-openapi/loads&quot;</span></span><br><span class="line">flags <span class="string">&quot;github.com/jessevdk/go-flags&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line"><span class="string">&quot;server/gen/restapi&quot;</span></span><br><span class="line"><span class="string">&quot;server/gen/restapi/factory&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyRegexp = regexp.MustCompile(<span class="string">`^/api`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed frontend/dist/*</span></span><br><span class="line"><span class="keyword">var</span> static embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api := factory.NewFactoryAPI(swaggerSpec)</span><br><span class="line">server := restapi.NewServer(api)</span><br><span class="line"><span class="keyword">defer</span> server.Shutdown()</span><br><span class="line"></span><br><span class="line">parser := flags.NewParser(server, flags.Default)</span><br><span class="line">parser.ShortDescription = <span class="string">&quot;Greeting Server&quot;</span></span><br><span class="line">parser.LongDescription = swaggerSpec.Spec().Info.Description</span><br><span class="line">server.ConfigureFlags()</span><br><span class="line"><span class="keyword">for</span> _, optsGroup := <span class="keyword">range</span> api.CommandLineOptionsGroups &#123;</span><br><span class="line">_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := parser.Parse(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">code := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> fe, ok := err.(*flags.Error); ok &#123;</span><br><span class="line"><span class="keyword">if</span> fe.Type == flags.ErrHelp &#123;</span><br><span class="line">code = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve swagger api server.</span></span><br><span class="line">server.ConfigureAPI()</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// remove &quot;/api&quot; fron api path for swagger api</span></span><br><span class="line">r.URL.Path = proxyRegexp.ReplaceAllString(r.URL.Path, <span class="string">&quot;&quot;</span>)</span><br><span class="line">server.GetHandler().ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve frontend HTML.</span></span><br><span class="line">public, err := fs.Sub(static, <span class="string">&quot;frontend/dist&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.FS(public)))</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;listening on localhost:3000...&quot;</span>)</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> if you want to use another port, you also have to modify app\frontend\src\client-axios\base.ts</span></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>※そのまま使用すると<code>server</code>パッケージのimportに失敗します、ご自身の環境での適切なパスに指定するか、<code>go.mod</code>でreplaceしてください”<br>このファイルは、自動生成された<code>server\gen\cmd\factory-server\main.go</code>をベースに拡張したファイルです。</p><p>生成したフロントエンドのコードを<code>go:embed</code>で埋め込みます。<br>詳しくは<a href="https://future-architect.github.io/articles/20210208/">Go 1.16からリリースされたgo:embedとは</a>をお読みください。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:embed frontend/dist/*</span></span><br><span class="line"><span class="keyword">var</span> static embed.FS</span><br></pre></td></tr></table></figure><p>埋め込んだファイルを利用できるようにHTTPハンドラを設定します。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serve frontend HTML.</span></span><br><span class="line">public, err := fs.Sub(static, <span class="string">&quot;frontend/dist&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.FS(public))</span><br></pre></td></tr></table></figure><p>一方、go-swaggerで生成したバックエンドAPIのロジックは<code>api/hello</code>のパスでアクセスできるように退避させつつ読み込みます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serve swagger api server.</span></span><br><span class="line">server.ConfigureAPI()</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// remove &quot;/api&quot; fron api path for swagger api</span></span><br><span class="line">r.URL.Path = proxyRegexp.ReplaceAllString(r.URL.Path, <span class="string">&quot;&quot;</span>)</span><br><span class="line">server.GetHandler().ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>本来であれば<code>server.Serve()</code>でポート番号の指定などを解釈しつつ、バックエンドAPIが起動するところを、上記の方法でうまく利用することができました。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxyRegexp = regexp.MustCompile(<span class="string">`^/api`</span>)</span><br></pre></td></tr></table></figure><p>パスに<code>api/</code>の文字列が存在するとバックエンドAPIが元々期待しているパスパターンと一致しないため、正規表現を用いて除外しています。<br>余談ですが正規表現の<code>MustCompile</code>は関数内で行うと、呼び出されるたびに毎回コンパイルが走るため、グローバル変数に持たせる事が推奨されています。</p><h2 id="アプリケーションの起動"><a href="#アプリケーションの起動" class="headerlink" title="アプリケーションの起動"></a>アプリケーションの起動</h2><p>これでアプリケーションが完成しました。<br>完成したアプリケーションを起動してみます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> app</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><img src="/images/20210426b/image_6.png" style="border:solid 1px #000000"><p>無事にアプリケーションが起動し、バックエンドAPIからのレスポンスを表示することができました。</p><p><img src="/images/20210426b/image_7.png"></p><p>ブラウザのデバックコンソールでバックエンドAPIとの疎通に成功している事が確認できます。<br>あとは出来上がったファイルを<code>go build</code>すれば単一バイナリで動くフルスタックWebアプリケーションの完成です。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul><li>go-swaggerで生成したバックエンドサーバーと、任意のフロントエンドWebアプリケーションを同じポートで起動することは可能。</li><li>クライアントサイドからバックエンドに繋ぐためのAPIクライアントも自動生成できる。</li><li><code>go:embed</code>を利用することで、単一バイナリとしてビルドすることが可能。</li></ul><p>大規模アプリケーションをこの構成で作成するには若干邪道な雰囲気を感じますが、手早くアプリケーションを開発したいGopherのみなさんにおススメの手法でした。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;渋川さんが投稿された&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://future-architect.github.io/articles/20210408/&quot;&gt;Go 1.16のembedとchiとSingle Page </summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="Frontend" scheme="https://future-architect.github.io/tags/Frontend/"/>
    
    <category term="Vue.js" scheme="https://future-architect.github.io/tags/Vue-js/"/>
    
    <category term="Go1.16" scheme="https://future-architect.github.io/tags/Go1-16/"/>
    
  </entry>
  
  <entry>
    <title>AWS CLIで用いるMFAをちょっとだけ便利に扱えるツールを公開しました</title>
    <link href="https://future-architect.github.io/articles/20210426a/"/>
    <id>https://future-architect.github.io/articles/20210426a/</id>
    <published>2021-04-25T15:00:00.000Z</published>
    <updated>2021-04-26T02:22:38.463Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210426a/access-3579221_640.jpg" class="img-middle-size"><blockquote><p><a href="https://pixabay.com/ja/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3579221">mohamed Hassan</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3579221">Pixabay</a>からの画像</p></blockquote><p>こんにちは、辻です。</p><p>AWSのIAMユーザのセキュリティ上、IAMユーザにMFA(他要素認証)を導入するケースがあります。MFAを有効にしているIAMユーザでGUI経由でログインする場合は、ログイン時に認証情報が求められて、MFAデバイスが出力するトークンを入力することでログインできます。一方AWS CLIを用いてリソースにアクセス場合はコマンド発行時に認証情報は求められません。代わりに以下のような記事にかかれているような、一時的な認証情報を発行することがよく行われます。</p><ul><li><a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/authenticate-mfa-cli/">MFA トークンを使用して、AWS CLI 経由で AWS リソースへのアクセスを認証する方法を教えてください。</a></li></ul><p><code>get-session-token</code> コマンドを発行することで一時的な認証情報を発行する、ということです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws sts get-session-token --serial-number arn-of-the-mfa-device --token-code code-from-token --profile my-login-profile</span><br></pre></td></tr></table></figure><p>コマンドが成功すると、以下のようなJSONがレスポンスとして返ってきます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Credentials&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;SecretAccessKey&quot;</span>: <span class="string">&quot;secret-access-key&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;SessionToken&quot;</span>: <span class="string">&quot;temporary-session-token&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Expiration&quot;</span>: <span class="string">&quot;expiration-date-time&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;AccessKeyId&quot;</span>: <span class="string">&quot;access-key-id&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返ってきたレスポンス <code>SecretAccessKey</code>, <code>SessionToken</code> を <code>~/.aws/credentials</code> に記述したり、あるいは環境変数を更新する必要があります。</p><p>上記のJSONの値を <code>~/.aws/credentials</code> に記述することでリソースにアクセスできるようになったものの、<code>get-session-token</code> コマンドを発行した認証情報は最大で129600秒(=36時間)です。一時的な認証情報という意味では妥当ですが、AWS CLIは頻繁に利用するため、ほぼ毎日 <code>get-session-token</code> コマンドで出力したJSONの値を <code>~/.aws/credentials</code> に貼り付ける作業が発生するようになりました。これはちょっと面倒です。</p><p>そこで <a href="https://github.com/future-architect/awsmfa">future-architect/awsmfa</a> というAWS CLIでMFAを扱うときにちょっとだけ便利にMFAを扱うコマンドラインツールを作りました。</p><h2 id="future-architect-awsmfa"><a href="#future-architect-awsmfa" class="headerlink" title="future-architect/awsmfa"></a><code>future-architect/awsmfa</code></h2><p><a href="https://github.com/future-architect/awsmfa"><img src="https://gh-card.dev/repos/future-architect/awsmfa.svg" alt="future-architect/awsmfa - GitHub"></a></p><h3 id="何ができるのか"><a href="#何ができるのか" class="headerlink" title="何ができるのか"></a>何ができるのか</h3><ul><li>AWSの <code>config</code> ファイルや <code>credential</code> ファイルにMFA用の名前付きプロファイルを生成</li><li>MFAに使用する値を、コマンド実行時に自動で更新</li></ul><h3 id="使い方"><a href="#使い方" class="headerlink" title="使い方"></a>使い方</h3><p><code>sts get-session-token</code> と同じ要領で <code>awsmfa</code> コマンドを実行するだけです。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awsmfa --serial-number arn:aws:iam::123456789012:mfa/my-login-role --profile my-login-profile code-from-token</span><br></pre></td></tr></table></figure><p>MFAの認証情報を扱うプロファイル名はデフォルトで <code>mfa</code> としています。(別のプロファイル名で保存したい場合はオプションに <code>--mfa-profile-name</code> を指定します。)上記の <code>awsfma ...</code> コマンドを実行すると以下のように <code>mfa</code> のプロファイル名が追加されます。2回目以降は <code>~/.aws/credentials</code> の <code>mfa</code> プロファイル名の値を更新するようになっています。</p><ul><li><code>~/.aws/config</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">region</span> = us-east-<span class="number">1</span></span><br><span class="line"><span class="attr">output</span> = json</span><br><span class="line"></span><br><span class="line">[profile mfa] &lt;- このプロファイル名が追加されます</span><br></pre></td></tr></table></figure><ul><li><code>~/.aws/credentials</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">aws_access_key_id</span>     = ABCDEFGHIJKLMNOPQRST</span><br><span class="line"><span class="attr">aws_secret_access_key</span> = ChEXAMPLEraRNW5iy8XgDyR4QNRT44kKRPmKEGQT</span><br><span class="line"></span><br><span class="line">[mfa] &lt;- このプロファイル名が追加されます。2回目以降は自動でこのプロファイルの中身を更新します</span><br><span class="line"><span class="attr">aws_access_key_id</span>     = AKIAIOSFODNN7EXAMPLE</span><br><span class="line"><span class="attr">aws_secret_access_key</span> = wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY</span><br><span class="line"><span class="attr">aws_session_token</span>     = AQoEXAMPLEH4aoAH0gNCAPyJxz4BlCFFxWNE1OPTgk5TthT+FvwqnKwRcOIfrRh3c/LTo6UDdyJwOOvEVPvLXCrrrUtdnniCEXAMPLE/IvU1dYUg2RVAJBanLiHb4IgRmpRV3zrkuWJOgQs8IZZaIv2BXIa2R4OlgkBN9bkUDNCJiBeb/AXlzBBko7b15fjrBs2+cTQtpZ3CYWFXG8C5zqx37wnOE49mRl/+OtkIKGO7fAE</span><br></pre></td></tr></table></figure><h3 id="インストール"><a href="#インストール" class="headerlink" title="インストール"></a>インストール</h3><p>Linuxの場合はシェルスクリプト一発でローカル環境にインストールできます。このコマンドラインツールはGoで書かれており、マルチプラットフォーム向けにシングルバイナリを簡単に提供できます。インストールが簡単に行えるのはとても良いですね。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sfL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;future-architect&#x2F;awsmfa&#x2F;master&#x2F;install.sh | sudo sh -s -- -b &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p>Windowsの場合は <a href="https://github.com/future-architect/awsmfa/releases">Releases</a> から最新のバイナリを取得して、パスが通っているディレクトリにバイナリを配備してください。</p><h3 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h3><p>AWS CLIで用いるMFAの運用をちょっとだけ楽にするツールを作りました。</p><p>やろうと思えばシェル芸でもできそうですし、<code>99designs/aws-vault</code> や <code>broamski/aws-mfa</code> などのよりリッチなOSSもあります。今回は自分たちのユースケースのために作ったツールを公開しました。</p><p>さっそくプルリクエストもいただきました。社外の方からも使っていただき嬉しく思います。</p><p><a href="https://github.com/future-architect/awsmfa/pull/9">https://github.com/future-architect/awsmfa/pull/9</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210426a/access-3579221_640.jpg&quot; class=&quot;img-middle-size&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pixabay.com/ja/users/mohamed_</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="AWS" scheme="https://future-architect.github.io/tags/AWS/"/>
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="Go" scheme="https://future-architect.github.io/tags/Go/"/>
    
    <category term="OSS推進タスクフォース" scheme="https://future-architect.github.io/tags/OSS%E6%8E%A8%E9%80%B2%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%95%E3%82%A9%E3%83%BC%E3%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>実世界データの特徴と処理方法</title>
    <link href="https://future-architect.github.io/articles/20210423b/"/>
    <id>https://future-architect.github.io/articles/20210423b/</id>
    <published>2021-04-22T15:00:01.000Z</published>
    <updated>2021-04-23T02:24:48.050Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。TIG DXユニットの村上です。</p><p>私は大学時代から深層強化学習の研究をしていますが、分野的にほとんど実世界のデータを扱うことがありませんでした。そんな私ですが、実務で実世界データの分析を行う機会があり、その違いに多くの学びがありました。</p><p>実世界データのデータ分析を行った結果見えてきた、実世界データの特徴と欠損値や不正データの処理について解説しようと思います。</p><p>簡易的ですがソースコードも示していますので、参考になれば幸いです。</p><h1 id="実世界データとは"><a href="#実世界データとは" class="headerlink" title="実世界データとは"></a>実世界データとは</h1><img src="/images/20210423b/search-4083722_640.jpg" class="img-middle-size"><blockquote><p><a href="https://pixabay.com/ja/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4083722">mohamed Hassan</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4083722">Pixabay</a>からの画像</p></blockquote><p>内容に入る前に、本記事での実世界データの定義を行っておきます。ここでは以下2点を満たすものを実世界データと呼ぶことにします。</p><ul><li>もともとはアナログデータである</li><li>データ品質を高める処理が行われていない生のデータ</li></ul><p>例えば身近なものだと、温度計や湿度計から取得されたデータは実世界データとなります。これらに欠損値補完<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>などのデータ品質を高める処理を施した後は実世界データと呼ばないことにします。</p><p>また、機械学習用のデータセットや、システムのモニタリングデータなどは実世界データではありません。</p><h1 id="実世界データの品質"><a href="#実世界データの品質" class="headerlink" title="実世界データの品質"></a>実世界データの品質</h1><p>実世界データのデータ品質は基本的に<code>悪い</code>です。欠損値が含まれていたり、不正なデータが存在するのが当たり前です。主な理由は物理的、人間の意志的な影響を受けるからです。これらの作用により、主に以下2ケースのデータ品質悪化が起こります。</p><ol><li><a href="#%E2%91%A0%E6%AC%A0%E6%90%8D%E5%80%A4%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%99%E3%82%8B">欠損値が発生する</a></li><li><a href="#%E2%91%A1%E4%B8%8D%E6%AD%A3%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%B7%B7%E5%85%A5%E3%81%99%E3%82%8B">不正なデータが混入する</a></li></ol><p>これらの発生原因と対処法について解説します。</p><h2 id="①欠損値が発生する"><a href="#①欠損値が発生する" class="headerlink" title="①欠損値が発生する"></a>①欠損値が発生する</h2><p>例えば、データの発生源であるIoTデバイスが屋外に設置されている場合、気象の影響を受けます。台風の時に固いものが飛んできてIoTデバイスに直撃、データを送信できなくなるなんてことも有り得ます。また、単純に電波不良などでデータがサーバに到達しなかったという状況も十分あり得ます。</p><p>このように挙げたらきりがありませんが、実世界ではデータがが発生したにも関わらずそれが取得できないことがよくあります。</p><h2 id="欠損値処理"><a href="#欠損値処理" class="headerlink" title="欠損値処理"></a>欠損値処理</h2><p>欠損値の処理に関しては、そのデータを使ってどのような分析を行うかで適切な処理の仕方が変わってきます。ここでは様々な処理方法とそのユースケースを解説します。</p><h3 id="欠損値を削除する"><a href="#欠損値を削除する" class="headerlink" title="欠損値を削除する"></a>欠損値を削除する</h3><p>欠損値が無視できるものであれば、削除してしまうのが手っ取り早いです。ではどのような時に無視しても良いのかですが、以下のケースがそれにあたります。</p><ol><li>後続のデータ分析で利用しない</li><li>データ数が減っても問題ない</li></ol><p>1番は分りやすいと思いますが、2番は要注意です。極端な例ではありますが、以下のような天気と気温のデータがあるとします。</p><p>見ての通り、データの発生源である温度計は雨が降ると高確率でデータを取得できない残念な仕様になっていたとします。</p><table><thead><tr><th align="center">データ</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center"><strong>天気</strong></td><td align="center">晴れ</td><td align="center">晴れ</td><td align="center">晴れ</td><td align="center">雨</td><td align="center">雨</td><td align="center">雨</td><td align="center">曇り</td><td align="center">曇り</td><td align="center">曇り</td></tr><tr><td align="center"><strong>気温</strong></td><td align="center">25℃</td><td align="center">24℃</td><td align="center">26℃</td><td align="center"></td><td align="center"></td><td align="center">18℃</td><td align="center">18℃</td><td align="center">20℃</td><td align="center">19℃</td></tr></tbody></table><p>このような温度計から得られたデータに対して欠損値削除を行い、気温から天気を予測するモデルを構築するとしたらどうなるでしょうか？おそらくそのモデルの予測結果は晴れか曇りのみになります。雨のデータがほとんど存在しないので、とりあえず晴れか曇りと予測しておけば正答率は高くなるということです。このように、データ数が減ること自体が問題になるケースが存在します。</p><p>以上を踏まえて、欠損値を削除しても問題ない場合はpandasを用いて簡単に削除することができます。<br>例として、以下のデータに対して欠損値削除を行います。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">         name gender  profession</span><br><span class="line"><span class="number">0</span>  Goodfellow    man         NaN</span><br><span class="line"><span class="number">1</span>        Mnih    man  researcher</span><br><span class="line"><span class="number">2</span>      Graves    NaN  researcher</span><br><span class="line"><span class="number">3</span>         NaN    NaN         NaN</span><br></pre></td></tr></table></figure><ul><li>全ての項目が欠損値の場合にその行を削除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">         name gender  profession</span><br><span class="line"><span class="number">0</span>  Goodfellow    man         NaN</span><br><span class="line"><span class="number">1</span>        Mnih    man  researcher</span><br><span class="line"><span class="number">2</span>      Graves    NaN  researcher</span><br></pre></td></tr></table></figure><ul><li>1つでも欠損値があればその行を削除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dropna(how=<span class="string">&#x27;any&#x27;</span>)</span><br><span class="line">   name gender  profession</span><br><span class="line"><span class="number">1</span>  Mnih    man  researcher</span><br></pre></td></tr></table></figure><h3 id="特定の値で補完する"><a href="#特定の値で補完する" class="headerlink" title="特定の値で補完する"></a>特定の値で補完する</h3><p>欠損値が削除できない場合、何らかの値で補完します。どのような値で補完するかはそのデータに対してどのような分析を行うかに依存するため、目的をよく考えて補完する値を選ぶ必要があります。補完する値の候補と主なユースケースは以下です。</p><ul><li>固定値：その項目に表れる値があらかじめ決まっている場合</li><li>平均値：その項目の値の分散が小さい場合</li><li>中央値：その項目の値の分散が大きい場合</li></ul><p>例えば平均値による補完を行う場合は次のようになります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">    age</span><br><span class="line"><span class="number">0</span>  <span class="number">20.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">21.0</span></span><br><span class="line"><span class="number">2</span>   NaN</span><br><span class="line"><span class="number">3</span>  <span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.fillna(b.mean())</span><br><span class="line">    age</span><br><span class="line"><span class="number">0</span>  <span class="number">20.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">21.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">21.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">22.0</span></span><br></pre></td></tr></table></figure><h3 id="一定のアルゴリズムに従って補完する"><a href="#一定のアルゴリズムに従って補完する" class="headerlink" title="一定のアルゴリズムに従って補完する"></a>一定のアルゴリズムに従って補完する</h3><p>欠損値が一定のアルゴリズムに従って推定できる場合、以下の補完方法が有効です。</p><ul><li>線形補完：前後のデータ間の中間の値で補完</li><li>スプライン補完：スプライン曲線を用いて値を推定</li></ul><p>例えば線形補完をする場合は以下のようになります。今回は分りやすいようにmethodを明示的に指定していますが、デフォルトで<code>linear</code>なので、線形補完する場合はmethodの指定は省略可能です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">    age</span><br><span class="line"><span class="number">0</span>  <span class="number">20.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">21.0</span></span><br><span class="line"><span class="number">2</span>   NaN</span><br><span class="line"><span class="number">3</span>  <span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.interpolate(method=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">    age</span><br><span class="line"><span class="number">0</span>  <span class="number">20.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">21.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">21.5</span></span><br><span class="line"><span class="number">3</span>  <span class="number">22.0</span></span><br></pre></td></tr></table></figure><p>これら以外にも様々な補完アルゴリズムが存在します。いずれもpandasで簡単に行うことができるので、<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html">公式ドキュメント</a>を参考にしてみてください。</p><h2 id="②不正なデータが混入する"><a href="#②不正なデータが混入する" class="headerlink" title="②不正なデータが混入する"></a>②不正なデータが混入する</h2><p>このケースはデータの生成過程で人間による入力が存在する場合、容易に発生し得るものです。また、データの生成過程に人間が介入しないとしても、何らかの事情でデータを手動で作成して差し込む場合もあります。</p><p>このケースの厄介な点は、それが正しいデータなのか、不正なデータなのかの判断が難しいことです。理論上有り得ないデータであればバリデーションチェックを行うことで正確に判断できるのですが、そうでない場合は不正なデータであることに気づくことが困難です。仮に怪しいデータを発見したとしても、それが不正なデータである裏付けを取るためには、そのデータの生成過程を精査する必要があり、多くの手間がかかります。</p><h3 id="不正データの検出方法"><a href="#不正データの検出方法" class="headerlink" title="不正データの検出方法"></a>不正データの検出方法</h3><p>次に不正なデータの検出方法を説明します。以下のフローチャートに従ってデータをチェックするのが効率的です。</p><p><img src="/images/20210423b/flow_chart.png"></p><p>①番、②番について詳しく見ていきます。</p><h4 id="①理論上有り得るデータかチェック（バリデーションチェック）"><a href="#①理論上有り得るデータかチェック（バリデーションチェック）" class="headerlink" title="①理論上有り得るデータかチェック（バリデーションチェック）"></a>①理論上有り得るデータかチェック（バリデーションチェック）</h4><p>この段階では確実に不正であるデータを検出します。そのために、まずは正しいデータとはどのようなデータかをしっかりと定義する必要があります。この定義に間違いがあると、本当は正しいデータでも不正なデータとして検出されてしまう可能性があります。さらに、そのデータの発生源に対して何らかのシステム的、人間の意思決定的な側面から変更が加わる場合、同時に正しいデータの定義にも変更が必要な可能性があります。</p><p>従って、正しいデータの定義は一度決めたらそれで終了ではなく、適時変更が入ることを前提とするのがベターです。</p><p>次にバリデーションチェックのやり方ですが、これはpandera<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>というpandasの拡張ライブラリを使うのがおすすめです。以下のように正しいデータの値域などを定義し、定義を満たさないものを検出することができます。</p><p>以下は<a href="https://pandera.readthedocs.io/en/stable/">pandera公式ドキュメント</a>からの引用です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pandera <span class="keyword">import</span> Column, DataFrameSchema, Int, Check</span><br><span class="line"></span><br><span class="line">simple_schema = DataFrameSchema(&#123;</span><br><span class="line">    <span class="string">&quot;column1&quot;</span>: Column(</span><br><span class="line">        Int, Check(<span class="keyword">lambda</span> x: <span class="number">0</span> &lt;= x &lt;= <span class="number">10</span>, element_wise=<span class="literal">True</span>,  <span class="comment"># ここで正しいデータを定義</span></span><br><span class="line">                   error=<span class="string">&quot;range checker [0, 10]&quot;</span>))  <span class="comment"># 弾かれた際のメッセージも定義できる</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># データをDataFrameに入力</span></span><br><span class="line">fail_check_df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&quot;column1&quot;</span>: [-<span class="number">20</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">30</span>],  <span class="comment"># 0 &lt;= x &lt;= 10 が正しいデータなので、-20と30は不正データ</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">simple_schema(fail_check_df)  <span class="comment"># バリデーションチェックを実行</span></span><br></pre></td></tr></table></figure><p>バリデーションチェックの実行結果は次のようになります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">SchemaError: &lt;Schema Column: <span class="string">&#x27;column1&#x27;</span> <span class="built_in">type</span>=<span class="built_in">int</span>&gt; failed element-wise validator <span class="number">0</span>:</span><br><span class="line">&lt;Check &lt;<span class="keyword">lambda</span>&gt;: <span class="built_in">range</span> checker [<span class="number">0</span>, <span class="number">10</span>]&gt;</span><br><span class="line">failure cases:</span><br><span class="line">   index  failure_case</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>           -<span class="number">20</span></span><br><span class="line"><span class="number">1</span>      <span class="number">3</span>            <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="②データの分布から逸脱していないかチェック"><a href="#②データの分布から逸脱していないかチェック" class="headerlink" title="②データの分布から逸脱していないかチェック"></a>②データの分布から逸脱していないかチェック</h4><p>①番で弾かれなかったデータは必ず正しいデータという訳ではありません。理論上有り得るデータだが、入力ミスなどで真のデータと少し異なってしまうケースもあります。</p><p>このような、バリデーションチェックで検出できなかったデータから不正データを見つけるのはものによりますが、一般的には難しいと思います。ここではデータの分布という観点から、不正データの検出手法を解説します。</p><h5 id="データをソートして検出"><a href="#データをソートして検出" class="headerlink" title="データをソートして検出"></a>データをソートして検出</h5><p>一番簡単な方法として、データを昇順や降順に並べ替えて、明らかに他のデータの値から逸脱しているものを検出するというものがあります。エクセルでも簡単に行うことができるため、まずはこの方法から入ると良いかもしれません。</p><p>この手法はお手軽に行うことができる一方で、統計学的妥当性はありません。本質的には人間の感覚による判断になっているため、注意が必要です。</p><h5 id="正規分布による外れ値検出"><a href="#正規分布による外れ値検出" class="headerlink" title="正規分布による外れ値検出"></a>正規分布による外れ値検出</h5><p>データが正規分布<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>に従う場合、この手法が有効です。正規分布では <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.489ex" xmlns="http://www.w3.org/2000/svg" width="6.553ex" height="1.995ex" role="img" focusable="false" viewBox="0 -666 2896.4 882" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path><path id="MJX-4-TEX-N-B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"></path><path id="MJX-4-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-4-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-4-TEX-I-1D707"></use></g><g data-mml-node="mo" transform="translate(825.2, 0)"><use xlink:href="#MJX-4-TEX-N-B1"></use></g><g data-mml-node="mn" transform="translate(1825.4, 0)"><use xlink:href="#MJX-4-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(2325.4, 0)"><use xlink:href="#MJX-4-TEX-I-1D70E"></use></g></g></g></svg></mjx-container> 以内にデータの約95%、 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.489ex" xmlns="http://www.w3.org/2000/svg" width="6.553ex" height="1.995ex" role="img" focusable="false" viewBox="0 -666 2896.4 882" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path><path id="MJX-3-TEX-N-B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"></path><path id="MJX-3-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-3-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D707"></use></g><g data-mml-node="mo" transform="translate(825.2, 0)"><use xlink:href="#MJX-3-TEX-N-B1"></use></g><g data-mml-node="mn" transform="translate(1825.4, 0)"><use xlink:href="#MJX-3-TEX-N-33"></use></g><g data-mml-node="mi" transform="translate(2325.4, 0)"><use xlink:href="#MJX-3-TEX-I-1D70E"></use></g></g></g></svg></mjx-container> 以内に約99.7%が含まれることが知られています。※ <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.489ex" xmlns="http://www.w3.org/2000/svg" width="1.364ex" height="1.489ex" role="img" focusable="false" viewBox="0 -442 603 658" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D707"></use></g></g></g></svg></mjx-container> は平均、 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D70E"></use></g></g></g></svg></mjx-container> は標準偏差</p><p><img src="/images/20210423b/image.png"></p><p>引用：<a href="https://ai-trend.jp/basic-study/normal-distribution/normal-distribution/">https://ai-trend.jp/basic-study/normal-distribution/normal-distribution/</a></p><p>従って、これらを逸脱したデータを不正データの可能性有りとみなすのは、一定の統計学的妥当性があります。</p><p>実装例として、<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.423ex" height="1.532ex" role="img" focusable="false" viewBox="0 -666 1071 677" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><use xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(500, 0)"><use xlink:href="#MJX-1-TEX-I-1D70E"></use></g></g></g></svg></mjx-container>を越えたものが検出される様子を以下に示します。10番目の<code>10000</code>のデータが外れ値（不正データ）の想定です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">    price</span><br><span class="line"><span class="number">0</span>     <span class="number">100</span></span><br><span class="line"><span class="number">1</span>     <span class="number">200</span></span><br><span class="line"><span class="number">2</span>     <span class="number">100</span></span><br><span class="line"><span class="number">3</span>      <span class="number">50</span></span><br><span class="line"><span class="number">4</span>     <span class="number">120</span></span><br><span class="line"><span class="number">5</span>     <span class="number">200</span></span><br><span class="line"><span class="number">6</span>     <span class="number">150</span></span><br><span class="line"><span class="number">7</span>     <span class="number">100</span></span><br><span class="line"><span class="number">8</span>      <span class="number">80</span></span><br><span class="line"><span class="number">9</span>      <span class="number">20</span></span><br><span class="line"><span class="number">10</span>  <span class="number">10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean = df.mean()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>std = df.std()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;price&#x27;</span>] &gt; (mean + <span class="number">2</span> * std).values[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">7</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">8</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">9</span>     <span class="literal">False</span></span><br><span class="line"><span class="number">10</span>     <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>10番目のデータがTrueになり、外れ値（不正データ）が検出できています。</p><h3 id="不正データの再発防止"><a href="#不正データの再発防止" class="headerlink" title="不正データの再発防止"></a>不正データの再発防止</h3><p>不正データを検出し、それらに対して削除などの対応を行った場合、それで終わりではまた再発する可能性があります。</p><p>例えば、不正データの発生原因が人間の介入によるものであった場合、人間が介入する割合を最小限に抑えるようシステム化を進める、人間が介入した際はそのデータのチェックを2人以上で行うなど、人間の作業フローを交えて不正データが発生しない仕組み作りを行う必要があります。</p><p>また、不正データの発生原因がシステムの故障によるものである場合、そのシステムを監視し、異常が検知された場合はその期間のデータを別の場所に隔離するなどの対応が必要になると思います。</p><p>このように、不正データを検知した際は、恒久、暫定的な再発防止策を早急に考える必要があります。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>今回は実世界データの品質が悪いことと、その対処法について解説しました。</p><p>これからの時代は増々データの品質が重視されると思いますので、引き続きデータに対する知識を深めていきたいと思います！</p><p>最後まで読んでくださり、ありがとうございました！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">欠損値補完： <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">pandera： <a href="https://pandera.readthedocs.io/en/stable/">https://pandera.readthedocs.io/en/stable/</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">正規分布の性質： <a href="https://ai-trend.jp/basic-study/normal-distribution/normal-distribution/">https://ai-trend.jp/basic-study/normal-distribution/normal-distribution/</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。TIG DXユニットの村上です。&lt;/p&gt;
&lt;p&gt;私は大学時代から深層強化学習の研究をしていますが、分野的にほとんど実世界のデータを扱うことがありませんでした。そんな私ですが、実務で実世界データの分析を行う機会があり、その違いに多くの学びがありました。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="DataScience" scheme="https://future-architect.github.io/categories/DataScience/"/>
    
    
    <category term="データ分析" scheme="https://future-architect.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E5%88%86%E6%9E%90/"/>
    
    <category term="データ品質" scheme="https://future-architect.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E5%93%81%E8%B3%AA/"/>
    
    <category term="欠損値" scheme="https://future-architect.github.io/tags/%E6%AC%A0%E6%90%8D%E5%80%A4/"/>
    
  </entry>
  
  <entry>
    <title>はじめてのリーダー論 ～もしも「明日からリーダーやって」と言われたら～</title>
    <link href="https://future-architect.github.io/articles/20210423a/"/>
    <id>https://future-architect.github.io/articles/20210423a/</id>
    <published>2021-04-22T15:00:00.000Z</published>
    <updated>2021-04-23T02:16:22.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、そして、初めまして！フューチャーに2015年に新卒で入社しました<strong>大野恭兵（おおのきょうへい）</strong>と申します。</p><p>技術ブログの中でも異色（！？）の「リーダー論」を、私の具体的なエピソードを交えつつお話します。</p><h2 id="この記事が想定する読者"><a href="#この記事が想定する読者" class="headerlink" title="この記事が想定する読者"></a>この記事が想定する読者</h2><p>主に <strong>「初めてリーダーになったはいいが、正直何をすればよいか分からない」</strong> というようなリーダーの初心者の方に向けて参考になると思います。</p><p>※ここで言うリーダーとは、チームリーダー（チームの責任者）という意味で用いています。</p><p>私くらいの年次（入社6年目）になりますと、リーダーポジションにつく機会が増えます。で、そうなったときに必ずぶつかる壁というのが、<strong>メンバーからリーダーへのポジションが変わったことによる、思考・アクションの変化への対応です。</strong></p><p>ポジションが変わると、考えるべきことも変わります。</p><p>ですので、この記事では <strong>リーダーになった初手の初手にまず何を考えれば良いか？</strong> という内容を私の経験を元に書かせていただきます！</p><p>将棋で言うところの「序盤」に当たる部分、と考えていただければと思います。</p><h2 id="私のリーダー経験について"><a href="#私のリーダー経験について" class="headerlink" title="私のリーダー経験について"></a>私のリーダー経験について</h2><img src="/images/20210423a/achievement-5597527_640.png" class="img-middle-size"><blockquote><p><a href="https://pixabay.com/ja/users/mediamodifier-1567646/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5597527">Mediamodifier</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5597527">Pixabay</a>からの画像</p></blockquote><p><strong>じゃあアンタはどんな経験をしてきたんだよ？</strong> という疑問が浮かんでいるかと思いますので、私のリーダー経験を少しお話します。</p><p>主に大規模プロジェクト内のチームリーダーを <strong>1年間以上</strong> 経験。チーム規模は<strong>10～30名</strong>。一筋縄ではいかないプロジェクトの推進がメインでした。</p><p>ただし、上記は私が進んで「リーダーやります！」と立候補したわけではなく、「明日からリーダーをやってね」と言われてのものでした。コンサルティング業界は仕事のスピード感が違う！と方方で言われていますが、このときほど「スピード感」を実感したときはありませんでした。</p><p>とはいえ、こうしたリーダーになるという経験は業界ではさほど珍しくないかと思いますし、成長へのチャンスです。こういった、一見すると無茶振りとも言うべき要望にどう答えていったのか…をこれから紹介していこうと思います。</p><h2 id="リーダー就任の「序盤」に考えたこと"><a href="#リーダー就任の「序盤」に考えたこと" class="headerlink" title="リーダー就任の「序盤」に考えたこと"></a>リーダー就任の「序盤」に考えたこと</h2><p>私が最初に考えたことは以下３つです。</p><ol><li><strong>リーダーとして達成すべき目標を確認しておく</strong></li><li><strong>チームの置かれている現状を把握する</strong></li><li><strong>チームのメンバーと仲良くなっておく</strong></li></ol><p>これらを具体的に説明したいと思います。</p><h3 id="1-リーダーとして達成すべき目標を確認しておく"><a href="#1-リーダーとして達成すべき目標を確認しておく" class="headerlink" title="1. リーダーとして達成すべき目標を確認しておく"></a>1. リーダーとして達成すべき目標を確認しておく</h3><p>いきなりですが、すべてのタスクには目標があります。</p><p>例えば、コーディング。１行１行見やすく、品質高く納期通りに仕上げる、みたいな目標は割と見えやすいですよね。実はここはリーダーも同じです。<strong>あなたがリーダーになったからには、リーダーとして達成すべき「目標」があるはずです。</strong></p><p>そしてあなたをリーダーにした上司は、それを達成してくれるはずだ！という期待を込めてあなたをリーダーにしています。</p><p>ですので、リーダーとして最初に考えるべきは</p><ul><li><strong>「自分が何を期待されているのか（達成すべき目標は何か）」</strong></li><li><strong>「そのために自分がすべきタスクは何か」</strong><br>かなと思います。</li></ul><p>ここがまずズレると、シビアな話ですが上司があなたに期待していた動きと違うことになり、評価を落とすことになってしまいます。</p><p>そして、出来れば自分で考えた答えを上司とすり合わせることもやっておくべきだと思います。</p><p>私の場合は、主にチームの立て直しがメインでしたので、</p><ul><li>「プロジェクトのマイルストン（例えば、開発フェーズ）の終わりが●月末なので、ここまでに全機能の開発を完了する」</li><li>「そのために自分はチームをマネジメントして、開発完了できるような計画・作戦立てをします」<br>みたいなことを考えて、実際にすり合わせしていました。</li></ul><h3 id="2-チームの置かれている現状を把握する"><a href="#2-チームの置かれている現状を把握する" class="headerlink" title="2. チームの置かれている現状を把握する"></a>2. チームの置かれている現状を把握する</h3><p>私はヘルプでチームリーダーになる機会が多かったので、現状を把握することも必要でした。</p><p>私が確認していたのは</p><ul><li>チームメンバーには誰がいるのか</li><li>メンバーそれぞれが持っているタスクは何か？</li><li>それぞれのタスクの優先度・期日は？</li><li>大変そうな人（タスク過多）はいないか？</li></ul><p>でした。</p><p>チームとして持っているリソースの確認と、それぞれのメンバーの持ち物（タスク）を出来得る限りすべて把握する。そして、それぞれの優先度・期日を改めて確認する。</p><p>こうすることで、<strong>実はやらなくてもよいタスクをやっている可能性を潰すことが出来ます。</strong>そして、その空いた時間で優先度の高いタスクを実施してもらう。</p><p>1.で設定した目標を達成するために、今やっていることは本当に「今やるべきこと」なのか？ということを再確認する。そういう意味で、現状把握はとても重要です。</p><h3 id="3-チームのメンバーと仲良くなっておく"><a href="#3-チームのメンバーと仲良くなっておく" class="headerlink" title="3. チームのメンバーと仲良くなっておく"></a>3. チームのメンバーと仲良くなっておく</h3><p><strong>実はこれが一番重要かもしれません。</strong></p><p>世の中には定量的マネジメント手法が多く溢れていますね。たしかに、定量的に物事を見るというのは大事な要素で欠かすことのできないものです。</p><p>ただし、実際にタスクを進めるのは「人」です。数字では語れない要素を数多く持っています。</p><p>人は感情を持つ生き物ですので、正味な話、やりたくない仕事とかやる気が出ないとかあるはずです。（かくいう私だってそうです）</p><p>そういった一人ひとりのメンバーの趣味・嗜好、モチベーションを知る。それをすることで、<strong>「この人はこういうタスクでモチベーションが上がってバリューを出してくれるから、このタスクを振ろう」</strong> という考え方がいずれ出来ます。</p><p>そういう動きができる第一歩として、まずはメンバーと仲良くなることは有効かなと思います。私はお酒が飲めませんので飲みニュケーションは出来ませんでしたが、（傍から見れば）くだらない雑談を多くすることで相手の本音を色々聞き出したりしていました。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>さて、少し雑多に書いてしまいましたがいかがでしたか。</p><p>正直な話、リーダーなんてなってみないと分からないところが多くあります。と同時に、その経験から得られるものも多いです。</p><p>この記事が「初めてのリーダー」となる方に役立つものになればこれ幸い、ということでシメとさせていただきます！</p><p>ここまで読んで頂きありがとうございました！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、そして、初めまして！フューチャーに2015年に新卒で入社しました&lt;strong&gt;大野恭兵（おおのきょうへい）&lt;/</summary>
      
    
    
    
    <category term="Management" scheme="https://future-architect.github.io/categories/Management/"/>
    
    
    <category term="マネジメント" scheme="https://future-architect.github.io/tags/%E3%83%9E%E3%83%8D%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88/"/>
    
    <category term="リーダーシップ" scheme="https://future-architect.github.io/tags/%E3%83%AA%E3%83%BC%E3%83%80%E3%83%BC%E3%82%B7%E3%83%83%E3%83%97/"/>
    
  </entry>
  
  <entry>
    <title>CircleCIでMarkdownのリンク切れを自動検知する</title>
    <link href="https://future-architect.github.io/articles/20210422b/"/>
    <id>https://future-architect.github.io/articles/20210422b/</id>
    <published>2021-04-21T15:00:01.000Z</published>
    <updated>2021-04-22T02:03:14.451Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/20210422b/chain-312403_640.png" class="img-small-size"><blockquote><p><a href="https://pixabay.com/ja/users/clker-free-vector-images-3736/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=312403">Clker-Free-Vector-Images</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=312403">Pixabay</a>から</p></blockquote><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャー棚井龍之介です。</p><p>私のチームでは、「システムの設計情報」や「実装に関わる業務知識」などを、<code>README.md</code> に整理して GitHub 管理しています。</p><p>設計資料や業務系のドキュメントが蓄積され、何度も更新され続けることに伴い、「あれ、この資料のリンクが切れてる。オリジナルのファイルはどこだっけ？」と探す機会が増えてきました。</p><p>本来ならば PullRequest のレビュー時に気付くべきですが、ファイル名のちょっとしたスペルミスや資料パスの変更などだと、目視でのチェックには限界があります。</p><p>こういった状況への対応として「<strong>リンク切れを自動検知する</strong>」ために、CircleCI で Markdown ファイルのリンク切れを検知できるようにしました。</p><h2 id="完成版コード"><a href="#完成版コード" class="headerlink" title="完成版コード"></a>完成版コード</h2><p><a href="https://github.com/r-ryu/markdown-link-checker"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/r-ryu/markdown-link-checker.png" width="460px"></a></p><p><a href="https://github.com/r-ryu/markdown-link-checker">https://github.com/r-ryu/markdown-link-checker</a></p><h1 id="使うツール"><a href="#使うツール" class="headerlink" title="使うツール"></a>使うツール</h1><p>Markdown チェックのために、<a href="https://github.com/tcort/markdown-link-check">markdown-link-check</a> を利用します。<br>Markdown テキストからリンクを抽出し、各リンクが生きている（200 OK）か死んでいるかをチェックします。</p><blockquote><p>markdown-link-check<br>Extracts links from markdown texts and checks whether each link is alive (200 OK) or dead.</p></blockquote><p>node のツールなので、<a href="https://github.com/tcort/markdown-link-check#installation">npm でインストール</a>すれば、任意の環境でリンクチェックできます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: markdown-link-check [options] [filenameOrUrl]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --progress         show progress bar</span><br><span class="line">  -c, --config [config]  apply a config file (JSON), holding e.g. url specific header configuration</span><br><span class="line">  -q, --quiet            displays errors only</span><br><span class="line">  -v, --verbose          displays detailed error information</span><br><span class="line">  -a, --alive &lt;code&gt;     comma separated list of HTTP code to be considered as alive</span><br><span class="line">  -r, --retry            retry after the duration indicated <span class="keyword">in</span> <span class="string">&#x27;retry-after&#x27;</span> header when HTTP code is 429</span><br><span class="line">  -h, --<span class="built_in">help</span>             display <span class="built_in">help</span> <span class="keyword">for</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h1 id="CircleCIへの記述"><a href="#CircleCIへの記述" class="headerlink" title="CircleCIへの記述"></a>CircleCIへの記述</h1><p>CircleCI の jobs 内で、markdown-link-check を呼び出します。</p><p><a href="https://github.com/tcort/markdown-link-check#check-links-from-a-local-markdown-folder-recursive">ツール本家の README</a> に記載された <code>$ find . -name \*.md -exec markdown-link-check &#123;&#125; \;</code> による実行方法は、CircleCI で実行した際に欲しい挙動が得られません。リンク切れが1つでも存在したら Task failed で落として欲しいのですが、<code>-exec</code> による方法では「最初にチェックされたファイルに、リンク切れがある場合のみ」Task failed で落ちます。2つ目以降のファイルにリンク切れが存在しても、CircleCI は検知してくれません。</p><p>CircleCI のチェックで、リンク切れファイルが<strong>1つでも</strong>存在する場合は Task failed で落としてもらうために、<code>xargs</code> を利用します。xargs を利用することで、対象ファイル全てに一括でリンターチェックが適用できます。（-exec の場合、1ファイルごとに処理されます。）</p><ul><li>引用: <a href="https://future-architect.github.io/articles/20210331/">今さらながらfindパイセンについてまとめてみた（‐execオプション）</a></li></ul><figure class="highlight bash"><figcaption><span>-execとxargsの違い</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -exex</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">echo</span> <span class="string">&quot;ファイル名: &#123;&#125;&quot;</span> \;</span><br><span class="line">ファイル名: ./test01.txt</span><br><span class="line">ファイル名: ./test02.txt</span><br><span class="line">ファイル名: ./test03.txt</span><br><span class="line">ファイル名: ./test04.txt</span><br><span class="line">ファイル名: ./test05.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># xargs</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs <span class="built_in">echo</span> <span class="string">&quot;ファイル名: &quot;</span></span><br><span class="line">ファイル名:  ./test01.txt ./test02.txt ./test03.txt ./test04.txt ./test05.txt</span><br></pre></td></tr></table></figure><p>CircleCI で markdown-link-check を xargs により実行させるコートはこちらです。<br>ツール自体が node 製なので、プライマリイメージには <code>cimg/node:15.11.0</code> を利用しています。</p><figure class="highlight yml"><figcaption><span>config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">markdown_link_check:</span></span><br><span class="line">    <span class="attr">docker:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cimg/node:15.11.0</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">checkout</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">markdown-link-check</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">find</span> <span class="string">.</span> <span class="string">-name</span> <span class="string">\*.md</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">--max-lines=1</span> <span class="string">markdown-link-check</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">workflow:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">markdown_link_check</span></span><br></pre></td></tr></table></figure><p>あとは CircleCI を回せば、リポジトリ内のリンク切れを全て検知してくれます。</p><h2 id="大量のリンク切れを検知したときは"><a href="#大量のリンク切れを検知したときは" class="headerlink" title="大量のリンク切れを検知したときは"></a>大量のリンク切れを検知したときは</h2><p>長期間メンテナンスされていないリポジトリの場合、markdown-link-check が大量のリンク切れを検知します。<br><code>.circleci/config.yml</code> に定義ファイルが追加された時点で、CircleCI が落ち続けてしまうので、まずはローカル実行でリンク切れ状況をチェックしましょう。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ circleci <span class="built_in">local</span> execute --job markdown_link_check</span><br><span class="line">（略）</span><br><span class="line"></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment"># リンク切れあり</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line">ERROR: 1 dead links found!</span><br><span class="line">[✖] ../docs/環境構築/README.md → Status: 400</span><br><span class="line"></span><br><span class="line">Task failed</span><br><span class="line">Error: task failed</span><br><span class="line"></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment"># リンク切れなし</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line">[✓] ../../docs/環境構築/README.md</span><br><span class="line"></span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><h2 id="特定のリンクは対象外にしたいとき"><a href="#特定のリンクは対象外にしたいとき" class="headerlink" title="特定のリンクは対象外にしたいとき"></a>特定のリンクは対象外にしたいとき</h2><p>正規表現で <code>ignorePatterns</code> を設定すれば、特定のリンクをチェック対象外に指定できます。</p><p>例えば、別サイトへのリンクをチェック対象外にしたい場合、<code>config.json</code> に以下設定を追加します。</p><figure class="highlight json"><figcaption><span>config.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ignorePatterns&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;^http&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-c</code> オプションで、config.jsonを渡します。</p><figure class="highlight yml"><figcaption><span>config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Markdown-Link-Check</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">find</span> <span class="string">.</span> <span class="string">-name</span> <span class="string">&#x27;*.md&#x27;</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">--max-lines=1</span> <span class="string">markdown-link-check</span> <span class="string">-c</span> <span class="string">config.json</span></span><br></pre></td></tr></table></figure><p>その他、config.json の設定次第で様々な動作調整が可能です。<br>詳細は <a href="https://github.com/tcort/markdown-link-check#config-file-format">Config file format</a> をご参照ください。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>ドキュメントの増加やメンバーの入れ替えなどにより、徐々に資料の陳腐化が進んでしまうのはあるあるだと思います。資料パスのリンク切れは自動検知可能なので、こういった作業は自動化・仕組み化して、エンジニアは開発に集中しましょう。</p><p>今回は「CircleCI で Markdown チェックを自動化する」方法でした。</p><p>この方法が、読んでいただいた方の役に立てたら幸いです。</p><h2 id="参照記事"><a href="#参照記事" class="headerlink" title="参照記事"></a>参照記事</h2><ul><li><a href="https://github.com/tcort/markdown-link-check#config-file-format">markdown-link-check</a></li><li><a href="https://future-architect.github.io/articles/20210331/">今さらながらfindパイセンについてまとめてみた</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/20210422b/chain-312403_640.png&quot; class=&quot;img-small-size&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pixabay.com/ja/users/clker-free-</summary>
      
    
    
    
    <category term="CI/CD" scheme="https://future-architect.github.io/categories/CI-CD/"/>
    
    
    <category term="Document" scheme="https://future-architect.github.io/tags/Document/"/>
    
    <category term="CircleCI" scheme="https://future-architect.github.io/tags/CircleCI/"/>
    
    <category term="Markdown" scheme="https://future-architect.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Technical Credibilityを築くということ</title>
    <link href="https://future-architect.github.io/articles/20210422a/"/>
    <id>https://future-architect.github.io/articles/20210422a/</id>
    <published>2021-04-21T15:00:00.000Z</published>
    <updated>2021-04-22T02:16:30.961Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/articles/20210414a/">春の入門連載2021</a>の7日目です。</p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、TIGの須田です。</p><p>私は新卒でフューチャーへ入社しITの世界でのキャリアが始まりました。その後、一度フューチャーを離れIoTプラットフォーマーのソリューションアーキテクトとして多くのお客様へ自社サービスの導入支援やIoTシステムの設計や構築の支援をしておりました。そうしたソリューションアーキテクトとしてのロールを通じて、多くの経験や学びを得ることができたのですが、その中でも特にTechnical Credibilityというキーワードについて自分の経験を交えて本ブログにて書いてみたいと思います。</p><p>本ブログのシリーズが、春の入門記事＆新人だった頃の自分に伝えたい内容を書こう、というテーマであったので迷わずこのテーマについて取り上げようと決めました。</p><h2 id="Technical-Credibilityとはなにか"><a href="#Technical-Credibilityとはなにか" class="headerlink" title="Technical Credibilityとはなにか"></a>Technical Credibilityとはなにか</h2><img src="/images/20210422a/climbing-4514507_640.jpg" class="img-middle-size"><blockquote><p><a href="https://pixabay.com/ja/users/rappellingusa-13786882/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4514507">Rappellingusa</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4514507">Pixabay</a>からの画像</p></blockquote><p>Technical Credibilityとは無理やり日本語に訳すと技術的信頼？信頼度？となります。Technical Credibilityの厳密な説明や定義が少ししにくいのですが、技術力やそのナレッジを通して信頼を得ていくこと、そのプロセス、と自分は解釈しています。</p><p>私はこの言葉をソリューションアーキテクトとして活動していた際に初めて知りました。ソリューションアーキテクトというロールはお客様の抱える課題や実現したいことに対して、主にテクニカルサイドからどのようにそれらを解決・実現できるかについて具体的なアドバイスやご支援するものです。そうしたロールであることからも、技術的なアドバイスを求められることが大きく期待されています。</p><p>こうした技術的なやり取りを通じてお客さんの信頼を得ていくプロセスをTechnical Credibilityを得る、とここでは表現したいと思います。</p><p>ソリューションアーキテクトの仕事そのものについてはこちらのエントリがとても参考になります。またこちらのエントリにもTechnical Credibilityの大切さについての言及があるのでこちらもぜひおすすめです。</p><iframe src="https://hatenablog-parts.com/embed?url=https%3A%2F%2Fimai-factory.hatenablog.com%2Fentry%2F2017%2F12%2F12%2F192439" style="border: 0; width: 100%; height: 190px;" allowfullscreen scrolling="no"></iframe><p>フューチャーは経営とITをデザインするという言葉が示す通り、ソフトウェアエンジニアであってもお客様の業務を理解し、一緒にシステムを作り上げていくことが求められます。そのためTechnical Credibilityの考え方が同じく重要だと考えています。</p><p>ここからはTechnical Credibilityを築くことの重要性や、その際にどのような考えやアクションが重要になってくるのか、またその中でのちょっとしたTipsなんかにふれていきたいと思います。</p><h2 id="Technical-Credibilityがなぜ大事なのか"><a href="#Technical-Credibilityがなぜ大事なのか" class="headerlink" title="Technical Credibilityがなぜ大事なのか"></a>Technical Credibilityがなぜ大事なのか</h2><p>ITの世界に限らずTechnical Credibilityは私たちの日常のいたるところで適用できる考え方だと思っています。例えば体調が優れないときは病院へ行き専門医に原因や対処法を診察してもらいますし、何か資産運用を始めたいとなった際にFPに相談される方もいらっしゃると思います。こうしたシーンにおいて、私たちが知らないことやより深く知りたいことを、その知識や経験を有している専門家に相談しアドバイスをもらうという観点では私たちITコンサルタントに期待される役割と同様です。</p><p>まず初めに、こうした特別な事情を有した相談は誰にでもできるものではありません。そうした経験を有している方へアドバイスを求めることが自然です。そうした際にまず大事になってくるのが、この人に相談ができる・したいと認知してもらえていることです。私たちも期待した答えが得られなさそうだったり、詳しくない人に専門的なアドバイスを求めようとはまず思わないですよね。（あえて専門家以外の方にフラットな意見を聞くことが重視されているようなシーンでは話は変わるかもしれません）</p><p>こうしたアドバイスをもらう際に、その一連のやり取りの中でこれぞまさに求めていたアドバイスだ！といった助言をいただけたとします。そうすると、また似たような悩みや関連する相談事があった際に、ぱっとその人の顔が思い浮かび、また相談してみようかしらと考えるのは自然なことではないでしょうか。そうした体験を繰り返すことで、最初はさしあたった相談や課題が主だったのが、より多くのことについてもまずこの人に相談にのってもらいたい、この人なら何かアイデアがあるんではないだろうかと大きな信頼へと変わっていきます。</p><p>このプロセスこそがTechnical Credibilityが築かれることでもたらされる好循環で、こうした信頼がうまれることでより多くの機会を創出することにつながります。特にビジネスの世界ではこうした些細な相談事から大きなプロジェクトへつながったり、はたまた一緒に大きな仕事をしていこうという機会にもつながってきます。</p><p>それではTechnical Credibilityを築くためにはどうしたらよいのでしょうか。このアプローチは人それぞれあると思いますが、私自身の経験や私自身がこの人はとてもTechnical Credibilityを築くのが上手だなと思える人たちの振る舞いを見て学んだポイントについてふれていきたいと思います。</p><h2 id="Technical-Credibilityを築くには"><a href="#Technical-Credibilityを築くには" class="headerlink" title="Technical Credibilityを築くには"></a>Technical Credibilityを築くには</h2><h3 id="自分の経験・知識を還元できそうな領域を見つける"><a href="#自分の経験・知識を還元できそうな領域を見つける" class="headerlink" title="自分の経験・知識を還元できそうな領域を見つける"></a>自分の経験・知識を還元できそうな領域を見つける</h3><p>まずは自分が提供できる専門性や得意な領域を見つけることがとても大事です。これについて、何かの専門家である必要はなく、自分の経験に裏付けされた何かアドバイスができる、といったそういったもので十分かと考えています。例えば、DynamoDBを使ったデータモデルの設計実装経験とその過程で得られた知見や、ライブラリの選定を通じて得た各プロダクトの特徴や適したユースケースを理解している、はたまた倉庫業務のアプリケーション開発を通じて得られた倉庫業務の知識そのもの、特定の産業用途に特化した独自プロトコルのフォーマットのパース処理を通じて得られプロトコル仕様、こうした人それぞれの経験がまさに価値を生んでいきます。こうしたナレッジは誰しも持っているものではありません。さらに、商用環境での導入などを通じてより実践に即したノウハウなどは、やってみたの域を超えた高い付加価値を有しています。</p><p>こうした経験はこれから同じチャレンジをする人たちや、今まさにはまっている人たちにとってはとても有益な情報となります。このように、まずは自分がこれまで経験をその中で培ったナレッジから何か貢献できることから始めていくことで、その人のTechnical Credibilityを築いていくことができるのではないでしょうか。こうした過程を重ねていくことで、○○のことなら前にｘｘさんが教えてくれたからまた相談してみよう、ぜひメンバとして一緒にやってもらいたいといったラベリングができあがり、より大きな相談事をもらえたり、チャンスへつながっていくのではないでしょうか。とにもかくにも、自分の経験や知識を惜しげもなくシェアしていくことが大事な一歩かと考えます。</p><p>例えばこのように普段使っている便利な小技だったり、やってみて分かったはまりどころ、がっつり業務導入した知見などを技術ブログとして共有することも社内、社外問わず自分のラベリングを作るのに効果的な手法ですね。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200116/index.html" data-iframely-url="//cdn.iframe.ly/AJ0a9bh?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20200803/index.html" data-iframely-url="//cdn.iframe.ly/vWZNkTt?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://future-architect.github.io/articles/20201013/index.html" data-iframely-url="//cdn.iframe.ly/SAxxrkF?iframe=card-small"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><h3 id="常に最新の情報をキャッチアップする"><a href="#常に最新の情報をキャッチアップする" class="headerlink" title="常に最新の情報をキャッチアップする"></a>常に最新の情報をキャッチアップする</h3><p>個別の技術要素を正しく理解することが全ての基本です。これがやりたかったらこのAPIを使えばよさそうですねとか、このクラウドサービスとこの機能を組みあわせれば実現できそうですね、など様々な技術要素を考慮しながら具体的な課題へのアプローチを提示できることがまずは重要です。特に、昨今のクラウドサービスの拡充やそれらのサービスの成長スピードなんかを考えると、つい昨日までしてた苦労が実はマネージドサービスやSaaSとして提供されていたり、新しい機能が使えることでよりシンプルな実装になったりというのはよくあることとなってきました。そのため、最新の情報を常にキャッチアップしておくことも、不要な苦労を避けてもらうためにも非常に重要となってきます。</p><p>こうした個別の技術要素を正しく理解しながら、自分の引き出しを増やして、いざという時にすっとアイデアや解決策そのものを引き出せるようにしておくこともとても大事なスキルとなってきます。</p><p>情報収集の仕方についてはみなさん好みのやり方があると思うのでここではふれませんが、すぐに試せる環境を手元に用意しておくことをおすすめします。最近ではDockerコンテナなどでたいていの実行環境はdocker pullで利用できますし、試すだけの環境構築の敷居はかなり下がっていると感じます。また様々な機能がクラウドサービスやSaaSとしても提供されるようになり、何かを確認したい・知りたい時は自分で手を動かして理解する方がよほど早くなってきているとも思います。前述したように、昨今における機能の充実速度はとても速いです。たくさんの利便性を享受できる一方で、理解しなくてはいけない事柄も同時に増えてきているとも言えます。こうした状況では実際に手を動かしてプロダクトを理解し、想定通りの挙動がとれた・できなかったという経験を通じたキャッチアップや理解の方が結果的に効率的なことが多いです。特に自分で手を動かすことで、ただ知っている状態より深みが増します。さきほど書いた通り、自分が実際に体験した事柄が価値を生んでいきます。そのため、手元ですぐに試して確認したり失敗したりできる環境をメンテナンスしておくが非常に大事です。さてやってみるか、となった際にその初速を高められる準備をしておくことをおすすめします。</p><p>また最近では<a href="https://www.oreilly.com/">O’Reilly Media</a>のように、書籍を横断したキーワード検索ができるものもあり、短期間でよりピンポイントでの深堀をしたい際はこうしたサービスを活用していくのもおすすめです。</p><h3 id="課題の本質を考える"><a href="#課題の本質を考える" class="headerlink" title="課題の本質を考える"></a>課題の本質を考える</h3><p>ある悩みや課題に対して、具体的な解決策を説得力をもってぱっと提示できることの重要性についてはさきほど記載した通りです。</p><p>一方で、その課題やゴールが果たして適切なものなのかを一歩立ち止まって考えられることも、相談相手のためにも重要なことが多いです。例えば、実はその課題の本質には別の根本的な課題があって、そちらにアプローチするのがより効果が高いといったシーンです。専門家へ相談するようなシーンにおいては、相談者自身も何が課題になっているかが分からない、把握が難しいケースも多いです。特に初めての取り組みや、ナレッジの取得が難しいような課題に取り組む際に私たちも何が分からないのか分からない、といった経験が一度はあるのではないでしょうか。こうした状況下で設定した課題やゴールについて、相談を受ける側はいい意味で第三者的な見方ができます。あれ、これって本当に実現したいことなのかな、という事が浮かんだら投げかけてみることで相談者にも新たな気付きをもらすことができますし、何よりもこれこそがアドバイスの神髄ではないのでしょうか。</p><p>またITの世界では、同じ課題感であっても属する業種業態などによってもとらえ方やアプローチが変わってくることもあります。そのため、技術要素しか興味がないので、、と食わず嫌いせずに、その課題が置かれている業界背景などにも目を向けてみることで得られるものもたくさんあります。</p><p>こうしたいわゆるドメインへの理解をどう行っていくかですが、一般的な知識であれば今では色んな情報が簡単に手に入るのではないでしょうか。私はよく就職活動なんかで使われるような業界本なんかも最初は読んだりします。よりテクニカルなトピックについては、最近だと動画コンテンツが充実してきています。例えば、既に活用されている方も多いかもしれませんが<a href="https://www.udemy.com/">Udemy</a>もおすすめで、ITコンテンツ以外の業界に特化した技術コンテンツなども充実しています。例として、製造業ですと様々なフィールドネットワークのためのプロトコル技術や、PLCといった機器操作方法などのコンテンツもたくさんあり、体系だった理解を効率的に進められます。またYouTubeにもこうした多くの動画が公開されており、短い時間で体系だったキャッチアップが必要な際にとても有用なコンテンツとなっています。まずは気になるワードなどで検索してみることをおすすめします。</p><p>例えば私はIoT関連のプロジェクトを担当することが多いのですが、その際に専門的な機器設備の仕組みなどをキャッチアップするのにこのYouTubeチャンネルにお世話になってます。</p><p><a href="https://www.youtube.com/c/Theengineeringmindset/featured">https://www.youtube.com/c/Theengineeringmindset/featured</a></p><p>ちなみに実機を使った何か確認がしたい！という場合はヤフオクだと専門的なデバイスも入手しやすいのでこちらもおすすめです。</p><h3 id="どうしてそうするのか・したのかを蓄積する"><a href="#どうしてそうするのか・したのかを蓄積する" class="headerlink" title="どうしてそうするのか・したのかを蓄積する"></a>どうしてそうするのか・したのかを蓄積する</h3><p>どんなシステムや技術課題、業種業態の話であっても、実現したいことやそのポイントには多くの共通点があることが多いです。そのため、どうしてそのような判断をしたのか、どのようなアドバイスのステップや検討を経由したのか、といったログを残しておくことも非常に重要です。これは前述した引き出しから適したアドバイスを素早く引き出せることにもつながります。</p><p>Architecture Decision Records(以下ADRs)をご存じでしょうか。私はロール上、システムアーキテクトとして実現したい仕組みや解決したい課題へのアプローチを立案することも多いのですが、ADRsのアプローチは非常に有用です。どういう過程を経由したのか、その各過程ではどういった考えあったのか、を形として残すことでなぜそうするのかを第三者にもステップを追ってシェアすることができます。どんなに解決策やアプローチが優れていたとしても、そこに納得感が伴わないとなかなか行動に移しにくのも確かです。そういった観点でもこういったログを一緒に作る、というアクションもこれまでの考えをより納得感をもった理解を促すためにも非常に大事なのではないでしょうか。</p><p>具体的なADRの例ですがADRの具体的な作り方はこちらがとても分かりやすく整理されていておすすめです。</p><div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://scrapbox.io/kawasima/%25E5%25AE%259F%25E8%25B7%25B5ADR" data-iframely-url="//cdn.iframe.ly/ca2LjZK"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>新卒でフューチャーへ入社した際はいわゆるIT未経験だったこともあり、テクニカルな側面でのキャッチアップや研磨にとにかくがむしゃらだったことを今でも覚えています。</p><p>それを正しく人に伝え、そこからさらなる価値を生み出していくこと、そのためにより広い視野で食わず嫌いせずにキャッチアップを続けることの大事さを新人だったころに自分に伝えてあげたい、、、ぜひ自分の得意な領域に磨きをかけつつも、色々な技術に実際に触れてみて、みなさんしか作れないTechnical Credibilityの源泉を蓄えていってください！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の7日目です。&lt;/p&gt;
&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こん</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
    <category term="技術的信頼" scheme="https://future-architect.github.io/tags/%E6%8A%80%E8%A1%93%E7%9A%84%E4%BF%A1%E9%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>The Apache Wayのお話</title>
    <link href="https://future-architect.github.io/articles/20210421b/"/>
    <id>https://future-architect.github.io/articles/20210421b/</id>
    <published>2021-04-20T15:00:01.000Z</published>
    <updated>2021-04-21T03:54:26.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは、<a href="/articles/20201107/">フューチャーOSS推進タスクフォース</a>の藤野です。</p><p>私が現在参加している<a href="https://www.apache.org/">The Apache Software Foundation（ASF）</a>の基本理念の一つである<a href="https://www.apache.org/theapacheway/">The Apache Way</a>について紹介します。</p><p>The Apache Wayを通して、ASFのことを少しでも知ってもらえたらと思います。</p><h2 id="The-Apache-Wayとは？"><a href="#The-Apache-Wayとは？" class="headerlink" title="The Apache Wayとは？"></a>The Apache Wayとは？</h2><p>この記事を読んでいる多くの方は、開発者や利用者等、様々な立場でOSSに何らかの形で関わりを持っていると思いますので、The Apache Software Foundationやそこで開発されているのOSSについていくつか程度の差はあれどご存知かと思われます。</p><p>The Apache Software Foundation とは、HTTPDやTomcat等、数多くのOSSプロジェクトの開発を支援している非営利団体で、世界で成功しているOSSコミュニティの一つです。</p><p>The Apache Wayとは、このThe Apache Software Foundationがどのようにプロジェクトを統治するのか、コミュニティ運営の基本指針のようなもので、ASFプロジェクトで長年にわたって使用されているコミュニティの振る舞いや運用方法のガバナンスモデルを提供します。</p><p>そしてこのThe Apache Wayは、コミュニティメンバによって其々捉え方が異なり、多くの解釈があります。<br>今日は、このThe Apache Wayの（私的な）解釈をまとめてみました。</p><h2 id="The-Apache-Wayの主要コンセプト"><a href="#The-Apache-Wayの主要コンセプト" class="headerlink" title="The Apache Wayの主要コンセプト"></a>The Apache Wayの主要コンセプト</h2><p>The Apache Wayを紐解くと4つに分割できます。そしてそのコンセプトは其々次の通りです。</p><ul><li><strong>MERITOCRACY（成果・実績主義）</strong><br>成果・実績によって評価され、統治され、その影響力は、公的に獲得したMerit、つまりコミュニティに貢献することに基づいています。</li><li><strong>Community</strong><br>組織ではなく、個人がASFに参加します。<br>相互に信頼し、互いに尊敬します。<br>BDFL（Benevolent Dictators For Life）は許可されません。</li><li><strong>Collaborative Development</strong><br>ASFのProjectは共同開発によって行われます。<br>コミュニティはコラボレーションなしでは成長できません。<br>コミュニティ全体で技術的な方向性を決定します。</li><li><strong>Open Communications</strong><br>Codeと意思決定に関連するすべての議論はPublicにアクセス可能でなければなりません。</li></ul><p>この4つの主要コンセプトをそれぞれ深堀りしてみましょう。</p><h2 id="MERITOCRACY"><a href="#MERITOCRACY" class="headerlink" title="MERITOCRACY"></a>MERITOCRACY</h2><p>まずは、MERITOCRACY（成果・実績主義）です。</p><p>ASFでは、すべての個人に対して参加する機会が与えられますが、その影響力は、公的に得られたMerit、つまりコミュニティに貢献した実績に基づいています。</p><p>では、そのMeritとは何でしょうか？Meritとは、コミュニティにとって有用な目に見える作業の実績です。そして、そのMeritはコード実績だけではありません。ほとんどのコミュニティは、ドキュメント、Webサイト、インフラストラクチャ、メーリングリストのヘルプ、およびバグレポートの等の貢献も高く評価しています。つまり、様々なロールのユーザがコミュニティに貢献することが出来ます。</p><p>また、Meritには様々な側面があります。</p><ul><li><strong>Meritは所属に関係なく個人にあります</strong><br>重要なのは、「あなたが誰であるかではなく、あなたが何をするか」です。<br>Meritは貢献者の所属する組織や企業には全く影響を受けません。</li><li><strong>Meritには有効期限がありません</strong><br>貢献者が、コミュニティへの参加をしばらくの間やめていたとしても、そのMeritは消えることはありません。後でコミュニティに戻ってきても、通常はコミュニティ内でのMeritを維持します。</li><li><strong>Meritは譲渡できません</strong><br>あるコミュニティで得られたMeritは、必ずしも別のコミュニティで評価されるとは限りません。Meritの認識は、コミュニティによって大きく異なります。</li><li><strong>より多くMeritを持っている人は、より多くの責任を得ます</strong><br>これはMeritの最も重要な側面のひとつです。貢献者のMeritに対する最も明白な報酬は、そのコミュニティ内のコミッターになることです。また、コミッターは、プロジェクトのリポジトリへの書き込みアクセス権を持っているので、コード、Webサイト等に直接貢献することが出来ます。 Meritを提供し続けているコミッターは、PMCになれる場合があります。<br>つまり、誰でもコミュニティに貢献することは出来ますが、全ての貢献者がコミッタになれるわけではありません。私自身もコミッタになる前は3桁以上のパッチを提出しています。コミッタからPMCになるにも2年以上活動を継続しました。<br>今コミュニティにいるコミッタやPMCは皆それぞれコミュニティへの大きな貢献によって、その地位にいます。</li></ul><h2 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h2><p>次は、Communityです。ASFでは、Communityの定義について厳格に定められています。</p><p>ASFでは、取締役会、他の役員、コミッター、およびメンバーを含むすべての参加者は、個人として参加しています。決して、企業からの参加であってはなりません。</p><p>これは、ASFの強みの1つであり、完全なベンダーの中立性を保障します。しかしながら、実際、一部の企業には雇われコミッタのような方もいますが、そうったコミッタに関しても企業として参加しているのではなく、あくまで個人参加となります。その貢献実績は個人にのみあります。前述したMERITOCRACYにあるように、個人の貢献実績によってコミュニティ内の役割が決まるので、一部の企業が自由にそのプロジェクトのコミッタを追加することはできません。</p><p>では、あるOSSプロダクトをASFに寄与する場合（Apache Incubator）はどうでしょうか？この場合、開発者が特定の企業から構成されていることは良くあることです。そのような場合においても、Apache Incubatorの卒業要件（TLPへの昇格要件）としてコミッタの多様性、つまり、コミッタが様々な企業からであることを示さなければなりません。</p><p>また、コミュニティ内では参加者全員が相互に信頼し、互いに尊敬することを期待します。そして、<a href="http://apache.org/foundation/policies/conduct.html">その行動規範</a>も明確に定義しています。</p><p>ASFのフラットな構造は、役職に関係なく参加者は同じ発言力を持ち、平等であるべきとされています。専門知識は高く評価されている一方で、BDFL（Benevolent Dictators For Life）は許可されていません。</p><p>そして、このCommunityにおいて、もっとも重要なコンセプトは「Community over Code」です。「Community over Code」とは、ASF内で非常に良く引用される格言で、健全なコミュニティが優れたコードよりもはるかに重要であることを明言しています。</p><p>優れたソフトウェアを創造することを目的とするASFが、その作り出されたプログラムコードそのものよりも、コミュニティ自体を大事にするASFの最も重要な特徴として強調されています。</p><h2 id="Collaborative-Development"><a href="#Collaborative-Development" class="headerlink" title="Collaborative Development"></a>Collaborative Development</h2><p>ASFの各プロジェクトは共同開発によって行われています。</p><p>コミュニティ全体によって方向性を決定しするため、主要な決定事項については、コンセンサスを得ようと努めています。この際に行われる意思決定は怠惰なコンセンサスアプローチ（lazy consensus approach）で行われます。これは以下のような数字による投票で行います。</p><ul><li>+1　賛成票</li><li> 0　棄権、意見なし</li><li>-1　反対票</li></ul><p>コンセンサスは100％の合意を意味するものではなく、 コミュニティの合意には、-1の投票が無く、いくつかの+1の投票を獲得するだけで十分です。反対票には代替案または反対票の理由の詳細な説明を含める必要があります。また、投票は通常72時間(3日)ルールで行われます。</p><p>これはさまざまなタイムゾーンのプロジェクト参加者が意思決定に参加できるように、十分な時間（少なくとも72時間）の投票が可能であることを保障します。</p><h2 id="Open-Communications"><a href="#Open-Communications" class="headerlink" title="Open Communications"></a>Open Communications</h2><p>ASFでは、その技術的な仕事はオープンに行われなければなりません。つまり、コードや技術的決定に関連するすべてのコミュニケーションが公開メーリングリストで行われる必要があります。メーリングリスト外の対談や会議でのディスカッションはすべての参加者がディスカッションして決定できるように、適切なメーリングリストに戻す必要があります。</p><p>コードや技術的決定に関連するプライベートな決定は許可されていません。私自身もApacheCon（ASF主催の国際カンファレンス）で他のコミッタ達とF2Fで議論することがあるのですが、そこで決めたことは、必ずその後開発用のメーリングリストに共有することを行っています。</p><p>もちろん、プロジェクトに非公開なメーリングリストはあります。しかしながら、ASFのすべての非公開メーリングリストには、セキュリティ問題など非公開にする特定の理由があります。</p><p>パブリックの場でできるだけ多くの仕事をするという概念は、The Apache Wayの基本であり、 オープンコミュニケーションは、誰もが自由にコミュニティに参加することを保障します。技術的な議論、コンセンサス、コードとドキュメントの作業をすべてオープンに行うことで、新しいユーザはメーリングリスト、アーカイブからプロジェクトの過去、現在、そして未来の方向性を知ることが出来ます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>The Apache Wayの主要なコンセプトを述べました。</p><p>これまでをまとめると、The Apache Wayとは、</p><p>「ASFの各プロジェクトでは、個人参加の原則により、ベンダーの中立性を促進し、特定の企業からの過度の影響を防ぎます。メンバーはその貢献実績により評価され、影響力は完全に平等です。プログラムコードや技術的な意思決定等の議論は全てのオープンで透過的でコンセンサスベースで行われます。」</p><p>と言い表せます。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>今回は私の解釈によるThe Apache Wayを述べました。</p><p>The Apache Wayは常に変化しフレキシブルで成長しています。</p><p>「There is no “one way” to The Apache Way. 」という言葉があります。</p><p>The Apache Wayは基本的な原則ではありますが、どう解釈するかは人それぞれです。このThe Apache Wayからも分かるように、ASFはコミュニティのガバナンスがしっかりしています。</p><p>そのため、これからコミュニティに参加しようと思っている人にとっては入り易いコミュニティだと思います。</p><p>ぜひ、参加してみてはいかがでしょう。</p><ul><li><a href="https://community.apache.org/gettingStarted/101.html">入門ページへ</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは、&lt;a href=&quot;/articles/20201107/&quot;&gt;フューチャーOSS推進タスクフォース&lt;/a&gt;の藤野で</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="OSS" scheme="https://future-architect.github.io/tags/OSS/"/>
    
    <category term="OSS推進タスクフォース" scheme="https://future-architect.github.io/tags/OSS%E6%8E%A8%E9%80%B2%E3%82%BF%E3%82%B9%E3%82%AF%E3%83%95%E3%82%A9%E3%83%BC%E3%82%B9/"/>
    
    <category term="ApacheWay" scheme="https://future-architect.github.io/tags/ApacheWay/"/>
    
  </entry>
  
  <entry>
    <title>情報の民主化のために発信しましょう</title>
    <link href="https://future-architect.github.io/articles/20210421a/"/>
    <id>https://future-architect.github.io/articles/20210421a/</id>
    <published>2021-04-20T15:00:00.000Z</published>
    <updated>2021-04-21T01:08:15.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、<a href="https://www.inspace.co.jp/">フューチャーインスペース株式会社</a>の柴尾です。<a href="/articles/20210414a/">春の入門連載2021</a>の6日目です。</p><p>複数のプロジェクトでルーターやスイッチといった物理的な装置の設定から、パブリッククラウド（主にAWS, GCP）まで設計、構築、保守運用、それらのクラウド業務の請求が複雑なのでバックオフィス部門との調整を行っています。</p><h1 id="新人のころを思い出してみて"><a href="#新人のころを思い出してみて" class="headerlink" title="新人のころを思い出してみて"></a>新人のころを思い出してみて</h1><p>私は2010年4月にフューチャーインスペース株式会社の前身である株式会社アセンディアへ大学卒業後入社しました。</p><p>忘れもしない出来事として当時東京採用・大阪採用・福岡採用・大分採用が定期的にWeb会議で会話していたものの、私も出身の地元である大分から3月31日に東京本社で初めて一同に介して、「明日からこのメンバーで研修か、こなせるのかな？」などと不安と期待と感情が混ざっている中で、研修の受け入れ担当から「明日から研修はフューチャーグループ合同でやるから」と衝撃の一言がありました（笑）</p><p>青天の霹靂とはまさにこのことで当時は誰も予想していなかった、</p><ul><li>フューチャーアーキテクト株式会社</li><li>フューチャーワン株式会社（当時は株式会社エルム）</li><li>フューチャーインスペース株式会社（当時は株式会社アセンディア）</li></ul><p>合同研修を初めて行いました。</p><p>研修の内容はこのブログ趣旨とは外れるので割愛しますが、この研修の体験は色々な意味でよかったと思います。</p><h1 id="新人の時に知りたかったあの知識"><a href="#新人の時に知りたかったあの知識" class="headerlink" title="新人の時に知りたかったあの知識"></a>新人の時に知りたかったあの知識</h1><p>さて、ブログの主題としては今の私が思うのはズバリ「 <strong>情報の発信による効果</strong> 」です。</p><p>私はAWSを触れるようになったのは最近なのですが、公式のドキュメントや他の企業ブログ、個人ブログを見るだけで自分の中に落とし込むことができませんでした。</p><p>そのような中で、JapanAWS-UserGroupこと<a href="https://jaws-ug.jp/">JAWS-UG</a> に出会い、衝撃を受けました。</p><p>利用者側が主導してコミュニティの運営、イベントの運営含め自主的に動いていることだけではなく、参加者側がただただ参加してハイ終わりではなく、参加して聞いた内容をブログにまとめ上げる、それも早い人はイベント終わった瞬間に、そういったインプットからアウトプットまでのスピード感に驚かされました。</p><p>AWS公式漫画でも紹介されていますので、引用させていただきます。</p><p><a href="https://aws.amazon.com/jp/campaigns/manga/vol11-2/">https://aws.amazon.com/jp/campaigns/manga/vol11-2/</a></p><p>COVID19によりオンライン会議が以前に比べて活発になった昨今では、AWS、JAWS-UGだけではなく様々な企業、コミュニティによるオンラインイベントが行われています。もしこの記事を見ていただいている方の同時刻にもイベントが行われているかもしれません。</p><p>話を戻して、そういった中で個人的に感じた、 <strong>発信すること</strong> については、一般的なPDCAに当てはめることができて以下のような効果があると思っています。</p><table><thead><tr><th>Step</th><th>想定される効果</th></tr></thead><tbody><tr><td>Plan</td><td>発信する内容の整理する過程で知識を落とし込める、自分の理解が曖昧な部分を洗い出せる</td></tr><tr><td>Do</td><td>実際に発信する</td></tr><tr><td>Check</td><td>目に触れた人から反応がある（コメント、あるいはフィードバック）</td></tr><tr><td>Action</td><td>自分だけではカバーできなかった範囲でさらに視野が広がる</td></tr></tbody></table><p>例えば、以前私が参加したとある講座があり参加してきました。正直私自身、データベースをそこまで詳しいエンジニアではなかったものの、必死になってリアルタイムでまとめて即公開をチャレンジしてみました。<br>（それも分からないところを書いて丸投げする形で）</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3.png"></p><p>すると、以下のように偶然時間が空いた人や少し経ってからポツポツとコメントを頂くようになって、</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3_2.png"></p><p>自分の足りなかった範囲を補うコメントであったり、タイプミス部分含めて指摘が貰えて、結果的に理解がより深まるようになりました。</p><p><img src="/images/20210421a/%E6%83%85%E5%A0%B1%E5%85%B1%E6%9C%89__3_3.png"></p><h1 id="なぜ、そう思ったのか（思うようになったか）"><a href="#なぜ、そう思ったのか（思うようになったか）" class="headerlink" title="なぜ、そう思ったのか（思うようになったか）"></a>なぜ、そう思ったのか（思うようになったか）</h1><p>正直、私は積極的に情報公開するタイプではありませんでした。</p><p>ただ私が研修後に入った始めてのプロジェクトで積極的に内部に情報を展開する文化があり、その展開された情報に対して、誰かが反応するという様子を見ていたことから、自然と敷居が低くなっていったのかもしれません。</p><p>2010年当時は今ほどチャットツールが活発ではなくメールベースでしたが、そのような行為があったことを忘れないように今でもメールを保存しています。<br><img src="/images/20210421a/sample.jpg"></p><p>また、それほど瞬発的に情報を整理できるタイプでもなかったため、相手に伝える情報を整理してから、伝えることを繰り返して訓練を積みました。</p><p>自分の幅を広げようと技術系のセミナーに行くと知らないことばかりで衝撃を受けて、それらをメモして調べていく中でまとめるといった行為に繋がり、繰り返していくことでそれまで散り散りになっていた知識が紐付いてきて、結果として身に着けてきたかなと思います。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>私の新人の時に知りたかったあの知識「 <strong>情報を発信すること</strong> 」でした。</p><p>直接、知識というものではなく意識に近いものですが、結果的に知識へ繋がるものだと思います。</p><ul><li>情報の発信することは怖いですよね？</li><li>出す情報が間違っていない？</li><li>この情報を出しても意味ある？</li></ul><p>…と考えるより、とりあえず発信しましょう。<br>発信することから得られることのほうが結果的に大きいです。</p><p>間違えていれば、誰かが指摘してくれます。素直に受け止めて次につなげましょう。ただただダメじゃんというFBしてくる一定の層がいますが、批判することに価値を見出している勢は、そういった視点があるという新しい学びと考えることにしましょう。</p><p>出している情報に価値を見出すのは自分ではなく他の人です。出さない情報には価値が付けられません。実は他にも同じことを知りたくて困っている人がいるかもしれないと考えることにしましょう。</p><p>エンジニアの知識は教科書どおり前から順に定着することが難しいものです。でも、きっと繰り返し継続して行っていくことで、ある日弾けるようにそれまでの知識が繋がっていくでしょう。</p><p>ぜひ今を楽しんでください。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、&lt;a href=&quot;https://www.inspace.co.jp/&quot;&gt;フューチャーインスペース株式会社&lt;/a</summary>
      
    
    
    
    <category term="Programming" scheme="https://future-architect.github.io/categories/Programming/"/>
    
    
    <category term="初心者向け" scheme="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
    <category term="情報発信" scheme="https://future-architect.github.io/tags/%E6%83%85%E5%A0%B1%E7%99%BA%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>議事メモ作成の心得</title>
    <link href="https://future-architect.github.io/articles/20210420a/"/>
    <id>https://future-architect.github.io/articles/20210420a/</id>
    <published>2021-04-19T15:00:00.000Z</published>
    <updated>2021-04-22T01:42:42.186Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。2020年10月入社の江口小夏です。<a href="/articles/20210414a/">春の入門連載2021</a>の5日目です。</p><p>新入社員の皆様、入社おめでとうございます！🌸</p><p>私は入社して約半年が経ちましたが、配属当初最も大変だと感じたのは議事メモ作成でした。この記事を読んでくださっている新入社員の方でも、議事録／議事メモ作成に時間を割いている方は多いのではないでしょうか？</p><p>私もまだまだ勉強途中ですが、少しでも議事録／議事メモを取る方の参考になればと思い筆を執りました。<br>ひとつの参考にしていただければ嬉しいです！</p><p>↓その他の議事メモ関連の記事はこちらから！↓</p><ul><li><a href="https://qiita.com/RuyPKG/items/abf72dde739e52364bcf">新人でも、楽がしたい！ ～議事録の準備～</a></li><li><a href="https://future-architect.github.io/articles/20210327/">議事録をサッと準備する</a></li></ul><h2 id="議事録-vs-議事メモ"><a href="#議事録-vs-議事メモ" class="headerlink" title="議事録 vs 議事メモ"></a>議事録 vs 議事メモ</h2><p><img src="/images/20210420a/writing.jpg"></p><p><a href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962">Free-Photos</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962">Pixabay</a>からの画像</p><p>企業やプロジェクトによって「議事録」をとるか、「議事メモ」をとるか変わると思います。<br>本ブログで扱う言葉を定義するためにも、議事録と議事メモの違いを確認しておきます。</p><p>議事録は、</p><blockquote><p>会議の内容や発言者を正確に記録し、会議の進行に沿って記載する。品質が重要で表現なども正確に記録する。</p></blockquote><p>一方で、議事メモは、</p><blockquote><p>会議の内容や発言者を正確に記録することはもちろんだが、サマリや決定事項、ToDoを明確にすることが最も重要。品質よりもスピード優先。</p></blockquote><p>自分自身の経験を踏まえて、本ブログでは<strong>議事メモ</strong>を取る場合を想定して書いていきます！</p><h2 id="議事メモ作成の目的"><a href="#議事メモ作成の目的" class="headerlink" title="議事メモ作成の目的"></a>議事メモ作成の目的</h2><p>皆さまご存知かと思いますが、念のため議事メモをとる目的を確認します。<br>（目的は、議事録でも同じ。）</p><p>主な目的は、</p><ul><li><strong>決定事項とToDoの確認と承認を得る → 認識齟齬防止</strong></li><li><strong>会議不参加者が会議内容を理解できるようにする</strong></li></ul><p>です。</p><p>特に一つ目は非常に重要なため、発言者や決定事項に対して承認を得たかはしっかり記載しておく必要があります。</p><hr><p>さてここまでで議事メモとは何か？をおさらいしました。<br>ここからは、議事メモをとる際の私なりのマインド面についてお話していきます。</p><h2 id="議事メモ作成を楽しむために"><a href="#議事メモ作成を楽しむために" class="headerlink" title="議事メモ作成を楽しむために"></a>議事メモ作成を楽しむために</h2><p>最初は「大変だな…」と感じていた議事メモ作成でしたが、徐々に議事メモを作成するのが楽しくなってきました。<br>その理由は以下のとおりです。</p><p><strong>1.議事メモとることで会議の内容を自然とおさらいできる</strong><br><strong>2.重要書類を作成するという責任感を感じる</strong></p><p>それぞれ説明していきます。</p><hr><p><strong>1. 会議の内容を自然とおさらいできる</strong></p><p>新入社員の頃は「会議の内容がさっぱり分からない…」なんてこともあるかもしれません。<br>そんな状態で会議中に議事メモ作成は大変かもしれませんが、以下のような良いこともあるかと思います。</p><ul><li><strong>議事メモ作成過程において、分からない内容や単語を再度復習・確認できる</strong></li><li><strong>発言の背景から、発言者の意図を読み取ることができる</strong></li></ul><p>結果として、会議をおさらいして自分の糧にできます。<br>キャッチアップ方法の一つとして是非議事メモを活用してみてください！</p><p><strong>2. 重要書類をつくっている責任感を感じる</strong></p><p>（「責任感＝楽しい」かどうかは人それぞれかもしれませんが…）</p><p>先ほど<a href="#%E8%AD%B0%E4%BA%8B%E3%83%A1%E3%83%A2%E4%BD%9C%E6%88%90%E3%81%AE%E7%9B%AE%E7%9A%84">議事メモ作成の目的</a>でも述べた通り、議事メモは<strong>「内容の承認を得て、認識齟齬を防止する」</strong>役割があります。これは議事メモが会議において非常に重要な書類である、ということです。</p><p>例えばスポーツでも、責任感のあるエースポジションを任されたらプレッシャーもありますが、終えたときの達成感や喜びもひとしおですよね。議事メモに対してそのようなイメージを持って、自分は楽しんでいます。</p><hr><p>これまで私なりの議事メモの楽しみ方をご紹介しました。</p><p>次に、議事メモをとる場合のコツやポイントをお伝えします。</p><p>意識するポイントなどは人それぞれですので、参考になる部分をご覧になっていただければと思います。</p><h2 id="コツ・手法"><a href="#コツ・手法" class="headerlink" title="コツ・手法"></a>コツ・手法</h2><h3 id="議事メモ作成ではここを意識しよう"><a href="#議事メモ作成ではここを意識しよう" class="headerlink" title="議事メモ作成ではここを意識しよう"></a>議事メモ作成ではここを意識しよう</h3><p>議事メモを作成するときに意識しているポイントを書いていきます。</p><hr><ul><li><strong>最低限、発言者と大まかな発言内容は確実に記録する</strong></li></ul><p>会議が進行する中で発言を一言一句漏らさずに書こうとすると、記載が間に合わないこともあります。<br>そんな時は、少なくとも<strong>発言者</strong>と<strong>何についてどんな意見を</strong>言っているのかに集中して書くと、議事メモに記載すべき最低限の内容をおさえることができます。</p><ul><li><strong>「～ため」「～ので」を聞き逃さない</strong></li></ul><p>ほとんどの発言には背景や意図、目的があります。なぜその発言があったかを、会議に出席していない人が理解するためにも重要なため、意識して聞きましょう。</p><ul><li><strong>ToDoを明確にする</strong></li></ul><p>会議で挙がったタスクやToDo事項は正確に記載する必要があります。期限やアウトプットの方法など不明点があれば、先輩など会議参加者に確認するのがベターです。</p><ul><li><strong>論点を意識して会議に臨む</strong></li></ul><p>議事メモ作成者だけに限りませんが、「この会議では何を決めなければいけないのか」を意識しておくことが大切です。</p><p>特に新入社員の頃は、会議が進行するにつれて、会議の内容に頭が追いついていけなくなることもあるかと思います。<br>しかし、会議で決めなければいけないことを頭に置いておけば、迷子になってしまったときも立ち返る基準になるはずです。</p><ul><li><strong>決定事項の合意がとれているかを確認する</strong></li></ul><p>決めなければならないことに対して顧客の合意がとれているかは非常に重要です。認識齟齬を防止するためにも、議事メモを記載するときは合意が取れているかを意識しておくと良いかと思います。</p><ul><li><strong>議事メモへの記載は時系列に沿うことよりも分かりやすさが重要</strong></li></ul><p>会議では議論が行ったり来たりすることも多々あります。</p><p>そのとき時系列順にすべて記載していると、見返したときに議事メモの内容が分かりづらくなることがあります。議論が進む中で、同じトピックに戻ったときは、時系列が違っていても同じ章に記載すると分かりやすくなります。</p><h3 id="議事メモチェックポイント"><a href="#議事メモチェックポイント" class="headerlink" title="議事メモチェックポイント"></a>議事メモチェックポイント</h3><p>会議終了後に議事メモを修正・清書するときのチェックポイントをいくつか挙げてみます。</p><hr><ul><li><strong>文章に主語があるか？</strong></li></ul><p>日本語は主語が省略されがちです。何／誰についての発言かを明確にするためにも、主語がない場合は補填しましょう。</p><ul><li><strong>分かりやすい日本語／シンプルな文章になっているか？</strong></li></ul><p>議事メモを読んで、すんなりと内容を理解できる状態にする必要があります。修正し終わった後に、顧客の会議不参加者になったつもりで議事メモを読み返してみると修正箇所が見えてきます。</p><ul><li><strong>誤字脱字、表記ゆれがないか？</strong></li></ul><p>誤字・脱字や同じ単語を別表現にしない、用語は正式名称で記載できている（略語を使っていない）かは最終チェックとして確認しましょう。</p><blockquote><p>例：プロジェクト／PJ</p></blockquote><ul><li><strong>名称は正式なものになっているか？</strong></li></ul><p>企業名や用語は略語などを使わず正式に書きましょう。</p><blockquote><p>NG:　フューチャー<br>OK： フューチャー株式会社</p></blockquote><ul><li><strong>口語が残っていないか？</strong></li></ul><p>口語体や崩れた日本語表現は適当な文章に直しましょう。</p><blockquote><p>NG:　XXXって思ってるんですよね<br>OK:　XXXと考えている。</p></blockquote><blockquote><p>NG:　XXXみたいな感じかな<br>OK:　XXXのようなイメージをしている。</p></blockquote><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>私もまだまだ勉強中の身ですが、教わったこと・学んだことをまとめてみました。<br>気を付けるべき点は会社やプロジェクトによって異なると思いますので、ひとつの参考にしていただければ幸いです。</p><p>最後まで読んでいただきありがとうございました！</p><h1 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h1><p><a href="https://qiita.com/RuyPKG/items/abf72dde739e52364bcf">新人でも、楽がしたい！ ～議事録の準備～</a><br><a href="https://future-architect.github.io/articles/20210327/">議事録をサッと準備する</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。2020年10月入社の江口小夏です。&lt;a href=&quot;/articles/20210414a/&quot;&gt;春の入門連載2021&lt;/a&gt;の5日目です。&lt;/p&gt;
&lt;p&gt;新入社員の皆様、入社おめでとうございます！🌸&lt;/p&gt;
&lt;p&gt;私は入社して約半年が経ちましたが、配属当初最</summary>
      
    
    
    
    <category term="Infrastructure" scheme="https://future-architect.github.io/categories/Infrastructure/"/>
    
    
    <category term="議事録" scheme="https://future-architect.github.io/tags/%E8%AD%B0%E4%BA%8B%E9%8C%B2/"/>
    
    <category term="春の入門連載" scheme="https://future-architect.github.io/tags/%E6%98%A5%E3%81%AE%E5%85%A5%E9%96%80%E9%80%A3%E8%BC%89/"/>
    
    <category term="新人向け" scheme="https://future-architect.github.io/tags/%E6%96%B0%E4%BA%BA%E5%90%91%E3%81%91/"/>
    
  </entry>
  
</feed>
