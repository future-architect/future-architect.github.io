<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>フューチャー技術ブログ</title>
    <link>https://future-architect.github.io/</link>
    
    <image>
      <url>https://future-architect.github.io/feed_icon.png</url>
      <title>フューチャー技術ブログ</title>
      <link>https://future-architect.github.io/</link>
    </image>
    
    <atom:link href="https://future-architect.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>フューチャーの開発者による公式技術ブログです。業務で利用している技術を幅広く紹介します。</description>
    <pubDate>Mon, 25 Oct 2021 01:22:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>AWS SDK for GoでDynamoDBの式を扱うヘルパーパッケージの使い方</title>
      <link>https://future-architect.github.io/articles/20211025a/</link>
      <guid>https://future-architect.github.io/articles/20211025a/</guid>
      <pubDate>Sun, 24 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211025a/top.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;676&quot;&gt;

&lt;p&gt;by &lt;a href=&quot;http://reneefrench.blogspot.com/&quot;&gt;Renée</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211025a/top.png" alt="" width="1200" height="676"><p>by <a href="http://reneefrench.blogspot.com/">Renée French</a></p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG真野です。</p><p>DynamoDBをGoで操作することにかけては、<a href="/tags/DynamoDB%C3%97Go/">DynamoDB×Go連載</a> に参加するくらい関心があるのですが、AWS SDK for Goの公式ライブラリに含まれる、ヘルパーパッケージについて存在を今までスルーしていました。使ってみると業務的には利用一択だと思ったので今後使っていくぞという覚書としてまとめます。</p><h2 id="DynamoDBの式をダイレクトに実装した例"><a href="#DynamoDBの式をダイレクトに実装した例" class="headerlink" title="DynamoDBの式をダイレクトに実装した例"></a>DynamoDBの式をダイレクトに実装した例</h2><p>私は公式のAWS SDK for Goの<a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/">dynamodbパッケージ</a>を用いる時に、ドキュメントのExampleに書いてあるように、ちまちま <code>ExpressionAttributeNames</code>や<code>ExpressionAttributeValues</code>や<code>FilterExpression</code>や<code>ProjectionExpression</code>を指定していました。</p><p>どんな感じかと言うと次のような感じです。</p><figure class="highlight go"><figcaption><span>Exampleに書いてあるような実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    db := dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line">    result, err := db.Scan(&amp;dynamodb.ScanInput&#123;</span><br><span class="line">        ExpressionAttributeNames: <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;#AT&quot;</span>: aws.String(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line">            <span class="string">&quot;#ST&quot;</span>: aws.String(<span class="string">&quot;SongTitle&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        ExpressionAttributeValues: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line">            <span class="string">&quot;:a&quot;</span>: &#123;</span><br><span class="line">                S: aws.String(<span class="string">&quot;No One You Know&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        FilterExpression:     aws.String(<span class="string">&quot;Artist = :a&quot;</span>),</span><br><span class="line">        ProjectionExpression: aws.String(<span class="string">&quot;#ST, #AT&quot;</span>),</span><br><span class="line">        TableName:            aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// エラーハンドリング</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> recs []Record</span><br><span class="line">    <span class="keyword">if</span> err := dynamodbattribute.UnmarshalListOfMaps(page.Items, &amp;recs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// エラーハンドリング</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これはこれで、DynamoDBのREST APIの仕様に詳しくなれるのと、AWS CLIを用いたDynamoDBアクセスする時と知識を流用できるので学びにはなるのですが、利用項目や条件が増えてくるとレビュー観点でツライですし、自分が実装するときも<code>ExpressionAttributeNames</code> が抜けていてエラーになるなど、生産性という意味では開発者側が試されているなと感じることが多かったです。</p><h2 id="ヘルパーパッケージの福音"><a href="#ヘルパーパッケージの福音" class="headerlink" title="ヘルパーパッケージの福音"></a>ヘルパーパッケージの福音</h2><p>業務でも様々な技術ブログでも DynamoDB SDK for Goを実装するときは上記のような設定をするコードをよく見ますが、実は公式に便利なヘルパーが用意されています。 <code>expression</code> パッケージです。式の組み立て全般をサポートしてくれるビルダーを提供してくれます。</p><ul><li><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/">https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/</a></li></ul><p><code>expression</code>パッケージ を用いると、<code>ExpressionAttributeNames</code> や <code>ExpressionAttributeValues</code> や <code>FilterExpression</code> などのDynamoDBの式を型安全に構築することができます。例をあげます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>), expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>))</span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db := dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line">result, err := db.Scan(&amp;dynamodb.ScanInput&#123;</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">FilterExpression:          expr.Filter(),</span><br><span class="line">ProjectionExpression:      expr.Projection(),</span><br><span class="line">TableName:                 aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expression</code> パッケージを利用して、フィルター条件やプロジェクション式を構築しています。ややコードとしては長くなりましたが、<code>dynamodb.ScanInput</code> のフィールドがの設定が一律シンプル下したことがわかります。この勢いで <code>TableName</code> も <code>expr</code> から指定したい気もしますが、それはパッケージの担当外なようです。</p><p>サンプルコードだけ見ると、心理的なハードルが高く思えるかもしれませんが、そもそも元の実装にあるような、<code>ExpressionAttributeNames</code> や <code>ExpressionAttributeValues</code> や <code>FilterExpression</code> の記載方法を覚え、正しく使用することの方が大変です。 <code>expression</code> パッケージを用いると、何かしら指定が論理的に正しくない場合は、式のビルド時にエラーで検知することができるため、開発時のトラブルシュートにも役立つと思います。</p><p>AWS SDK for Goを生で用いてDynamoDBアクセスを行うのであれば、基本的には積極的に使っていくパッケージでしょう。</p><h2 id="論理式"><a href="#論理式" class="headerlink" title="論理式"></a>論理式</h2><p>先程の例ではEqualでしたが、ドキュメントを見る通り、AND, OR, NotEqualや、LessThan, GreaterThan などなど、一通りの演算子が揃っています。選び放題・使い放題のガッツがあるパッケージです。</p><p><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/">https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/expression/</a></p><p>例えばフィルターで、Artistが Red, Green, Blue のどれかという条件を指定すると以下のようになります。</p><figure class="highlight go"><figcaption><span>OR条件を指定した例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Red&quot;</span>)).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Green&quot;</span>))).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Blue&quot;</span>)))</span><br><span class="line"></span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>), expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>もちろんAND, ORをネスト化することもできます。<code>Artist</code> が <code>Blue</code> のときは <code>Year</code> が <code>2021</code> 年であると追加します。</p><figure class="highlight go"><figcaption><span>ネストした条件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Red&quot;</span>)).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Green&quot;</span>))).</span><br><span class="line">Or(expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;Blue&quot;</span>)).</span><br><span class="line">And(expression.Name(<span class="string">&quot;Year&quot;</span>).Equal(expression.Value(<span class="string">&quot;2021&quot;</span>))),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>式で表現すると <code>Artist == Red || Artist == Green || (Artist == Blue &amp;&amp; Year == 2021)</code> といった感じでしょうか。式が複雑になる場合はこういった擬似コードでコメントの補足を入れると良いかなと思います。</p><h2 id="ProjectionExpressionを指定するのが面倒問題"><a href="#ProjectionExpressionを指定するのが面倒問題" class="headerlink" title="ProjectionExpressionを指定するのが面倒問題"></a>ProjectionExpressionを指定するのが面倒問題</h2><p><code>expression</code>パッケージを利用していくと、Projectionの設定が面倒な場合があります。</p><figure class="highlight go"><figcaption><span>面倒な例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line"></span><br><span class="line">proj := expression.NamesList(expression.Name(<span class="string">&quot;SongTitle&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;Rate&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;PublishedAt&quot;</span>),</span><br><span class="line"> expression.Name(<span class="string">&quot;Price&quot;</span>))  <span class="comment">// やたら数が多くなるし項目追加時に見逃しやすい</span></span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合は自前で一工夫すると良いでしょう。ヘルパー関数をさらに作っても良いかもしれません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filt := expression.Name(<span class="string">&quot;Artist&quot;</span>).Equal(expression.Value(<span class="string">&quot;No One You Know&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []expression.NameBuilder</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;SongTitle&quot;</span>, <span class="string">&quot;AlbumTitle&quot;</span>, <span class="string">&quot;Rate&quot;</span>, <span class="string">&quot;PublishedAt&quot;</span>, <span class="string">&quot;Price&quot;</span>&#125; &#123;</span><br><span class="line">names = <span class="built_in">append</span>(names, expression.Name(name))</span><br><span class="line">&#125;</span><br><span class="line">proj := expression.NamesList(names[<span class="number">0</span>], names[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithFilter(filt).WithProjection(proj).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このあたりを作り込みすぎると、独自DSLを作るような感じになるかと思いますが、愚直に書きすぎると表現の密度が下がりすぎて保守がツライ場合もあるので、バランスを見て取り入れて行くと良いかなと思います。</p><h2 id="クエリの場合"><a href="#クエリの場合" class="headerlink" title="クエリの場合"></a>クエリの場合</h2><p>先程まではScanの例でしたが、Queryの場合はさらに <code>expression</code> が役立ちます。ハッシュキーにDeviceID、ソートキーにTimestampという典型的な時系列データを保持するDeviceLogというテーブルに対しての実装例です。</p><figure class="highlight go"><figcaption><span>クエリの実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryTable</span><span class="params">(ctx context.Context, deviceID <span class="keyword">string</span>, start, end time.Time)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">keyCond := expression.Key(<span class="string">&quot;DeviceID&quot;</span>).Equal(expression.Value(deviceID)).</span><br><span class="line">And(expression.Key(<span class="string">&quot;Timestamp&quot;</span>).Between(</span><br><span class="line">expression.Value(start.Format(time.RFC3339)),</span><br><span class="line">expression.Value(end.Format(time.RFC3339))))</span><br><span class="line"></span><br><span class="line">filterCond := expression.Name(<span class="string">&quot;DeviceType&quot;</span>).Equal(expression.Value(<span class="string">&quot;Normal&quot;</span>)).</span><br><span class="line">And(expression.Name(<span class="string">&quot;CreatedYear&quot;</span>).GreaterThan(expression.Value(<span class="number">2018</span>)))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithKeyCondition(keyCond).WithFilter(filterCond).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result, err := db.QueryWithContext(ctx, &amp;dynamodb.QueryInput&#123;</span><br><span class="line">KeyConditionExpression:    expr.KeyCondition(),</span><br><span class="line">ProjectionExpression:      expr.Projection(),</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">FilterExpression:          expr.Filter(),</span><br><span class="line">TableName:                 aws.String(<span class="string">&quot;DeviceLog&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>あるデバイスに対して、開始～終了日時を指定し、さらに適当なフィルター条件も追加しました。クエリの場合は、<code>KeyConditionExpression</code>と <code>FilterExpression</code> の両方が設定できるため、<code>expression</code> パッケージを利用しない時は<code>ExpressionAttributeNames</code> と <code>ExpressionAttributeValues</code> の管理が煩雑になりがちでした。</p><h2 id="Update-Expression"><a href="#Update-Expression" class="headerlink" title="Update Expression"></a>Update Expression</h2><p>DynamoDBに対するUpdate式も、クエリと同様になかなかとっつき難かったです。<code>expression</code>パッケージを用いない場合は、通常の文字列なのでカンマの位置などかなり気をつけることが多いです。</p><figure class="highlight go"><figcaption><span>実装例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">_, err := db.UpdateItemWithContext(ctx, &amp;dynamodb.UpdateItemInput&#123;</span><br><span class="line">TableName:        aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">Key: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;Artist&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Acme Band&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;SongTitle&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Happy Day&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeNames: <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;#AT&quot;</span>:  aws.String(<span class="string">&quot;AlbumTitle&quot;</span>),</span><br><span class="line"><span class="string">&quot;#Y&quot;</span>:   aws.String(<span class="string">&quot;Year&quot;</span>),</span><br><span class="line"><span class="string">&quot;#REV&quot;</span>: aws.String(<span class="string">&quot;Revision&quot;</span>),</span><br><span class="line"><span class="string">&quot;#UPA&quot;</span>: aws.String(<span class="string">&quot;UpdatedAt&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeValues: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;:t&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Louder Than Ever&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:y&quot;</span>: &#123;</span><br><span class="line">N: aws.String(<span class="string">&quot;2015&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:inc&quot;</span>: &#123;</span><br><span class="line">N: aws.String(<span class="string">&quot;1&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;:upa&quot;</span>: &#123;</span><br><span class="line">S: aws.String(time.Now().UTC().Format(time.RFC3339)),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">UpdateExpression: aws.String(<span class="string">&quot;SET #Y = :y, #AT = :t, #UPA = :upa ADD #REV :inc&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これは <code>expression</code> パッケージを用いると次のようになります。</p><figure class="highlight go"><figcaption><span>expressionを用いたUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = dynamodb.New(session.Must(session.NewSession()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">update := expression.Set(expression.Name(<span class="string">&quot;AlbumTitle&quot;</span>), expression.Value(<span class="string">&quot;Louder Than Ever&quot;</span>)).</span><br><span class="line">Set(expression.Name(<span class="string">&quot;Year&quot;</span>), expression.Value(<span class="string">&quot;2015&quot;</span>)).</span><br><span class="line">Set(expression.Name(<span class="string">&quot;UpdatedAt&quot;</span>), expression.Value(time.Now())).</span><br><span class="line">Add(expression.Name(<span class="string">&quot;Revision&quot;</span>), expression.Value(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">expr, err := expression.NewBuilder().WithUpdate(update).Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := db.UpdateItemWithContext(ctx, &amp;dynamodb.UpdateItemInput&#123;</span><br><span class="line">TableName: aws.String(<span class="string">&quot;Music&quot;</span>),</span><br><span class="line">Key: <span class="keyword">map</span>[<span class="keyword">string</span>]*dynamodb.AttributeValue&#123;</span><br><span class="line"><span class="string">&quot;Artist&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Acme Band&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;SongTitle&quot;</span>: &#123;</span><br><span class="line">S: aws.String(<span class="string">&quot;Happy Day&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeNames:  expr.Names(),</span><br><span class="line">ExpressionAttributeValues: expr.Values(),</span><br><span class="line">UpdateExpression:          expr.Update(),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>式の構築部分が型セーフに実装できていることが分かると思います。</p><p>少し残念なのは、 <code>Key</code> の部分は <code>expr</code> から生成できないということでしょうか。ここだけはハッシュキー（とソートキー）をダイレクトに指定する必要があるので、レベル感がズレて勿体ない気がします。（KeyConditionのように指定したかったですね）</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>AWS SDK for Goの <code>dynamodb</code> パッケージを用いると時に必須とも言える、 <code>expression</code> パッケージの使い方について触れました。</p><p><code>expression</code> パッケージを用いると、従来DynamoDBのAPI仕様を理解したフィールドや、文字列で式を設定する必要があった部分を、型安全に構築することができます。</p><p>いくつか残念なところはあるにしろ、メリットは計り知れないのでうまく活用していきたいですね。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/DynamoDB/">DynamoDB</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%BC%8F/">式</category>
      
      
      <comments>https://future-architect.github.io/articles/20211025a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Google Drive API v3をサービスアカウトとGoから利用</title>
      <link>https://future-architect.github.io/articles/20211022a/</link>
      <guid>https://future-architect.github.io/articles/20211022a/</guid>
      <pubDate>Thu, 21 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;TIG真野です。&lt;/p&gt;
&lt;p&gt;Google</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG真野です。</p><p>Google DriveにアップロードされたExcelファイルを利用したちょっとしたジョブを実装する機会があり、処理を動かしたいのがAWSなど別のプラットフォームであったため、サービスアカウントを用いてGoogle Drive APIにアクセスするGoプログラムを作りました。</p><p>いくつかの人が書いている通り、Google Drive APIもv2, v3で情報が入り乱れていて本家のドキュメントを探したて見ながら試行錯誤したりちょっと悩みました。また、サービスアカウント利用する実装例が少なかったので手順をまとめていきます。</p><h2 id="認証方式"><a href="#認証方式" class="headerlink" title="認証方式"></a>認証方式</h2><p>Google Drive APIを用いたコード実装を始める前に、事前にアカウントなどの権限周りの準備を実施します。</p><p>Google Drive APIを使うための<a href="https://cloud.google.com/docs/authentication?hl=ja#getting_credentials_for_server-centric_flow">認証方式</a>には大きく4つの方法があります。</p><ol><li><strong>APIキー</strong>: 一般公開データに匿名でアクセスする</li><li><strong>OAuth2</strong>: エンドユーザーに代わって限定公開データにアクセスする</li><li><strong>環境提供のサービス アカウント</strong>: Google Cloud 環境内でサービス アカウントに代わって限定公開データにアクセスする</li><li><strong>サービスアカウント</strong>: Google Cloud 環境外でサービス アカウントに代わって非公開データにアクセスする</li></ol><p>今回はGCP以外の環境で動かしたいので、4のサービスアカウントを利用します。</p><h2 id="サービスアカウントの払い出し"><a href="#サービスアカウントの払い出し" class="headerlink" title="サービスアカウントの払い出し"></a>サービスアカウントの払い出し</h2><p>サービスアカウントはGCPのProjectに紐づきます。もし利用できるProjectが存在しなければ<a href="https://console.cloud.google.com/cloud-resource-manager">リソース管理ページ</a>から作成します。詳しくは<a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects">プロジェクトの作成と管理 - Google Cloud</a>を確認下さい。</p><p>続いて、Projectの<a href="https://console.cloud.google.com/apis/library/drive.googleapis.com">Google Drive API</a> から、Google Drive APIを有効にします。有効にしないとこのProjectから払い出したサービスアカウントの認証情報では、Google Drive APIを利用できないです。</p><img src="/images/20211022a/Google_Drive_APIの有効化.png" alt="Google_Drive_APIの有効化.png" width="1200" height="640" loading="lazy"><p>続いて、<a href="https://console.cloud.google.com/apis/api/drive.googleapis.com/credentials">APIとサービスにある、Google Drive APIの認証情報</a>タブから、「認証情報を作成」をクリックして、サービスアカウントの作成を行います。今回は適当に、google-drive-exampleという名前にしました。</p><img src="/images/20211022a/認証情報を作成.png" alt="認証情報を作成.png" width="1200" height="470" loading="lazy"><p>数十秒待つと、サービスアカウントの作成されます。その後は、サービスアカウントの「キー」から、キーを作成します。タイプはJSONで良いと思います。</p><img src="/images/20211022a/image.png" alt="image.png" width="1200" height="628" loading="lazy"><p>ダウンロードしたJSONファイルは大事に保存します。AWS上で使う場合は、AWS Systems Manager Parameter StoreにSecureString属性をつけて保存し利用すると良いでしょう。</p><h2 id="サービスアカウントのDriveへのアクセス権限を追加"><a href="#サービスアカウントのDriveへのアクセス権限を追加" class="headerlink" title="サービスアカウントのDriveへのアクセス権限を追加"></a>サービスアカウントのDriveへのアクセス権限を追加</h2><p>先程作成したサービスアカウントの <code>google-drive-example@xxxx-xxxx-123456.iam.gserviceaccount.com</code> に、アクセスしたいGoogle Drive先の権限を付与します。</p><p>アクセスさせたいフォルダなどを右クリックして、「共有」から先程のアカウントIDを指定します。</p><img src="/images/20211022a/権限付与.png" alt="権限付与.png" width="1200" height="388" loading="lazy"><p>これでgoogle-drive-exampleのIDから、Google Drive APIを用いて指定のフォルダにアクセスできるようになりました。</p><h2 id="実装（List）"><a href="#実装（List）" class="headerlink" title="実装（List）"></a>実装（List）</h2><p>GoからGoogle Drive API v3を利用します。</p><figure class="highlight sh"><figcaption><span>パッケージ取得</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/api/drive/v3</span><br></pre></td></tr></table></figure><p>まず指定されたフォルダ配下にあるファイルの一覧表示します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;google.golang.org/api/drive/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name)&quot;</span>).</span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line"><span class="built_in">println</span>(f.Name, f.Id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行する前に先程取得したJSONキーファイルを環境変数で指定する必要があります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOOGLE_APPLICATION_CREDENTIALS=./project-name-123456789abc.json</span><br></pre></td></tr></table></figure><p>環境変数に <code>GOOGLE_APPLICATION_CREDENTIALS</code> が設定されていれば、SDK側が自動で認証してくれます。詳しくは<a href="https://cloud.google.com/docs/authentication/production">サービス アカウントとして認証する - Google Cloud</a> を参照下さい。</p><p>実行すると、先程権限を付与したフォルダ配下のファイル一覧が取得できると思います。</p><h2 id="実装（ダウンロード）"><a href="#実装（ダウンロード）" class="headerlink" title="実装（ダウンロード）"></a>実装（ダウンロード）</h2><p>続いて、フォルダにExcelファイルがアップロードされているとして、それらをダウンロードします。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package, import 部分は省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name, mimeType)&quot;</span>). <span class="comment">// mimeTypeを追加する</span></span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line"><span class="keyword">if</span> f.MimeType == <span class="string">&quot;application/vnd.google-apps.folder&quot;</span> &#123;</span><br><span class="line"><span class="comment">// フォルダの場合はスキップ</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := download(ctx, srv, f.Name, f.Id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to download: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(ctx context.Context, srv *drive.Service, name, id <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">create, err := os.Create(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;create file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> create.Close()</span><br><span class="line"></span><br><span class="line">resp, err := srv.Files.Get(id).Context(ctx).Download()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;get drive file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(create, resp.Body); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write file: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>さきほどのList表示するコードと大部分は同じですが、mimeTypeを追加で設定しているのはご注意下さい。Fieldsに指定できる項目は<a href="https://developers.google.com/drive/api/v3/reference/files">Google Drive APIの開発者ページのfiles</a>に記載がありました。</p><p>今回はmimeTypeでフォルダに対してはダウンロード処理をしないようにスキップ処理を入れています。</p><p>ダウンロードですが、今回はExportではなくGetを利用しています。スプレッドシートの場合はExportを呼び出しxlsx形式にする必要があるかもしれませんが、単純にバイナリをそのまま落とすのであればGetです。</p><p>こちらを実行すると、権限付与したフォルダ配下のファイルを全て取得できると思います。</p><h2 id="指定したフォルダ配下のみのファイルをダウンロードしたい"><a href="#指定したフォルダ配下のみのファイルをダウンロードしたい" class="headerlink" title="指定したフォルダ配下のみのファイルをダウンロードしたい"></a>指定したフォルダ配下のみのファイルをダウンロードしたい</h2><p><a href="https://developers.google.com/drive/api/v3/reference/files/list">Google Drive APIの Files: list</a>を確認すると<code>q</code>オプションで検索対象の絞り込みが可能です。いくつか<a href="https://developers.google.com/drive/api/v3/search-files">検索例</a>がドキュメントに記載されています。</p><p><code>&#39;1234567&#39; in parents</code> といった例が記載されていますが、1234567には指定したいフォルダのIDを設定します。IDはブラウザで開いた時にURLで設定されている値です。複数を指定したい場合は <code>or</code> 条件で追加も可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;files(id, name, mimeType, parents)&quot;</span>).</span><br><span class="line">Q(fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; in parents or &#x27;%s&#x27; in parents&quot;</span>, <span class="string">&quot;1234567&quot;</span>, <span class="string">&quot;890abcd&quot;</span>)). <span class="comment">// 特定のフォルダ配下</span></span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>どういった検索条件を指定できるかは、文法としてまとまっているので迷ったら確認すると早いです。</p><ul><li><a href="https://developers.google.com/drive/api/v3/ref-search-terms">https://developers.google.com/drive/api/v3/ref-search-terms</a></li></ul><h2 id="フォルダ指定かつ再帰的にファイルを探索したい"><a href="#フォルダ指定かつ再帰的にファイルを探索したい" class="headerlink" title="フォルダ指定かつ再帰的にファイルを探索したい"></a>フォルダ指定かつ再帰的にファイルを探索したい</h2><p>さきほどの <code>q</code> の指定で再帰的にファイルを指定するのは難しいです。</p><p>例えば、以下のようにネストした構造を保つ場合に、targetFolderのファイルIDを指定しても取得できるのは folder1, folder2までです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">targetFolder</span><br><span class="line">  └ folder1</span><br><span class="line">  |   └ file1.xlsx</span><br><span class="line">  |   └ file2.xlsx</span><br><span class="line">  └ folder2</span><br><span class="line">      └ file3.xlsx</span><br></pre></td></tr></table></figure><p>この場合は自前で再帰的にList APIをコールする処理を実装する必要があります。少し面倒ですね。少し面倒ですが、最初の実装にあるとおり、OR条件で親フォルダを決め打ちで指定するのが簡単で良いかもしれません。</p><p>（parents は複数要素が設定されると思うので、ネストした親フォルダも設定できた場合は、<code>q</code> に <code>&#39;FILE-ID&#39; in parents</code> の指定で実現できそうです。設定方法がよく分からず今回は上記の結論となりました）</p><h2 id="ページング"><a href="#ページング" class="headerlink" title="ページング"></a>ページング</h2><p>List APIのドキュメントを確認すると、pageSizeはデフォルトが100で、最大が1000までです。これを超過する場合は、pageTokenを指定してページング処理を行う（複数回APIをコールする）必要があります。</p><ul><li><a href="https://developers.google.com/drive/api/v3/reference/files/list">https://developers.google.com/drive/api/v3/reference/files/list</a></li></ul><p>簡単な実装例です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package, import 部分は省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">srv, err := drive.NewService(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve Drive client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> paging <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r, err := srv.Files.List().PageSize(<span class="number">1000</span>).</span><br><span class="line">Fields(<span class="string">&quot;nextPageToken, files(id, name, parents)&quot;</span>). <span class="comment">// nextPageTokenをFiledsに追加</span></span><br><span class="line">PageToken(paging).</span><br><span class="line">Context(ctx).Do()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to retrieve files: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.Files &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s %s %+v\n&quot;</span>, f.Name, f.Id, f.Parents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">paging = r.NextPageToken</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(paging) == <span class="number">0</span> &#123; <span class="comment">// 次のページング先が無ければ終了</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ファイル数が1000を超過する可能性がある場合は、忘れないようにしたいですね。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>サービスアカウントを用いて、Google Drive API v3をGo SDKを用いて操作する例をいくつかまとめました。Google Drive上のファイルにアクセスできると、システムやアプリに機能として組み込まなくても、ちょっとした業務を効率化することができると思います。うまく役立てていけると良いなと考えています。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/GoogleDrive/">GoogleDrive</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88/">サービスアカウント</category>
      
      <category domain="https://future-architect.github.io/tags/GoogleWorkspace/">GoogleWorkspace</category>
      
      
      <comments>https://future-architect.github.io/articles/20211022a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>FigmaからFlutterに変換するプラグインを比較する</title>
      <link>https://future-architect.github.io/articles/20211021a/</link>
      <guid>https://future-architect.github.io/articles/20211021a/</guid>
      <pubDate>Wed, 20 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;フューチャーでは、FigmaやAdobe</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャーでは、FigmaやAdobe XDなどのデザインツールの利用が以前よりも少しづつ増えています。今回の題材はFigmaです。</p><p>先月の「<a href="https://future-architect.github.io/articles/20210915a/">Adobe XDからFlutterに変換する</a>」の記事では、Adobe XDで作成したデザインをFlutterコードに落とし込むためのTipsを渋川さんが紹介してくれました。XD→Flutterの変換は、<a href="https://blog.adobe.com/jp/publish/2020/09/25/cc-web-xd-flutter-plugin-now-available.html">AdobeとGoogleが協力して開発している</a>プラグインがあるため、変換ツールの選択肢で迷うことはあまり無いのかなと思います。</p><p>それに対して、Figma→Flutterの変換は公式で開発 or 推奨されているツールが無く、様々な個人・企業が出しているツールからどれかを選択して利用する必要があります。この記事では、<strong>Figma→Flutterの変換をサポートする主なツールを紹介し、実際にそれらを使ってFlutterコードを出力した結果の比較を行っていきます。</strong>「Figmaからのコード生成って色々な方法があって何が良いのかよく分からん！」という人の参考になれば嬉しいです。</p><h1 id="Figma→Flutterを実現する方法"><a href="#Figma→Flutterを実現する方法" class="headerlink" title="Figma→Flutterを実現する方法"></a>Figma→Flutterを実現する方法</h1><p>FigmaからFlutter用のdartコードを生成する方法は主に以下の2パターンが存在するようです。</p><ol><li>Figmaのプラグインを使う方法</li><li>Figmaプラグインではない外部のサービスを利用する方法</li></ol><p>それぞれを紹介していきます。</p><h3 id="Figmaのプラグインを使う方法"><a href="#Figmaのプラグインを使う方法" class="headerlink" title="Figmaのプラグインを使う方法"></a>Figmaのプラグインを使う方法</h3><p>FigmaをFlutterに変換できると謳っているプラグインは複数存在していて、個人がメインで開発しているものから、企業が公開しているものまで様々です。ここでは、2021年10月時点のインストール数の上位4つを紹介します。<br>（<a href="https://www.figma.com/community/search?model_type=public_plugins&q=flutter">Figma Communityのページで検索する</a>と、インストール数がもっと少ないものもいくつか出てきます。）</p><p><strong>① Figma to Code（HTML, Tailwind, Flutter, SwiftUI）</strong></p><img src="/images/20211021a/Figma_to_Code.png" alt="Figmaからコード生成イメージ" width="1200" height="600" loading="lazy"><p>インストール数：28.5k<br>最終更新日：2021年3月9日</p><p><a href="https://www.figma.com/community/plugin/842128343887142055/Figma-to-Code-(HTML%2C-Tailwind%2C-Flutter%2C-SwiftUI)">Figma to Code (HTML, Tailwind, Flutter, SwiftUI</a>は、Bernardo Ferrariという人が主に開発をしているプラグインで、ソースが<a href="https://github.com/bernaferrari/FigmaToCode">githubに公開</a>されています。Figma→Flutter以外にもSwiftUI、tailwindcss、HTML5にも対応しているようですが、今回はFlutterの出力のみを試してみます。</p><p><strong>② Flutter Export</strong><br><img src="/images/20211021a/thumbnail-1.png" alt="Flutter Exportアイコン" width="1200" height="600" loading="lazy"><br>インストール数：11.3k<br>最終更新日：2019年11月22日</p><p><a href="https://www.figma.com/community/plugin/778755750523021654/Flutter-Export">Flutter Export</a>は、とてもFlutterに変換できそうな名前が付いていますが、Figmaで作ったものをPNG画像で出力するだけのプラグインのようです。インストールして少し試してみましたが、上手く動かすことができませんでした。最終更新日も約2年前と古く、メンテもされていなそうなので、今回の<strong>比較対象外</strong>とします。<br>（インストール数が少し多い理由が謎です。）</p><p><strong>③ FigmaToFlutter</strong><br><img src="/images/20211021a/thumbnail-2.png" alt="thumbnail-2.png" width="1200" height="600" loading="lazy"><br>インストール数：10.8k<br>最終更新日：2021年1月2日</p><p><a href="https://www.figma.com/community/plugin/844008530039534144/FigmaToFlutter">FigmaToFlutter</a>は、1つ目のFigma to Codeと同様に個人が開発しているプラグインで、使い方も非常に似ています。今回の<strong>比較対象</strong>とします。</p><p><strong>④ Assistant by Grida</strong><br><img src="/images/20211021a/thumbnail-3.png" alt="Assistant by Gridaイメージ" width="1200" height="600" loading="lazy"><br>インストール数：4.7k<br>最終更新日：2021年8月25日</p><p><a href="https://www.figma.com/community/plugin/896445082033423994/Assistant-by-Grida">Assistant by Grida</a>は、以前はBridgedという名前だったプラグインです。</p><p>Gridaという組織が開発しているようですが、<a href="https://www.grida.co/">Gridaのページ</a>を見てもGridaがどういう組織なのか（企業なのかどうかも）分からずでした。Gridaのページにはプラグインの<a href="https://www.grida.co/docs/getting-started">ドキュメント</a>もありますが、空ページが多かったり、まだ発展途上な感が否めないですが、今回の<strong>比較対象</strong>とします。</p><h3 id="Figmaのプラグイン以外を使う方法"><a href="#Figmaのプラグイン以外を使う方法" class="headerlink" title="Figmaのプラグイン以外を使う方法"></a>Figmaのプラグイン以外を使う方法</h3><p>Figmaのプラグインを使う方法以外にも、Figmaからコードを生成する方法はあるようです。<br>以下2つを紹介します。</p><p><strong>⑤ Flutlab.io</strong><br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.29.55.png" alt="Flutlab.ioイメージ" width="1031" height="460" loading="lazy"></p><p><a href="https://flutlab.io/">FlutLab.io</a>は、Flutter用のオンラインIDE（総合開発環境）で、その中の機能としてFigma to Flutter Converterというものがあるようです。オンラインIDEは、セキュリティ等のポリシー上、実際のPJで利用できるかが不透明なため、今回は<strong>比較対象外</strong>とします。</p><p><strong>⑥ Bravo Studio</strong><br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.30.51.png" alt="Bravo Studioイメージ図" width="927" height="432" loading="lazy"></p><p><a href="https://www.bravostudio.app/">Bravo Studio</a>は、デザインツールで作成したデザインをノーコードでアプリに変換するサービスです。最終的にネイティブコードを出力できたり、APIを叩く等の機能性を持たせることができたりするようで面白そうです。<br>ただし、このツール自体の使い方のキャッチアップが割と必要そうな印象を受けた（コードを上手く出力するためにFigma側のLayerの命名を調整する必要がある等）のと、実際のPJで利用できるだけの自由度があるかが未知数だったので、今回は<strong>比較対象外</strong>とします。</p><h3 id="今回の検証対象"><a href="#今回の検証対象" class="headerlink" title="今回の検証対象"></a>今回の検証対象</h3><p>様々なFigma→Flutterの実現方法を紹介してきましたが、今回の比較対象は以下の3つのFigmaプラグインとします。</p><ul><li><a href="https://www.figma.com/community/plugin/842128343887142055/Figma-to-Code-(HTML%2C-Tailwind%2C-Flutter%2C-SwiftUI)">Figma to Code (HTML, Tailwind, Flutter, SwiftUI</a></li><li><a href="https://www.figma.com/community/plugin/844008530039534144/FigmaToFlutter">FigmaToFlutter</a></li><li><a href="https://www.figma.com/community/plugin/896445082033423994/Assistant-by-Grida">Assistant by Grida</a></li></ul><h1 id="Figma→Flutterを試して比較してみる"><a href="#Figma→Flutterを試して比較してみる" class="headerlink" title="Figma→Flutterを試して比較してみる"></a>Figma→Flutterを試して比較してみる</h1><h2 id="比較方法"><a href="#比較方法" class="headerlink" title="比較方法"></a>比較方法</h2><h3 id="比較で使うFigmaとエクスポートの粒度"><a href="#比較で使うFigmaとエクスポートの粒度" class="headerlink" title="比較で使うFigmaとエクスポートの粒度"></a>比較で使うFigmaとエクスポートの粒度</h3><p>今回は、Figma上で作った以下のログイン画面をFlutterのコードに変換できるかを試していきます。<br><img src="/images/20211021a/スクリーンショット_2021-10-08_14.44.54.png" alt="スクリーンショット_2021-10-08_14.44.54.png" width="543" height="434" loading="lazy"><br>「<a href="https://future-architect.github.io/articles/20210915a/">Adobe XDからFlutterに変換する</a>」の記事では、一つの画面を丸ごとエクスポートするのは、AdobeとGoogleが協力して開発しているプラグインであっても中々上手くいかないことが多く、要素ごとにエクスポートをして貼り付けていくことを推奨していました。</p><p>よって、今回のFigma→Flutterの検証では様々な粒度でのエクスポートを試していきます。具体的には下記の<strong>①〜③</strong>を試していきます。下図の<strong>画面全体</strong>は、OS側で描画するホームバー等もFigma上で表現してしまっていて、それらの要素を省くと<strong>①ログインフォーム全体</strong>との差分があまり無くなるので今回の検証では省略します。<br><img src="/images/20211021a/スクリーンショット_2021-10-11_15.24.18.png" alt="スクリーンショット_2021-10-11_15.24.18.png" width="911" height="525" loading="lazy"></p><p>また<strong>①〜③</strong>のUIパーツ生成の検証に加え、画像の扱いについても比較検証を行いたいと思います。</p><h3 id="比較で使うdartコード"><a href="#比較で使うdartコード" class="headerlink" title="比較で使うdartコード"></a>比較で使うdartコード</h3><p>Android Studioで新規のFlutterプロジェクトを作り、<a href="https://flutter.dev/docs/get-started/test-drive?tab=androidstudio">生成されるデモアプリ</a>のScaffoldからheaderとbodyの中身を消した状態にして、body部分にプラグインが生成したdartコードをそのまま貼っていきます。ログインフォームが画面の中央部あたりに来るようにCenterウィジェットで囲っておきます。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">          child: <span class="comment">//ここにコードを貼り付けていきます</span></span><br><span class="line">          ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比較結果"><a href="#比較結果" class="headerlink" title="比較結果"></a>比較結果</h2><h3 id="比較①-ログインフォーム全体の出力"><a href="#比較①-ログインフォーム全体の出力" class="headerlink" title="比較①　ログインフォーム全体の出力"></a>比較①　ログインフォーム全体の出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_13.47.58.png" alt="ログインフォーム" width="340" height="231" loading="lazy"></td><td><img src="/images/20211021a/login_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/login_figma2flutter.png" alt="figma to flutter" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/login_assistantByGrida.png" alt="assistanbe by grid結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ログインフォーム全体を出力対象として、各プラグインで出力した結果を上に示しています。<br>出力結果がプラグインによって全く異なるため、一つづつ見てきましょう。</p><p>まず、<strong>Figma to Code</strong>は、最も生成されたコードの質が高かったです。ContainerでそれぞれのUI要素の枠組みを作り、ColumnとRowで並べて、Sized Boxで要素間の隙間を作っていて、比較的可読性も高いコードになっていました。工事現場のような黄色と黒の線が出ているのは一番外側のContainerのheightが足りなく、中の要素がはみ出しているためです。これは、足りないheightの値を調整するだけで解消しました。<br>入力欄やボタンを判別することはできないようなので、生成されたコードはただの箱が並んでいるだけですが、生成結果をベースとしながら手直しをしていく前提で考えれば、割と実用的かなという印象です。</p><p>次の<strong>FigmaToFlutter</strong>は、エラーが出てしまいました。少し手直ししてエラーを解消すればいいというレベルじゃないくらいそもそものコードの中身が足りていなかったです。出力対象をもっとシンプルにして、何かが変わるかを見てみたいと思います。</p><p>最後の<strong>Assistant by Grida</strong>は、テキストしか出力されず、惜しい結果となりました。生成されたコードを見ても、テキスト以外の要素を出そうとした形跡は無かったです。こちらについても、出力対象をもっとシンプルにして、何が変わるかを見てみたいと思います。</p><h3 id="比較②-ログインボタンのみの出力"><a href="#比較②-ログインボタンのみの出力" class="headerlink" title="比較②　ログインボタンのみの出力"></a>比較②　ログインボタンのみの出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_14.00.39.png" alt="ログインボタン" width="338" height="154" loading="lazy"></td><td><img src="/images/20211021a/button_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/button_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/button_assistantByGrida.png" alt="Assistant by Grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ログインのボタン（青いボタンとログインのテキスト）を出力対象として、各プラグインで出力した結果を上に示しています。出力結果を一つづつ見てきましょう。</p><p>まず、<strong>Figma to Code</strong>は、問題ない出力結果で、1つ目の検証で起こっていた「要素のはみ出し」現象も無くなりました。</p><p>次の<strong>FigmaToFlutter</strong>は、再びエラーが出てしまいました。FigmaToFlutterが生成するコードでは、Figma to Codeと異なり、Stackウィジェットが使われています。Stackウィジェットは要素を重ねるときに使うウィジェットなので、Figma上の要素の重なり方が出力結果に何かしら影響している可能性があります。（今回のケースの出力対象は「ログイン」というテキスト部分と青い角丸の四角部分を重ねて作っています。）よって、出力対象を更にシンプルにして、要素の重なりが全く無い場合どうなるかを見てみようと思います。</p><p>最後の<strong>Assistant by Grida</strong>は、一見何も表示されていないように見えますが、白い「ログイン」という字だけ表示されていて、背景と同化してしまっています。こちらについても生成コードがStackウィジェットを使っているので、Figma上の要素の重なりが無くなると出力品質が変わってくるかもしれません。</p><h3 id="比較③-ログインボタンの箱のみの出力"><a href="#比較③-ログインボタンの箱のみの出力" class="headerlink" title="比較③　ログインボタンの箱のみの出力"></a>比較③　ログインボタンの箱のみの出力</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/スクリーンショット_2021-10-11_14.05.06.png" alt="Figmaログインボックスのみ" width="338" height="73" loading="lazy"></td><td><img src="/images/20211021a/box_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/box_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/box_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>最後に、ログインのボタンの箱（青い角丸の四角）部分のみを出力対象として、各プラグインで出力した結果を上に示しています。</p><p>まず、<strong>Figma to Code</strong>は、問題ない出力結果でした。安定感があります。</p><p>次の<strong>FigmaToFlutter</strong>は、初めてエラーが出ず、出力結果としても問題ないものになりました。やはり、少しでも要素の重なりがあると上手く動いてくれない傾向があるようです。あまり実用的ではないですね。</p><p>最後の<strong>Assistant by Grida</strong>では、やっとテキスト以外の要素を出力することができましたが、角丸の表現ができておらず、サイズも正しくありません。</p><h3 id="比較④-画像の扱い"><a href="#比較④-画像の扱い" class="headerlink" title="比較④　画像の扱い"></a>比較④　画像の扱い</h3><div class="scroll"><table><thead><tr><th>出力対象(Figma)</th><th>Figma to Code</th><th>FigmaToFlutter</th><th>Assistant by Grida</th></tr></thead><tbody><tr><td><img src="/images/20211021a/Logo.png" alt="ロゴ" width="1200" height="513" loading="lazy"></td><td><img src="/images/20211021a/png_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/png_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/png_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr><tr><td><img src="/images/20211021a/SVGロゴ.png" alt="svgロゴ" width="74" height="67" loading="lazy"></td><td><img src="/images/20211021a/svg_figma2code.png" alt="figma to code結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/svg_figma2flutter.png" alt="figma to flutter結果" width="357" height="698" loading="lazy"></td><td><img src="/images/20211021a/svg_assistantByGrida.png" alt="assistant by grida結果" width="357" height="698" loading="lazy"></td></tr></tbody></table></div><p>ラスター画像、ベクター画像をそれぞれ出力対象として、各プラグインで出力した結果を上に示しています。</p><p>まず、<strong>Figma to Code</strong>は、全ての画像をFlutterLogo()に差し替えてしまいます。画像を表示させる気がそもそも無さそうですね。</p><p>次の<strong>FigmaToFlutter</strong>は、画像の扱いが最も優れていました。ラスター画像の場合はAssetImageを使って表示をするコードが生成され、ベクター画像の場合は<a href="https://pub.dev/packages/flutter_svg">flutter_svg</a>パッケージを使ったコードを生成してくれます。また、画像ファイル自体をプラグインの画面上でダウンロードもできるようになっていました。</p><p>最後の<strong>Assistant by Grida</strong>では、下記のようなImage.network()を使ったコードが生成されますが、”grida://“で始まるURLが上手く動作しません。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">&quot;grida://assets-reservation/images/13902:10114&quot;</span>,</span><br><span class="line">  width: <span class="number">315</span>,</span><br><span class="line">  height: <span class="number">134</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="比較結果まとめ"><a href="#比較結果まとめ" class="headerlink" title="比較結果まとめ"></a>比較結果まとめ</h3><p>Figma→Flutterを実現するためのプラグインの比較を行ってきました。比較結果を以下の表に示します。</p><div class="scroll"><table><thead><tr><th>#</th><th>プラグイン名</th><th>総合評価</th><th>テキスト</th><th>シェイプ</th><th>ラスター画像</th><th>ベクター画像</th><th>要素のネスト/重なり</th></tr></thead><tbody><tr><td>1</td><td>Figma to Code</td><td>◎</td><td>◎</td><td>◎</td><td>✕</td><td>✕</td><td>◎</td></tr><tr><td>2</td><td>FigmaToFlutter</td><td>△</td><td>◯</td><td>◯</td><td>◎</td><td>◎</td><td>✕</td></tr><tr><td>3</td><td>Assistant by Grida</td><td>△</td><td>◯</td><td>△</td><td>✕</td><td>✕</td><td>✕</td></tr></tbody></table></div><p>比較をした3つのプラグインをそれぞれ一言で表すと、</p><ul><li><strong>Figma to Code</strong>は「安定感がある」</li><li><strong>FigmaToFlutter</strong>は「実用的ではないが今後に期待」</li><li><strong>Assistant by Grida</strong>は「ずっと惜しい」</li></ul><p>という結果になりました。<br>実際の開発に導入するのであれば、<strong>Figma to Code</strong>以外は選択肢から外れるかな、という印象です。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>今回紹介したプラグインとサービスのまとめ。</p><div class="scroll"><table><thead><tr><th>#</th><th>名称</th><th>種別</th><th>変換結果</th><th>備考</th></tr></thead><tbody><tr><td>1</td><td>Figma to Code</td><td>プラグイン</td><td>◎</td><td>安定感が感じられる</td></tr><tr><td>2</td><td>Flutter Export</td><td>プラグイン</td><td>ー</td><td>Figmaで作ったものをPNG画像化するのみ</td></tr><tr><td>3</td><td>FigmaToFlutter</td><td>プラグイン</td><td>△</td><td>今後に期待</td></tr><tr><td>4</td><td>Assistant by Grida</td><td>プラグイン</td><td>△</td><td>ずっと惜しい</td></tr><tr><td>5</td><td>Flutlab.io</td><td>外部サービス</td><td>ー</td><td>オンライン上の変換であったためPJによっては利用できない可能性を考慮し、今回は検証をスキップ</td></tr><tr><td>6</td><td>Bravo Studio</td><td>外部サービス</td><td>ー</td><td>Figma側の命名規則があるなどお作法があり今回は検証スキップ</td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E6%8A%80%E8%A1%93%E9%81%B8%E5%AE%9A/">技術選定</category>
      
      <category domain="https://future-architect.github.io/tags/Figma/">Figma</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%E3%82%A2%E3%83%97%E3%83%AA/">モバイルアプリ</category>
      
      <category domain="https://future-architect.github.io/tags/Flutter/">Flutter</category>
      
      
      <comments>https://future-architect.github.io/articles/20211021a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>OpenTelemetryとgo-chiを繋げてみる</title>
      <link>https://future-architect.github.io/articles/20211020a/</link>
      <guid>https://future-architect.github.io/articles/20211020a/</guid>
      <pubDate>Tue, 19 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;OpenTelemetryのGoのTraceがstableになり、1.0がリリースされました。最初の1.0宣言からはだいぶ時間がかかりましたが、Go/Javaなどさまざまな言語の開発が同時進行で、共通のプロトコルも決めて、なおかつさまざまな拡張のAPIを提供して、さらに&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>OpenTelemetryのGoのTraceがstableになり、1.0がリリースされました。最初の1.0宣言からはだいぶ時間がかかりましたが、Go/Javaなどさまざまな言語の開発が同時進行で、共通のプロトコルも決めて、なおかつさまざまな拡張のAPIを提供して、さらに<a href="https://opentelemetry.io/registry/">その拡張も現時点で300以上も提供されている</a>あたり、かなり巨大な風呂敷をどかーんと広げたような感じがします。</p><div class="scroll"><table><thead><tr><th align="center">日時</th><th align="left">できごと</th></tr></thead><tbody><tr><td align="center">2021/02/17</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-specification-v1-0-0-tracing-edition-72dd08936978">OpenTelemetryのTracingの仕様が1.0に</a></td></tr><tr><td align="center">2021/02/26</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-net-reaches-v1-0-e7c5e975fd44">.NET実装が1.0に</a></td></tr><tr><td align="center">2021/03/06</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/tag/v1.0.0">Java実装が1.0に</a></td></tr><tr><td align="center">2021/03/27</td><td align="left"><a href="https://medium.com/opentelemetry/announcing-opentelemetry-python-1-0-4e097562b8e0">Python実装が1.0に</a></td></tr><tr><td align="center">2021/09/20</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-cpp/releases/tag/v1.0.0">C++実装が1.0に</a></td></tr><tr><td align="center">2021/09/21</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-go/releases/tag/v1.0.0">Go実装が1.0に</a></td></tr><tr><td align="center">2021/09/27</td><td align="left"><a href="https://medium.com/opentelemetry/opentelemetry-collector-achieves-tracing-stability-milestone-80e34cadbbf5">OpenTelemetry CollectorがGA</a></td></tr><tr><td align="center">2021/10/01</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-js/releases/tag/stable%2Fv1.0.0">JavaScript実装が1.0に</a></td></tr><tr><td align="center">2021/10/01</td><td align="left"><a href="https://github.com/open-telemetry/opentelemetry-ruby/releases/tag/opentelemetry-sdk%2Fv1.0.0">Ruby実装が1.0に</a></td></tr></tbody></table></div><p>PHP/Rust/Swift/Erlangあたりはコミットチャンス？</p><h1 id="2年前からアップデートされていると感じたポイント"><a href="#2年前からアップデートされていると感じたポイント" class="headerlink" title="2年前からアップデートされていると感じたポイント"></a>2年前からアップデートされていると感じたポイント</h1><p>OpenTelemtryと、その前身のOpenCensusについてはこのブログでも取り上げました。</p><ul><li><a href="/articles/20190604/">OpenCensus(OpenTelemetry)とは | フューチャー技術ブログ</a></li></ul><p>基本的な考え方は前回紹介したものと変わっていませんが、2年前からいくつか変わったかも？と思ったところをピックアップするとこんなところですかね。</p><ul><li>OpenTelemetryはOpenTelemetry専用のエージェント（ログ中継サービス）の活用も最初から視野に入っており、エージェント向けのエクスポーターも提供されている（OpenCensusにもあったがバージョンが最終版でも0.1.11で安定版ではなかった）。</li><li>stdoutロガーが一級市民扱い？</li><li>トレース、メトリックスという2種類の機能のほかに、Fluentdのようなアプリケーションのログ機能も開発中</li></ul><p>今までは、エクスポーターを明示的にアプリケーションが設定する使い方がメインでした。エージェントを使うということは、アプリケーションは最終的なログ収集基盤について知る必要がなくなり、システムを疎結合にできます。</p><p>stdoutは地味でデバッグ用途っぽさが前のOpenCensusにはありましたが、stdoutロガーはコンテナとの相性が抜群です。ログを受けとって流す先をカスタマイズできるようにするために、コンテナ内部にエージェントの接続先設定を変更するロジックを仕込む必要はありません。コンテナの外から色々できます。認証とかを気にする必要もありません。クラウドサービスだと、ログドライバーの選択だけで良くなりますね。</p><p>で、stdoutに出すとなると、トレース以外の情報とかと混ざってしまいがちなので、アプリケーションログ出力とかも一緒に出せる仕組みが整備されるといいな、というところでアプリケーションログ機能もOpenTelemetryが備えるのはうれしいですね。ただ出すだけではなくて、<a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#trace-context-fields">トレースとリンクできるようにトレースIDを持つ</a>ことが検討されてるようですね。実装は<a href="https://github.com/observIQ/stanza">Go製のFluentd的なStanza</a>をベースにするとかなんとか。</p><h1 id="OpenTelemetryは分散しない人にも注目"><a href="#OpenTelemetryは分散しない人にも注目" class="headerlink" title="OpenTelemetryは分散しない人にも注目"></a>OpenTelemetryは分散しない人にも注目</h1><p>OpenTelemtryはその名の通り「テレメトリー」のためのソフトウェア群です。テレメトリーは一般用語です。次の解説がわかりやすいです。</p><ul><li><a href="https://tenbou.nies.go.jp/science/description/detail.php?id=87">環境技術解説: テレメトリー（環境展望台)</a></li></ul><p>分散システムのすべてにsshしてログファイルをtailするとかはナンセンスですし、野生動物のトラッキング的に遠隔で情報収集する仕組みですが、そうじゃない人にも、何の情報をどう出すか、の指標にまで踏み込もうとしている点は個人的に注目ポイントです。</p><p>例えば、ウェブサービスのエンドポイントやデータベース接続でどんな情報を出すのか、といった情報がまとまっています。小規模のアプリケーションを作る人にも参考になるでしょう。</p><ul><li><a href="https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/trace/semantic_conventions">トレースのログ出力内容</a></li></ul><p>ログのエラーレベルについても<a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#severity-fields">ガイドライン</a>が作られています。まだまだログの実装自体は行われていませんが、このあたり、言語やロギングライブラリによっても指標はバラバラでした。エラーレベル自体はそこまでブレることはないですが（CRITICALとかがあったりなかったりはあるが）、どういうキーですか？（LEVEL？SEVERITY？)とかも違っていました。そのため、ログ収集基盤を作った時に何をエラーとして通知するかは毎回手作りしていたと思いますが、指標が決まってくるとデフォルトでいい感じに動くようになってくるでしょう。ということで、各言語の次世代ロギングライブラリを作ってOSS界隈で名前を売りたい会社は今がチャンスと言えます。</p><p>以前、<a href="https://future-architect.github.io/articles/20210427b/">Future Tech Nightでローカルで動くログビューア</a>を試しに作って発表しました。これも構造化ロギングを前提としたものですが、アプリケーションログ出力が平準化されるなら、少ない設定でいい感じに動くビューアーとかも開発しやすくなりますね。</p><h1 id="OpenTelemetryの始め方"><a href="#OpenTelemetryの始め方" class="headerlink" title="OpenTelemetryの始め方"></a>OpenTelemetryの始め方</h1><p>アプリケーションに組み込む方法を紹介します。スタートするにはまずOpenTelemetryのサイトのRegisteryを見ると良さそうです。生のAPIを叩いてもいいのですが、アプリケーションの特定のミドルウェアやフレームワークとのインタフェースがinstrumentationとして提供されています。アプリケーション側のトレース情報を取り出す便利ライブラリがいくつもあります。</p><img src="/images/20211020a/スクリーンショット_2021-10-02_11.52.04.png" alt="スクリーンショット_2021-10-02_11.52.04.png" width="1200" height="725" loading="lazy"><p>ここに対応したいプラグインが登録されていれば、そのサンプルコードを参考にするのが簡単です。例えば、gorilla/muxを使っていれば、<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/github.com/gorilla/mux">gorilla/mux用のinstrumentation</a>があるので<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/example/server.go#L44">このサンプルの通り</a>にアプリケーションに組み込めばいいので簡単ですね。gorilla/muxのミドルウェアとして実装されています。初期設定はありますが、実質一行です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Use(otelmux.Middleware(<span class="string">&quot;my-server&quot;</span>))</span><br></pre></td></tr></table></figure><p>ただ、これでは１つのスパンが作られるだけなので、内部でスパンを作ったりしたい場合は<code>context.Context</code>の内部に格納された情報をもとに新しいスパンを作るAPIがあるのでそれを使います。<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/example/server.go#L71-L72">サンプルの中にもあります</a>ね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, span := tracer.Start(ctx, <span class="string">&quot;getUser&quot;</span>, oteltrace.WithAttributes(attribute.String(<span class="string">&quot;id&quot;</span>, id)))</span><br><span class="line"><span class="keyword">defer</span> span.End()</span><br></pre></td></tr></table></figure><p>このサンプルもstdoutエクスポーターがが最初から設定されているので、まずはこの状態で動かしてみて、欲しい情報が出ているか確認します。確認できたら、エクスポーター側も変更して、実際の出力先へのインタフェースを追加していきます。GCPとか、OSSのJaegerとかZipkinとかもありますし、SaaSのSplunkとかNew Relicとかありますね。</p><p>AWSはコレクター向けのものがあるので、アプリのエクスポーターとしてはコレクターを選択してコレクターの設定をするとX-Rayに出せるようです。</p><h1 id="go-chiと繋ぐ"><a href="#go-chiと繋ぐ" class="headerlink" title="go-chiと繋ぐ"></a>go-chiと繋ぐ</h1><p>で、ここを見るとお気に入りのgo-chiがありません。go-chiに繋いでみます。gorilla/muxもgo-chiも、ミドルウェアとしては言語標準的なインタフェースを共有しているため、gorilla/muxが使えないか試してみましたが、スパン名がUnknownとなってしまいます。</p><p>というのも、インタフェースは同じであっても、<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/github.com/gorilla/mux/otelmux/mux.go#L120-L130">gorilla/mux</a>のエクスポーターは、contextに入っているgorilla/mux専用のデータにアクセスしてパス情報をとってきているからです。</p><p>では標準ライブラリの<a href="https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/net/http">net/http向けのエクスポータ</a>が使えるかというと、これもそのままでは使えません。net/httpのエクスポータはスパン名をミドルウェア作成時に固定値（ここでは<code>&quot;Hello&quot;</code>)で渡す必要があります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">otelHandler := otelhttp.NewHandler(http.HandlerFunc(helloHandler), <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">&quot;/hello&quot;</span>, otelHandler)</span><br></pre></td></tr></table></figure><p>エンドポイントごとに別の名前を設定したい場合は、これをベースにchiのミドルウェアを作るとしたら（net/httpのexporterラッパー)次のようにエンドポイントごとに設定が必要ですし、URLのパスとスパン名と同じような名前を二度書かないといけないのはクールじゃないですね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/httpを使うとイマイチ</span></span><br><span class="line">r := chi.NewRouter()</span><br><span class="line">r.With(otel(<span class="string">&quot;hello&quot;</span>).Get(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">r.With(otel(<span class="string">&quot;bye&quot;</span>).Get(<span class="string">&quot;/bye&quot;</span>, byeHandler)</span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>高機能なRouterと繋ぐには新しいinstrumentationを実装する必要があることがわかりました。ただ、インタフェースも含めてgorilla/muxのものがほぼ近いのでこれを改造すれば良さそうです。gorilla/muxから情報をもらってくるところを書き換えれば良さそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 変更前</span></span><br><span class="line">route := mux.CurrentRoute(r)</span><br><span class="line"><span class="keyword">if</span> route != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">spanName, err = route.GetPathTemplate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">spanName, err = route.GetPathRegexp()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">spanName = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">routeStr := spanName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 変更後</span></span><br><span class="line">c := chi.RouteContext(r.Context())</span><br><span class="line">spanName := c.RoutePattern()</span><br></pre></td></tr></table></figure><p>これで完璧じゃん、と思ったが、spanNameが空文字にしかなりません。30分ぐらい悩んだところ、ミドルウェアから次のhttp.Hanlderの処理が終わった後にしか<a href="https://github.com/go-chi/chi/issues/270">正しい情報が返ってこないというissue</a>を発見。gorilla/muxのinstrumentationのミドルウェアの実装は、スパン作成時にattributeを設定していますが、APIを見るとあとからも設定できそうです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本ロジックを処理</span></span><br><span class="line">tw.handler.ServeHTTP(rrw.writer, r2)</span><br><span class="line"><span class="comment">// 終わってからchiのAPIを使っていろいろ情報を収集してspanの名前とか属性を変更</span></span><br><span class="line">c := chi.RouteContext(r.Context())</span><br><span class="line">spanName := c.RoutePattern()</span><br><span class="line">span.SetName(spanName)</span><br><span class="line">span.SetAttributes(semconv.HTTPServerAttributesFromHTTPRequest(tw.service, spanName, r)...)</span><br></pre></td></tr></table></figure><p>これでchiでもOpenTelemetryと繋がりました！ gorilla/muxのと同じように、1行<code>Use</code>を書くだけで全部のロジックにトレース出力が差し込めます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1行で全エンドポイントにパスをスパン名としたトレースログ出力ができるように</span></span><br><span class="line">r.Use(otelchi.Middleware(<span class="string">&quot;hello-world&quot;</span>))</span><br></pre></td></tr></table></figure><p>動く実装は次のところに置いておきます。</p><p><a href="https://gitlab.com/osaki-lab/otelchi">https://gitlab.com/osaki-lab/otelchi</a></p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>OpenTelemetryの概要と、個人的に気になっているアップデートの方向性、実際にアプリに組み込む方法、go-chiに繋いでみる方法などを紹介しました。</p><p>OpenTelemetryは単に便利なライブラリというだけでなく新しいエコシステムを作る土台となるものです。いろいろ作りたくなりますね。</p><p>本記事を書くにあたって<a href="https://twitter.com/ymotongpoo">@ymotongpoo氏</a>と<a href="https://twitter.com/katzchang">@katzchang</a>氏にアドバイスをいただきました。ありがとうございました。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://opentelemetry.io/">OpenTelemetry公式サイト</a></li><li><a href="https://github.com/open-telemetry/opentelemetry-specification">OpenTelemetry仕様リポジトリ</a></li><li><a href="https://github.com/open-telemetry/docs-ja">OpenTelemetryドキュメント日本語化プロジェクト</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/OpenTelemetry/">OpenTelemetry</category>
      
      <category domain="https://future-architect.github.io/tags/CNCF/">CNCF</category>
      
      <category domain="https://future-architect.github.io/tags/go-chi/">go-chi</category>
      
      
      <comments>https://future-architect.github.io/articles/20211020a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Engineer Camp2021: Python の AST モジュールを使ってクラス構造を可視化する</title>
      <link>https://future-architect.github.io/articles/20211019a/</link>
      <guid>https://future-architect.github.io/articles/20211019a/</guid>
      <pubDate>Mon, 18 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは、Future のインターン Engineer Camp に参加した空閑です。&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Future のインターン Engineer Camp に参加した空閑です。<a href="/articles/20210927b/">Python連載</a>の9本目です。</p><p>今回のインターンではソースコード静的解析システムの開発に取り組みました。そこで本記事では、開発内容の一部である、Python の AST モジュールを使ったクラス構造の可視化について紹介します。</p><p>Python の環境構築については以下を参考にしました。</p><ul><li><a href="/articles/20210611a/">サーバーアプリ開発環境(Python／FastAPI) - Future Tech Blog</a></li></ul><p>また、本記事で出てくる AST については下記を参照ください。言語やパーサは違いますが基本的な考え方は同じです。</p><ul><li><a href="/articles/20200903/">ANTLRを業務で活用した話 - Future Tech Blog</a></li></ul><h1 id="Python-の-AST-モジュール"><a href="#Python-の-AST-モジュール" class="headerlink" title="Python の AST モジュール"></a>Python の AST モジュール</h1><p>Python では AST（抽象構文木）を扱うモジュールが<a href="https://docs.python.org/ja/3/library/ast.html">標準ライブラリ</a>として提供されています。まずは試しに、適当なソースコードの AST を取得してみます。</p><figure class="highlight py"><figcaption><span>target.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushed = <span class="keyword">not</span> self.pushed</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;target.py&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    source = f.read()</span><br><span class="line">    tree = ast.parse(source=source)</span><br><span class="line">    <span class="built_in">print</span>(ast.dump(tree, indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><details>  <summary>出力結果（長いので折り畳み）</summary>  <div>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        ClassDef(</span><br><span class="line">            name=&#x27;Button&#x27;,</span><br><span class="line">            bases=[],</span><br><span class="line">            keywords=[],</span><br><span class="line">            body=[</span><br><span class="line">                FunctionDef(</span><br><span class="line">                    name=&#x27;__init__&#x27;,</span><br><span class="line">                    args=arguments(</span><br><span class="line">                        posonlyargs=[],</span><br><span class="line">                        args=[</span><br><span class="line">                            arg(arg=&#x27;self&#x27;)],</span><br><span class="line">                        kwonlyargs=[],</span><br><span class="line">                        kw_defaults=[],</span><br><span class="line">                        defaults=[]),</span><br><span class="line">                    body=[</span><br><span class="line">                        Assign(</span><br><span class="line">                            targets=[</span><br><span class="line">                                Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Store())],</span><br><span class="line">                            value=Constant(value=False))],</span><br><span class="line">                    decorator_list=[]),</span><br><span class="line">                FunctionDef(</span><br><span class="line">                    name=&#x27;push&#x27;,</span><br><span class="line">                    args=arguments(</span><br><span class="line">                        posonlyargs=[],</span><br><span class="line">                        args=[</span><br><span class="line">                            arg(arg=&#x27;self&#x27;)],</span><br><span class="line">                        kwonlyargs=[],</span><br><span class="line">                        kw_defaults=[],</span><br><span class="line">                        defaults=[]),</span><br><span class="line">                    body=[</span><br><span class="line">                        Assign(</span><br><span class="line">                            targets=[</span><br><span class="line">                                Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Store())],</span><br><span class="line">                            value=UnaryOp(</span><br><span class="line">                                op=Not(),</span><br><span class="line">                                operand=Attribute(</span><br><span class="line">                                    value=Name(id=&#x27;self&#x27;, ctx=Load()),</span><br><span class="line">                                    attr=&#x27;pushed&#x27;,</span><br><span class="line">                                    ctx=Load())))],</span><br><span class="line">                    decorator_list=[])],</span><br><span class="line">            decorator_list=[])],</span><br><span class="line">    type_ignores=[])</span><br></pre></td></tr></table></figure>  </div></details><p><code>ast.parse</code> にソースコードを渡すことで AST が得られます。実際には、ツリーの根を表すAST ノードを取得することになります。<code>ast.dump</code> は引数に AST ノードを取り、そのノードを根とするツリーを、フォーマットした文字列として返します。</p><p>では次に、AST をたどって特定のノードに反応するコードを書いてみます。<code>ast.NodeVisitor</code> は AST をトラバースするための基底クラスで、このクラスを継承して独自の処理を追加します。これは Visitor パターンとなっているため、クラスごとに <code>visit_&#123;class_name&#125;</code> のメソッドを用意していきます。例えば、ソースコード内で定義されている関数名を列挙するためには、関数定義を表すノード <code>ast.FunctionDef</code> に反応する <code>visit_FunctionDef</code> メソッドを作成し、その中で関数名を表す <code>ast.FunctionDef.name</code> を参照します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNodeVisitor</span>(<span class="params">ast.NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_FunctionDef</span>(<span class="params">self, node: ast.FunctionDef</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(node.name)</span><br><span class="line">        self.generic_visit(node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;target.py&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    source = f.read()</span><br><span class="line">    tree = ast.parse(source=source)</span><br><span class="line">    MyNodeVisitor().visit(tree)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__init__</span><br><span class="line">push</span><br></pre></td></tr></table></figure><p><code>visit_&#123;class_name&#125;</code> を定義することで、<code>ast.&#123;class_name&#125;</code> のノードを訪れたときのみ実行されるメソッドが作成できます。また、以下の引用のように <code>self.generic_visit()</code> を省略してしまうと、そのノードの子ノードは訪れることができないので注意してください。</p><blockquote><p>注意して欲しいのは、専用のビジター・メソッドを具えたノードの子ノードは、このビジターが generic_visit() を呼び出すかそれ自身で子ノードを訪れない限り訪れられないということです。<br><a href="https://docs.python.org/ja/3/library/ast.html#ast.NodeVisitor.generic_visit">https://docs.python.org/ja/3/library/ast.html#ast.NodeVisitor.generic_visit</a></p></blockquote><h1 id="ツール概要"><a href="#ツール概要" class="headerlink" title="ツール概要"></a>ツール概要</h1><p>今回の目標は、パッケージ・モジュール・クラスをノードとする図のようなツリーの作成です。パッケージとモジュールはディレクトリ構造にしたがってつなぎ、モジュールの下にはその中で定義されているクラスをつなぎます。作成にあたり、モジュール違いの同名クラスなどが出現することに注意します。</p><img src="/images/20211019a/graph_sample.PNG" alt="graph_sample.PNG" width="1036" height="661" loading="lazy"><p>AST はディレクトリ構造までは表現しないため、今回は以下の手順で解析を行います。</p><ol><li>Node 定義</li><li>ディレクトリ構造解析</li><li>クラス定義解析</li><li>Graphviz で可視化</li></ol><h2 id="1-Node-定義"><a href="#1-Node-定義" class="headerlink" title="1. Node 定義"></a>1. Node 定義</h2><p>解析する前に準備として <code>Node</code> クラスを定義しておきます。これを可視化するツリーのノードと一対一で対応させます。そして <code>Node</code> を継承した <code>NodePackage</code>, <code>NodeModule</code>, <code>NodeClass</code> を定義し、可視化に必要な情報を保持しておきます。今回はノードの識別に最小限必要なパスおよびクラス名を保持しました。これらはグラフのラベル等に使用します。</p><figure class="highlight py"><figcaption><span>node.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: <span class="type">Optional</span>[Node] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        obj_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        self.children: <span class="built_in">list</span>[Node] = []</span><br><span class="line">        self.parent: <span class="type">Optional</span>[Node] = parent</span><br><span class="line">        self.path: <span class="type">Optional</span>[<span class="built_in">str</span>] = path</span><br><span class="line">        <span class="comment"># Graphviz で可視化する際のラベル</span></span><br><span class="line">        self.obj_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = obj_name</span><br><span class="line">        <span class="comment"># obj_name をルートノードから順にドットで連結したもの</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.obj_name_full: <span class="type">Optional</span>[<span class="built_in">str</span>] = obj_name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj_name_full = (</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;parent.obj_name_full&#125;</span>.<span class="subst">&#123;obj_name&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">if</span> parent.obj_name_full <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span> obj_name</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeRoot</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodePackage</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;パッケージ情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        path: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: NodeRoot | NodePackage,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="comment"># obj_name はディレクトリ名</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(path, parent, obj_name=os.path.basename(path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeModule</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;モジュール情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path: <span class="built_in">str</span>, parent: NodePackage</span>):</span></span><br><span class="line">        <span class="comment"># obj_name はファイル名から拡張子を取り除いたもの</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            path, parent, obj_name=os.path.splitext(os.path.basename(path))[<span class="number">0</span>]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeClass</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;クラス情報を表現するノード&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent: NodeModule | NodeClass, node: ast.ClassDef</span>):</span></span><br><span class="line">        <span class="comment"># obj_name はクラス名</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(path=parent.path, parent=parent, obj_name=node.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-ディレクトリ構造解析"><a href="#2-ディレクトリ構造解析" class="headerlink" title="2. ディレクトリ構造解析"></a>2. ディレクトリ構造解析</h2><p>探索対象のパス以下を再帰的に解析し、パッケージおよびモジュールのみのツリーを作成します。この時点では図のようなツリーが構築されています。</p><img src="/images/20211019a/graph_sample_pre.PNG" alt="graph_sample_pre.PNG" width="665" height="421" loading="lazy"><figure class="highlight py"><figcaption><span>tree.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_module_tree</span>(<span class="params">search_path: <span class="built_in">str</span>, root: <span class="type">Optional</span>[NodeRoot] = <span class="literal">None</span></span>) -&gt; NodeRoot:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;パスを再帰的にたどり、パッケージ・モジュールのみのツリーを作成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        search_path (str): 対象ファイル・ディレクトリのパス</span></span><br><span class="line"><span class="string">        root (NodeRoot, optional): ツリーのルート. Defaults to None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        NodeRoot: ツリーのルート</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">search_path: <span class="built_in">str</span>, parent_node: Node</span>):</span></span><br><span class="line">        <span class="comment"># 正規表現で検索</span></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> glob.iglob(search_path):</span><br><span class="line">            <span class="comment"># 絶対パス</span></span><br><span class="line">            abspath = os.path.abspath(path)</span><br><span class="line">            <span class="comment"># パッケージ</span></span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(parent_node, NodeRoot) <span class="keyword">or</span> <span class="built_in">isinstance</span>(</span><br><span class="line">                    parent_node, NodePackage</span><br><span class="line">                )</span><br><span class="line">                node_package = NodePackage(abspath, parent_node)</span><br><span class="line">                parent_node.children.append(node_package)</span><br><span class="line">                <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">                    dfs(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;file&#125;</span>&quot;</span>, node_package)</span><br><span class="line">            <span class="comment"># モジュール</span></span><br><span class="line">            <span class="keyword">elif</span> os.path.splitext(path)[<span class="number">1</span>] == <span class="string">&quot;.py&quot;</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(parent_node, NodePackage)</span><br><span class="line">                node_module = NodeModule(abspath, parent_node)</span><br><span class="line">                parent_node.children.append(node_module)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        root = NodeRoot()</span><br><span class="line">    dfs(search_path, root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="3-クラス定義解析"><a href="#3-クラス定義解析" class="headerlink" title="3. クラス定義解析"></a>3. クラス定義解析</h2><p>各モジュールについて、クラス定義を解析していきます。<code>NodeModule</code> が指定するパスを読み込み、<code>visit_ClassDef</code> を実装した <code>ClassDefNodeVisitor</code> で処理します。また、<code>ClassDefNodeVisitor</code> には親ノードへのポインタを追加の情報として持たせています。<code>generic_visit</code> の前後で親ノードを入れ替えることで、クラス内クラスなども表現することができます。</p><figure class="highlight py"><figcaption><span>tree.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_definition_tree</span>(<span class="params">root: NodeModule</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;モジュール内のクラス定義のツリーを作成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        root (NodeModule): モジュールノード</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        NodeRoot: ツリーのルート</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> root.path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;to pass type check&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(root.path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8-sig&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            source = f.read()</span><br><span class="line">            tree = ast.parse(source=source)</span><br><span class="line">            ClassDefNodeVisitor(root).visit(tree)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e, file=sys.stderr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDefNodeVisitor</span>(<span class="params">ast.NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        parent: NodeModule | NodeClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># クラス定義ノード到達時の処理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_ClassDef</span>(<span class="params">self, node: ast.ClassDef</span>):</span></span><br><span class="line">        c_node = NodeClass(self.parent, node)</span><br><span class="line">        self.parent.children.append(c_node)</span><br><span class="line">        pre_parent = self.parent</span><br><span class="line">        self.parent = c_node</span><br><span class="line">        self.generic_visit(node)</span><br><span class="line">        self.parent = pre_parent</span><br></pre></td></tr></table></figure><h2 id="4-Graphviz-で可視化"><a href="#4-Graphviz-で可視化" class="headerlink" title="4. Graphviz で可視化"></a>4. Graphviz で可視化</h2><p>詳細な実装はここにはあげませんが、実際に作成したツリーをトラバースしながら辺を張っていきます。同じラベルのノードはひとまとめにされてしまうので、異なるノードは異なる ID を持つように注意します。今回の実装では <code>obj_name_full</code> を ID として使うことができます。また、ノードの種類ごとに色を付けるのも良いでしょう。</p><h1 id="解析結果"><a href="#解析結果" class="headerlink" title="解析結果"></a>解析結果</h1><p>標準ライブラリの可視化結果を載せます。全体を載せるには大きすぎる（PDF で約 2 MB）ため、拡大しています。青がパッケージ、オレンジがモジュール、緑がクラスに対応しています。</p><img src="/images/20211019a/graph_2.PNG" alt="graph_2.PNG" width="1200" height="187" loading="lazy"><p>図では <code>http</code> パッケージの下に、<code>server</code> モジュールがあり、その下にいくつかのクラスがあることが確認できます。実際、該当ディレクトリを見に行くと下図のようになっており、可視化できていることがわかります。<br><img src="/images/20211019a/image.png" alt="image.png" width="1200" height="643" loading="lazy"></p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>今回は AST モジュールを使ってクラス構造を可視化しました。紹介した実装は静的解析の基礎となる部分であり、機能追加によって、メソッドノードの追加や型情報、コールグラフなど、より高度な情報を可視化できます。興味を持った方はぜひ、この記事から静的解析を始めていただければと思います。</p><h1 id="インターンの感想"><a href="#インターンの感想" class="headerlink" title="インターンの感想"></a>インターンの感想</h1><p>今回のインターンでは、プロジェクトの一員として開発に取り組みました。したがって、ミーティングやドキュメントなど、普段の個人開発ではほとんど発生しない、コミュニケーションの部分が特に重要に感じました。コミュニケーションによって文脈を共有することで、後に発生する意思決定や軌道修正などがしやすくなっていた気がします。その点では、毎日のミーティングや Slack での議論など、ご協力いただいた受け入れ先のプロジェクトの方々に感謝しています。</p><p>また、今回は静的解析ツールの開発に取り組みましたが、それでも linter や formatter など既存の静的解析ツールはかなり有用でした。デバッグにはもちろん、型ヒントやフォーマットを通してツール側からも文脈の共有が行えるため、コミュニケーションと併せてその重要性を感じました。今回のインターンは約一か月でしたが、より長期間で大規模なプロジェクトであれば、静的解析ツールはもはや必須といっても過言ではないと思います。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B3/">インターン</category>
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B3%E3%82%A2%E3%83%86%E3%82%AF/">コアテク</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90/">構文解析</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B32021/">インターン2021</category>
      
      <category domain="https://future-architect.github.io/tags/%E9%9D%99%E7%9A%84%E8%A7%A3%E6%9E%90/">静的解析</category>
      
      
      <comments>https://future-architect.github.io/articles/20211019a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Engineer Camp2021（スマートファクトリー）での学び</title>
      <link>https://future-architect.github.io/articles/20211018a/</link>
      <guid>https://future-architect.github.io/articles/20211018a/</guid>
      <pubDate>Sun, 17 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。フューチャーの夏季インターンシップEngineer Camp</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。フューチャーの夏季インターンシップEngineer Camp 2021に参加した森下です。<br>このインターンシップを通じて得た経験や学んだことをお話ししていきます。</p><img src="/images/20211018a/5374a3ec-6860-bbad-4295-474880d81f10.png" alt="" title="illustACからカフェラテさんのイラスト" width="1200" height="900" loading="lazy"><h1 id="インターンシップの内容"><a href="#インターンシップの内容" class="headerlink" title="インターンシップの内容"></a>インターンシップの内容</h1><p>フューチャーでは毎年夏に「Engineer Camp」「Project Camp」という2つのインターンシップが開催されています。私が参加したEngineer Campでは実際のプロジェクトの中で業務に携わり、フューチャーの技術やコンサルタントのあり方を学ぶことができます。</p><p>詳しい内容は「採用イベント情報」のnoteにも掲載されてますのでご覧ください。</p><ul><li><a href="https://note.com/future_event/n/n76e7e7d4beef#vDFIY">【対象：新卒】サマーインターン＜Engineer Camp＞｜採用イベント情報 | フューチャー株式会社｜note</a></li></ul><p>今年はフルリモートでの開催となり、11人のメンバーで4週間業務を体験しました。<br>私は参加したコースは「業界最大級のスマートファクトリー機能開発」です。</p><blockquote><p>②業界最大級のスマートファクトリー機能開発<br>スマートファクトリーを推進せよ。従来のアナログ工場制御系のイメージを打ち壊し、時代を先行く工場のさらなる進化を目指す</p></blockquote><blockquote><p>＜概要＞<br>我々の暮らしを支える製造現場には未だ多く課題があり、スマートファクトリー化することで操業を助けることは重要です。今回は、実際に構築し動いている工場システムの機能拡張および横展開として、以下のいずれか、または複数にチャレンジする予定です。</p></blockquote><blockquote><p>１）Go言語でのAPI設計・開発・テスト<br>２）Terraformを用いたAWS構築・エンハンス<br>３）TypeScriptを利用したフロントエンド開発</p></blockquote><h1 id="技術経験と参加目的"><a href="#技術経験と参加目的" class="headerlink" title="技術経験と参加目的"></a>技術経験と参加目的</h1><p>私は昨年Engineer Campに参加した先輩の勧めでこのインターンシップを知りました。</p><p>フューチャーはコンサルティングからシステム開発までを一気通貫して行う珍しい業務体系をした企業ですので、IT業界を中心に就職活動をしている私にとって業務をイメージできる良い経験になると考え参加を決意しました。</p><p>参加前の技術経験は以下の通りです。</p><ul><li>言語<ul><li>C言語：高専・大学での講義や研究に使用</li><li>Python：大学の研究に使用</li><li>Go言語：インターンに向けて一通りを勉強</li></ul></li><li>GiuHub：触れたことがある程度</li><li>技術系アルバイトやインターンの経験なし</li><li>チーム開発経験なし</li><li>資格：応用情報技術者試験</li></ul><p>このインターンに参加した大きな目的は実際の業務のイメージを持つことです。</p><p>私はこれまで技術系のアルバイトやチーム開発の経験が無かったため、就職活動を進める前にGitHubを使った作業の進め方や会議を中心としたコミュニケーションの取り方など体験したいと考えました。</p><h1 id="インターンで取り組んだこと"><a href="#インターンで取り組んだこと" class="headerlink" title="インターンで取り組んだこと"></a>インターンで取り組んだこと</h1><p>私が配属されたプロジェクトではアナログ制御された工場のDXを手掛けており、私は制御系の監視およびその通知を行うバックエンド寄りのシステム開発をさせていただきました。開発に際しては以下を使用しました。</p><ul><li>Go言語</li><li>AWS<ul><li>Lambda</li><li>DynamoDB</li></ul></li><li>Docker</li><li>GitHub</li></ul><p>インターン期間の序盤は配布されたPCのセットアップやプロジェクトのキャッチアップを中心に行いました。セットアップ際のプロキシ設定では、その方法が既にフューチャーの技術ブログに記事が掲載されており、導入がスムーズに行われました。他にも開発の様々な場面で技術ブログが活用されており、技術発信に力を入れているフューチャーの社風を感じられました。</p><p>キャッチアップでは稼働中のシステムのコードをたくさん読みましたが、どれも命名規則やドキュメントなどがしっかりしており、とても読みやすかったのが印象的でした。今後チーム開発を行ううえでも整ったコードを書く力は重宝されるため、大学在学のうちから綺麗なコードが書けるよう努力したいと感じました。</p><p>その後はドキュメント処理のタスクを行い実際の作業に移りました。</p><p>作業の中ではLambdaとDynamoDBを使用しましたが、私はインターン参加前までAWSに全く触れてこなかったため、共有されたコードや記事を読み社員の方からサポートを受けながら作業を進めました。一か月のインターン生の私にも個別のAWSのアカウントを割り振ってくださり、操作を通じて理解を深めることができました。</p><h1 id="学んだこと"><a href="#学んだこと" class="headerlink" title="学んだこと"></a>学んだこと</h1><p>今回のEngineer Campは「技術面」「コミュニケーション面」「企業面」で学びに溢れた4週間でした。</p><h3 id="技術面"><a href="#技術面" class="headerlink" title="技術面"></a>技術面</h3><p>このインターンでは実際のプロジェクトに携わることで業務に使用される様々な技術に触れることができます。AWSのサービスは「いつか使ってみたい！」と思いつつもハードルが高く手を出せずにいましたが、インターンの中で目的をもって活用することで意欲的に取り組むことができました。AWSやDockerに関して全くの初心者だったため業務で稼働しているコードや記事などから扱い方を学ぶのは大変でしたが、フューチャーにはAWSのエキスパートがたくさんいるためSlackを通じて多くの方がサポートしてくださり理解を深めることができました。</p><p>業務の中でコードのレビューをしていただいたことが大きな学びに繋がりました。これまで研究活動の中でコードを書く際には「自分が見返したときに分かる」ような命名や関数の分け方をしており、他の人にコードを共有する際には変数や関数の意味を説明しながら共有していました。ですがチーム開発ではコードを見ただけで伝わる書き方や厳格な命名規則が求められることを教わりました。実際に稼働しているシステムを見ても明示的な関数名やテストを意識した関数粒度などがなされており、今後身に付けるべき力だと感じました。</p><h3 id="コミュニケーション面"><a href="#コミュニケーション面" class="headerlink" title="コミュニケーション面"></a>コミュニケーション面</h3><p>今回のインターンはフルリモートで開催されたためコミュニケーションの手段がSlackとビデオ通話に限られます。そのため作業の進捗や詰まっている所を自ら発信しなくては仕事をしているのかすら伝わりません。初めは何を報告すべきなのか分かりませんでしたが「Twitter感覚で呟いて」と言われ、些細なことでも小まめに状況をSlackで報告をすると、問題なく進められた部分であっても追加のアドバイスがいただけたり、いざ困ったときに素直に質問ができるようになりました。対面で作業ができないコロナ渦ならではの問題ですが、小まめな報告の必要性を学ぶきっかけになりました。</p><p>「的確に伝える力」を鍛える必要があると教わりました。リモートワークに限らず自分が「何がわからないのか」「何をしたらどうなって困っているのか」を言葉で的確に伝える能力は必要です。実際の業務を行っていると質問の体系も複雑になり、質問したい個所を絞り込めずに何度も社員の方に意図を「推測」させてしまいました。この伝える筋力を着けることも今後の課題です。</p><h3 id="企業面"><a href="#企業面" class="headerlink" title="企業面"></a>企業面</h3><p>今年のEngineer Campはリモートでの開催でしたが、日々のSlack、ミーティング、懇親会で社員の方と触れ合う中で、フューチャーのアットホームな社風を強く感じました。またSlackで質問を投げかけた際には多くの方がサポートをしてくださったり、技術ブログでの発信力も含めてフューチャーの技術を共有する意識の高さを感じました。</p><p>Engineer Campでは週に一度、様々な社員の方が講義をしてくださいます。そこでは「経営面や業界から見たフューチャー」や「Vulsの開発に至るまで」の話など就活イベントなどではなかなか聞けない話をたくさん聞くことができ、フューチャーへの企業理解を深めることができました。</p><h1 id="結び"><a href="#結び" class="headerlink" title="結び"></a>結び</h1><p>リモートでの開催でコミュニケーションの手段に限りはありましたが、インターンの中で交流会や講義などのイベントもたくさん詰め込まれており、存分にフューチャーを体感した４週間だったと思います。また同年代のメンバーと技術面での交流ができたことが刺激になりました。</p><p>この記事を見て参加を検討されている学生がいましたら是非お勧めしたいインターンシップです！</p><p>最後になりますが受け入れ担当チームの皆様をはじめ、インターン期間中にサポートいただいたフューチャー社員の皆様、ありがとうございました！</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B3/">インターン</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%B7%A5%E5%A0%B4/">工場</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%B32021/">インターン2021</category>
      
      
      <comments>https://future-architect.github.io/articles/20211018a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS利用料金をSlackに円グラフ付きで投稿する</title>
      <link>https://future-architect.github.io/articles/20211015a/</link>
      <guid>https://future-architect.github.io/articles/20211015a/</guid>
      <pubDate>Thu, 14 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、フューチャーにアルバイトとして参加中の中山です。</p><p>今日はアルバイトで参加しているプロジェクト内でAWSの利用料金をSlackに通知する仕組みを作成したので共有したいと思います。</p><p>私が参加しているプロジェクトでは、毎月AWSにいくらかかっているのか、加えてそれぞれのサービスは全体のコストの内どのぐらいの割合を占めているのか知りたいという話があり、今回AWSから利用額を取得しSlackに通知する仕組みを作る流れとなりました。</p><p>今回の記事では、実際に採用したAPIやサービスに加え、採用を検討したが実際には利用しなかったサービスなども交え、似たような仕組みを作ってみたいと思っている方に少しでも情報提供できればと考えています。</p><p>参考：<a href="https://github.com/furiko/aws-cost-notify-to-slack">今回のソースコード</a></p><h1 id="システム概要"><a href="#システム概要" class="headerlink" title="システム概要"></a>システム概要</h1><p>それでは実際にどのような仕組みで動いているか説明します。</p><p>図のように、</p><ol><li>CloudWatchにより定時起動でLambdaを呼び出す</li><li>GetCostAndUsageAPIを用いて先月分の利用料金を取得し、<a href="https://github.com/wcharczuk/go-chart">go-chart</a>を用いて円グラフ化</li><li>SlackにWebhookとfiles.uploadを用いて通知</li></ol><p>という仕組みになっています。Cloudwatchでは毎月1日にLambdaが起動するように設定しています。所属しているプロジェクトではGo言語を採用しているため、go-chartを採用してグラフを作成しています。</p><p>Webhookは、各サービスの利用料金を箇条書きで通知するために利用しており、files.uploadは円グラフをアップロードするために利用しています。</p><img src="/images/20211015a/cost-explorer.drawio.png" alt="cost-explorer.drawio.png" width="570" height="352" loading="lazy"><h2 id="投稿例"><a href="#投稿例" class="headerlink" title="投稿例"></a>投稿例</h2><p>Slackに実際に投稿されるものは、各サービスの利用料金を箇条書きにしたものとデータを元に作成された円グラフの2点です。以下に例を示します。<br>箇条書きの方は都合上、Othersという項目を追加していますが、実際にはAPIから返ってきた値を全てそのまま載せています。</p><h3 id="AWS利用料金箇条書き"><a href="#AWS利用料金箇条書き" class="headerlink" title="AWS利用料金箇条書き"></a>AWS利用料金箇条書き</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monthly Report</span><br><span class="line">AWS Account: 111111111111</span><br><span class="line">Start: 2021-08-01, End: 2021-08-31</span><br><span class="line">Total Cost: $1000</span><br><span class="line">Amazon DynamoDB: 500.00(50)%</span><br><span class="line">AWS Lambda: 200.00(20)%</span><br><span class="line">Amazon Kinesis: 150.00(15)%</span><br><span class="line">Others: 100.00(10)%</span><br><span class="line">Tax: 50.00(5)%</span><br></pre></td></tr></table></figure><h3 id="利用料金円グラフ"><a href="#利用料金円グラフ" class="headerlink" title="利用料金円グラフ"></a>利用料金円グラフ</h3><img src="/images/20211015a/output.png" alt="output.png" width="512" height="512" loading="lazy"><h2 id="GetCostAndUsage-API"><a href="#GetCostAndUsage-API" class="headerlink" title="GetCostAndUsage API"></a>GetCostAndUsage API</h2><p><a href="https://aws.amazon.com/jp/aws-cost-management/aws-cost-explorer/">AWS Cost Explorer</a>が提供するAPIで、指定した期間のアカウントに紐づくAWSの利用料金を取得することができます。パラメータの指定方法など詳細は、<a href="https://docs.aws.amazon.com/ja_jp/aws-cost-management/latest/APIReference/API_GetCostAndUsage.html">ドキュメント</a>を参照ください。</p><p>ここでは、1ヶ月分のAWS各サービスの利用料金を取得する場合のGo言語の場合のサンプルを載せておきます。<br>注意点として、このAPIは<code>us-east-1</code>でのみ提供されるのでLambdaを<code>ap-northeast-1</code>などにデプロイしている場合でもAPIを呼び出す際には必ず<code>us-east-1</code>を指定する必要があります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">granularity := <span class="string">&quot;MONTHLY&quot;</span></span><br><span class="line">metrics := []<span class="keyword">string</span>&#123;<span class="string">&quot;BlendedCost&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">svc := costexplorer.New(session.Must(session.NewSession(&amp;aws.Config&#123;</span><br><span class="line">    Region: aws.String(<span class="string">&quot;us-east-1&quot;</span>), <span class="comment">// GetCostAndUsageAPIはus-east-1のみで提供</span></span><br><span class="line">&#125;)))</span><br><span class="line"></span><br><span class="line">result, err := svc.GetCostAndUsage(&amp;costexplorer.GetCostAndUsageInput&#123;</span><br><span class="line">    TimePeriod: &amp;costexplorer.DateInterval&#123; <span class="comment">// 取得したい期間を指定</span></span><br><span class="line">        Start: aws.String(start),</span><br><span class="line">        End:   aws.String(end),</span><br><span class="line">    &#125;,</span><br><span class="line">    Granularity: aws.String(granularity),</span><br><span class="line">    GroupBy: []*costexplorer.GroupDefinition&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Type: aws.String(<span class="string">&quot;DIMENSION&quot;</span>),</span><br><span class="line">            Key:  aws.String(<span class="string">&quot;SERVICE&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Metrics: aws.StringSlice(metrics),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>GoSDKの<a href="https://docs.aws.amazon.com/sdk-for-go/api/service/costexplorer/">ドキュメント</a>も必要な場合は参照ください。</p><h2 id="円グラフ作成"><a href="#円グラフ作成" class="headerlink" title="円グラフ作成"></a>円グラフ作成</h2><p>GetCostAndUsageAPIで取得できたAWS各サービスごとの利用料金を用いて円グラフを作成します。今回はGo言語で実装したいという条件があったので、<a href="https://github.com/wcharczuk/go-chart">go-chart</a>を用いて作成しました。基本的には<a href="https://github.com/wcharczuk/go-chart/blob/master/examples/pie_chart/main.go">サンプル</a>のコード参考にし、全体に占める割合が少ないサービスはOthersとしてまとめました。また、今回はLambda上で画像を生成し、Slackに送信している関係上、一度pngファイルに書き出すなどせず、バッファに画像データを書き込んで送信する形をとりました。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values []chart.Value</span><br><span class="line">others := chart.Value&#123;</span><br><span class="line">    Label: <span class="string">&quot;Others&quot;</span>,</span><br><span class="line">    Value: <span class="number">0.0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// グラフデータの作成</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> results &#123;</span><br><span class="line">    <span class="comment">// 全体に占める割合が1.0%未満のサービスはOthersにまとめる</span></span><br><span class="line">    <span class="keyword">if</span> v.Ratio &lt; <span class="number">1.0</span> &#123;</span><br><span class="line">        others.Value += v.Cost</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    values = <span class="built_in">append</span>(values, chart.Value&#123;</span><br><span class="line">        Value: v.Cost,</span><br><span class="line">        Label: v.Name,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">values = <span class="built_in">append</span>(values, others)</span><br><span class="line"></span><br><span class="line"><span class="comment">// グラフの作成</span></span><br><span class="line">pie := chart.PieChart&#123;</span><br><span class="line">    Width:  <span class="number">512</span>,</span><br><span class="line">    Height: <span class="number">512</span>,</span><br><span class="line">    Values: values,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// バッファに画像データを書き込む</span></span><br><span class="line">buffer := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">err := pie.Render(chart.PNG, buffer)</span><br></pre></td></tr></table></figure><h3 id="GetMetricsWidgetImage-API"><a href="#GetMetricsWidgetImage-API" class="headerlink" title="GetMetricsWidgetImage API"></a>GetMetricsWidgetImage API</h3><p>はじめ、円グラフを作成しようと探していた際に<a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/APIReference/API_GetMetricWidgetImage.html">GetMetricsWidgetImage</a>というAPIを知りました。このAPIを利用して前日との利用料の差額を出している記事なども見つけましたが、このAPIは利用料金の円グラフ化はできるのですが、<strong>対象となるデータはCloudWatchで監視できるリソースのみ</strong>であり、GetCostAndUsageAPIで取得できる全てのデータを対象とすることはできなかったため採用を見送りました。</p><p>私自身、初めはグラフ作成に必要なデータを送れば円グラフを作成して返してくれるAPIだと思っていたのですが、上述の通り、Cloudwatchの監視メトリクスをグラフ化するためのAPIであり、汎用的にグラフ作成に用いるAPIではありませんでした。</p><h2 id="Slack連携"><a href="#Slack連携" class="headerlink" title="Slack連携"></a>Slack連携</h2><p>次に、上記で取得した各サービスの利用料金と円グラフをSlackに連携する方法について紹介します。<br>開発当初Webhookを用いてテキストのみをSlack連携していたところに円グラフを後から追加したため、今回のサービスではWebhookとfiles.uploadの両方を用いていますが、Bot Tokenに適切なScopeの設定をすることで自作のSlackApp1つで、テキストの投稿・円グラフのアップロードの両方を実現可能かと思います。</p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>Slackに対して通知する代表的な手段として<a href="https://slack.com/intl/ja-jp/help/articles/115005265063-Slack-%E3%81%A7%E3%81%AE-Incoming-Webhook-%E3%81%AE%E5%88%A9%E7%94%A8">Incoming Webhook</a>があります。今回のシステムではこちらを利用して、各サービスごとの使用量を箇条書きで通知しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">endpoint := SLACKENDPOINT</span><br><span class="line"></span><br><span class="line">body := <span class="keyword">struct</span> &#123;</span><br><span class="line">    Text <span class="keyword">string</span> <span class="string">`json:&quot;text&quot;`</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    Text: fmt.Sprintf(<span class="string">&quot;*Monthly Report*\n %v&quot;</span>, cost),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonString, err := json.Marshal(body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(http.MethodPost, endpoint, bytes.NewBuffer(jsonString))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">_, err = http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure><h3 id="files-upload"><a href="#files-upload" class="headerlink" title="files.upload"></a>files.upload</h3><p>Webhookではファイル自体のアップロードはできないため、files.uploadを用いてLambda内で生成した円グラフの画像をSlackにアップロードしています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api := slack.New(SLACKAPITOKEN)</span><br><span class="line"></span><br><span class="line">_, err := api.UploadFile(</span><br><span class="line">    slack.FileUploadParameters&#123;</span><br><span class="line">        Reader:   b,</span><br><span class="line">        Filename: <span class="string">&quot;output.png&quot;</span>,</span><br><span class="line">        Channels: []<span class="keyword">string</span>&#123;SLACKCHANNEL&#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>AWSのAPIを用いて月々の使用量を取得し、Slackに通知する仕組みの紹介をしてきました。</p><p>円グラフを作成して各サービスの割合を出し、各サービスのコスト比重を見返すことは今後のAWS利用の効率化などの考察の一助となると思いますので、興味がある方はぜひこの機会にSlackでAWS利用料金をチェックする仕組みを組んでみてください。</p><p>最後に今回のサービスで利用しているコードの全文を載せておきます。最後まで読んでいただきありがとうございました。</p><h2 id="コード全文"><a href="#コード全文" class="headerlink" title="コード全文"></a>コード全文</h2><p>全文：<a href="https://github.com/furiko/aws-cost-notify-to-slack">今回のソースコード</a></p><p><strong>環境変数</strong> について<br>４つ利用しています。実行前に事前に準備をお願いします。</p><ul><li>SLACK_ENDPOINT: Webhookの投稿先URLです</li><li>SLACK_API_TOKEN: files.uploadで用いるToken文字列です</li><li>SLACK_CHANNEL: Slackの投稿先チャンネルです</li><li>AWS_ACCOUNT: Slackに投稿される箇条書き文字列の冒頭にある<code>AWS Account:</code>に付与する値です</li></ul><p>Lambdaで実行する場合は各自事前にLambdaの準備とコードのデプロイをお願いします。</p><p>Lambdaではなくローカル環境で実行する場合は、main関数内の<code>lambda.Start(Handle)</code>を<code>Handle(context.Background())</code>に書き換えて実行してください。また、<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>は各自設定をお願いします。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/Slack/">Slack</category>
      
      
      <comments>https://future-architect.github.io/articles/20211015a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>トップゲート×フューチャー LT大会登壇レポート</title>
      <link>https://future-architect.github.io/articles/20211014a/</link>
      <guid>https://future-architect.github.io/articles/20211014a/</guid>
      <pubDate>Wed, 13 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG所属の鈴木です。この度縁あって、2021年9月14日に株式会社トップゲート様とフューチャーで共同開催された、GCPをテーマにしたLT大会に登壇しました。</p><p>簡単にLT大会の内容や、登壇した感想をまとめてみたいと思います。</p><h1 id="今回のLT大会について"><a href="#今回のLT大会について" class="headerlink" title="今回のLT大会について"></a>今回のLT大会について</h1><p>トップゲート様が定期開催している初心者向け勉強会である、Beginner’s Labにフューチャーも参加させていただく形で今回のLT大会は開催されました。テーマはGCPということで、普段GCPを触っているなかで得た知見やTips、便利ツールや苦労話を紹介し合う会となりました。</p><p>トップゲート様とフューチャーで3名ずつ、「先鋒」「中堅」「大将」という体でキャリアの短さ順に発表するとのことで、私はフューチャーの先鋒でした。私は新人研修後インフラチームにアサインされてからGCPをずっと触り続けているのですが、クラウド未経験ということもあって日々の業務で色々とハマっており、その苦労も盛り込めたらな～という気持ちでLTに臨みました。</p><img src="/images/20211014a/image.png" alt="登壇の様子" width="1200" height="513" loading="lazy"><h1 id="LTの紹介"><a href="#LTの紹介" class="headerlink" title="LTの紹介"></a>LTの紹介</h1><h3 id="Flutter-×-ML-Kitで笑顔度の分析をしてみた"><a href="#Flutter-×-ML-Kitで笑顔度の分析をしてみた" class="headerlink" title="Flutter × ML Kitで笑顔度の分析をしてみた"></a>Flutter × ML Kitで笑顔度の分析をしてみた</h3><p>トップゲート青木様の発表です。モバイル向け機械学習SDKである<a href="https://developers.google.com/ml-kit">ML Kit</a>を用いた、<a href="https://future-architect.github.io/articles/20210510a/">Flutter</a>による顔認識・笑顔度分析アプリの実装を紹介してくれました。ML Kitではオフラインでも動作する高速 なAI推論機能を手軽に実装できます。</p><h3 id="死活監視を自前で頑張って実装した話"><a href="#死活監視を自前で頑張って実装した話" class="headerlink" title="死活監視を自前で頑張って実装した話"></a>死活監視を自前で頑張って実装した話</h3><p>当社から鈴木の発表です。このトークでは、外部IPアドレスが付与されていないGCEインスタンスを外形監視する仕組みがマネージドで見つからず、Cloud Functionを使って監視を実現したエピソードを紹介しました。監視のアラート実装はログメトリクスを使って試行錯誤したのですが、実はその間<a href="https://cloud.google.com/blog/ja/products/operations/create-logs-alerts-preview">Googleでマネージドなログアラート機能</a>が実装されていたオチで、「あの苦労は一体…」という気分もお届けしました。</p><script async class="speakerdeck-embed" data-id="98f9c63325be4014a84cfb5a1ce9e875" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h3 id="Hibernateでらくらく-Cloud-Spanner"><a href="#Hibernateでらくらく-Cloud-Spanner" class="headerlink" title="Hibernateでらくらく Cloud Spanner"></a>Hibernateでらくらく Cloud Spanner</h3><p>トップゲート田中様の発表です。HibernateはJava系言語で利用できるオープンソースのORマッパーですが、Cloud SpannerのSQL方言に即した形でSQLを生成をしてくれる<a href="https://github.com/GoogleCloudPlatform/google-cloud-spanner-hibernate">Google Cloud Spanner Dialect for Hibernate ORM</a>の紹介・デモを発表してくれました。とかく性能面が話題になるCloud Spannerですが、周辺ツールの拡充による「使いやすさ」も着実に進歩しているようです。</p><h3 id="あなたの顧客、2段階認証出来てますか？-顧客のGCP環境に2段階認証を導入した話"><a href="#あなたの顧客、2段階認証出来てますか？-顧客のGCP環境に2段階認証を導入した話" class="headerlink" title="あなたの顧客、2段階認証出来てますか？ ~ 顧客のGCP環境に2段階認証を導入した話 ~"></a>あなたの顧客、2段階認証出来てますか？ ~ 顧客のGCP環境に2段階認証を導入した話 ~</h3><p>当社から柳澤の発表です。GCP環境で2段階認証を利用する場合の解説や落とし穴など実例を交えて解説してくれました。なお、「結局最後はGoogle側で対応(マネージドサービス化)」されたというオチは私とかぶっていました。</p><script async class="speakerdeck-embed" data-id="2f5d243ff7e3474295de83fc728fc5ee" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h3 id="VPC-SCでインフラを多層的に守る"><a href="#VPC-SCでインフラを多層的に守る" class="headerlink" title="VPC SCでインフラを多層的に守る"></a>VPC SCでインフラを多層的に守る</h3><p>トップゲート山川様の発表です。本トークでは、GCPリソースの防御の考え方として、Cloud IAMやファイアウォールでアクセス管理・権限管理をすることに加え、<a href="https://cloud.google.com/vpc-service-controls">VPC Service Controls</a>を使用した機密性の確保の大切さを語っていただきました。</p><h3 id="Cloud-Spannerに抱く不安とその対処法"><a href="#Cloud-Spannerに抱く不安とその対処法" class="headerlink" title="Cloud Spannerに抱く不安とその対処法"></a>Cloud Spannerに抱く不安とその対処法</h3><p>フューチャー齋場の発表です。まさかのトップゲート田中様とCloud Spannerかぶりをしてしまったのですが、それだけCloud Spannerの「銀の弾丸」感ある性能が話題になっているということだと思います。このトークでは、Cloud Spannerを採用したアーキテクチャを顧客へ提案する際に、「本当にそんなうまくいくの？」という不安をひとつづつクリアにしていったときのノウハウを共有してくれました。</p><script async class="speakerdeck-embed" data-id="1fdc2c8b3271489695859e397fd9031a" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h1 id="登壇した感想"><a href="#登壇した感想" class="headerlink" title="登壇した感想"></a>登壇した感想</h1><p>ML KitやHibernateのようなツールを知ることができて単純に学びがあったほか、GCPを導入していく過程での「あるあるハマりポイント」だったり「あのサービスって実際どうなの？」のような皆が抱えるモヤモヤがシェアされていて、私のような若手でも共感しかない大会でした。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/LT/">LT</category>
      
      <category domain="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/">登壇レポート</category>
      
      <category domain="https://future-architect.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%90%88%E5%90%8C%E5%8B%89%E5%BC%B7%E4%BC%9A/">合同勉強会</category>
      
      
      <comments>https://future-architect.github.io/articles/20211014a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS Certified Advanced Networking - Specialty合格体験記</title>
      <link>https://future-architect.github.io/articles/20211013b/</link>
      <guid>https://future-architect.github.io/articles/20211013b/</guid>
      <pubDate>Tue, 12 Oct 2021 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;TIGの伊藤真彦です。&lt;/p&gt;
&lt;p&gt;来たる11月13日に&lt;a href=&quot;https://gocon.jp/2021autumn/&quot;&gt;Go Conference 2021</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>TIGの伊藤真彦です。</p><p>来たる11月13日に<a href="https://gocon.jp/2021autumn/">Go Conference 2021 Autumn</a>に、技術ブログでもお馴染みの澁川さん、辻さんと共に登壇させていただくことになりました。</p><p>楽しい発表になるように頑張ります。</p><p>宣伝を挟みましたが、AWS Certified Advanced Networking - Specialtyに合格しましたので、今回も合格体験記を書きます。</p><h1 id="AWS-Certified-Advanced-Networking-Specialtyとは"><a href="#AWS-Certified-Advanced-Networking-Specialtyとは" class="headerlink" title="AWS Certified Advanced Networking - Specialtyとは"></a>AWS Certified Advanced Networking - Specialtyとは</h1><img src="/images/20211013b/image.png" alt="合格バッチ" width="600" height="600" loading="lazy"><p>その名の通り高度なネットワーク知識に特化した試験です。<br>オンプレミスとのハイブリッドクラウド、Direct Connect接続、複数社のVPCの合体技といった様々な前提条件ありきのセキュアな通信、ベストプラクティスの知識が求められます。</p><p>AWS Certified Security - Specialtyと比べると、他の試験では出題されない要素が多めです。<br>前提条件が複雑なため、問題の要点を読み解く難易度はいくつかSolutions Architect - Professionalに匹敵する問題があります。<br>簡単な問題もこの試験でのみ出てくるものが多く、覚えればすぐに解けるものの、見覚えが無いと手も足も出ないような問題が出題される傾向がありました。</p><h1 id="学習方法"><a href="#学習方法" class="headerlink" title="学習方法"></a>学習方法</h1><p>今回も<a href="https://aws.koiwaclub.com/">aws.koiwaclub.com</a>で合格できました。<br>あまりにも初見の情報が多く、また初見の場合一切推測できないものが多いため保険としてudemyの教材も買ってみましたが、終わってみた所感としては必要なかったかなと感じました。</p><p>下記の内容を一通り理解する必要があります。</p><h4 id="複雑なネットワーキング"><a href="#複雑なネットワーキング" class="headerlink" title="複雑なネットワーキング"></a>複雑なネットワーキング</h4><ul><li>AWS Direct Connect(様々な前提条件、観点での設問が沢山出ます)</li><li>VPN</li><li>VPCピアリング</li><li>AWS Transit Gateway</li></ul><h4 id="セキュアな通信"><a href="#セキュアな通信" class="headerlink" title="セキュアな通信"></a>セキュアな通信</h4><ul><li>AWS WAF</li><li>侵入防止システム (IPS)</li><li>DDoS 保護</li><li>VPCフローログ</li></ul><h4 id="グローバル、低遅延なネットワーキング"><a href="#グローバル、低遅延なネットワーキング" class="headerlink" title="グローバル、低遅延なネットワーキング"></a>グローバル、低遅延なネットワーキング</h4><ul><li>Amazon Route 53</li><li>Amazon CloudFront</li><li>Lambda@Edge</li></ul><h4 id="ハイパフォーマンスコンピューティング"><a href="#ハイパフォーマンスコンピューティング" class="headerlink" title="ハイパフォーマンスコンピューティング"></a>ハイパフォーマンスコンピューティング</h4><p>分散処理基板等の用途でEC2インスタンスを利用する際の下記のような前提知識が出題されます。</p><ul><li>プレイスメントグループ</li><li>拡張ネットワーキング</li><li>ジャンボフレーム</li><li>Elastic Network Interface</li><li>HVM AMI</li></ul><h4 id="その他基礎知識"><a href="#その他基礎知識" class="headerlink" title="その他基礎知識"></a>その他基礎知識</h4><ul><li>パブリックサブネット、プライベートサブネット</li><li>NACL、セキュリティグループ</li><li>インターネットゲートウェイ、NATゲートウェイ</li><li>ALB、CLB、NLBなどロードバランサーの使い分け</li><li>CIDR、サブネット、IPアドレスなどの基礎知識</li><li>Wireshark、SquidなどAWSに限らないネットワーク関連のツールの知識</li></ul><p>例えばEC2インスタンスのセキュリティグループの設定で169.254.169.254、ポート80番のアウトバウンドが塞がっているとインスタンスのメタデータにアクセスできず、IAMロールの取得に失敗する事などマニアックな問題が数多く出題されます。</p><p>参考: <a href="https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/WindowsGuide/instancedata-data-retrieval.html">https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/WindowsGuide/instancedata-data-retrieval.html</a></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>一通り頭に詰め終わってからの本番は一時間かからない程度で済みましたが、初見の段階では問題の意味を理解する事すらできず、学習の辛さはトップレベルでした。</p><p>一発で合格できて良かったです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/Network/">Network</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/">合格記</category>
      
      
      <comments>https://future-architect.github.io/articles/20211013b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【合格記】Google Cloud Professional Data Engineer認定資格を振り返る</title>
      <link>https://future-architect.github.io/articles/20211013a/</link>
      <guid>https://future-architect.github.io/articles/20211013a/</guid>
      <pubDate>Tue, 12 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211013a/follow-learning-path_2x.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;274&quot; title=&quot;学習イメージ&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211013a/follow-learning-path_2x.png" alt="" width="476" height="274" title="学習イメージ" loading="lazy"><p>こんにちは、TIGの玉木です。先日<a href="https://cloud.google.com/certification/data-engineer?hl=ja">Professional Data Engineer認定資格</a>を取得しました。この記事ではその振り返りをします。</p><h2 id="筆者について、受験のモチベーション"><a href="#筆者について、受験のモチベーション" class="headerlink" title="筆者について、受験のモチベーション"></a>筆者について、受験のモチベーション</h2><p>新卒から3年半ほど機械学習モデリングを行っており、ここ半年はAWSでサーバーサイドの実装を主に担当しています。業務でGCPを扱ったことはありませんが、社内で「みんなで資格とっていきましょう！」のような機運があり、以前から機械学習とも関係があるデータエンジニアリングに興味があったため、今回Professional Data Engineer認定資格を受けることにしました。</p><h2 id="出題範囲"><a href="#出題範囲" class="headerlink" title="出題範囲"></a>出題範囲</h2><p>以下公式サイトの<a href="https://cloud.google.com/certification/guides/data-engineer?hl=ja">認定試験ガイド</a>からのサマリです。</p><ol><li>データ処理システムの設計</li><li>データ処理システムの構築と運用化</li><li>機械学習モデルの運用化</li><li>ソリューションの品質保証</li></ol><p>1, 2は近い内容なのかなと思います。例えばバッチ/ストリーミング処理をする場合、どのようにデータを受け取り、どのように変換し、どのように保存するか、などが理解している必要があると思います。</p><p>3は機械学習に関する出題です。学習済みモデルとはなんだっけ？分類問題、回帰問題の違いってなんだっけ？うまく学習できていないときどうするんだっけ？のようなことが理解できている必要があると思います。自分には機械学習のバックグラウンドがあったため、機械学習の問題に関しては楽できました。</p><p>4はセキュリティやモニタリングに関する問題が出ます。自分はセキュリティ周りの問題が苦手で苦労しました。</p><h2 id="やった勉強"><a href="#やった勉強" class="headerlink" title="やった勉強"></a>やった勉強</h2><p>使用した教材は以下3つです。</p><ul><li>coursera: <a href="https://ja.coursera.org/professional-certificates/gcp-data-engineering-jp">Google Cloud 認定の準備: クラウドデータエンジニア プロフェッショナル認定証 日本版 プロフェッショナル認定</a></li><li><a href="https://gihyo.jp/book/2021/978-4-297-11948-5">Google Cloudではじめる実践データエンジニアリング入門</a></li><li><a href="https://www.shoeisha.co.jp/book/detail/9784798158839">スケーラブルデータサイエンス データエンジニアのための実践Google Cloud Platform</a></li></ul><p>最初に取り組んだのはcourseraの<a href="https://ja.coursera.org/professional-certificates/gcp-data-engineering-jp">Google Cloud 認定の準備: クラウドデータエンジニア プロフェッショナル認定証 日本版 プロフェッショナル認定</a>です。結構な量があり、終えるのに根気が要ります。また、よくスキルバッチキャンペーンといったcourseraの授業が1ヶ月ただになるキャンペーンをGoogle Cloudが行っているので、タイミングが合えばその機会に取り組むのをおすすめします。</p><p>ここで出題範囲の内容を6〜7割カバーできます。コース1から5でデータパイプラインの設計実装を学んで、コース6の最後で模擬試験を行う、といった授業になります。自分はこの模擬試験があまりできなくて結構焦った思い出があります。先述の「自分はセキュリティ周りの問題が苦手で苦労しました。」のように、自分の苦手分野がわかるので、コース6の模擬試験、もしくは<a href="https://cloud.google.com/certification/sample-questions/data-engineer?hl=ja">公式サイトの模擬試験</a>をある程度勉強した後に受けてみるのをおすすめします。</p><p>個人的にcourseraには非常にお世話になっているのですが、動画コンテンツであるため、復習がしづらく、本に比べて学習が疲れると思っています。そこでいくつか本を買いました。</p><p>次に取り組んだのは<a href="https://gihyo.jp/book/2021/978-4-297-11948-5">Google Cloudではじめる実践データエンジニアリング入門</a>という今年の2月に出た本です。試験勉強という観点では、実際の問題に近い問題をたくさん解く方が手っ取り早いかもしれませんが、業務に役立てるという観点ではこの本を一通り試したのは非常によかったです。データ基盤とは何か？GCPでデータ基盤作るにはどうすればいいか？といったことが書かれています。BigQueryの内部アーキテクチャ、クエリ最適化といった話や、権限管理の話が自分にとって特に参考になりました。好みの問題があると思うのですが、動画コンテンツが苦手な方は、最初のデータ基盤周りのインプットはこちらの方が楽かなと思います。</p><p>次に取り組んだのは<a href="https://www.shoeisha.co.jp/book/detail/9784798158839">スケーラブルデータサイエンス データエンジニアのための実践Google Cloud Platform</a>です。原著は先程紹介したcourseraのコース1の先生が書かれた本で、Google Cloudではじめる実践データエンジニアリング入門に比べてケーススタディに沿ったハンズオン部分が多めといった印象です。courseraの授業やGoogle Cloudではじめる実践データエンジニアリング入門と重複する内容もありますが、少し違ったケーススタディで再度手を動かしたい方におすすめです。</p><h2 id="受けた感想"><a href="#受けた感想" class="headerlink" title="受けた感想"></a>受けた感想</h2><p>自宅のネット環境が不安定なので、渋谷のテストセンターで試験を受けてきました。快適に受けられたので自宅のネット環境に不安がある方にはおすすめです。</p><p>テスト終了後、合格という文字が画面に出て、テストの2日後に正式にデジタル認定書のリンクが書かれたメールが届きました。</p><p>まだ業務でGCPを使ったデータ基盤構築をしてはいないのですが、実際にそのような業務にあたることがあればスムーズに入れるんじゃないかなぐらいの知識を得たかな、と思っています。自分のように機械学習のバックグラウンドがある方は、結構取り組みやすい分野だとも思います。難易度もそこまで高すぎるわけでもないので、これからデータ基盤周りのことを学びたい方には、勉強のきっかけとしておすすめの資格試験だと思います。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Professional Data Engineer認定資格を取得するにあたって取り組んだことを紹介しました。これからProfessional Data Engineer認定資格を受けてみようかなと考えている方に参考になれば幸いです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%90%88%E6%A0%BC%E8%A8%98/">合格記</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0/">データエンジニアリング</category>
      
      
      <comments>https://future-architect.github.io/articles/20211013a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>S3でクロスアカウントアクセスする時に気をつけるポイント</title>
      <link>https://future-architect.github.io/articles/20211012a/</link>
      <guid>https://future-architect.github.io/articles/20211012a/</guid>
      <pubDate>Mon, 11 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;こんにちは。TIG/DXユニット 2020年新卒の渡辺です。&lt;/p&gt;
&lt;p&gt;Amazon</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。TIG/DXユニット 2020年新卒の渡辺です。</p><p>Amazon S3を利用したファイル連携を行う際、アカウント内に閉じた利用であれば特段問題ない場合でも、システム間連携となるとクロスアカウントが発生し、目的とした操作をするためには然るべき設定が必要になることがあります。</p><p>今回は、自アカウント（アカウントA）のS3バケットに対して他アカウント（アカウントB）から書き込みを行い、アカウントAから当該ファイルを参照する際に注意する設定について紹介していきます。</p><p>必要な設定は以下の2つです。</p><ul><li>バケットポリシーの設定</li><li>オブジェクト所有者の変更</li></ul><img src="/images/20211012a/image.png" alt="アカウントAのS3バケットへアカウントBからアクセスする様子" width="1200" height="431" loading="lazy"><h2 id="バケットポリシーの設定"><a href="#バケットポリシーの設定" class="headerlink" title="バケットポリシーの設定"></a>バケットポリシーの設定</h2><p>クロスアカウントアクセスを許可する設定として<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/cross-account-access-s3/">公式</a>では、それぞれバケットポリシー、ACL、AssumeRoleを用いた3つの方法が紹介されていいます。</p><p>今回はバケットポリシーを利用する方法を記載します。lambdaなどから利用する分には標準的で、多用される方法かと思います。リソースベースポリシーをサポートしていないAWSサービスを利用する際などは残りの方法を検討ください。</p><p>書き込み先であるアカウントAのS3バケットに設定するバケットポリシーの例は以下の通りです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Principal&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;AWS&quot;</span>: <span class="string">&quot;arn:aws:iam::123456789012:root&quot;</span></span><br><span class="line">           &#125;,</span><br><span class="line">            <span class="attr">&quot;Action&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;s3:PutObject&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;arn:aws:s3:::my-bucket/*&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;Condition&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;StringEquals&quot;</span>: &#123;</span><br><span class="line">                   <span class="attr">&quot;s3:x-amz-acl&quot;</span>: <span class="string">&quot;bucket-owner-full-control&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>アカウントBに対して、アカウントAのS3バケット（<code>my-bucket</code>）への<code>PutObject</code>権限を付与しています。</p><p><code>Principal</code>にはアカウントBのIDを設定してください。IAMユーザーを指定する場合は、末尾の<code>root</code>を<code>user:userName</code>の形式に変更し、ユーザ名を設定してください。</p><p>また例のように<code>Condition</code>を設定することで、オブジェクトのACLが<code>bucket-owner-full-control</code>（後述）に<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/s3-require-object-ownership/">設定されている場合のみアップロードできる</a>ようになります。<code>bucket-owner-full-control</code>が付与されていない書き込みはエラーとなるため、誤った書き込み自体を防ぐことが可能になります。</p><p>バケットポリシーの設定は以上ですが、アカウントBのユーザー権限が制限されていて、当該バケットへの<code>PutObject</code>が許可されていない場合は、ユーザーへのIAMポリシーの追加が必要になるので忘れずに設定しましょう。</p><h2 id="オブジェクト所有者の変更"><a href="#オブジェクト所有者の変更" class="headerlink" title="オブジェクト所有者の変更"></a>オブジェクト所有者の変更</h2><p>バケットポリシーの設定により、アカウントBからアカウントAのS3バケットへの書き込みは可能になりました。しかし、単純に書き込むだけでは、<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/s3-bucket-owner-access/">書き込んだファイルがアカウントAから読めない</a>という問題が発生します。</p><p>なぜなら、各オブジェクトにはそれぞれ所有者が決まっており、デフォルトでは書き出しを行なったアカウント（今回の場合はアカウントB）が所有者に設定されるためです。</p><p>現在の所有者は、オブジェクトの[プロパティ]から確認することができます。</p><img src="/images/20211012a/image_2.png" alt="マネジメントコンソールからオブジェクトの所有者を確認" width="1200" height="444" loading="lazy"><p>アカウントAからオブジェクトを見るためには、まずS3バケットの[アクセス許可]にある[オブジェクト所有者]を<code>希望するバケット所有者</code>に変更します。 この設定により、アカウントBから書き込みを行う際に、オブジェクト所有者を変更することが可能になります。</p><img src="/images/20211012a/image_3.png" alt="オブジェクトの所有者を確認" width="828" height="475" loading="lazy"><p>上記設定を行なった上で、アカウントBから書き込む際に<code>bucket-owner-full-control</code>を付与することで、所有者をアカウントAに変更することができます。CLIから付与する例は以下の通りです（プログラムから書き出す際も同様に付与する必要があります。付与する方法は各言語の<code>aws-sdk</code>リファレンスを参照ください）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws s3 cp sample.txt s3://my-bucket --acl bucket-owner-full-control</span><br></pre></td></tr></table></figure><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>今回は、S3でクロスアカウントアクセスをする際に注意する設定について紹介しました。</p><p>特にオブジェクト所有者の変更（<code>bucket-owner-full-control</code>の付与）は忘れやすく、「普段プログラムから書き込んでいるが、急遽CLIから書き込んでみたらエラーになり焦る」ということが発生しないように覚えておくといいと思います。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/S3/">S3</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%AF%E3%83%AD%E3%82%B9%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88/">クロスアカウント</category>
      
      
      <comments>https://future-architect.github.io/articles/20211012a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS Glueで複雑な処理を開発するときのTips</title>
      <link>https://future-architect.github.io/articles/20211011a/</link>
      <guid>https://future-architect.github.io/articles/20211011a/</guid>
      <pubDate>Sun, 10 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211011a/glue_python_spark.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;260&quot; loading=&quot;lazy&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211011a/glue_python_spark.png" alt="" width="790" height="260" loading="lazy"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。TIGの藤田です。</p><p><a href="/articles/20210927b/">Python連載</a> の8日目として、PySparkを使用したGlueジョブ開発のお話をします。</p><p>ETLツールとして使用されるAWS Glueですが、業務バッチで行うような複雑な処理も実行できます。また、処理はGlueジョブとして、Apache Spark分散・並列処理のジョブフローに簡単に乗せることができます！</p><p>特に複雑な処理は、やや割高な開発エンドポイントは使用せず、ローカル端末で、しっかり開発・テストを行いたいですよね。そのためのローカル開発Tipsをご紹介します。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol><li><a href="#Glue%E3%82%B8%E3%83%A7%E3%83%96%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%A8%E5%AE%9F%E8%A1%8C%E6%A6%82%E8%A6%81">Glueジョブの開発と実行概要</a></li><li><a href="#Tip1-%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89">Tip1: ローカル環境構築</a></li><li><a href="#Tip2-pyspark-sparksql%E9%96%8B%E7%99%BA">Tip2: PySpark, SparkSQL開発</a></li><li><a href="#Tip3-%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88-pytest">Tip3: 単体テスト(pytest)</a></li><li><a href="#Tip4-%E3%83%87%E3%83%BC%E3%82%BF%E3%82%AB%E3%82%BF%E3%83%AD%E3%82%B0%E3%81%A9%E3%81%86%E3%81%99%E3%82%8B%E5%95%8F%E9%A1%8C">Tip4: データカタログどうする問題</a></li></ol><h2 id="Glueジョブの開発と実行概要"><a href="#Glueジョブの開発と実行概要" class="headerlink" title="Glueジョブの開発と実行概要"></a>Glueジョブの開発と実行概要</h2><p>ローカル開発の前に、AWS Glueでのジョブ実行方法を簡単にお話します。複雑な処理をSparkジョブで実行するには、以下4ステップでOKです。</p><p>１）ジョブスクリプトを作成、S3に配置<br>２）ジョブ実行定義<br>３）「ワークフロー」によるジョブフロー定義<br>４）AWS Athenaを使った実行結果確認</p><p>３）のジョブフロー定義については、規模や構成によって他の方法を検討する余地が大きいですが、Glueの「ワークフロー」でも、以下のような機能は用意されています。</p><p>・画面GUIでのジョブフロー定義<br>・ジョブの並列実行、分岐、待合せ<br>・オンディマンド、スケジュール、EventBridgeイベントによるトリガ実行<br>・画面からの実行状態、結果、エラー確認、リトライ実行</p><p>４）について、<a href="https://docs.aws.amazon.com/ja_jp/athena/latest/ug/what-is.html">Athena</a>は、標準的なSQLを使用してS3のデータを直接分析できるサービスです。Athenaのクエリ実行には、AWS Glueデータカタログ（DatabaseやTable）の登録が必要ですが、これはAthenaのクエリエディタにDDLを実行すると簡単に行えます。（Glueのデータカタログ定義はTerraform等でも行えるので運用上は他の方法でもよいと思います。）</p><h2 id="Tip1-ローカル環境構築"><a href="#Tip1-ローカル環境構築" class="headerlink" title="Tip1: ローカル環境構築"></a>Tip1: ローカル環境構築</h2><p><a href="https://aws.amazon.com/jp/blogs/big-data/developing-aws-glue-etl-jobs-locally-using-a-container/">AWS公式にGlueコンテナが配布</a>されて、docker-composeによる環境構築が容易になりました。ローカル環境構築の詳細は、<a href="/articles/20210521a/">AWS Glueの開発環境の構築(2021)</a>を参照ください。</p><h2 id="Tip2-PySpark-SparkSQL開発"><a href="#Tip2-PySpark-SparkSQL開発" class="headerlink" title="Tip2: PySpark, SparkSQL開発"></a>Tip2: PySpark, SparkSQL開発</h2><p>Glueでは、3つのジョブタイプ、Python shell, Spark streaming, Spark script （Python, Scala）が選択できますが、今回はSpark script（PySpark, SparkSQL）を採用しました。<a href="https://spark.apache.org/docs/latest/api/python/index.html">PySpark</a>は、<a href="http://spark.apache.org/">Apache Spark</a>をPythonで呼出すライブラリです。<a href="https://spark.apache.org/sql/">SparkSQL</a>は、Apache Sparkのモジュールの1つで、SQLとDataFrameによる構造化データの処理を可能にします。</p><p>複雑な業務処理の実装にも以下のメリットがありました。</p><ul><li>構造化データ（Table）をメモリ上のDataFrameに取込み効率的に加工できる。</li><li>データカタログ（Table定義）があれば、プログラム上データ取込用のモデル定義を別につくる必要がない。</li><li>SparkSQLにより、複数ファイル（Table）の結合を含む、<a href="https://databricks.com/blog/2016/07/26/introducing-apache-spark-2-0.html">標準的なSQLによる操作が可能</a>。</li><li>SQL関数に含まれないPythonの関数やライブラリを使いたい場合にも、ユーザー定義関数 （UDF）を使えば、DataFrameの構造を維持したまま、特定のカラムに対してのみ処理を実行できる。</li></ul><p>以下、2ファイル(2 Tables)を結合してユーザー定義関数処理をするスクリプト例です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"><span class="keyword">from</span> awsglue.utils <span class="keyword">import</span> getResolvedOptions</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> DecimalType</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, ROUND_FLOOR, ROUND_HALF_UP, ROUND_CEILING</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round_fraction</span>(<span class="params">target: Decimal, meth: <span class="built_in">str</span>, pos: <span class="built_in">str</span></span>):</span></span><br><span class="line">    p = &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: <span class="string">&quot;1.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: <span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>: <span class="string">&quot;0.01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4&quot;</span>: <span class="string">&quot;0.001&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    methods = &#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: ROUND_FLOOR,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: ROUND_HALF_UP,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>: ROUND_CEILING,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pos <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> meth == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> pos == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    <span class="keyword">return</span> target.quantize(Decimal(p[pos]), rounding=methods[meth])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">udf_round_fraction = F.udf(round_fraction, DecimalType(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_sample</span>(<span class="params">glueContext, spark, input_dir, output_dir</span>):</span></span><br><span class="line">    data = [<span class="string">&quot;calc_source&quot;</span>, <span class="string">&quot;attributes&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        p = <span class="string">f&quot;s3://<span class="subst">&#123;input_dir&#125;</span>/<span class="subst">&#123;d&#125;</span>/&quot;</span></span><br><span class="line">        <span class="comment"># Sample to convert DynamicFrame to DataFrame then create temporary view</span></span><br><span class="line">        glueContext.create_dynamic_frame.from_options(</span><br><span class="line">            connection_type=<span class="string">&quot;s3&quot;</span>,</span><br><span class="line">            connection_options=&#123;<span class="string">&quot;paths&quot;</span>: [p]&#125;,</span><br><span class="line">            <span class="built_in">format</span>=<span class="string">&quot;parquet&quot;</span>,</span><br><span class="line">        ).toDF().createOrReplaceTempView(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SQL sample to join two tables</span></span><br><span class="line">    wk_main = spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        SELECT</span></span><br><span class="line"><span class="string">            src.id</span></span><br><span class="line"><span class="string">        ,src.number1</span></span><br><span class="line"><span class="string">        ,src.number2</span></span><br><span class="line"><span class="string">        ,src.position</span></span><br><span class="line"><span class="string">        ,src.method</span></span><br><span class="line"><span class="string">        ,src.group</span></span><br><span class="line"><span class="string">        ,att.attribute1</span></span><br><span class="line"><span class="string">        FROM</span></span><br><span class="line"><span class="string">            calc_sourcesrc</span></span><br><span class="line"><span class="string">        INNER JOIN</span></span><br><span class="line"><span class="string">            attributesatt</span></span><br><span class="line"><span class="string">        ON</span></span><br><span class="line"><span class="string">            src.group=att.group</span></span><br><span class="line"><span class="string">        WHERE</span></span><br><span class="line"><span class="string">            src.number1ISNOT NULL</span></span><br><span class="line"><span class="string">        ANDsrc.number2ISNOT NULL</span></span><br><span class="line"><span class="string">        ANDsrc.number2&lt;&gt;0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># UDF sample to calculate fractions</span></span><br><span class="line">    wk_main = wk_main.withColumn(</span><br><span class="line">        <span class="string">&quot;calc_result&quot;</span>,</span><br><span class="line">        udf_round_fraction(</span><br><span class="line">            F.col(<span class="string">&quot;number1&quot;</span>) / F.col(<span class="string">&quot;number2&quot;</span>),</span><br><span class="line">            F.col(<span class="string">&quot;method&quot;</span>),</span><br><span class="line">            F.col(<span class="string">&quot;position&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wk_main.write.mode(<span class="string">&quot;overwrite&quot;</span>).<span class="built_in">format</span>(<span class="string">&quot;parquet&quot;</span>).save(<span class="string">f&quot;s3://<span class="subst">&#123;output_dir&#125;</span>/sample_out/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    args = getResolvedOptions(sys.argv, [<span class="string">&quot;input_dir&quot;</span>, <span class="string">&quot;output_dir&quot;</span>])</span><br><span class="line">    glueContext = GlueContext(SparkContext.getOrCreate())</span><br><span class="line">    spark = glueContext.spark_session</span><br><span class="line">    <span class="comment"># Exec</span></span><br><span class="line">    exec_sample(glueContext, spark, args[<span class="string">&quot;input_dir&quot;</span>], args[<span class="string">&quot;output_dir&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Tip3-単体テスト-pytest"><a href="#Tip3-単体テスト-pytest" class="headerlink" title="Tip3: 単体テスト(pytest)"></a>Tip3: 単体テスト(pytest)</h2><p>ローカル環境での、PySparkスクリプトの単体テストは<a href="https://github.com/pytest-dev/pytest/">pytest</a>で可能です。方法は<a href="/articles/20191206/">AWS Glueの単体テスト環境の構築手順</a>を参照ください。実行結果のアサーションをファイル単位で行う場合は、DataFrameを比較できるツール（<a href="https://github.com/MrPowers/chispa">chispa</a>など）を利用すると便利です。</p><h2 id="Tip4-データカタログどうする問題"><a href="#Tip4-データカタログどうする問題" class="headerlink" title="Tip4: データカタログどうする問題"></a>Tip4: データカタログどうする問題</h2><p>データカタログは、データのファイルシステムをDatabaseとTableのように定義して管理する<a href="https://hive.apache.org/index.html">Hive</a>メタストア同様の機能を担っています。</p><p>データカタログは、上記Glueコンテナのディフォルト設定では呼出すことができず、CSVファイルを読込む際にデータ型定義ができない課題がありました。</p><p>CSVファイルをDataFrameに読込む際に、schema定義をかいてやることはできますが、ローカル環境でしか使わないコードを、対象データのカラムすべてに対して書くのは嬉しくありません。AWS環境のGlueデータカタログの定義と二重管理にもなります。そこで、2パタンの解決策をご紹介します。</p><ul><li>Tip4-1. AWS環境に接続してGlueデータカタログを使用する</li><li>Tip4-2. CSVではなく、Parquetファイルを使う</li></ul><h3 id="Tip4-1-AWS環境に接続してGlueデータカタログを使用する"><a href="#Tip4-1-AWS環境に接続してGlueデータカタログを使用する" class="headerlink" title="Tip4-1. AWS環境に接続してGlueデータカタログを使用する"></a>Tip4-1. AWS環境に接続してGlueデータカタログを使用する</h3><p>AWSアカウントの使える状態であれば、AWS環境のS3からGlueデータカタログを使用してファイルを読込むのが楽です。ローカル環境のGlueコンテナ内から、以下のようなコードが実行できます。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> awsglue.context <span class="keyword">import</span> GlueContext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glueContext = GlueContext(SparkContext.getOrCreate())</span><br><span class="line">df = glueContext.create_dynamic_frame.from_catalog(</span><br><span class="line">    database=<span class="string">&quot;sampledb&quot;</span>,</span><br><span class="line">    table_name=<span class="string">&quot;departuredelays&quot;</span>,</span><br><span class="line">    push_down_predicate=<span class="string">&quot;(any==&#x27;sample&#x27;)&quot;</span>,</span><br><span class="line">).toDF()</span><br><span class="line"></span><br><span class="line">df.write.mode(<span class="string">&quot;overwrite&quot;</span>).<span class="built_in">format</span>(<span class="string">&quot;parquet&quot;</span>).save(</span><br><span class="line">    <span class="string">&quot;s3://bucket_name/departuredelays_out/any=sample/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>このスクリプト実行のためには、DatabaseとTable定義を予めGlueデータカタログに登録しておく必要があります。Athenaから登録するには以下のようなDDLを使用します。読込みファイルがCSVの場合です。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE sampledb</span><br><span class="line">  LOCATION <span class="string">&#x27;s3://bucket_name/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> sampledb.departuredelays (</span><br><span class="line">  `<span class="type">date</span>` string,</span><br><span class="line">  `delay` <span class="type">int</span>,</span><br><span class="line">  `distance` <span class="type">int</span>,</span><br><span class="line">  `origin` string,</span><br><span class="line">  `destination` string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  `<span class="keyword">any</span>` string)</span><br><span class="line"><span class="type">ROW</span> FORMAT SERDE</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">&#x27;separatorChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;escapeChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;quoteChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;s3://bucket_name/departuredelays&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;has_encrypted_data&#x27;</span><span class="operator">=</span><span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;skip.header.line.count&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">  )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>おまけですが、出力結果をAthenaから確認するためには、出力ディレクトリのTable定義を登録します。今回出力ファイルはParquetなので、DDLは以下のようになります。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> sampledb.departuredelays_out (</span><br><span class="line">  `<span class="type">date</span>` string,</span><br><span class="line">  `delay` <span class="type">int</span>,</span><br><span class="line">  `distance` <span class="type">int</span>,</span><br><span class="line">  `origin` string,</span><br><span class="line">  `destination` string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  `<span class="keyword">any</span>` string)</span><br><span class="line"><span class="type">ROW</span> FORMAT SERDE</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe&#x27;</span></span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat&#x27;</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;s3://bucket_name/departuredelays_out&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;has_encrypted_data&#x27;</span><span class="operator">=</span><span class="string">&#x27;false&#x27;</span></span><br><span class="line">  )</span><br><span class="line">;</span><br></pre></td></tr></table></figure></br></br><h3 id="Tip4-2-CSVではなく、Parquetファイルを使う"><a href="#Tip4-2-CSVではなく、Parquetファイルを使う" class="headerlink" title="Tip4-2. CSVではなく、Parquetファイルを使う"></a>Tip4-2. CSVではなく、Parquetファイルを使う</h3><p>AWS環境の使えない状態でも、ファイルをParquetフォーマットで作成できれば、型の保存された状態で読込ができます。Parquetは、CSVよりも保存性や読書き性能の面で有利です（<a href="https://databricks.com/jp/glossary/what-is-parquet">Apache Parquetについて</a>）。</p><p>Parquetファイルは直接開いて中が確認できないですが、上記のようにAthenaで確認できますし、ローカル環境でも、Jupyter Notebook上でDataFrameに読込んでschema表示・データ表示できます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>AWS Glueで複雑な処理を開発するときのTipsをご紹介しました。複雑なロジック開発とテストにAWS Glue環境を用いるのは費用面で不利なので、ぜひローカル環境を活用したいところです。特にファイルIOについては、ローカル環境とAWS環境で同じコードで処理できるようにするのがポイントだと思います。Glueジョブ開発の一助になれば幸いです。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li><a href="/articles/20211006a/">AWS Glue Data CatalogでCSVを扱う - フューチャー技術ブログ</a><ul><li>AWS環境で、Glueデータカタログを使ってCSVファイルを扱う方法が紹介されています。</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      <category domain="https://future-architect.github.io/tags/Glue/">Glue</category>
      
      <category domain="https://future-architect.github.io/tags/Athena/">Athena</category>
      
      <category domain="https://future-architect.github.io/tags/PySpark/">PySpark</category>
      
      <category domain="https://future-architect.github.io/tags/SparkSQL/">SparkSQL</category>
      
      
      <comments>https://future-architect.github.io/articles/20211011a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Microsoft Learnを使用したスキル向上チャレンジ</title>
      <link>https://future-architect.github.io/articles/20211008b/</link>
      <guid>https://future-architect.github.io/articles/20211008b/</guid>
      <pubDate>Thu, 07 Oct 2021 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;TIGの川村英之です。&lt;/p&gt;
&lt;p&gt;みなさん、Azureの勉強をどうやっていますか？&lt;br&gt;本を買う、Webで情報収集、有料のセミナーなど様々な方法がありますが、&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>TIGの川村英之です。</p><p>みなさん、Azureの勉強をどうやっていますか？<br>本を買う、Webで情報収集、有料のセミナーなど様々な方法がありますが、<a href="https://docs.microsoft.com/ja-jp/learn/">Microsoft Learn</a>はご存じでしょうか？</p><p>私事ですが、このサイトを利用することでAzureの知識を身につけ、資格取得にもつなげることができました。</p><p>当ドキュメントはそんなMicrosoft Learn（以下MS Learn）の概要と利用方法、サイトを活用したイベント開催などをご紹介しようと思います。</p><h1 id="MS-Learnとは"><a href="#MS-Learnとは" class="headerlink" title="MS Learnとは"></a>MS Learnとは</h1><p>Microsoft LearnはMicrosoftが提供する、無料で利用できる学習用Webサイトです。ただドキュメントを参照するだけでなく、時限的なサンドボックス環境も提供され実際のAzure環境を操作しながら学ぶこともできます。元々はMicrosoftの社内用教育ドキュメントだったというもので、これを一般に公開したそうです。また、この手のサイトにある英語を機械翻訳したままの読みづらいサイトではなく、日本語ローカライズにも力が入っておりドキュメントの読みやすさも一定のレベルを誇っています。</p><p>＜MS Learnトップページ＞<br><img src="/images/20211008b/mslearn01.jpg" alt="MS Learnトップページ" width="1200" height="1205" loading="lazy"></p><p>Azure以外にもMicrosoft365、GitHUB、.Net、Office365などのMirosoft製品について学ぶこともでき、各モジュール（学習コンテンツ）を連携させたラーニングパスを使用することで、体系だった学習を行うこともできます。（例：資格取得向けのラーニングパスを使用し受験前の学習を行う）</p><p>＜ラーニングパスの例＞<br><img src="/images/20211008b/mslearn02.jpg" alt="ラーニングパスの画面" width="1200" height="1204" loading="lazy"></p><p>各モジュールを実施すると経験値がたまり、経験値が一定の数値に達するとレベルアップするというゲーム的要素もあります。こちらは後述するクラウドスキルチャレンジでも利用します。</p><h1 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h1><p>アカウントを作りMS Learnにログインしたら<a href="https://docs.microsoft.com/ja-jp/learn/browse/">ドキュメントの検索ページ</a>に行きます。そこから、学習したいコンテンツを検索し学習を行う形になります。学習したいポイントがピンポイントかつ明確な場合はモジュール単位、一つのテーマを体系だてて学びたい時はラーニングパス単位で学習を行うのが良いと思います。</p><p>＜AZ-104での検索例＞<br><img src="/images/20211008b/mslearn03.jpg" alt="AZ-104の検索結果" width="1200" height="805" loading="lazy"></p><p>演習の中でサンドボックスを使用する場合は、サンドボックスを有効化した上でAzure Portalにアクセスし仮想マシンを作成したり、学習ページからAzure CLIを実行してWebサーバを構築したりと実際のAzureを操作しながら学習を進めることができます。</p><p>＜サンドボックスを使用したドキュメント例＞<br><img src="/images/20211008b/mslearn04.jpg" alt="サンドボックスを使用したドキュメント例" width="999" height="1494" loading="lazy"></p><p>各ページのコンテンツを学習して、次ページに遷移すると経験値が加算されます。ラーニングパスを全て学習し終えるとボーナスポイントも加算されてレベルアップが早くなります。</p><h1 id="クラウドスキルチャレンジ"><a href="#クラウドスキルチャレンジ" class="headerlink" title="クラウドスキルチャレンジ"></a>クラウドスキルチャレンジ</h1><p>フューチャーでは定期的にMS Learnを利用したクラウドスキルチャレンジというイベントを開催し、イベント期間で積み上げた経験値を使って勝敗を競い合うイベントを行っています。</p><p>このイベントは申請を行えばどなたでも開催できるイベントで、会社内、会社間でもイベント開催が可能となっております。状況により一部制約はありますが、「期間中に積み上げた経験値で競う方式」、「事前に定義された特定のカリキュラムのクリア数を競う方式」の２つの方式にそれぞれ個人戦、チーム戦といったルールを組み合わせての開催が可能です。</p><p>＜クラウドスキルチャレンジ（画像のイベントは経験値＆チーム戦）＞<br><img src="/images/20211008b/mslearn06.jpg" alt="クラウドスキルチャレンジ 2021秋のトップページ" width="1200" height="1123" loading="lazy"></p><p>クラウドスキルチャレンジを開催したい、開催に興味がある方はMicrosoftの事務局（<a href="mailto:&#109;&#115;&#x6a;&#x70;&#99;&#115;&#99;&#64;&#x6d;&#105;&#99;&#x72;&#111;&#115;&#111;&#x66;&#x74;&#x2e;&#99;&#111;&#109;">&#109;&#115;&#x6a;&#x70;&#99;&#115;&#99;&#64;&#x6d;&#105;&#99;&#x72;&#111;&#115;&#111;&#x66;&#x74;&#x2e;&#99;&#111;&#109;</a>）にコンタクトをとることで、イベントについての説明を聞いたり、開催についての調整を行うことができます。</p><h1 id="終わりに"><a href="#終わりに" class="headerlink" title="終わりに"></a>終わりに</h1><p>誰でも無料で利用でき、サンドボックス環境で実際の環境を操作することもでき、経験値・レベル制によって自分の学習状況積み上げができるMS Learn。</p><p>クラウドスキルチャレンジと組み合わせることで、楽しみながら学習も行える素晴らしいサービスですので皆様も活用してはいかがでしょうか。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/Azure/">Azure</category>
      
      <category domain="https://future-architect.github.io/tags/Microsoft/">Microsoft</category>
      
      <category domain="https://future-architect.github.io/tags/MicrosoftLearn/">MicrosoftLearn</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97/">スキルアップ</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%82%B9%E3%82%AD%E3%83%AB%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8/">クラウドスキルチャレンジ</category>
      
      
      <comments>https://future-architect.github.io/articles/20211008b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>scikit-learn 1.0 リリース！更新内容を一部紹介します。</title>
      <link>https://future-architect.github.io/articles/20211008a/</link>
      <guid>https://future-architect.github.io/articles/20211008a/</guid>
      <pubDate>Thu, 07 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;こんにちは、TIG所属の玉木です。この記事は&lt;a href=&quot;/articles/20210927b/&quot;&gt;Python連載&lt;/a&gt;の7本目の記事になります。&lt;/p&gt;
&lt;p&gt;2021年9月24日にscikit-learn</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>こんにちは、TIG所属の玉木です。この記事は<a href="/articles/20210927b/">Python連載</a>の7本目の記事になります。</p><p>2021年9月24日にscikit-learn 1.0がリリースされました。私が大学院生のころ、scikit-learnのサンプルを動かすところから機械学習を勉強したので、ついに1.0かとなんだか感慨深い気持ちがあります(<a href="/articles/20210511a/">この記事</a>で紹介しているPython 機械学習プログラミングです)。本記事ではリリースから少し時間が経ってしまいましたが、<a href="https://scikit-learn.org/stable/auto_examples/release_highlights/plot_release_highlights_1_0_0.html">リリースハイライト</a>、<a href="https://scikit-learn.org/stable/whats_new/v1.0.html">チェンジログ</a>から、個人的に気になった以下の4つの内容を紹介しようと思います。</p><ol><li>キーワード引数の強制</li><li>pandasのデータフレームからの特徴量名のサポート</li><li>新しいplot用のクラス追加</li><li>StratifiedGroupKFoldの追加</li></ol><h2 id="1-キーワード引数の強制"><a href="#1-キーワード引数の強制" class="headerlink" title="1. キーワード引数の強制"></a>1. キーワード引数の強制</h2><p>scikit-learnの機械学習のモデルのクラス、メソッドは、多くの入力パラメータを持ちます。</p><p>以前のscikit-learnでは以下のようにクラスをインスタンスすることができました。以下<a href="https://scikit-learn.org/stable/auto_examples/release_highlights/plot_release_highlights_1_0_0.html">リリースハイライト</a>からの引用です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">est = HistGradientBoostingRegressor(<span class="string">&quot;squared_error&quot;</span>, <span class="number">0.1</span>, <span class="number">100</span>, <span class="number">31</span>, <span class="literal">None</span>,</span><br><span class="line">    <span class="number">20</span>, <span class="number">0.0</span>, <span class="number">255</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">False</span>, <span class="string">&quot;auto&quot;</span>, <span class="string">&quot;loss&quot;</span>, <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">1e-7</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>上記は極端な例ですが、この記述の仕方だと、各位置の引数がどんな意味をもつかわからず、APIドキュメントを確認する必要があります。このような位置引数を用いた初期化はTypeErrorが発生するようになります。代わりに以下のようにキーワード引数を用いて初期化します。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">est = HistGradientBoostingRegressor(</span><br><span class="line">    loss=<span class="string">&quot;squared_error&quot;</span>,</span><br><span class="line">    learning_rate=<span class="number">0.1</span>,</span><br><span class="line">    max_iter=<span class="number">100</span>,</span><br><span class="line">    max_leaf_nodes=<span class="number">31</span>,</span><br><span class="line">    max_depth=<span class="literal">None</span>,</span><br><span class="line">    min_samples_leaf=<span class="number">20</span>,</span><br><span class="line">    l2_regularization=<span class="number">0.0</span>,</span><br><span class="line">    max_bins=<span class="number">255</span>,</span><br><span class="line">    categorical_features=<span class="literal">None</span>,</span><br><span class="line">    monotonic_cst=<span class="literal">None</span>,</span><br><span class="line">    warm_start=<span class="literal">False</span>,</span><br><span class="line">    early_stopping=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    scoring=<span class="string">&quot;loss&quot;</span>,</span><br><span class="line">    validation_fraction=<span class="number">0.1</span>,</span><br><span class="line">    n_iter_no_change=<span class="number">10</span>,</span><br><span class="line">    tol=<span class="number">1e-7</span>,</span><br><span class="line">    verbose=<span class="number">0</span>,</span><br><span class="line">    random_state=<span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>位置引数を用いた初期化に比べて、キーワード引数を持ちいた初期化の方が各引数の意味がわかり、非常に読みやすいです。すべての位置引数が禁止されるわけではないのですが、ライブラリの方で可読性が良くなるように書き方を強制してくれるのは嬉しい変更です。</p><h2 id="2-pandasのデータフレームからの特徴量名のサポート"><a href="#2-pandasのデータフレームからの特徴量名のサポート" class="headerlink" title="2. pandasのデータフレームからの特徴量名のサポート"></a>2. pandasのデータフレームからの特徴量名のサポート</h2><p>scikit-learnでは機械学習のためのデータ変換、前処理の機能が多くあります。例えばscikit-learnのpreprocessモジュールのOneHotEncoderを用いればカテゴリ変数を数値表現に変換でき、StandardScalerを用いれば、数値を標準化できます。</p><p>これまでは変換器の入力がpandasのデータフレームであっても、元の列名を保持できず、列名が欲しい場合は自分で列名を作って与える必要がありました。scikit-learn 1.0ではColumnTransformerのような変換器が列名を保持するようになり、get_feature_names_outメソッドを使うだけで簡単にデータ変換後の列名も取得できるようになりました。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder, StandardScaler</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">X = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&quot;category_name&quot;</span>: [<span class="string">&quot;Men/T-shirts&quot;</span>, <span class="string">&quot;Women/T-shirts&quot;</span>, <span class="string">&quot;Women/T-shirts&quot;</span>],</span><br><span class="line">    <span class="string">&quot;brand_name&quot;</span>: [<span class="string">&quot;Nike&quot;</span>, <span class="string">&quot;adidas&quot;</span>, <span class="string">&quot;PUMA&quot;</span>],</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Xは以下のようなデータフレームになります。</p><img src="/images/20211008a/X_origin.png" alt="Xのデータフレーム" width="591" height="262" loading="lazy"><p>ColumnTransformerを用いて、Xのカテゴリ変数に対してはone-hot encoding、量的変数に対しては標準化を行います。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preprocessor = ColumnTransformer(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;numerical&quot;</span>, StandardScaler(), [<span class="string">&quot;price&quot;</span>]),</span><br><span class="line">        (<span class="string">&quot;categorical&quot;</span>, OneHotEncoder(), [<span class="string">&quot;category_name&quot;</span>, <span class="string">&quot;brand_name&quot;</span>]),</span><br><span class="line">    ],</span><br><span class="line">    verbose_feature_names_out=<span class="literal">False</span>,</span><br><span class="line">).fit(X)</span><br><span class="line"></span><br><span class="line">preprocessor.get_feature_names_out()</span><br></pre></td></tr></table></figure><p>preprocessor.get_feature_names_out()の出力は以下のようになります。列名が保持されているだけでなく、変換後の特徴量に対しても列名がつけられていることがわかります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;category_name_Men/T-shirts&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;category_name_Women/T-shirts&#x27;</span>, <span class="string">&#x27;brand_name_Nike&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;brand_name_PUMA&#x27;</span>, <span class="string">&#x27;brand_name_adidas&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>今回追加されたget_feature_names_out()はscikit-learnでデータ変換を行い、pandasのデータフレームに再度変換したい場合などに便利です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(preprocessor.transform(X), columns=preprocessor.get_feature_names_out())</span><br></pre></td></tr></table></figure><p>以下の画像のように変換後のデータを簡単にデータフレームに戻すことができます。<br><img src="/images/20211008a/scikit.png" alt="データフレームに戻した表現" width="1200" height="161" loading="lazy"></p><p>pandasのget_dummiesメソッドを使っても同様のone-hot encodingは可能です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(X)</span><br></pre></td></tr></table></figure><p>以下get_dummiesの出力です。<br><img src="/images/20211008a/pandas.png" alt="get_dummies出力結果の表" width="1200" height="162" loading="lazy"></p><p>ほぼ同じデータフレームが得られました。今回のように数値変換も同時にscikit-learnで行いたい場合などには、scikit-learnの変換器を通してget_feature_names_out()を使うのがいいのかなと思います。</p><h2 id="3-新しいplot用のクラス追加"><a href="#3-新しいplot用のクラス追加" class="headerlink" title="3. 新しいplot用のクラス追加"></a>3. 新しいplot用のクラス追加</h2><p>これまで混合行列やROC曲線を描画したいときは、sklearn.metricsモジュールのplot_confusion_matrixやplot_roc_curveが使えましたが、scikit-lean 1.0からは非推奨になり、1.2では削除の予定とのことです。代わりにConfusionMatrixDisplay、PrecisionRecallDisplayといったクラスが追加されました。元のplot_*関数はestimatorが引数に必要だったのですが、from_predictionsメソッドを使うことにより、ラベルと予測した値を渡せば描画ができるようになりました。</p><p>以下<a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ConfusionMatrixDisplay.html">APIドキュメント</a>からサンプルコードの引用です。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> ConfusionMatrixDisplay</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">X, y = make_classification(random_state=<span class="number">0</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">clf = SVC(random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">SVC(random_state=<span class="number">0</span>)</span><br><span class="line">y_pred = clf.predict(X_test)</span><br><span class="line">ConfusionMatrixDisplay.from_predictions(y_test, y_pred)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>描画される混合行列は以下になります。<br><img src="/images/20211008a/confusion_matrix.png" alt="描画される混合行列のマトリクス図" width="306" height="266" loading="lazy"></p><h2 id="4-StratifiedGroupKFoldの追加"><a href="#4-StratifiedGroupKFoldの追加" class="headerlink" title="4. StratifiedGroupKFoldの追加"></a>4. StratifiedGroupKFoldの追加</h2><p>機械学習のモデルの評価において、交差検証における検証データの作り方は非常に重要です。例として、以下のKaggle State Farm Distracted Driver Detectionに参加したスライドが参考になります。</p><p><a href="https://speakerdeck.com/iwiwi/kaggle-state-farm-distracted-driver-detection?slide=22">https://speakerdeck.com/iwiwi/kaggle-state-farm-distracted-driver-detection?slide=22</a></p><p>このスライドでは検証データに同じドライバーのデータを使っていたために、学習データの汎化性能を正しく評価できなかった、学習データと検証データ間に同じドライバーのデータを含めないようにしたら正しく評価できるようになった、と報告しています。</p><p>このようにデータの分割の手法は重要なのですが、今回追加されたStratifiedGroupKFoldは、そのデータ分割の手法のうちの１つです。StratifiedGroupKFoldはStratifiedKFoldとGroupKFoldの２つの機能をあわせたデータの分割方法です。StratifiedKFoldは各セブセットのクラスの比率が維持されるようにデータを分割します。特にクラスの分布が均等でない場合に有効です。</p><p>GroupKFoldは、各セブセット間に同じグループが含まれないように分割します。先程の例のように、同じドライバーを含めてしまうと不当に高くモデルの性能を評価してしまう、といったことを防ぎます。この２つの特徴をどちらも同時に使いたいときがあるのですが、これまでscikit-learnにはこの機能はなく、自分で実装する必要がありました。scikit-learn 1.0からは簡単に使えるようになりました。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>本記事ではscikit-learn 1.0に追加された以下の機能を簡単に紹介しました。</p><ol><li>キーワード引数の強制</li><li>pandasのデータフレームからの特徴量名のサポート</li><li>新しいplot用のクラス追加</li><li>StratifiedGroupKFoldの追加</li></ol><p>普段scikit-learnを使っている方の参考になれば幸いです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/DataScience/">DataScience</category>
      
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/">機械学習</category>
      
      <category domain="https://future-architect.github.io/tags/pandas/">pandas</category>
      
      <category domain="https://future-architect.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
      <comments>https://future-architect.github.io/articles/20211008a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pandas 1.0以降での変更点を一部紹介します</title>
      <link>https://future-architect.github.io/articles/20211007b/</link>
      <guid>https://future-architect.github.io/articles/20211007b/</guid>
      <pubDate>Wed, 06 Oct 2021 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211007b/1080x360.png&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;360&quot;&gt;

&lt;p&gt;SAIGの小橋昌明です。業務ではずっとPythonを書いています。&lt;/p&gt;
&lt;p&gt;今回は &lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211007b/1080x360.png" alt="" width="1080" height="360"><p>SAIGの小橋昌明です。業務ではずっとPythonを書いています。</p><p>今回は <a href="/articles/20210927b/">Python連載</a> の6日目です。</p><p>Pythonを使ってデータ分析をする上で無くてはならないのがpandasです。<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/index.html">リリースノート</a>を見てみると、メジャーアップデートによる1.0.0 がリリースされたのが2020年の1月で、現時点での最新は1.3.3です。</p><p>ただ、1.0以降の機能で私自身が使ってるものは何だろうかと考えてみると、<code>query</code>関数のエスケープシーケンスだけしか使っていない気がします。DataFrameから条件を指定してデータを抽出する<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html">query関数</a>は、列名に記号を含んでいたりすると上手く動かないことがありますが、v1.0以降はbacktick記号 (` ` )で囲むと動くようになりました。リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#other">こちら</a>。</p><p>しかし上記は新しい機能のごく一部にすぎません。せっかくバージョンアップされているのに、機能を使わないのはちょっともったいない……</p><p>今回、pandas 1.0以降の変更点を調べたので、2つ紹介します。</p><p>なお、1.0以降の最も大きい機能追加はpd.NAが導入されたことだと思います。が、これに関しては<a href="https://qiita.com/hkzm/items/52195729e9b00ae88789">pandas 1.2.0+ での pd.NA の特徴</a>という記事に非常に詳しく書かれているので、本記事では述べません。</p><h2 id="重複したラベルを許容しないオプション指定-v1-2～"><a href="#重複したラベルを許容しないオプション指定-v1-2～" class="headerlink" title="重複したラベルを許容しないオプション指定(v1.2～)"></a>重複したラベルを許容しないオプション指定(v1.2～)</h2><p>※試験的な機能（Experimental Feature）</p><p>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.2.0.html#optionally-disallow-duplicate-labels">こちら</a>、User Guide内の説明は<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/duplicates.html#disallowing-duplicate-labels">こちら</a>です。<br>このセクションのサンプルコードは全て、執筆時点の最新であるpandas 1.3.3を用いています。</p><p>pandasのindexやcolumnには重複したラベルを付けることができます。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>v1.2以降では、<code>set_flags</code>関数を用いて、ラベル重複を許容しないようにすることができます。重複していた場合は<code>DuplicateLabelError</code>というエラーが上がります。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]).set_flags(allows_duplicate_labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">DuplicateLabelError: Index has duplicates.</span><br><span class="line">      positions</span><br><span class="line">label</span><br><span class="line">a        [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>ラベルに重複があるかどうかを調べるだけならば、<code>is_unique</code>関数を使えばよいです。こちらは1.0よりも前からある機能です。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]).index.is_unique</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="https://sinhrks.hatenablog.com/entry/2015/07/11/223124">ラベルが重複していると処理時間が長くなってしまう</a>ので、<code>concat</code>などでDataFrameを作った後はラベルを振り直した方が良いのでしょう。</p><p>さて、<code>allows_duplicate_labels</code> の値は操作を通じて伝播（propagate）していきます。<br>ただ試験的な機能につき、伝播しない操作も多く存在するため注意しましょう、とドキュメントには書いてあります。</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.2.0.html#optionally-disallow-duplicate-labels">リリースノート</a>にある例です。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = (</span><br><span class="line">    pd.Series([<span class="number">1</span>, <span class="number">2</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">      .set_flags(allows_duplicate_labels=<span class="literal">False</span>)</span><br><span class="line">)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重複ラベルが発生する操作</span></span><br><span class="line">a.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">DuplicateLabelError: Index has duplicates.</span><br><span class="line">      positions</span><br><span class="line">label</span><br><span class="line">a        [<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>新しいSeriesを作る<code>reindex</code>関数の返り値にも、<code>allows_duplicate_labels=False</code>が伝播して設定されています。</p><p>では、試しに<code>merge</code>関数の例をやってみましょう。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_B&#x27;</span> : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">&#125;)</span><br><span class="line">df1 = df1.set_flags(allows_duplicate_labels=<span class="literal">False</span>) <span class="comment"># set_flags()関数は新たなDataFrameを返すので、再度代入する必要がある</span></span><br><span class="line">df1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_B</span><br><span class="line"><span class="number">0</span>   foo     <span class="number">10</span></span><br><span class="line"><span class="number">1</span>   bar     <span class="number">20</span></span><br><span class="line"><span class="number">2</span>   baz     <span class="number">30</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_C&#x27;</span> : [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">&#125;, index=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br><span class="line">df2</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_C</span><br><span class="line"><span class="number">1</span>   foo    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>   foo    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>   bar    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>col_Aを基準に<code>merge</code>すると、結果のDataFrameのindexは新たに0から振り直されるので、重複は発生しません。したがって、indexを基準に<code>merge</code>します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1.merge(df2, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A_x  col_B col_A_y  col_C</span><br><span class="line"><span class="number">1</span>     bar     <span class="number">20</span>     foo    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>     bar     <span class="number">20</span>     foo    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>     baz     <span class="number">30</span>     bar    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>エラーが発生せずに、重複ラベルを含むDataFrameが作れてしまいました。<code>allows_duplicate_labels</code>の値を確認します。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp = df1.merge(df2, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">temp.flags.allows_duplicate_labels</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>どうやら、<code>merge</code>をすると<code>allows_duplicate_labels</code>の値は伝播されないようです。まだ挙動には注意が必要そうですね。</p><h2 id="存在しないラベルに対する-locの挙動（v1-0～、v1-1～）"><a href="#存在しないラベルに対する-locの挙動（v1-0～、v1-1～）" class="headerlink" title="存在しないラベルに対する.locの挙動（v1.0～、v1.1～）"></a>存在しないラベルに対する.locの挙動（v1.0～、v1.1～）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col_A&#x27;</span> : [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col_B&#x27;</span> : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">    <span class="string">&#x27;col_C&#x27;</span> : [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">&#125;)</span><br><span class="line">df1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col_B  col_C</span><br><span class="line"><span class="number">0</span>   foo     <span class="number">10</span>    <span class="number">0.1</span></span><br><span class="line"><span class="number">1</span>   bar     <span class="number">20</span>    <span class="number">0.2</span></span><br><span class="line"><span class="number">2</span>   baz     <span class="number">30</span>    <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>ここで、<code>.loc</code>関数で複数の行を指定し、その中に存在しない行名が入っている場合の挙動を示します。<br>まずはpandas 1.0.0より前の挙動から。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 0.25.3</span></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">FutureWarning:</span><br><span class="line">Passing <span class="built_in">list</span>-likes to .loc <span class="keyword">or</span> [] <span class="keyword">with</span> <span class="built_in">any</span> missing label will <span class="keyword">raise</span></span><br><span class="line">KeyError <span class="keyword">in</span> the future, you can use .reindex() <span class="keyword">as</span> an alternative.</span><br><span class="line"></span><br><span class="line">    col_A  col_B  col_C</span><br><span class="line"><span class="number">1</span>     bar   <span class="number">20.0</span>    <span class="number">0.2</span></span><br><span class="line"><span class="number">999</span>   NaN    NaN    NaN</span><br></pre></td></tr></table></figure><p>将来的にはエラーになるよという旨の<code>FutureWarning</code>が出ます。また、存在しないindexの分は<code>NaN</code>が要素に入ります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 0.25.3</span></span><br><span class="line">df1.loc[:, [<span class="string">&#x27;col_A&#x27;</span>, <span class="string">&#x27;col-C&#x27;</span>]] <span class="comment"># 列名を間違えた場合</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">  col_A  col-C</span><br><span class="line"><span class="number">0</span>   foo    NaN</span><br><span class="line"><span class="number">1</span>   bar    NaN</span><br><span class="line"><span class="number">2</span>   baz    NaN</span><br></pre></td></tr></table></figure><p>列を指定するときにうっかり列名を間違えたりすると、全要素が<code>NaN</code>の列が新たに作られたDataFrameが返ってきます。<br>実際のデータ分析ではDataFrameを表示しないでしょうから、分析を進めるとしばらく後で思わぬエラーに遭遇して戸惑うかもしれません。</p><p>この挙動は1.0以降で変更されました。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 1.0.0</span></span><br><span class="line"></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">&#x27;Passing list-likes to .loc or [] with any missing labels is no longer supported, see https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#deprecate-loc-reindex-listlike&#x27;</span></span><br></pre></td></tr></table></figure><p>1.0以降では存在しない行名が含まれている場合、<code>KeyError</code>が上がります。<br>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#removal-of-prior-version-deprecations-changes">こちら</a>です。<br>（「列名を間違えた場合」の例でも全く同じエラーになるので、こちらは割愛します）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas 1.3.3 = 最新版</span></span><br><span class="line"></span><br><span class="line">df1.loc[[<span class="number">1</span>, <span class="number">999</span>]]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">&#x27;[999] not in index&#x27;</span></span><br></pre></td></tr></table></figure><p>さらに1.1以降では、エラーメッセージが分かりやすくなりました。どのラベルが存在しないかを表示してくれます<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。<br>リリースノートは<a href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.1.0.html#keyerrors-raised-by-loc-specify-missing-labels">こちら</a>です。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>1.0.0 メジャーアップデート後のpandasの、新しい機能や変更点を紹介しました。Experimental Featureもあり、使う際には注意も必要ですが、必要に応じて活用していけると良いですね。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">調べていたら1.2.3と最新1.3.3との間でKeyErrorのメッセージが少し違っていることにも気づいたのですが、あまりにもマニアックなので脚注に書くだけに留めておきます。いつ変更されたんだろう?</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      <category domain="https://future-architect.github.io/tags/pandas/">pandas</category>
      
      
      <comments>https://future-architect.github.io/articles/20211007b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java17対応版！Javaコーディング規約の紹介</title>
      <link>https://future-architect.github.io/articles/20211007a/</link>
      <guid>https://future-architect.github.io/articles/20211007a/</guid>
      <pubDate>Wed, 06 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211007a/top.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;556&quot;&gt;


&lt;p&gt;フューチャーのGitHubリポジトリで公開している&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211007a/top.png" alt="" width="640" height="556"><p>フューチャーのGitHubリポジトリで公開している<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>をJava17に対応させたのでその宣伝記事です。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Future Enterprise Coding Standards | Javaコーディング規約</a></li></ul><h2 id="Java17"><a href="#Java17" class="headerlink" title="Java17"></a>Java17</h2><p>先日の2021年9月14日にJava17がリリースされました。</p><p>Java17は長期サポートされる（LTS）バージョンです。前回のLTSのJava11からすると、3年ぶりのLTS版のリリースとなります。</p><h3 id="Java12からJava17の新機能"><a href="#Java12からJava17の新機能" class="headerlink" title="Java12からJava17の新機能"></a>Java12からJava17の新機能</h3><p>前回のLTS版から追加されたみてJava17まででどんな機能が追加されたのかを簡単にまとめると以下です。（これら以外にもあります。）</p><ul><li>switch式とswitch新構文</li><li>テキストブロック</li><li>レコード</li><li>パターンマッチング</li><li>シールクラス</li></ul><p>次のページが大変参考になります。</p><ul><li><a href="https://docs.oracle.com/javase/jp/16/language/java-language-changes.html">Oracle Help Center | Java言語の変更</a></li><li><a href="https://www.ne.jp/asahi/hishidama/home/tech/java/uptodate.html#JDK12">ひしだま’s 技術メモページ | Java新機能（Javaの変更点）</a></li></ul><h2 id="Javaコーディング規約"><a href="#Javaコーディング規約" class="headerlink" title="Javaコーディング規約"></a>Javaコーディング規約</h2><p>フューチャーでは<a href="https://future-architect.github.io/coding-standards/">Future Enterprise Coding Standards</a>と名前をつけてコーディング規約を公開しています。その辺りの詳しい話は2016年に公開された記事を参照してください。</p><ul><li><a href="/articles/20160902/">システム屋さんがうれしいJava8対応のコーディング規約を公開します！！</a></li></ul><p>特に<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>は2016年に公開してからもJavaのアップデートに伴って更新し続けています。そのおかげかこの<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>は、現在、日本ではかなり有名になり（と勝手に思っています😅）、「<a href="https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92Java-%E6%96%B0%E7%89%88-%E5%B1%B1%E7%94%B0-%E7%A5%A5%E5%AF%9B/dp/4798151122">独習Java新版</a>」や「<a href="https://www.amazon.co.jp/%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82-%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E6%8A%80%E8%A1%93-%E8%AA%AD%E3%81%BF%E3%82%84%E3%81%99%E3%81%8F%E4%BF%9D%E5%AE%88%E3%81%97%E3%82%84%E3%81%99%E3%81%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E4%BD%9C%E6%B3%95-PRESS-plus/dp/4297120488">[増補改訂]良いコードを書く技術</a>」などでもリンクが紹介されるほどです。</p><p>今回はこの<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>をJava17のリリースに伴って、Java17で追加された新機能や新構文についての規約の追加や変更を行いました。</p><p>以降で、Java17にどのような構文が追加されて、<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>でどのようなルールを追加したのか簡単に紹介します。</p><h3 id="switch式"><a href="#switch式" class="headerlink" title="switch式"></a>switch式</h3><p>switch式は式として書けるswitch構文です。例えば次のように使用します。<br>（構文についての詳細は「<a href="https://docs.oracle.com/javase/jp/16/language/switch-expressions.html">Oracle Help Center | Java言語更新 &gt; Switch式</a>」などを参照してください。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> day = DayOfWeek.SUNDAY;</span><br><span class="line"><span class="keyword">var</span> shortDay = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY -&gt; <span class="string">&quot;M&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY -&gt; <span class="string">&quot;W&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> FRIDAY -&gt; <span class="string">&quot;F&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY, THURSDAY -&gt; <span class="string">&quot;T&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> SUNDAY, SATURDAY -&gt; <span class="string">&quot;S&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>switch式が使用できない以前は、上記の例のような場合、変数宣言と代入を別の場所に記述する必要があるおかげで、変数を実質的finalにできず、Javaのラムダ式と一緒に使いにくいなどの問題がありましたが、switch式を使えばこの問題の多くを解決することができます。</p><p>関連するコーディング規約は次のリンクです。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#switch-%E5%BC%8F">Future Enterprise Coding Standards | Javaコーディング規約 &gt; switch 式</a></li></ul><p>switch式は便利なことが多いため、<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>でも積極的に使用するように推奨しています。</p><h3 id="switch新構文"><a href="#switch新構文" class="headerlink" title="switch新構文"></a>switch新構文</h3><p>switch文は、<code>break</code>の記述忘れによって起こるフォールスルーが原因で不具合を生みやすい構文です。そのため使用を避けることをコーディングルールとされることが少なくない構文でもあります。</p><p>Java17（正確にはJava14）では、switch式が追加されたついでに、case句の構文にアロー構文が使用できるようになりました。これを使用すると<code>break</code>を使用しなくてもそれぞれのcaseが独立しフォールスルーが起こらなくなります。<br>（構文についての詳細は「<a href="https://docs.oracle.com/javase/jp/16/language/switch-expressions.html">Oracle Help Center | Java言語更新 &gt; Switch式</a>」などを参照してください。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = LocalDate.now();</span><br><span class="line"><span class="keyword">switch</span> (date.getDayOfWeek()) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !localCalendar.isHoliday(date) &amp;&amp;</span><br><span class="line">            !localCalendar.isHoliday(date.minusDays(<span class="number">1</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// breakは不要です！</span></span><br><span class="line">    <span class="keyword">case</span> TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!localCalendar.isHoliday(date)) &#123;</span><br><span class="line">            work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>関連するコーディング規約は以下のリンクです。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#switch-%E6%96%87">Future Enterprise Coding Standards | Javaコーディング規約 &gt; switch 文</a></li><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#switch-%E5%BC%8F">Future Enterprise Coding Standards | Javaコーディング規約 &gt; switch 式</a></li></ul><p><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>では、フォールスルーの問題を避けるため、switch式とswitch文を記述する際はアロー構文の使用を推奨することにしました。</p><p>「<a href="https://docs.oracle.com/javase/jp/16/language/switch-expressions.html">Oracle Help Center | Java言語更新 &gt; Switch式</a>」でもアロー構文を推奨する記載があります。次は「<a href="https://docs.oracle.com/javase/jp/16/language/switch-expressions.html">Oracle Help Center | Java言語更新 &gt; Switch式</a>」からの引用です。</p><blockquote><p><strong>ノート:</strong><code>case L -&gt;</code>ラベルの使用をお薦めします。<code>case L:</code>ラベルの使用時は、<code>break</code>文または<code>yield</code>文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。<br><code>case L -&gt;</code>ラベルで、複数の文または式でないコード、あるいは<code>throw</code>文を指定するには、それらをブロック内に囲みます。<code>case</code>ラベルが生成する値を<code>yield</code>文で指定します。</p></blockquote><h3 id="テキストブロック"><a href="#テキストブロック" class="headerlink" title="テキストブロック"></a>テキストブロック</h3><p>テキストブロックは複数行のテキストをそのまま記述できる構文です。<br>（構文についての詳細は「<a href="https://docs.oracle.com/javase/jp/16/language/text-blocks.html">Oracle Help Center | Java言語更新 &gt; テキスト・ブロック</a>」などを参照してください。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String message = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        これはテキストブロックです。</span></span><br><span class="line"><span class="string">        複数行のテキストをそのまま複数行のテキストで書くことができます。</span></span><br><span class="line"><span class="string">        複数の文字列リテラルを+で連結して記述するよりも読みやすいです。</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>テキストブロックについてのスタイルガイドが公式の「<a href="https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks">テキスト・ブロック・プログラマーズ・ガイド</a>」の「<a href="https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks">Style Guidelines For Text Blocks（英語）</a>」に記載されています。</p><p><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>には<a href="https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks">Style Guidelines For Text Blocks（英語）</a>を参考にして日本語で書いた内容が記載されています。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%95%E3%82%99%E3%83%AD%E3%83%83%E3%82%AF">Future Enterprise Coding Standards | Javaコーディング規約 &gt; テキストブロック</a></li></ul><p>例えば、基本的にテキストブロックの中で<code>\n</code>を使うことを禁止しますが、記述しても良い場合について書いていたりします。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSVとしての１レコードをわかりやすくするために、1レコード内の改行コードデータについては`\n`を使用しています。</span></span><br><span class="line">String csv = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        名前,説明,MIMEタイプ</span></span><br><span class="line"><span class="string">        CSV,&quot;</span>Comma-Separated Valuesの略\nCharacter-Separated Valuesの意味で使用されることもある<span class="string">&quot;,&quot;</span>text/csv<span class="string">&quot;</span></span><br><span class="line"><span class="string">        TSV,&quot;</span>Tab-Separated Valuesの略<span class="string">&quot;,&quot;</span>text/tab-separated-values<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="レコード"><a href="#レコード" class="headerlink" title="レコード"></a>レコード</h3><p>レコードはJavaで名前付きタプルを実現しようと設計された新しい構文と機能です。</p><p>「<a href="https://blogs.oracle.com/otnjp/post/records-come-to-java-ja">Oracle Technology Network Japan Blog | Javaにレコードが登場</a>」が詳しいです。<br>構文としては次のように記述します。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Rect</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> width, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>関連するコーディング規約は次のリンクです。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#%E3%83%AC%E3%82%B3%E3%83%BC%E3%83%88%E3%82%99">Future Enterprise Coding Standards | Javaコーディング規約 &gt; レコード</a></li></ul><p>コーディング規約では、使用する箇所を明確にする必要があることや、JavaDocや記述スタイルについてのルールが追加されています。</p><h3 id="パターンマッチング"><a href="#パターンマッチング" class="headerlink" title="パターンマッチング"></a>パターンマッチング</h3><p>Java17では<code>instanceof</code>の式に続けて変数名を書くことで、型がマッチした場合に変数がその型として使用できるようになる構文です。<br>（構文についての詳細は「<a href="https://docs.oracle.com/javase/jp/16/language/pattern-matching-instanceof-operator.html">Oracle Help Center | Java言語更新 &gt; instanceofのパターン・マッチング</a>」などを参照してください。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="keyword">var</span> lower = s.toLowerCase();</span><br><span class="line">    <span class="comment">// このように書く必要がない！</span></span><br><span class="line">    <span class="comment">// var lower = ((String)o).toLowerCase();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ちなみに、プレビュー機能を使用する場合、switchとパターンマッチングを組み合わせて使用することも可能です。）</p><p>関連するコーディング規約は次のリンクです。</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html#%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9">Future Enterprise Coding Standards | Javaコーディング規約 &gt; インスタンス</a></li></ul><p>とても便利なので、コーディング規約では、キャストの際に使用するように推奨しています。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>その他、Java17の新機能や廃止機能に合わせていくつか（主にサンプルコードを）修正しています。是非一度見てみてください！</p><ul><li><a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Future Enterprise Coding Standards | Javaコーディング規約</a></li></ul><p>ちなみに、この<a href="https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html">Javaコーディング規約</a>ですが、ルールが多くとても厳しいです。</p><p>これは、そのまま使うことをあまり想定していなくて、自分のチームで使用しないルールは、マークダウンから削除したり入れ替えたりして使うことを想定しているためです。各自が必要なルールを考えて追加するよりは不要なルールを削除する方が簡単なため、予め多くのルールを用意するようにしています。</p><p>「ルールが多すぎて、とてもじゃないけど守りきれないから結局使えない」と思う方は、いくつかを削除する前提で見ていただけると良いと思います。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Java/">Java</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84/">コーディング規約</category>
      
      <category domain="https://future-architect.github.io/tags/Java17/">Java17</category>
      
      
      <comments>https://future-architect.github.io/articles/20211007a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWSクラウドの耐障害性、可用性を高めるための前提知識</title>
      <link>https://future-architect.github.io/articles/20211006b/</link>
      <guid>https://future-architect.github.io/articles/20211006b/</guid>
      <pubDate>Tue, 05 Oct 2021 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;TIGの伊藤真彦です。&lt;br&gt;最近会社のPodCastである&lt;a href=&quot;https://anchor.fm/futuretechcast&quot;&gt;Future Tech</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>TIGの伊藤真彦です。<br>最近会社のPodCastである<a href="https://anchor.fm/futuretechcast">Future Tech Cast</a>に出演させていただきました。聞いていただけると嬉しいです。</p><p>先日クラウドサービスの障害について社内で体系的に説明する機会があり、0から全体的なイメージがつかめるような情報を整理してみました。</p><h1 id="まえがき、良質なクラウドサービス"><a href="#まえがき、良質なクラウドサービス" class="headerlink" title="まえがき、良質なクラウドサービス"></a>まえがき、良質なクラウドサービス</h1><p>Webサービス、ITソリューションが自前のサーバーではなくクラウドサービスを利用して構築されるようになって久しいですが…と語っていきたい所ですが、私がITの世界に足を踏み入れた時には、既にAWSを使う事が当たり前の時代になっていました、世の中の変遷を語るだけの含蓄を私は持っていません。</p><p>私のようにIT技術に触れた瞬間からクラウドサービスが存在していた世代が産まれる程度に長い時間をかけ、AWS、GCP、Azure各種クラウドサービスは業界に浸透し、使いこなすためのノウハウは一朝一夕では身につかないほど膨大な知識量となりました。</p><p>現在のクラウドサービスでは、提供されるサービスを最大限活用することで、世界中からのアクセスに低遅延で応答する、数百万人規模の同時アクセスに耐える、障害発生時も継続して利用可能であるなど、高い性能を有するサービスを作ることも可能です。</p><p>一方で性能とコストを天秤にかけベストな落としどころを見極めるための知識、同じ性能を維持したままコストを抑えるための知識も必要です。</p><p>今回はAWSの耐障害性、高可用性をテーマに、必要な知識を体系的に学べる情報を集めました。</p><h1 id="クラウドサービスにおける障害とは"><a href="#クラウドサービスにおける障害とは" class="headerlink" title="クラウドサービスにおける障害とは"></a>クラウドサービスにおける障害とは</h1><p>クラウドサービスの実態は各国、各地域に実際にサーバーなどハードウェアが設置されたデータセンターと呼ばれる施設であり、私たちはそれをレンタルしてサービスを構築しています。</p><p>最近の事例だと<a href="https://www.youtube.com/watch?v=Pn3miC_tTH0&t=2s">AWS公式によるEC2 Macインスタンスの紹介動画</a>でAWS EC2担当部署のVice PresidentであるDavid Brown氏がウキウキでトラックに満載されたMacを手にする動画が記憶に新しいです。</p><p>ひたすらMacの箱を開けるお仕事を何時間まで楽しくやれるか、時給100円で良いのでやってみたいです。</p><img src="/images/20211006b/image.png" alt="image.png" width="1200" height="625" loading="lazy"><p>▲AWS EC2 Mac Instances Launch - macOS in the cloud for the first time, with the benefits of EC2 - Youtubeより</p><p>この動画がどこまで本当かはともかく、クラウドサービスとして提供されたものは、行きつくところまで行けば必ず物理的なハードウェア本体が存在し、それらはAWS職員によって管理されてています。当然と言えば当然のことですが、物理機器がそこにある以上何らかの原因で利用できなくなる可能性は0ではありません。</p><p>下記のような原因が想定できます。</p><ul><li>ハードウェア本体の故障</li><li>前段のネットワーク機器の故障による通信不良</li><li>許容量を超えたアクセス</li><li>その他設備の故障に起因するハードウェア不具合</li><li>自然災害によるネットワーク断</li><li>データセンターの火災</li><li>悪意のある攻撃による故障、接続不良</li><li>AWSでのオペレーションミス</li></ul><p>例えば<a href="https://aws.amazon.com/jp/message/56489/">2019年の東京リージョンの大規模障害</a>では空調設備の管理システム障害によるサーバーのオーバーヒートという生々しい原因がレポートされています。今年(2021年)は<a href="https://aws.amazon.com/jp/message/17908/">AWS Direct Connect</a>のリージョンレベルでの大規模障害がありました。ここまで大きく、また具体的な調査レポートが報告されることは年に一度あるか無いかといったレベルです。</p><p>しかし大規模障害によりAWSに依存する各種サービスが軒並み利用不能になり、ソーシャルゲームのtwitter公式アカウントが障害報告をツイートしはじめる事で、大事件が起きている事が非IT系の方々まで伝わる様子を一度は目にすることになるでしょう。</p><p>さて、上記のシナリオで出てきたTwitterはタイムラインの運用基盤にAWSを採用している事が<a href="https://press.aboutamazon.com/news-releases/news-release-details/twitter-selects-aws-strategic-provider-serve-timelines/">AWS公式のプレスリリース</a>でも確認できます。しかしながら障害発生時においても日本でTwitterを利用することは可能です。</p><p>もちろんTwitterが凄いのですが、そこには大規模障害発生時においても正常に動くシステムを構築するためのノウハウがあるはずです。</p><p>どのようなノウハウがあるかを、私が思いつく限り整理してみました。</p><h1 id="可用性について"><a href="#可用性について" class="headerlink" title="可用性について"></a>可用性について</h1><p>可用性とは、システムが継続して稼働できる度合いや能力を意味します。</p><p>英語ではアベイラビリティと呼びます、アベイラビリティゾーンのアベイラビリティと同じです。AWSクラウドそのものの可用性という意味でももちろん使われますが、自分たちで構築するシステム単位での可用性という意味でも使われます。</p><p>可用性が高いことを高可用性と表現することがあります。</p><h1 id="SPOFについて"><a href="#SPOFについて" class="headerlink" title="SPOFについて"></a>SPOFについて</h1><p>障害発生時に利用できるサービスと利用できないサービスの差はどこにあるのでしょうか。答えはSPOF(Single Point Of Failure)、日本語で言うと単一障害点の有無が大きく影響します。SPOFとはその名の通り、その単一箇所が働かないと、システム全体が障害となるような箇所を指します。</p><p>例えば、WEBサービスを自分たちで購入した一台のサーバーを利用して動いている場合、サーバーのLANケーブルが１本抜けただけでサービスが止まります。</p><p>そこで、アプリケーションを複数台のサーバーにインストールして、それらをロードバランサー経由で利用し、トラブルが起きたサーバーはロードバランサーから切り離す仕組みを作る事でリスクを回避できます。部分的に壊れることがある前提で、壊れても正常に動く仕組みにする事を冗長化と呼びます。</p><p>AWSクラウドにおいてもオンプレミスにおいても、SPOFの存在を見抜き、冗長化することが堅牢なサービスを作る手段になります。一方冗長化をすると当然必要なハードウェアが増えていくため、必要なインフラコストは増えていきます。闇雲にリッチな構成を整えるだけでなく、サービスが求める可用性とコストのバランスを考慮する必要があります。</p><p>AWSのマネージドサービスの場合、ある程度の冗長化が済んでいるものが多いです。サービスごとに、リージョンレベル、AZレベルでの耐障害性があるもの、また利用方法によって耐障害性を高めることができるものがあります。AWSクラウドのものであっても、意識して利用しないとSPOFとなるサービスも存在するため、サービスの特性をきちんと理解して運用しましょう。</p><h1 id="AZ、リージョンについて"><a href="#AZ、リージョンについて" class="headerlink" title="AZ、リージョンについて"></a>AZ、リージョンについて</h1><img src="/images/20211006b/image_2.png" alt="image.png" width="815" height="394" loading="lazy"><p>クラウドサービスの耐障害性においては、AZ(アベイラビリティゾーン)、リージョンという概念が存在します。</p><p>東京リージョンのap-northeast-1aのように住所のようなものとして使うほか、障害の規模感、および耐障害性のレベル感として、AZ障害、マルチAZ、マルチリージョンやクロスリージョンバックアップといった使われ方をします。</p><p>AWSクラウドを利用する上では必須の知識とも言えます、公式ドキュメントは<a href="https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">こちら</a>です。</p><h2 id="AZ-アベイラビリティーゾーン-とは"><a href="#AZ-アベイラビリティーゾーン-とは" class="headerlink" title="AZ(アベイラビリティーゾーン)とは"></a>AZ(アベイラビリティーゾーン)とは</h2><p>前述の通り、AWSクラウドも究極的にはデータセンターのハードウェアをレンタルしている事になります。</p><p>AZとは、このデータセンターをネットワークで接続し、冗長化したエリアのことを指します。AWSクラウドを利用するロケーションを選択する際の最小単位がリージョンであり、データセンターを指定することはできません。AWSクラウドのシステムは、データセンターで火災が発生するレベルの事象が起きても問題なく利用できる、もしくは即座に復旧されることになります。</p><p>東京リージョンの場合、現在<code>ap-northeast-1a</code>から<code>ap-northeast-1d</code>まで4つのAZが存在します。AZごとのネットワークレイテンシが違いすぎる事がないよう、各AZは互いに100km圏内に存在します。障害の内容によっては、どのAZであっても軒並み利用不能になる、リージョンレベルでの障害が発生します</p><h2 id="リージョンとは"><a href="#リージョンとは" class="headerlink" title="リージョンとは"></a>リージョンとは</h2><p>AZをグループ化したものをリージョンと呼びます。日本では東京リージョン、大阪リージョンが存在します。</p><p>リージョンが増える度に<a href="https://aws.amazon.com/jp/blogs/news/now-open-third-availability-zone-in-the-aws-canada-central-region/">AWS公式ブログ</a>やプレスリリースで現状が紹介されますが、日本にリージョンが2つある事が中々恵まれている事が伺えます。</p><img src="/images/20211006b/image_3.png" alt="image.png" width="1024" height="520" loading="lazy"><p>リージョンが変わるとネットワークレイテンシがAZの変化より大きく変わるため、耐障害性の面だけでなく、世界中からのアクセスに問題なく対応するという観点でクロスリージョンでの冗長化をする場合があります。</p><p>日本で利用されるサービスは当然日本のリージョンで運用した方がネットワークレイテンシが少ないため、基本的にはどの国にサービス利用者が多く存在するかでリージョンを選ぶことになります。</p><p>マネージドサービスにはデフォルトでAZレベルの耐障害性を持っているものの、更にリージョンレベルで複製する機能を備えたものも存在します。</p><h1 id="障害発生時にダウンしないサービスを作る"><a href="#障害発生時にダウンしないサービスを作る" class="headerlink" title="障害発生時にダウンしないサービスを作る"></a>障害発生時にダウンしないサービスを作る</h1><p>どのようなサービスを、どのように冗長化できるのか、マネージドサービスが基本的にはどのレベルでの冗長化が為されているのかを学ぶことで、適切な耐障害性を持ったサービスを構築するための足がかりとなります。</p><h2 id="AZレベルでの冗長化"><a href="#AZレベルでの冗長化" class="headerlink" title="AZレベルでの冗長化"></a>AZレベルでの冗長化</h2><p>同じリソースを複数台、マルチAZ構成で展開することで、一つのAZが利用不可能になってもサービスを継続利用できます。</p><p>例としては、WEBサーバーを複数のAZに分散配置して、前段にELBを設置する手法があります。AWS公式のユーザーズガイドの<a href="https://docs.aws.amazon.com/ja_jp/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html">Elastic Load Balancing の仕組み</a>の画像が参考になります。</p><img src="/images/20211006b/image_4.png" alt="image.png" width="392" height="359" loading="lazy"><p>この構成を取ることで、特定のAZが利用不可能になってもサービス全体としては機能します。</p><p>障害発生時にもサービスの性能を落としたくない場合は、一つ一つプロビジョニングしているEC2インスタンスを<a href="https://docs.aws.amazon.com/ja_jp/autoscaling/plans/userguide/what-is-aws-auto-scaling.html">AWS Auto Scaling</a>を利用したインスタンス群にすることも可能です。AWS Auto Scalingはインスタンスの負荷に応じて自動でサービスをスケーリングすることでコストダウンする事も狙いの一つですが、インスタンスの不具合を自動復旧できる事や、AZ障害発生時にも総合的な性能を維持する事も期待できます。</p><p>EC2インスタンス以外でも、<a href="https://aws.amazon.com/jp/rds/features/multi-az/">RDSのマルチAZ配置</a>や、<a href="https://docs.aws.amazon.com/ja_jp/AmazonElastiCache/latest/red-ug/AutoFailover.html">ElastiCacheのマルチAZ配置</a>など、デフォルトではAZレベルの冗長化がなされていないサービスが存在します。</p><p>古いサービスの場合、NATゲートウェイを使えば良い所をNATインスタンスのままになっていて、そこがSPOFになる場合があります。AWS S3の場合はデフォルトでマルチAZでの耐久性が保証されていますが、バケットの耐久性の設定を1ゾーン低頻度アクセスにすることで、コストを抑えることも可能です。</p><p>利用しているサービスが、現在どのような耐障害性を持っていて、どのような強化が可能かを把握する事が重要です。</p><h2 id="リージョンレベルでの冗長化"><a href="#リージョンレベルでの冗長化" class="headerlink" title="リージョンレベルでの冗長化"></a>リージョンレベルでの冗長化</h2><p>前述しましたが何らかの原因でリージョン全体が利用できなくなる可能性は0ではありません、数年に一度くらいの頻度では発生しうる障害です。リージョン間での冗長化を行う事で、リージョン全体が利用できなくなるほどの障害発生時においてもサービスの停止を回避することは可能です。</p><p>性質上システム全体を冗長化しないと一切の問題なく動くようにはできない事と、大規模障害の発生頻度を考慮すると、このレベルで冗長化されているサービスは比較的少ないです。</p><p>S3のクロスリージョンレプリケーション、DynamoDBのグローバルテーブル、RDSのクロスリージョンリードレプリカなど、マネージドサービスにはサービスごとにリージョンを超えた複製を行うシステムが公式から提供されている事があります。</p><p><a href="https://docs.aws.amazon.com/ja_jp/elasticloadbalancing/latest/application/introduction.html">Application Load Balancer</a>は別のリージョンにアクセスを振り分けることができない、<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/copy-ami-region/">AMI</a>や<a href="https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/ebs-copy-snapshot.html">EBSのスナップショット</a>はそのままでは別のリージョンでは利用できず、クロスリージョンのコピーを作成する必要があるなど、AZ間での冗長化とは前提、難易度が異なってくる場合があります。</p><h1 id="障害復旧可能なサービスを作る"><a href="#障害復旧可能なサービスを作る" class="headerlink" title="障害復旧可能なサービスを作る"></a>障害復旧可能なサービスを作る</h1><p>障害発生時に一切ダウンしないサービスを作るという目標を据える事も可能ですが、コストや工数と求められるレベル感のバランスにより実現できないケースは大いにあり得ます。</p><p>しかし障害発生時の復旧を可能な限り迅速に行うための準備、障害によるダメージを最小限に抑えるための工夫を行う余地はあります。</p><p>そのような観点で工夫できないか検証する、または要求レベルとしてどのような品質が求められるかをあらかじめ検討、定義する事は必要になってくるでしょう。</p><h2 id="RPO-RTOについて"><a href="#RPO-RTOについて" class="headerlink" title="RPO, RTOについて"></a>RPO, RTOについて</h2><p>障害復旧においてはRPO、RTOという概念があります（AWSの試験に出ます）。</p><p>RPOは<code>Recovery Point Objective</code>の略です。障害発生時に主にアプリケーションのデータ損失がどの地点まで回復可能かを意味します。RTOは<code>Recovery Time Objective</code>の略です。これは単純に障害発生時から回復までに要する時間です。これらの指標はサービスの性能を意味するものにもなりますが、ビジネス的な要求から指標を定義することで、災害復旧戦略を逆算することが可能になります。</p><p>例えばデータベースのバックアップを一時間に一度保存すればRPOは最長一時間になります、データベースのクロスリージョンリードレプリカを作成して、障害発生時にレプリカをマスターに昇格すればおけばRPOはほぼリアルタイムになります。</p><p>RTOの例ですが、システムのレプリカを別リージョンに常に展開し、障害発生時はアクセスをレプリカに接続させることで、RTOがほぼ０のような厳しい条件をクリアできます。RTOに時間の猶予が許される場合は、普段は単一リージョンで運用することでコストを抑えることが可能になります。</p><h2 id="障害復旧のための様々な戦略"><a href="#障害復旧のための様々な戦略" class="headerlink" title="障害復旧のための様々な戦略"></a>障害復旧のための様々な戦略</h2><p>障害復旧のための戦略にはいくつか名称が付けられているものがあります。</p><p>障害復旧はディザスタ・リカバリ(DR)と呼ばれ、障害発生時に退避するリージョンをDRリージョンと呼ぶことがあります。</p><h3 id="パイロットライト"><a href="#パイロットライト" class="headerlink" title="パイロットライト"></a>パイロットライト</h3><p>パイロットライトとは、ガスヒーターなどの設備が、素早く着火できるように常に点灯している小さな火の事です。</p><p>そのパイロットライトのように、DRリージョンに停止したサーバーを用意しておく、IaaSを用いて別リージョンにシステムを構築するといった手法を意味します。障害発生時はDRリージョンに切り替えを行います、基本的には<a href="https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53</a>の接続先設定の変更によって切り替えを行います。</p><p>コストを抑えつつ、リージョンレベルの可用性を持たせることが可能になります。</p><h3 id="ウォームスタンバイ"><a href="#ウォームスタンバイ" class="headerlink" title="ウォームスタンバイ"></a>ウォームスタンバイ</h3><p>DRリージョンにスペックを下げた同構成でシステム一式を常時起動しておきます。</p><p>障害発生時は素早くDRリージョンに切り替え、必要に応じてスケールアップします。</p><h3 id="マルチサイト"><a href="#マルチサイト" class="headerlink" title="マルチサイト"></a>マルチサイト</h3><p>ホットスタンバイとも呼ばれます、スペックも含め全く同じ構成をDRリージョンに用意しておきます。</p><p>コストがかかっても一切ダウンが許されないシステムではこのような構成をとることが可能です。</p><h3 id="バックアップと復元"><a href="#バックアップと復元" class="headerlink" title="バックアップと復元"></a>バックアップと復元</h3><p>上記3つはリージョンが利用不能な状態でも復元可能な手法ですが、定期的にデータのバックアップを取り、リージョンが回復してから可能な限り素早くシステムを回復できるように備える事も立派なDR戦略です。</p><p>RDSやEBS、AMIなど各サービスごとに、どのように定期的なバックアップをとることが出来るのかを把握することは大切です。</p><h1 id="障害を検知、自動通知、復旧する仕組みを整備する"><a href="#障害を検知、自動通知、復旧する仕組みを整備する" class="headerlink" title="障害を検知、自動通知、復旧する仕組みを整備する"></a>障害を検知、自動通知、復旧する仕組みを整備する</h1><p>障害発生時は公式のアナウンスを待つより早く気が付けるに越したことはありません。</p><p>AWS全体ではなく、自分たちのシステムだけが落ちている可能性もあります。</p><p>ヘルスチェックの仕組みを整備し、通知する仕組みを整備することで、障害にいち早く気がつくことが可能になります。</p><p>これら仕組みは、<a href="https://aws.amazon.com/jp/cloudwatch/">Amazon CloudWatch</a>、<a href="https://aws.amazon.com/jp/sns/?whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc">Amazon SNS</a>といったサービスを活用することで構築可能です。</p><p><a href="https://aws.amazon.com/jp/rds/">Amazon RDS</a>の場合、<a href="https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/UserGuide/USER_Events.html">Amazon RDS イベント通知</a>という仕組みが用意されています。</p><p><a href="https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/UsingAlarmActions.html">EC2インスタンスの場合、CloudWachアラームを受けて自動で復旧、再起動する設定</a>が用意されています。</p><h1 id="性能面での可用性を高める"><a href="#性能面での可用性を高める" class="headerlink" title="性能面での可用性を高める"></a>性能面での可用性を高める</h1><p>AWSクラウド側に問題が無くても、思わぬアクセス急増やDDoS攻撃など悪意のあるアクセスに対し、構築したシステムの性能が追いついていないことでシステムが利用不可能になることはあり得ます。</p><p>一方必要以上にハイスペックなシステムを整えるとインフラコストが問題になってきます。</p><p>システムの需要と可用性のバランスを整えていくことが重要になります。</p><h2 id="アクセスの急増に備える"><a href="#アクセスの急増に備える" class="headerlink" title="アクセスの急増に備える"></a>アクセスの急増に備える</h2><p>新製品のプレスリリースを行った結果会社のホームページが落ちた、ソーシャルゲームをリリースしたが想定以上の人気にサーバーがダウンした、というような事例が実際に起きています。</p><p>AWSクラウドの場合<a href="https://aws.amazon.com/jp/autoscaling/">AWS Auto Scaling</a>を活用したシステムを構成する事で、高いコスト効率を保ちつつ、急激なアクセス増に耐えるシステムを構築することが可能です。</p><p>前述したDDoS攻撃は<a href="https://aws.amazon.com/jp/shield/?whats-new-cards.sort-by=item.additionalFields.postDateTime&whats-new-cards.sort-order=desc">AWS Shield</a>を利用してシステムを保護することが可能です。</p><h2 id="キャッシュを有効活用する"><a href="#キャッシュを有効活用する" class="headerlink" title="キャッシュを有効活用する"></a>キャッシュを有効活用する</h2><p>アクセスを処理する能力をシステム全体の性能だけで解決すると当然コストがかかります。</p><p>キャッシュ層を構築することで、コストを抑えつつアクセスに効率よく応答することが可能になります。</p><p><a href="https://aws.amazon.com/jp/cloudfront/">Amazon CloudFront</a>によるコンテンツのキャッシュや、DBの前段に<a href="https://aws.amazon.com/jp/elasticache/">Amazon ElastiCache</a>を配置するといった戦略が考えられます。</p><h2 id="レイテンシを意識する"><a href="#レイテンシを意識する" class="headerlink" title="レイテンシを意識する"></a>レイテンシを意識する</h2><p>リージョン間の冗長化は障害発生に備えたものだけではなく、世界中で安定して使えるサービスを作るという意味でも役に立ちます。</p><p><a href="https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53</a>には<a href="https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/TutorialTransitionToLBR.html">レイテンシーベースルーティング</a>というルーティングアルゴリズムがあり、これを活用することで、複数リージョンに展開したシステムのうち、最もレイテンシの少ないリージョンを利用することが可能になります。</p><p>ヘルスチェックを活用することで、普段はレイテンシが最小のリージョンを利用し、障害発生時は別のリージョンにフェイルオーバーする、といった仕組みを整えることが可能になります。</p><h1 id="安全なリリース、ダウンタイムゼロでのリリースを行う"><a href="#安全なリリース、ダウンタイムゼロでのリリースを行う" class="headerlink" title="安全なリリース、ダウンタイムゼロでのリリースを行う"></a>安全なリリース、ダウンタイムゼロでのリリースを行う</h1><p>アプリケーションの新機能をリリースした際にバグがあった、リリース手順を間違えてしまった、というシナリオで障害が発生することも考えられます。<br>またデプロイ時に瞬間的にアクセスできなくなることをダウンタイムと呼びます。<br>デプロイ戦略を整備することで、リリース失敗時に素早く切り戻す、ユーザーへの影響を最小限に留める、デプロイにおけるダウンタイムを最小に抑えることが可能です。<br>ここにもコストと性能のバランスに応じた様々な戦略が存在します。</p><h2 id="Blue-Greenデプロイ"><a href="#Blue-Greenデプロイ" class="headerlink" title="Blue/Greenデプロイ"></a>Blue/Greenデプロイ</h2><p>ブルーおよびグリーンと呼ぶ同じ環境を２つ用意し、デプロイ時には利用していない方の環境を更新し、更新した環境を利用開始し、問題があった場合は元の環境に接続し直す手法をBlue/Green デプロイと呼びます。</p><p><a href="https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53</a>を利用すれば基本的にどのアーキテクチャでも実現可能です。<a href="https://aws.amazon.com/jp/codedeploy/">AWS CodeDeploy</a>を利用すると、<a href="https://aws.amazon.com/jp/quickstart/architecture/blue-green-deployment/">AWS Elastic Beanstalk</a>、<a href="https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/userguide/deployment-type-bluegreen.html">Amazon ECS</a>などのサービスで、整備されたBlue/Greenデプロイを実現するための仕組みを利用することが可能です。</p><p>最も安全ですが、２環境分の運用コストが発生します。</p><h2 id="Canaryリリース"><a href="#Canaryリリース" class="headerlink" title="Canaryリリース"></a>Canaryリリース</h2><p>２環境の接続先を切り替える際の戦略として、Canaryリリースと呼ばれる戦略があります。これはトラフィックの一部を新環境に流し、問題なければ全員にリリースしていく手法です。ここでのCanary(カナリア)は、炭鉱労働者が一酸化炭素中毒やガス漏れに気がつくよう、カゴに入れたカナリアを連れて、カナリアが死んでしまった場合はその場から退避をする手法を検討した、生理学者John Scott Haldane氏による実験に由来します。<br>気の毒な話ですが、新環境に真っ先に触れる一部のユーザーがこのカナリアに例えられています。</p><p><a href="https://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53</a>では加重ルーティングポリシーと呼ばれるルーティングアルゴリズムが存在します。</p><p>これは指定した比率で複数のリソースにトラフィックをルーティングするアルゴリズムです。一部のトラフィックがセーフであれば残りを一気に切り替えることも、10%、20%と線形に切り替える比率を増やしていくことも可能です。Canaryリリースは<a href="https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/canary-release.html">API Gateway</a>でも機能として用意されています。<a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/11/application-load-balancer-simplifies-deployments-support-for-weighted-target-groups/">2019年から、同じことをALBでもできるようになりました</a>。</p><h2 id="冗長化されたサーバーの更新戦略"><a href="#冗長化されたサーバーの更新戦略" class="headerlink" title="冗長化されたサーバーの更新戦略"></a>冗長化されたサーバーの更新戦略</h2><p>完全に切り分けた環境を切り替えない手法でも、冗長化された複数のサーバーをどのように更新していくか、という観点での戦略があります。</p><p>これら戦略は<a href="https://docs.aws.amazon.com/ja_jp/elasticbeanstalk/latest/dg/using-features.rolling-version-deploy.html">AWS Elastic Beanstalk</a>のオプションとして用意されており、参考になります。</p><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>同じ環境でWebサーバーを既存の台数と同じ数だけ新しく構築し、問題なければ古いサーバーを削除します。</p><p>問題があった際の既存の状態への影響が少ないですが、一時的にコストがかかります。</p><p>新旧のシステムが一時的に混在するというデメリットもあります。</p><h3 id="Rolling"><a href="#Rolling" class="headerlink" title="Rolling"></a>Rolling</h3><p>サーバーの一部をシステムから切り離し、更新を行ってからシステムに再接続します。</p><p>コストは抑えられますが、一時的なシステムの性能ダウンと、新旧のシステムが一時的に混在するというデメリットがあります。性能低下を防ぐため、一時的にサーバーを増やして、問題なければ古いサーバーを落とす処理を繰り返す<code>Rolling with additional batch </code>と呼ばれる戦略もあります。一度に何台のサーバーを操作するかはシステムの全体的なサイズとリリースにかかる時間のバランスを見て調整します。</p><h3 id="トラフィック分割"><a href="#トラフィック分割" class="headerlink" title="トラフィック分割"></a>トラフィック分割</h3><p>Blue/Greenデプロイ、Canaryリリースと同様の手法をロードバランサーの単位で行います。</p><h3 id="All-At-Once"><a href="#All-At-Once" class="headerlink" title="All At Once"></a>All At Once</h3><p>瞬間的なシステム断が許容できる場合は、全てのサーバーをまとめて更新します。</p><p>手間がかからないという意味では最も楽な仕組みです。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>障害を起こさないための戦略、障害発生時の対応を体系的に学ぶという観点で、思いつく限り書いてみました。</p><ul><li>クラウドサービスも人が運用したシステムであり、様々な障害が起こりうる</li><li>耐障害性を向上する</li><li>復旧戦略を整備する</li><li>障害を検知する仕組みを整備する</li><li>高可用性を持ったシステムを作る</li><li>リリース戦略を整備する</li></ul><p>各観点においてさらに深掘り、詳細な説明をする余地がまだまだありますので、この記事を読んで気になった点を調べてみてください。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/">初心者向け</category>
      
      <category domain="https://future-architect.github.io/tags/AWS%E8%A8%AD%E8%A8%88/">AWS設計</category>
      
      
      <comments>https://future-architect.github.io/articles/20211006b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS Glue Data CatalogでCSVを扱う</title>
      <link>https://future-architect.github.io/articles/20211006a/</link>
      <guid>https://future-architect.github.io/articles/20211006a/</guid>
      <pubDate>Tue, 05 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p><a href="/articles/20210927b/">Python連載</a>の5本目です。</p><p>当初テーマを<a href="https://databricks.com/jp/glossary/pyspark">PySpark</a>で予定しておりましたが、そこから派生して、<a href="https://aws.amazon.com/jp/glue/">AWS Glue</a>を題材にさせていただきます。</p><h1 id="AWS-Glue-Data-Catalogについて"><a href="#AWS-Glue-Data-Catalogについて" class="headerlink" title="AWS Glue Data Catalogについて"></a>AWS Glue Data Catalogについて</h1><p>Glueといっても大きく下記の３種類、処理系をいれると4種類に分かれると思っていますが、それぞれ全く別のプロダクトという理解をしています。</p><ul><li>AWS Glue<ul><li>Spark（実装はPython or scala）</li><li>python shell (Pythonのみ)<ul><li>python shellを利用る場合、<a href="https://aws.amazon.com/jp/about-aws/whats-new/2019/01/introducing-python-shell-jobs-in-aws-glue/">1/16DPU</a>で動かせるため、時間制約のないサーバレス処理としても優秀に思えます。</li><li>料金は<a href="https://aws.amazon.com/jp/glue/pricing/">こちら</a>をご覧ください</li></ul></li></ul></li><li>AWS Glue Data Catalog<ul><li>Hive MetaStore</li></ul></li><li>AWS Glue DataBrew</li></ul><h1 id="CSVを利用する上での困りごと"><a href="#CSVを利用する上での困りごと" class="headerlink" title="CSVを利用する上での困りごと"></a>CSVを利用する上での困りごと</h1><h3 id="1-crawlerが利用できない"><a href="#1-crawlerが利用できない" class="headerlink" title="1. crawlerが利用できない"></a>1. crawlerが利用できない</h3><p>AWSが推奨する<a href="https://docs.aws.amazon.com/ja_jp/athena/latest/ug/glue-best-practices.html">ベストプラクティス</a>では、「crawlerを利用することでデータをCatalog化し、多様や処理系で利用できる」とされていますが、’”’ダブルクォーテーションで囲まれたフィールドを持つCSV（TSVも同様）の場合、正しく読み込まれず（※）、AWS上の<a href="https://docs.aws.amazon.com/ja_jp/athena/latest/ug/csv-serde.html">ドキュメント</a>でも対応が必要とされています。</p><img src="/images/20211006a/名称未設定ファイル.drawio_(3).png" alt="クローラが利用できないイメージ図" width="689" height="209" loading="lazy"><h3 id="2-テーブルのデータ型を全てStringに設定する必要がある"><a href="#2-テーブルのデータ型を全てStringに設定する必要がある" class="headerlink" title="2. テーブルのデータ型を全てStringに設定する必要がある"></a>2. テーブルのデータ型を全てStringに設定する必要がある</h3><p>crawlerを利用できないこともシステム運用上の困りごとになりますが、それ以上にデータ型に問題があります。</p><p>OpenCSVSerDeを利用したCatalogでは、データ型をStringに固定する必要があり、<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%82%BF%E3%83%AD%E3%82%B0">Catalog</a>化のメリットが半減してしまいます。</p><h1 id="CSVへの対応方法"><a href="#CSVへの対応方法" class="headerlink" title="CSVへの対応方法"></a>CSVへの対応方法</h1><h3 id="利用するCSVファイル"><a href="#利用するCSVファイル" class="headerlink" title="利用するCSVファイル"></a>利用するCSVファイル</h3><h5 id="データ"><a href="#データ" class="headerlink" title="データ"></a>データ</h5><figure class="highlight plaintext"><figcaption><span>sample.csv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;ID&quot;,&quot;NAME&quot;,&quot;FLG&quot;,&quot;NUM&quot;,&quot;DATE&quot;,&quot;DATE TIME&quot;</span><br><span class="line">&quot;1&quot;,&quot;あいうえお&quot;,&quot;1&quot;,&quot;100000000.00000000&quot;,&quot;2021-10-01&quot;,&quot;2021-10-01 18:00:13.271231&quot;</span><br><span class="line">&quot;2&quot;,&quot;かきくけこ&quot;,&quot;0&quot;,&quot;100000000.00000000&quot;,&quot;2021-10-01&quot;,&quot;2021-10-02 19:01:13.271231&quot;</span><br><span class="line">&quot;3&quot;,&quot;さしすせそ&quot;,&quot;1&quot;,&quot;100000000.00000000&quot;,&quot;2021-10-01&quot;,&quot;2021-10-03 20:30:13.271231&quot;</span><br></pre></td></tr></table></figure><h5 id="crawlerで読み込んだ直後の状態"><a href="#crawlerで読み込んだ直後の状態" class="headerlink" title="crawlerで読み込んだ直後の状態"></a>crawlerで読み込んだ直後の状態</h5><p>crawlerで読み込んだデータをAthenaより表示すると以下の状態となります。<br>データが欠損して表示されている事がわかります。<br><img src="/images/20211006a/スクリーンショット_2021-10-05_8.44.32.png" alt="Athenaで表示したデータ欠損の様子" width="1200" height="198" loading="lazy"></p><p>同じく、Athenaのメニューより見たテーブル定義になります。<br>定義的には一見正しく見えますが、前述の通り正しく動かない状態になります。<br><img src="/images/20211006a/スクリーンショット_2021-10-05_8.44.23.png" alt="Athenaのメニューより見たテーブル定義" width="519" height="261" loading="lazy"></p><h3 id="対応方法１：OpenCSVSerDeを利用する"><a href="#対応方法１：OpenCSVSerDeを利用する" class="headerlink" title="対応方法１：OpenCSVSerDeを利用する"></a>対応方法１：OpenCSVSerDeを利用する</h3><p>crawlerでCSVを読み込み、DDL化します。<br>このDDLを修正ます。</p><figure class="highlight sql"><figcaption><span>ddl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> `sample`(</span><br><span class="line">  `id` <span class="type">bigint</span>,    <span class="comment">-- 型をstringに変更</span></span><br><span class="line">  `name` string,</span><br><span class="line">  `flg` <span class="type">bigint</span>,   <span class="comment">-- 型をstringに変更</span></span><br><span class="line">  `num` <span class="keyword">double</span>,   <span class="comment">-- 型をstringに変更</span></span><br><span class="line">  `<span class="type">date</span>` string,</span><br><span class="line">  `<span class="type">date</span> <span class="type">time</span>` string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">  `<span class="keyword">year</span>` string,</span><br><span class="line">  `<span class="keyword">month</span>` string,</span><br><span class="line">  `<span class="keyword">day</span>` string)</span><br><span class="line"><span class="comment">-- DELIMITEDを削除し、OpenCSVSerdeに置き換えます。</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED       <span class="comment">-- 削除</span></span><br><span class="line">  FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> <span class="comment">-- 削除</span></span><br><span class="line"><span class="comment">-- ROW FORMAT SERDE</span></span><br><span class="line"><span class="comment">--   &#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span></span><br><span class="line"><span class="comment">-- WITH SERDEPROPERTIES (</span></span><br><span class="line"><span class="comment">--   &#x27;escapeChar&#x27;=&#x27;\\&#x27;,</span></span><br><span class="line"><span class="comment">--   &#x27;quoteChar&#x27;=&#x27;\&quot;&#x27;,</span></span><br><span class="line"><span class="comment">--   &#x27;separatorChar&#x27;=&#x27;,&#x27;)</span></span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span></span><br><span class="line">OUTPUTFORMAT</span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;s3://sample/work/sample/&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;CrawlerSchemaDeserializerVersion&#x27;</span><span class="operator">=</span><span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;CrawlerSchemaSerializerVersion&#x27;</span><span class="operator">=</span><span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;UPDATED_BY_CRAWLER&#x27;</span><span class="operator">=</span><span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;areColumnsQuoted&#x27;</span><span class="operator">=</span><span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;averageRecordSize&#x27;</span><span class="operator">=</span><span class="string">&#x27;66&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;classification&#x27;</span><span class="operator">=</span><span class="string">&#x27;csv&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;columnsOrdered&#x27;</span><span class="operator">=</span><span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;compressionType&#x27;</span><span class="operator">=</span><span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;delimiter&#x27;</span><span class="operator">=</span><span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;objectCount&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;recordCount&#x27;</span><span class="operator">=</span><span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sizeKey&#x27;</span><span class="operator">=</span><span class="string">&#x27;310&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;skip.header.line.count&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;typeOfData&#x27;</span><span class="operator">=</span><span class="string">&#x27;file&#x27;</span>)</span><br></pre></td></tr></table></figure><p>修正後、全てのデータが表示できるようになります。<br>ただし、全てはString型として認識されているため、データは文字列として扱う必要があります。<br><img src="/images/20211006a/スクリーンショット_2021-10-05_9.05.19.png" alt="欠損がなくなったAthena実行結果" width="1200" height="196" loading="lazy"></p><hr><h3 id="対応方法２：crawlerのカスタム分類子（Grok）を利用する"><a href="#対応方法２：crawlerのカスタム分類子（Grok）を利用する" class="headerlink" title="対応方法２：crawlerのカスタム分類子（Grok）を利用する"></a>対応方法２：crawlerのカスタム分類子（Grok）を利用する</h3><p>正規表現を元にした、パーサーを自分で用意する形になります。<br>詳細は、AWSをの<a href="https://docs.aws.amazon.com/ja_jp/glue/latest/dg/custom-classifier.html#classifier-builtin-patterns">公式</a>を見るのが良いと思いますが、抜粋、要約すると、フィールド単位にマッピング定義を作る方法となります。</p><p><code>%&#123;PATTERN:field-name:data-type&#125;</code></p><ul><li>マッピング定義<ul><li>PATTERN<br><a href="https://github.com/hpcugent/logstash-patterns/blob/master/files/grok-patterns">Grokのデータ型</a>を指定します。</li><li>field-name:<br>CSVのフィールドを指定します。</li><li>data-type:<br>Catalogの<a href="https://docs.aws.amazon.com/ja_jp/glue/latest/dg/aws-glue-api-common.html">データ型</a>を指定します。</li></ul></li></ul><p>今回のCSVでは、以下の形となります。<br><a href="https://goodbyegangster.hatenablog.com/entry/2018/10/12/001644">こちら</a>がよく纏められており、見ながらやったのですが、どうしても読み込んでくれませんでした。。。</p><p>なお、構文チェックはWebで可能です。</p><ul><li>構文チェック<ul><li><a href="http://grokconstructor.appspot.com/do/match">Grok Constructor</a></li></ul></li><li>Grokパターン<ul><li><code>&quot;%&#123;INT:ID:int&#125;&quot;, &quot;%&#123;DOUBLE_BYTE:NAME:STRING&#125;&quot;, &quot;%&#123;BASE16FLOAT:NUM:STRING&#125;, &quot;%&#123;DATE:DATE:DATE&#125;&quot;, &quot;%&#123;DATESTAMP:DATE TIME: TIMESTAMP&#125;&quot;</code></li></ul></li><li>カスタムパターン<ul><li><code>DOUBLE_BYTE [^\x01-\x7E]*</code></li></ul></li><li>画面の入力例<ul><li><img src="/images/20211006a/スクリーンショット_2021-10-05_14.54.17.png" alt="Grok入力例" width="755" height="1120" loading="lazy"></li></ul></li></ul><h3 id="対応方法３：CSVをparquestに変換して利用する"><a href="#対応方法３：CSVをparquestに変換して利用する" class="headerlink" title="対応方法３：CSVをparquestに変換して利用する"></a>対応方法３：CSVをparquestに変換して利用する</h3><p>システムとの親和性が最も高いparquestに変換後、crawlerでCatalog化します。<br>parquestへの変換では、元データに何も手を入れない形にします。</p><figure class="highlight python"><figcaption><span>sample-csv-to-parquest.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">s3 = boto3.resource(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read s3</span></span><br><span class="line">csv = s3.Object(<span class="string">&#x27;$&#123;バケット&#125;&#x27;</span>, <span class="string">&#x27;work/sample/sample.csv&#x27;</span>).get()[<span class="string">&#x27;Body&#x27;</span>].read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">f = io.StringIO(csv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert parquet</span></span><br><span class="line">pd.read_csv(f).to_parquet(<span class="string">&#x27;/tmp/sample.parquet&#x27;</span>, compression=<span class="string">&#x27;snappy&#x27;</span>)</span><br><span class="line"><span class="comment"># save s3</span></span><br><span class="line">s3.meta.client.upload_file(<span class="string">&#x27;/tmp/sample.parquet&#x27;</span>, <span class="string">&#x27;$&#123;バケット&#125;&#x27;</span>, <span class="string">&#x27;work/sample-parquest/sample.parquet&#x27;</span>)</span><br></pre></td></tr></table></figure><p>この変換処理をワークフローでcrawlerとつなげます。<br><img src="/images/20211006a/スクリーンショット_2021-10-05_18.54.29.png" alt="ワークフロー例" width="1200" height="364" loading="lazy"></p><p>全ての成功を確認後、Athenaからデータを見てると、余計な一手間がいらずデータを参照でき、データ型もCatalogの範囲内でハンドリングされています。</p><h3 id="実行結果"><a href="#実行結果" class="headerlink" title="実行結果"></a>実行結果</h3><img src="/images/20211006a/スクリーンショット_2021-10-05_18.59.15.png" alt="実行結果" width="1200" height="395" loading="lazy"><h3 id="データプレビュー"><a href="#データプレビュー" class="headerlink" title="データプレビュー"></a>データプレビュー</h3><img src="/images/20211006a/スクリーンショット_2021-10-05_18.58.52.png" alt="データプレビュー" width="1200" height="209" loading="lazy"><h3 id="テーブル定義"><a href="#テーブル定義" class="headerlink" title="テーブル定義"></a>テーブル定義</h3><img src="/images/20211006a/スクリーンショット_2021-10-05_18.58.58.png" alt="テーブル定義" width="384" height="212" loading="lazy"><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>データ型を認識でき、手軽に実行できる<code>対応方法３：CSVをparquestに変換して利用する</code>を基本方針として考える形で良いと思いました。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      <category domain="https://future-architect.github.io/tags/Glue/">Glue</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%AB%E3%82%BF%E3%83%AD%E3%82%B0/">データカタログ</category>
      
      
      <comments>https://future-architect.github.io/articles/20211006a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Future Tech Night #16 ～クラウド時代のDWH～</title>
      <link>https://future-architect.github.io/articles/20211005b/</link>
      <guid>https://future-architect.github.io/articles/20211005b/</guid>
      <pubDate>Mon, 04 Oct 2021 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211005b/archive-g39b73f1f8.jpg&quot; alt=&quot;PexelsによるPixabayからの画像&quot; title=&quot;800&quot; width=&quot;533&quot; height=&quot;&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211005b/archive-g39b73f1f8.jpg" alt="PexelsによるPixabayからの画像" title="800" width="533" height=""><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>今回の投稿は、先日TIG(Technology Innovation Group)の杉江と私でスピーカーを担当した「<a href="https://future.connpass.com/event/222633/">Future Tech Night #16～クラウド時代のDWH～</a>」の登壇後記です。</p><h2 id="発表資料"><a href="#発表資料" class="headerlink" title="発表資料"></a>発表資料</h2><p>以前に実施した社内勉強会のコンテンツを外部発信向けに整理したものとなります。私は元の資料の作成に関わっていなかったため、整理に際して一から目を通しました。内容も量も読み応えのある内容で、今回の登壇機会を介して私自身の知識のアップデートにも繋がりました。</p><script async class="speakerdeck-embed" data-id="64dae075c9874158ae72778f910d2299" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><h2 id="コンテンツ構成"><a href="#コンテンツ構成" class="headerlink" title="コンテンツ構成"></a>コンテンツ構成</h2><p>以下の構成で発表を行いました。それぞれ簡単に内容をご紹介しますので、気になるコンテンツがあれば是非資料に目を通して頂ければと思います。</p><h3 id="クラウドDWHアーキテクチャ概要"><a href="#クラウドDWHアーキテクチャ概要" class="headerlink" title="クラウドDWHアーキテクチャ概要"></a>クラウドDWHアーキテクチャ概要</h3><p>主にDWHの用途で2010年付近から普及が進んだMPP(大規模並列分散処理)型RDBのアーキテクチャの紹介と、それがパブリッククラウドの特性を活かしてどのように進化してきているか解説しています。</p><p>今回の発表では次の3つのプロダクトを取り上げました。</p><ul><li>Snowflake<ul><li>主要なパブリッククラウド上(AWS、Azure、GCP)で利用可能なプロダクト</li><li>Wharehouseというコンピュート(クエリーエンジン)のインスタンスタイプと処理時間に応じて課金</li></ul></li><li>Google Cloud BigQuery<ul><li>GCPの提供するサービス</li><li>クエリの実行時間に応じて課金</li></ul></li><li>Microsoft Azure Synapse Analytics<ul><li>データを保持する分散ストレージが60個固定</li><li>コンピュートのインスタンスタイプと起動時間に応じて課金</li></ul></li></ul><h3 id="データベースインフラストラクチャ"><a href="#データベースインフラストラクチャ" class="headerlink" title="データベースインフラストラクチャ"></a>データベースインフラストラクチャ</h3><p>クラウド型DWHを構成するインフラレイヤの技術要素に関して解説してます。</p><ul><li>ストレージ<ul><li>データベースのストレージ管理構造や、クラウド型DWHの特徴と言える分散ファイルシステムを紹介</li></ul></li><li>ネットワーク<ul><li>分散ストレージのアーキテクチャでは、冗長性確保の観点で同一データを複数のストレージに対して書き込むため、高速ネットワークが必須</li></ul></li><li>コンピュート<ul><li>前述の3プロダクト間でコンセプトが異なっており、その違いを紹介</li></ul></li></ul><h3 id="データベースソフトウェア"><a href="#データベースソフトウェア" class="headerlink" title="データベースソフトウェア"></a>データベースソフトウェア</h3><p>列/行指向フォーマットやメタデータ管理など、データの保存形式に関わる内容を中心に解説しています。</p><h3 id="検証結果"><a href="#検証結果" class="headerlink" title="検証結果"></a>検証結果</h3><p>前述の3プロダクトを対象に、それぞれの特徴を見るために実環境での検証を実施しましました。<br>検証内容と結果の一部を抜粋して紹介しています。</p><h3 id="今後に向けて"><a href="#今後に向けて" class="headerlink" title="今後に向けて"></a>今後に向けて</h3><p>今回の発表では触れなかったAmazon Redshiftのアップデートなど、各プロダクトの動向に関して考察しています。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>主要なクラウド型DWHは、コンピュートとストレージが分離されたアーキテクチャという共通点があり、これによって処理の高速化と共に、データの規模・処理特性に応じた柔軟な構成変更が可能というクラウドの恩恵を享受できます。</p><p>機能面での比較では中々差が見えにくいですが、それぞれ特徴的な課金体系を持っており、利用されるシステム特性に応じてコストに差が出てくるケースが想定されます。導入検討/選定時点におけるこのコストの見極めが私たちにとって重要かつ難しいポイントとなってくると感じています。</p><p>「クラウドの無限のインフラストラクチャリソースを利用」したソフトウェアであることから、クラウドベンダ(AWS/GCP/Azure)提供のDWHだけでない選択肢(Snowflake)があるというのも見逃せません。このようなクラウドベンダ以外によるミドルウェアが増えてくる可能性がありそうです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/DB/">DB</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E7%99%BB%E5%A3%87%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88/">登壇レポート</category>
      
      <category domain="https://future-architect.github.io/tags/DB/">DB</category>
      
      <category domain="https://future-architect.github.io/tags/TechNight/">TechNight</category>
      
      <category domain="https://future-architect.github.io/tags/Spanner/">Spanner</category>
      
      <category domain="https://future-architect.github.io/tags/Snowflake/">Snowflake</category>
      
      
      <comments>https://future-architect.github.io/articles/20211005b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>イテレータと仲良くなろう</title>
      <link>https://future-architect.github.io/articles/20211005a/</link>
      <guid>https://future-architect.github.io/articles/20211005a/</guid>
      <pubDate>Mon, 04 Oct 2021 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20211005a/python-logo-master-v3-TM.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;203&quot;&gt;

&lt;p&gt;SAIG の佐藤尭彰です。最近は業務で Python</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20211005a/python-logo-master-v3-TM.png" alt="" width="601" height="203"><p>SAIG の佐藤尭彰です。最近は業務で Python ばっかり書いています。</p><p>今回は <a href="/articles/20210927b/">Python連載</a> の第4回目で、Python の中でも「なんとなく」で扱われがちなイテレータについてです。</p><h2 id="イテレータとは"><a href="#イテレータとは" class="headerlink" title="イテレータとは"></a>イテレータとは</h2><p>あるコンテナの中の要素に1つずつアクセスできるオブジェクト。</p><p>もう少し <a href="https://docs.python.org/ja/3/tutorial/classes.html#iterators">公式</a> から引用すると、</p><blockquote><p>(<code>iter()</code>) 関数は、コンテナの中の要素に1つずつアクセスする <code>__next__()</code> メソッドが定義されているイテレータオブジェクトを返します。</p></blockquote><p>つまり、コンテナの中身を1つずつ返す <code>__next__()</code> メソッドを持つ (ようなオブジェクトを返す <code>__iter__()</code> 関数を持つ) ことがイテレータの本質です。</p><p><code>list</code> などのシーケンスと異なり、実態として中身が存在する必要がありません。これを実装するための1手段が <strong>ジェネレータ</strong> や <strong>ジェネレータ式</strong> であり、返すべき値はこれらを呼び出すたびに都度計算してよいのです。このイテレータの性質から、イテレータを使えるところ (= <code>iterable</code> を要求されるところ) にシーケンスでなくイテレータを渡すとメモリや実行時間を削減することができます。</p><p>一方でイテレータは実際に値が帰ってくるまでは中身が確定しません。確定させるためには <code>list</code> もしくは <code>tuple</code> などにキャストする必要があります。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">5</span>)))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x7f594ded2a58</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>▲ ざっくり printf デバッグをするときに忘れがちな <code>list()</code></p><h2 id="組み込みのイテレータ"><a href="#組み込みのイテレータ" class="headerlink" title="組み込みのイテレータ"></a>組み込みのイテレータ</h2><p>組み込み = import なしに使える、標準のもの</p><h3 id="よく見るもの"><a href="#よく見るもの" class="headerlink" title="よく見るもの"></a>よく見るもの</h3><p>ここは使いこなしているユーザが多いのではないでしょうか。</p><ul><li><code>map(func, iterable)</code>: 第2引数に第1引数を作用させたものを返す</li><li><code>filter(func, iterable)</code>: 第2引数に第1引数を作用させた結果が真値となる要素のみを返す</li><li><code>enumerate(iterable)</code>: インデックスと中身のタプルを返す</li><li><code>zip(iter1, iter2, ...)</code>: それぞれの iterable の i 番目からなるタプルを返す<ul><li>長さがまちまちなときは最短なもので止まる</li></ul></li></ul><h3 id="あまり見ないけど便利なもの"><a href="#あまり見ないけど便利なもの" class="headerlink" title="あまり見ないけど便利なもの"></a>あまり見ないけど便利なもの</h3><p>本題その1です。</p><ul><li><code>filter(None, iterable)</code><ul><li>第1引数に<code>None</code>を渡すと、iterable内の要素自体が真値を返すような要素のみを返します</li><li>つまり「<code>None</code>, <code>False</code>, <code>0</code>(と等価なもの), <code>&#39;&#39;</code>, <code>[]</code>, etc. 」を除くことができます。<strong>0が消えることを除いては</strong> かなり使い勝手がよく、無為な <code>if</code> 文でインデントを一つ掘るよりも見通しの良いコードを書くことができます</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># やりがちな例</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">iter</span>:</span><br><span class="line">    <span class="keyword">if</span> v:</span><br><span class="line">        process(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ↑と等価な例</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, <span class="built_in">iter</span>):</span><br><span class="line">    process(v)</span><br></pre></td></tr></table></figure><ul><li><code>reversed(seq)</code><ul><li>いわゆるリバースイテレータを返します。逆順にしたコピーを返す <code>[::-1]</code> よりも軽くて便利なことが多いです</li><li>一方で、(事実上)引数<code>seq</code>は<code>list</code>か<code>tuple</code>である必要があります</li></ul></li><li><code>iter(callable, sentinel)</code>: 2引数版 <code>iter</code><ul><li>sentinel と一致するまで callable を叩いた返り値を返します</li><li>文字通りの番兵がいるようなテキストデータ・バイナリデータをパースするときに役に立つ（かも）</li></ul></li></ul><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a><a href="https://docs.python.org/ja/3/library/itertools.html">itertools</a></h2><p>本題その2です。</p><p>import することでいろいろなイテレータが作れます。どこで使うんだと言うのもありますが、大体はいつか使える関数です。</p><h3 id="主な無限イテレータ"><a href="#主な無限イテレータ" class="headerlink" title="主な無限イテレータ"></a>主な無限イテレータ</h3><ul><li><code>count(start[, step=1])</code>: stop がない無限 <code>range</code></li><li><code>cycle(iterable)</code>: <code>cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D A B C D ...</code><ul><li>だいたい <code>zip</code> などの <strong>一番短いやつに揃えて止まる</strong> 系ジェネレータを止めたくないときに使います</li></ul></li></ul><h3 id="主な-普通の-イテレータ"><a href="#主な-普通の-イテレータ" class="headerlink" title="主な(普通の)イテレータ"></a>主な(普通の)イテレータ</h3><ul><li><code>accumulate(p[, func])</code><ul><li>累積和。<code>np.cumsum(v)</code></li><li>このほか第2引数 func は幅広い二項演算を取ることができるため <code>np.cumprod</code> にしたり累積 <code>max</code> したり色々できます</li></ul></li><li><code>chain.from_iterable(iterable)</code><ul><li>2重のネストに限定された <code>np.ravel</code> です<ul><li>ネストされていない要素が混じっていたり、3重ネスト以上を平坦化したい場合はおとなしく <code>collections.abc.Iterable</code> かどうかを判定するしかないようです</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line">a = [[<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], [<span class="number">6</span>]]</span><br><span class="line">b = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">it</span>):</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(item, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> flatten(item):</span><br><span class="line">                <span class="keyword">yield</span> child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(chain.from_iterable(a)) <span class="comment"># =&gt; [1, 2, [3, 4], 5, 6]</span></span><br><span class="line"><span class="built_in">list</span>(flatten(a)) <span class="comment"># =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">list</span>(chain.from_iterable(b)) <span class="comment"># =&gt; TypeError: &#x27;int&#x27; object is not iterable</span></span><br><span class="line"><span class="built_in">list</span>(flatten(b)) <span class="comment"># =&gt; [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>▲ こんな感じで組むと <code>flatten</code> できる</p><ul><li><code>groupby(iterable[, key])</code><ul><li>前から見ていって <code>key</code> が一致するような要素集合を (<code>key</code>, <code>要素集合</code>) の形で返します</li><li>iterable がソート済ならばだいたい <code>df.groupby</code> ですが、ソートされていないと <code>key</code> が変わるたびにブロックを返すので敢えてそれを利用する使い道もあります<ul><li>タイムスタンプ順にそろえておいて、同じ人の連続ログをひとまとめにして見たい、など</li><li>C++ の <code>uniq</code> と同じような動作です</li></ul></li></ul></li><li><code>islice(iterable[, start], stop[, step])</code><ul><li><code>iterable[start:stop:step]</code></li><li><code>reversed</code> 同様、コピーを作らないのでメモリに優しいです</li></ul></li><li><code>takewhile(pred, seq)</code><ul><li><code>pred</code> が偽になったら終了するイテレータ</li><li><strong>リスト内包でbreak</strong>したくなったらこれを思い出して下さい</li></ul></li></ul><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>標準ライブラリを上手に使って快適な Python ライフを。</p><p>次回は10月7日、小橋昌明さんの pandasの内部で何が起きているか です。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85%E5%90%91%E3%81%91/">初心者向け</category>
      
      <category domain="https://future-architect.github.io/tags/Python/">Python</category>
      
      
      <comments>https://future-architect.github.io/articles/20211005a/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
