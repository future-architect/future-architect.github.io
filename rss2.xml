<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>フューチャー技術ブログ</title>
    <link>https://future-architect.github.io/</link>
    
    <image>
      <url>https://future-architect.github.io/feed_icon.png</url>
      <title>フューチャー技術ブログ</title>
      <link>https://future-architect.github.io/</link>
    </image>
    
    <atom:link href="https://future-architect.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>フューチャーの開発者による公式技術ブログです。業務で利用している技術を幅広く紹介します。</description>
    <pubDate>Wed, 10 Aug 2022 05:47:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>【メディア業界】新聞社の編集業務とフューチャーの取組み</title>
      <link>https://future-architect.github.io/articles/20220810a/</link>
      <guid>https://future-architect.github.io/articles/20220810a/</guid>
      <pubDate>Tue, 09 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220810a/absolutvision-WYd_PkCa1BY-unsplash.jpg&quot; alt=&quot;absolutvision-WYd_PkCa1BY-unsplash.jpg&quot; width=&quot;1200&quot; height=&quot;800&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220810a/absolutvision-WYd_PkCa1BY-unsplash.jpg" alt="absolutvision-WYd_PkCa1BY-unsplash.jpg" width="1200" height="800" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは！2021年入社、TIGメディアユニット所属の武田です。</p><p>本記事は<a href="/articles/20220616a/">「業界ドメインに詳しくなろう」シリーズ連載</a>の「メディア業界へのチャレンジ」第2回目です。前回の<a href="/articles/20220715a/">新聞業界（メディア業界）基礎編</a>では、新聞業界（メディア業界）の変遷や新聞社の使命についてご紹介しました。<br>今回はさらに新聞業界に深入りし、新聞社の具体的な編集業務やフューチャーの新聞業界への取組みについてご紹介します。</p><h1 id="新聞社の編集業務-～新聞ができるまで～"><a href="#新聞社の編集業務-～新聞ができるまで～" class="headerlink" title="新聞社の編集業務　～新聞ができるまで～"></a>新聞社の編集業務　～新聞ができるまで～</h1><p>まずはじめに、一般的な新聞製作の流れについてご説明します。<br>新聞社ごとに作業順序や部署の呼び方、業務の割り振りは異なる部分もありますが、基本的にどの新聞社も以下のような工程で紙面を制作しています。<br><img src="/images/20220810a/image_(36).png" alt="紙面の制作フロー" width="1200" height="267" loading="lazy"></p><h2 id="1-取材"><a href="#1-取材" class="headerlink" title="1. 取材"></a>1. 取材</h2><p>まずは記者による取材です。政治、経済、文化、スポーツ、事件など世の中の様々な出来事を取材します。</p><p>記者が日常的に行なっている取材の形は、大きく分けて「会見取材」と「懇談取材」の2種類があります。「会見取材」は、報道陣の要請に応じて、あるいは自発的に、当事者が行なう説明の場であり、録音やカメラ撮影が許されます。記者の出席は基本的に自由で、質疑応答もあります。<br>もう一方の「懇談取材」は、正式な手続きや形式を踏まない取材を指します。録音や撮影がNGということも多く、メモさえも許されない場合があります。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>その他にも「発生もの」と呼ばれる取材もあります。</p><p>例えば、事件や事故の当事者や家族、関係者への取材などがそれにあたります。事件や事故の関係者に、喜んで話してくれる人はいないのが当たり前で、取材先で断られたり、冷たく追い帰されたり、非難されたりすることもしばしば起こります。もちろん、いきなり訪ねる失礼は承知の上で記者も取材をしています。</p><p>記者は、関係者の辛さや痛みを察しながらも、その出来事の事実や核心を広く世の中に伝えることで、事件や事故の原因や経緯が明らかになり、それが取材に協力してくれた人々への恩返しになると信じて取材活動を続けています。そんな一生懸命な記者の真意や熱意、誠意が伝わって、徐々に心を開き、取材に協力してくれる人もいます。</p><h2 id="2-記事出稿"><a href="#2-記事出稿" class="headerlink" title="2. 記事出稿"></a>2. 記事出稿</h2><p>記者は取材してきた内容をもとに原稿を作成し、デスクに送ります。（送稿・入稿）</p><p>デスクは、記者が書いた原稿をチェックしてアレンジしたり、削ったり、加筆したり、書き換えさせたりして、最適な形で記事を紙面に載せるための責任者です。取材の指揮をとるのもデスクの仕事で、誰にどこに取材に向かってもらうかを指示したり、記者が取材した内容に対して「もっとこういう話も聞いてきいてくれ」「こういう写真を追加で撮ってきてほしい」とアドバイスをします。</p><p>ちなみに、どこの新聞社でも取材記者としての経験を積んだ後に「デスク」という役職を任されることが多いようです。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p>デスクが念入りにチェックをした後は校閲に送ります。（出稿）</p><p>※自社で作成する記事以外にも、共同通信社や時事通信社などの外部通信社からの入稿もあります。</p><h2 id="3-校閲"><a href="#3-校閲" class="headerlink" title="3. 校閲"></a>3. 校閲</h2><p>情報の正確さを身上とする新聞記事に「間違い」はあってはならぬものです。そこで重要になってくるのが、記事の校閲です。</p><p>校閲部門は、各部からあがってくる全ての記事を読み、誤字脱字のチェックや、事実確認を行います。事実確認では、記事と一緒に送られてくる照合資料やインターネットなどを駆使して、触れられている情報は正しいか、固有名詞や日付に誤りはないかなど、調べられるものは全て調べます。校閲と聞くと「誤字・脱字を直す仕事」と思われがちですが、実はこの「事実確認」の部分に時間をかけています。</p><p>単純な文字の誤りだけでなくコンテンツの内容にまで踏み込み、徹底した事実確認のもと、著者ですら気づかないような間違い、表現上の矛盾点などを発見し修正しています。<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p><p>新聞という商品の品質管理を担うのが校閲部門というわけです。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p><h2 id="4-編集デスク会議"><a href="#4-編集デスク会議" class="headerlink" title="4. 編集デスク会議"></a>4. 編集デスク会議</h2><p>編集デスク会議では、各部のデスクが集まり、「この記事は重要だから大きく掲載する」「この記事は一面トップに」「この記事は小さく」などと、掲載する記事や、その扱い方を決めます。</p><p>面白い原稿があれば、取材記者に依頼して、足りない要素を加えて原稿を膨らませてもらうことや、反対に原稿を短く削ったりすることもあります。<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p><h2 id="5-紙面レイアウト"><a href="#5-紙面レイアウト" class="headerlink" title="5. 紙面レイアウト"></a>5. 紙面レイアウト</h2><p>掲載する記事が決まったら紙面のレイアウト作業（割り付けとも呼ばれる）をしていきます。新聞社によって、整理部の記者が行ったり、面担（経済面、社会面などの面ごとの割り付け担当者）と呼ばれる役職が存在したりします。</p><p>どの記事を一番強調するか、記事の価値を評価し見出しや本文を削りながら、位置やサイズを調整していきます。「見出し」は記事にとってとても重要です。おそらくほとんどの方は、見出しを読んで興味を持ったらその記事を読み始めるのではないでしょうか。文字の種類やデザイン、大きさ、文字数などでニュースの価値の大小を知らせるとともに、記事の内容が一目でわかるような見出しを付けます。</p><p>10人いれば、10通りの紙面ができるといわれているほど、レイアウトには個性がにじみ出ます。新聞社の特徴を出しつつ、そこに自分の個性を活かしていくために、日々、試行錯誤しています。<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p><h2 id="6-印刷"><a href="#6-印刷" class="headerlink" title="6. 印刷"></a>6. 印刷</h2><p>紙面が完成したら工場にデータを送って印刷していきます。工場にデータが送られると、刷版という印刷の原版が作られます。<br>印刷には輪転機と呼ばれる高さ10メートルにも及ぶ巨大な機械を使います。新聞の印刷に使われるのは巨大なロールになった巻き取り紙と呼ばれるもので、１本の巻き取り紙をのばすと、約16キロメートルにもなります。輪転機は、印刷はもちろん、裁断、ページ折りまでを自動で行ないます。１秒で25部から50部もの新聞を超高速で刷り上げて新聞の形にしていきます。<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup><br>輪転機は、かつて必ず新聞社内に置かれていましたが、通信システムの発達に伴い、外部に印刷機能を移している新聞社も出てきました。<br>大手新聞各社は印刷工場を別会社化し、その専門性を高めながら、連携する他紙の印刷を行なったり、新聞以外の印刷も受注したりといった専業会社として、独自に発展している例も増えています。</p><p>こうして新聞の出来上がりです！</p><h1 id="フューチャーの新聞業界への取組み"><a href="#フューチャーの新聞業界への取組み" class="headerlink" title="フューチャーの新聞業界への取組み"></a>フューチャーの新聞業界への取組み</h1><p>ここからはフューチャーの新聞業界への取組みについて紹介していきます。</p><p>昨今のソーシャルメディアの普及に伴う新聞発行部数の減少を鑑みて、新聞社は新聞販売を主軸とした従来のビジネスモデルから、デジタルビジネスへのシフトが急務とされています。そこで大事になるのが、紙やデジタルといった媒体別の対策ではなく読者にとって読みやすいコンテンツをタイムリーに届けることに主眼を置いた「コンテンツファースト」の実現です。そのためには、紙の締切時刻や紙面割の管理を超えた新たな発想への転換が必須でした。それを支えるためのコンテンツ管理システムが「GlyphFeeds」です。</p><img src="/images/20220810a/image_(28).png" alt="GlyphFeeds" width="1200" height="383" loading="lazy"><h2 id="「コンテンツファースト」を支えるGlyphFeeds"><a href="#「コンテンツファースト」を支えるGlyphFeeds" class="headerlink" title="「コンテンツファースト」を支えるGlyphFeeds"></a>「コンテンツファースト」を支えるGlyphFeeds</h2><p>GlyphFeedsは、フューチャーが開発したメディア業界向けのコンテンツマネジメントシステムを中核に持つクラウドサービスです。<br>全てのコンテンツを集約して管理するデータベースを搭載しており、記者が取材して書く記事やカメラマンが撮影した写真などを一括管理できます。</p><p>また、編集業務ワークフローを搭載していて、原稿の作成から編集まで、多様な編集業務をGlyphFeedsの画面一つで行うことができ、記者、デスク、校閲、整理、デジタル担当者などの全アクターによる統合編集が可能な上、パソコンやタブレットなどの端末と通信環境さえあれば、どこからでも行えます。従来は、媒体毎に「個別編集」を行っており、修正反映が大変でしたが、「統合編集」では、同一素材を派生させて利用しており、一括で修正反映が可能です。<br>コンテンツを適切なタイミングで新聞紙面やデジタルサイト・ニュースアプリ等に届けることで、コンテンツの価値を最大化できます。</p><p>GlyphFeedsは新聞社に不可欠な「可用性」にも強みを持ちます。クラウド基盤を利用し世界レベルでの冗長構成をとっているため、仮に日本で大きな災害が起きたときでも取材・報道活動を継続できます。どんな災害時でもニュースを届けなくてはならない使命を持つ新聞社にとって、非常に大きな意味を持ちます。<br><img src="/images/20220810a/image_(29).png" alt="image_(29).png" width="1200" height="473" loading="lazy"></p><h2 id="コンテンツの価値を再定義する"><a href="#コンテンツの価値を再定義する" class="headerlink" title="コンテンツの価値を再定義する"></a>コンテンツの価値を再定義する</h2><p>また、GlyphFeedsには一般公開用のコンテンツ活用APIも搭載しており、既存媒体向けの掲載編集に加えて、コンテンツを活用した新規サービス創出にも寄与します。<br><a href="https://prtimes.jp/main/html/rd/p/000000140.000033323.html">日刊工業新聞社プロジェクト</a>では、コンテンツを活用した新規サービスとして、一つ一つの記事や画像を商品として売り出すECサイトを構築しました。これにより、紙面などに掲載されなかったコンテンツにも価値を見出すことができるようになりました。<br><img src="/images/20220810a/image_(31).png" alt="" width="1200" height="587" loading="lazy"></p><p>まだまだGlyphFeedsの魅力は伝えきれませんが、過去にもGlyphFeedsについて紹介された記事がございますので、ぜひ<a href="https://future-architect.github.io/articles/20200914/">こちら</a>も御覧ください。</p><h2 id="私たちで未来を創造する"><a href="#私たちで未来を創造する" class="headerlink" title="私たちで未来を創造する"></a>私たちで未来を創造する</h2><p>2022年から始まった<a href="https://kyodonewsprwire.jp/release/202204089747">読売新聞社プロジェクト</a>では、単なるGlyphFeeds導入だけではなく、新たな業務領域にも踏み込み、新聞社各社が利用できる業界標準のプラットフォーム構築に取り組んでいます。</p><p>マルチベンダーで複雑化したシステムの集約による維持管理コストの低減や、業務フローの効率化で取材記者や編集記者の作業負担を軽減する働き方改革など、新聞業界全体の課題解決を目指します。</p><p>さらに、今後はGX（グリーントランスフォーメーション）も視野に入れ、環境へのアプローチも積極的に行っていきます。<br><img src="/images/20220810a/image_(35).png" alt="" width="1200" height="373" loading="lazy"></p><p>今後のGlyphFeedsの成長にぜひご期待ください！</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>新聞社の編集業務、そしてフューチャーの新聞業界への取り組みについて紹介してきましたが、いかがだったでしょうか。<br>少しでも新聞業界、GlyphFeedsに興味を持っていただけたら幸いです！</p><p>次回からは2回に渡り、新聞社のビジネスモデルの現状とこれからについて紹介する予定です。<br>新聞社の未来はどうなっていくのか・・・新聞業界のDXに携わるフューチャーの視点で新聞社の未来について考察していきます。</p><p>お楽しみに！</p><p>アイキャッチ画像は <a href="https://unsplash.com/es/@freegraphictoday?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">AbsolutVision</a> on <a href="https://unsplash.com/s/photos/newspaper?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a> を利用させていただきました。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">メディアポ「新聞記者の仕事　いろいろな取材のかたち」：<a href="https://www.homemate-research-newspaper-office.com/useful/12659_facil_062/">https://www.homemate-research-newspaper-office.com/useful/12659_facil_062/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">メディアポ「新聞記者のステップアップ「デスクから支局長」」：<a href="https://www.homemate-research-newspaper-office.com/useful/12670_facil_073/">https://www.homemate-research-newspaper-office.com/useful/12670_facil_073/</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">毎日ことば「新聞校閲は時間との闘い」：<a href="https://mainichi-kotoba.jp/blog-20181020">https://mainichi-kotoba.jp/blog-20181020</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="vertical-align: top; padding-right: 10px;">4.</span><span style="vertical-align: top;">メディアポ「新聞紙面の校閲」：<a href="https://www.homemate-research-newspaper-office.com/useful/12683_facil_086/">https://www.homemate-research-newspaper-office.com/useful/12683_facil_086/</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="vertical-align: top; padding-right: 10px;">5.</span><span style="vertical-align: top;">メディアポ「掲載する新聞記事は編集デスク会議で決定」：<a href="https://www.homemate-research-newspaper-office.com/useful/12677_facil_080/">https://www.homemate-research-newspaper-office.com/useful/12677_facil_080/</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="vertical-align: top; padding-right: 10px;">6.</span><span style="vertical-align: top;">メディアポ「新聞紙面のレイアウト作業」：<a href="https://www.homemate-research-newspaper-office.com/useful/12680_facil_083/">https://www.homemate-research-newspaper-office.com/useful/12680_facil_083/</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="vertical-align: top; padding-right: 10px;">7.</span><span style="vertical-align: top;">メディアポ「新聞の印刷から搬送」：<a href="https://www.homemate-research-newspaper-office.com/useful/12684_facil_087/">https://www.homemate-research-newspaper-office.com/useful/12684_facil_087/</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Business/">Business</category>
      
      
      <category domain="https://future-architect.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E6%A5%AD%E7%95%8C/">メディア業界</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9/">ビジネス</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%A5%AD%E7%95%8C%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3/">業界ドメイン</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%96%B0%E8%81%9E%E6%A5%AD%E7%95%8C/">新聞業界</category>
      
      
      <comments>https://future-architect.github.io/articles/20220810a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go 1.19のメモリ周りの更新</title>
      <link>https://future-architect.github.io/articles/20220808a/</link>
      <guid>https://future-architect.github.io/articles/20220808a/</guid>
      <pubDate>Sun, 07 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;a href=&quot;/articles/20220801a/&quot;&gt;Go 1.19リリース連載&lt;/a&gt;の6本目です。&lt;/p&gt;
&lt;p&gt;Go 1.19では、いくつかメモリ周りの更新がありました。1つはガベージコレクタ周りのお話と、あとはメモリモデルの更新です。　ライブラリでは&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><a href="/articles/20220801a/">Go 1.19リリース連載</a>の6本目です。</p><p>Go 1.19では、いくつかメモリ周りの更新がありました。1つはガベージコレクタ周りのお話と、あとはメモリモデルの更新です。　ライブラリでは<a href="https://pkg.go.dev/sync/atomic#Int64">sync&#x2F;atomic.Int64</a>など、いくつか型が追加されました。</p><h1 id="ガベージコレクタ"><a href="#ガベージコレクタ" class="headerlink" title="ガベージコレクタ"></a>ガベージコレクタ</h1><p><a href="https://go.dev/doc/gc-guide">ガベージコレクタの詳細と調整の仕方についてのドキュメント</a><br>が追加されました。このドキュメントはスライダーで動作の変化がみられるインタラクティブなドキュメントになっているので、ぜひご覧ください。</p><img src="/images/20220808a/スクリーンショット_2022-08-03_21.22.41.png" alt="" width="1200" height="500" loading="lazy"><p>「GoはJavaと違って、GCの調整ポイントがほとんどなく、最初からトップスピード（オプションの選択の中で相対的に）だよ」みたいに説明されることもありましたが、そういうわけにも行かなくなったというか、ある程度知っておく必要はあるかもしれません。とはいえ、デフォルトでも十分うまくやってくれますし、そもそも即座に終了するユーティリティでは頑張る必要もないので、長期間動作するサーバー系とくにリクエストごとのメモリ消費が大きいものを使っている人は必読ですが、そうでない人はそこまで追いかける必要はないかもしれません。</p><p>なお、これはGoの言語仕様ではなく、Go製の純正Go処理系に特化した話（ただしgccgoもかなり似ているという注釈つき)とのことです。また、処理系依存の話なので将来はまた変わってくる可能性があります。</p><p>Goのメモリ戦略が最初に紹介されています。</p><ul><li>スタックメモリはGCを使わずにまとめて解放という戦略で扱われている</li><li>ヒープはGCが管理する。ヒープにおくかスタックにおくかはプログラムのロジックを見てきまる</li><li>GoのGCはマークアンドスイープ方式を利用</li></ul><h2 id="環境変数-GOGC-（go-1-18以前よりあった）"><a href="#環境変数-GOGC-（go-1-18以前よりあった）" class="headerlink" title="環境変数: GOGC （go 1.18以前よりあった）"></a>環境変数: GOGC （go 1.18以前よりあった）</h2><p>ここで設定した値(100で10MB、200で20MB)だけヒープメモリが使用されると、GCが実行されるようになります。数値を小さくすればするほど、GCが走りやすくなるため、無駄なメモリは減ります。一方でGCのマーク処理は重いため、CPUを消費します。このパラメータは「CPUコストとメモリ使用量の間のトレードオフ」を調整するものであると説明されています。</p><h2 id="環境変数-GOMEMLIMIT-（go-1-19で追加）"><a href="#環境変数-GOMEMLIMIT-（go-1-19で追加）" class="headerlink" title="環境変数: GOMEMLIMIT （go 1.19で追加）"></a>環境変数: GOMEMLIMIT （go 1.19で追加）</h2><p>GOGCはCPUとメモリのトレードオフの設定としては有効ですが、実際のメモリ使用量を考慮したものではありません。実際に必要なライブヒープ（GCで削除されない）が急に増えた場合に、GOGCだけで調整しようとするとCPU消費量が無駄に多くなり過ぎてしまいます。そこで<a href="https://go.googlesource.com/proposal/+/master/design/48409-soft-memory-limit.md">提案された</a>のがこの環境変数での設定です。このGCガイドには書かれてないですが、”100MB”とか、”100MiB”といった内容を設定するようです。</p><p>なお、これはソフトリミットであって、GCが稼働後にこのメモリ量以下になることが保証されてません。GC対象じゃないライブヒープが増えてしまうといくらGCでも解放できません。ガベージじゃないですし。5-10%ほど余裕をみて設定しましょう、と書かれています。また、データ量に比例してメモリを消費するようなプログラムの場合、データ量側を制限せずにメモリ制限だけしてしまうとパフォーマンス低下が発生するとあります。</p><p>このドキュメントでは、Goの仮想メモリの使い方の解説、ストップザワールドのGCは重い(CPUの25%を持っていくし、マークとスイープを同時に行うのでレイテンシーが大幅に伸びる）という話や、プロファイリングの指標の紹介などがあります。</p><h1 id="メモリモデルの更新"><a href="#メモリモデルの更新" class="headerlink" title="メモリモデルの更新"></a>メモリモデルの更新</h1><p><a href="https://go.dev/ref/mem">The Go Memory Model</a>が8年ぶりに更新されています。そのベースとなっているのがRuss Coxが投稿した3つのドキュメントです。</p><ul><li><a href="https://research.swtch.com/hwmm">Hardware Memory Models</a></li><li><a href="https://research.swtch.com/plmm">Programming Language Memory Models</a></li><li><a href="https://research.swtch.com/gomm">Updating the Go Memory Model</a></li></ul><p>なお、2014年版も、2022年版も同じ前書きとなっています。</p><blockquote><p>アドバイス</p><p>同時にアクセスする複数のgoroutineによってデータを変更するようなプログラムでは、そのようなアクセスを直列化しなければなりません。</p><p>アクセスを直列化してデータを保護するには、チャネル操作またはsync、sync&#x2F;atomicパッケージ内の要素などを使います。</p><p>プログラムの動作を理解するためにこのドキュメントの残りの部分を読まなければならない場合、あなたは頭が良すぎます。</p><p>賢くならないでください。</p></blockquote><p>ようするにGo開発者が行うべきことは、チャネル、sync&#x2F;atomicパッケージなどを適切に使うこと、と言い切っています。これは2014年版も2022年版も変わりません。CPU特有の癖などを駆使したトリッキーなロックフリーな順序制御！！！みたいなことをするとトラブルの元になるのでやめとけよ、ということですね。このドキュメント自体はGoでアプリを書く人向けというよりも、主にランタイムやコンパイラを実装する人向けのデザインドキュメントのようなものかと思います。</p><h3 id="The-Go-Memory-Modelの更新内容"><a href="#The-Go-Memory-Modelの更新内容" class="headerlink" title="The Go Memory Modelの更新内容"></a>The Go Memory Modelの更新内容</h3><p>Go公式ドキュメントの方でどのような変更があったのかを目diffで差分を調べました。</p><ul><li>Happens Beforeが[<a href="https://go.dev/ref/mem#model]">https://go.dev/ref/mem#model]</a>(Memory Model)にリライト<ul><li>他の言語のメモリモデルの論文等と同じ語彙を使って厳密に書き換えたように見える</li></ul></li><li><a href="https://go.dev/ref/mem#restrictions">Implementation Restrictions for Programs Containing Data Races</a>が追加<ul><li>ThreadSanitizer (go build -race) の紹介や、単一の命令で一度に読み書きできない操作が分断されて行われた時（スライスの3つの構成要素とか)の問題について言及</li></ul></li><li>Synchronization<ul><li><a href="https://go.dev/ref/mem#locks">Locksのセクション</a>で、1.18で追加されたTryLockの記述が追加</li><li><a href="https://go.dev/ref/mem#atomic">Atomic Values</a>, <a href="https://go.dev/ref/mem#finalizer">Finalizers</a>, <a href="https://go.dev/ref/mem#more">Additional Mechanisms</a>が追加</li></ul></li><li><a href="https://go.dev/ref/mem#badcompiler">Incorrect compilation</a>が追加<ul><li>コンパイラ実装者向け</li></ul></li></ul><p>Synchronizationのセクションは追加説明やここ　８年間のライブラリの追加を反映した小粒な変更となっています。大きく説明が変わったのが最初のモデル説明（ただし内容は大きく変わっていないように見える）と、コンパイラ実装者向けの説明の追加ですね。</p><h2 id="メモリモデルの概要"><a href="#メモリモデルの概要" class="headerlink" title="メモリモデルの概要"></a>メモリモデルの概要</h2><p>Russ Coxの3つの記事を読んでみました。1周では理解できなかったので、何周か読んでみた結果のダイジェストです。</p><h3 id="メモリモデルとは"><a href="#メモリモデルとは" class="headerlink" title="メモリモデルとは"></a>メモリモデルとは</h3><ul><li>シングルスレッドでは不要だったが、マルチプロセスが出てきたので必要になった。</li><li>大雑把にメモリモデルというのは、「メモリの読み書きの順序」の決定性の問題<ul><li>コンパイラが最適化目的で命令を入れ替えることもある<ul><li>RISCのCPU向けコンパイラの方が積極的に介入するというのを聴いたことがある(渋川補足)</li></ul></li><li>CPUが命令を解釈して制約を崩さない中でリアルタイムに順序を勝手に書き換えることもある（渋川補足: アウトオブオーダー）</li></ul></li><li>メモリオーダーにはランクがある。逐次一貫性(Sequential Consistency)→弱い一貫性→ゆるい一貫性とここでは３段階あるある。弱いほど並び替えが自由に行われる。<ul><li>保証が弱ければ弱いほど、パフォーマンスのための組み替えの自由度が上がるのでパフォーマンスは上がる</li></ul></li><li>ハードウェアとプログラミング言語の両方がメモリをモデルを持つ</li><li>ハードウェアメモリモデルは、ハードウェアとその上で動くソフトウェアの契約</li><li>言語側のメモリモデルは、コンパイラとプログラマーの契約</li><li>言語側のメモリモデルの現在の標準は極めて保守的な（Java 1.5、C++11、Go 1.19など)は逐次一貫性だが、 これでは性能が上がらないため、ハードウェアはより柔軟性が高い（ゆるい）メモリモデルを持つのが普通とのこと</li><li>保証が必要以上に強いと、それに甘えたソフトウェア実装になってしまい、将来速度のためにゆるいメモリモデルのCPUがリリースされると動かないということになりかねない。</li></ul><h3 id="ハードウェアのお話"><a href="#ハードウェアのお話" class="headerlink" title="ハードウェアのお話"></a>ハードウェアのお話</h3><p>以下の図は<a href="https://research.swtch.com/hwmm">Hardware Memory Models</a>からの引用になります。</p><ul><li>逐次一貫性では常に共有メモリと同期を取る</li></ul><img src="/images/20220808a/一貫性.png" alt="一貫性" width="964" height="190" loading="lazy"><ul><li>Intel(x86-TSO)の方がそれよりもゆるいモデルとなっている。</li></ul><img src="/images/20220808a/intel.png" alt="intel" width="964" height="360" loading="lazy"><ul><li>ARMはさらに弱いモデル。スレッドがメモリのコピーを持って、必要に応じて他のスレッドにコピーを伝搬させる実装とのこと。</li></ul><img src="/images/20220808a/ARM.png" alt="ARM" width="616" height="588" loading="lazy"><ul><li>メモリバリア（あるいはメモリフェンスとも呼ばれる）を使うことで、前の処理が終わることを明示的に示せる。</li></ul><p>あとは、Plan 9をPentium Proに移植しようとしたときの苦労話がたくさん書かれています。ここが一番語りたかったことではないか？</p><h3 id="プログラミング言語のメモリモデル"><a href="#プログラミング言語のメモリモデル" class="headerlink" title="プログラミング言語のメモリモデル"></a>プログラミング言語のメモリモデル</h3><ul><li>主にDRF-SCが利用される<ul><li>SC for DRFとも呼ばれる</li><li>データレースがない状態ではデータレースがないプログラムは逐次一貫した方法で実行されることが保証されて、結果が想像しやすい。</li></ul></li><li>Goのメモリモデル<ul><li>DRF-SC。他の言語と同じ。</li><li>データのレースコンディションがある状況での実装がちょっと違う。<ul><li>C++は自由</li><li>Javaはそのコンディションの状況もより厳密に定義されていてデバッグが楽</li><li>Goは保守的なrace conditionチェックと、実行時はノーガード(パニック)</li></ul></li></ul></li></ul><p>1行にまとめると、メモリモデルの強度はパフォーマンスとのトレードオフがあり、弱くするほど最適化の余地があるが、コードと実際の動きの違いが出てきて動作の予測はしにくくなる。最新のGoをはじめとした各種プログラミング言語は保守的で予測しやすいものを選んだが、その下のハードウェアは柔軟なモデルを採用している、という感じですかね。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>GCの方は調整の余地が多少出てきたため、大規模なアプリケーションではこのあたりも意識する必要が出てきました。といっても、調整の環境変数はまだ2つなので、まだまだ十分にシンプルかと思います。</p><p>メモリモデルの説明は、読めば読むほど普段のプログラミングの話からはちょっと遠い、レイヤーがかなり低い話でした。普段の開発でどのような影響があるかというとあまりないかと思います。syncパッケージの提供する各種同期プリミティブ、チャネルを使った同期、sync&#x2F;atomicパッケージなどを普段から正しく使っていれば特に問題はありません。</p><p>The Go Memory Modelのドキュメントを今回初めてじっくり読んでみましたが、<a href="https://go.dev/ref/mem#synchronization">Synchronization</a>のセクションが、メモリに限らず、「○○と△△は、必ず前者の完了後にもう片方が呼ばれる」といったタイミングについての言語仕様集ともなっていますので、一度軽く目を通しておくとよさそうです。読書会のネタに最適。</p><p>余談ですが、Apple SiliconのmacはRosetta2でインテルバイナリをARMでエミュレーションして実行しますが、Appleはこのためにインテル方式の強い制約を実装したようです。同じARMといっても、MicrosoftのSurfaceのインテルエミュレーションと比べてAppleの方がパフォーマンスが圧倒的に高いのは、元々のコアの性能差もあるがこういうところにあるようです。</p><ul><li><a href="https://www.infoq.com/news/2020/11/rosetta-2-translation/">https://www.infoq.com/news/2020/11/rosetta-2-translation/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%A2%E3%83%87%E3%83%AB/">メモリモデル</category>
      
      
      <comments>https://future-architect.github.io/articles/20220808a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go 1.19 Genericsのアップデート</title>
      <link>https://future-architect.github.io/articles/20220805a/</link>
      <guid>https://future-architect.github.io/articles/20220805a/</guid>
      <pubDate>Thu, 04 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220805a/baner.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;479&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220805a/baner.png" alt="" width="1200" height="479" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは。DXユニットの村上です。<br>本記事は<a href="/articles/20220801a/">Go 1.19リリース連載</a>の5本目です。関数やレシーバのジェネリクスの微修正についてご紹介します。</p><p>Release Noteでは次の箇所になります。</p><p><a href="https://tip.golang.org/ref/spec#Declarations_and_scope">https://tip.golang.org/ref/spec#Declarations_and_scope</a></p><blockquote><p>The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.</p></blockquote><p>翻訳すると以下のようになります。</p><blockquote><p>関数の型パラメータやメソッドレシーバで宣言されたもののスコープは、関数名の後ろから関数本体の終端までです。</p></blockquote><p>しかし本アップデートはGo 1.19でリリース予定でしたが、Go 1.20でのリリースに変更されたようです。<br><a href="https://github.com/golang/go/issues/51503#issuecomment-1154209161">https://github.com/golang/go/issues/51503#issuecomment-1154209161</a></p><p>よってGo 1.20リリース予定の紹介という感じになります。</p><h1 id="従来の問題点"><a href="#従来の問題点" class="headerlink" title="従来の問題点"></a>従来の問題点</h1><p>こちらのissueで問題提起されています。<br><a href="https://github.com/golang/go/issues/51503">https://github.com/golang/go/issues/51503</a></p><p>以下のコードが例として提示されています。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T[T any] <span class="keyword">struct</span> &#123;&#125; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T[T])</span></span> Bar() &#123;&#125; <span class="comment">// error: T is not a generic type</span></span><br></pre></td></tr></table></figure><p>前者がOKなら後者もOKであるべきと議論されていました。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>後者がビルドエラーとなる原因は以下のissueで説明されています。<br><a href="https://github.com/golang/go/issues/52038">https://github.com/golang/go/issues/52038</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T[T])</span></span> Bar() &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>[T]</code>の<code>T</code>が外側（左側）の<code>T</code>を参照しているため、エラーとなるようです。</p><p>逆に外側を<code>T</code>以外にすればエラーにはなりません。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hoge[T any] <span class="keyword">struct</span>&#123;&#125; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Hoge[T])</span></span> Bar() &#123;&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>後者の<code>Hoge</code>、<code>[T]</code>は前者の<code>Hoge</code>、<code>[T any]</code>をそれぞれ参照できているため問題ありません。</p><p>もしくは<code>[T]</code>を別の文字に置き換えても大丈夫です。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T[T any] <span class="keyword">struct</span>&#123;&#125; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T[Hoge])</span></span> Bar() &#123;&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h1 id="解決策"><a href="#解決策" class="headerlink" title="解決策"></a>解決策</h1><p>冒頭で引用したリリースノートの内容にすることで、これがエラーにならなくなります。<br>レシーバの中で宣言された型のスコープを関数名以降にします。<br>これによって、外側の<code>T</code>のスコープは関数名以降となり、<code>[T]</code>に適用されなくなります。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>かなりマイナーアップデートですが、Golangがより洗練された言語になることは間違いないかと思います。<br>修正範囲が大きいということで惜しくもGo 1.19でのリリースは見送られることになりましたが、Go 1.20では修正されるということで期待したいと思います。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9/">ジェネリクス</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      
      <comments>https://future-architect.github.io/articles/20220805a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go1.19 net/http のアップデート</title>
      <link>https://future-architect.github.io/articles/20220804a/</link>
      <guid>https://future-architect.github.io/articles/20220804a/</guid>
      <pubDate>Wed, 03 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220804a/top.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;361&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220804a/top.png" alt="" width="827" height="361"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIGの辻です。<a href="(/articles/20220801a/)">Go 1.19連載</a>の4本目です。</p><p><a href="https://tip.golang.org/doc/go1.19">Go Release Notes</a> に記載がある Minor changes to the library の <code>net/http</code> の3点のアップデートについて触れていきます。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><ul><li><code>ResponseWriter.WriteHeader</code> がユーザーが定義した 1xx 系の情報レスポンスをサポートした</li><li><code>MaxBytesReader</code> が読み取り制限を超過した場合に <code>MaxBytesError</code> を返却するようになった</li><li><code>Location</code> ヘッダーのない 3xx 系のレスポンスをエラーとして扱わないようになった</li></ul><h2 id="①ResponseWriter-WriteHeader-がユーザーが定義した-1xx-系の情報レスポンスをサポートした"><a href="#①ResponseWriter-WriteHeader-がユーザーが定義した-1xx-系の情報レスポンスをサポートした" class="headerlink" title="①ResponseWriter.WriteHeader がユーザーが定義した 1xx 系の情報レスポンスをサポートした"></a>①<code>ResponseWriter.WriteHeader</code> がユーザーが定義した 1xx 系の情報レスポンスをサポートした</h2><p>Go 1.19 からユーザーが定義したHTTPのレスポンスコード 1xx 系の情報ヘッダーをサポートするようになりました。Go 1.18 まではGoの <code>net/http</code> を使ったHTTPサーバでステータスコード 1xx 系を書き込むことはできませんでした。関連するIssue は以下などが挙げられます。</p><ul><li><a href="https://github.com/golang/go/issues/26089">net&#x2F;http: Server&#x2F;Handler&#x2F;ResponseWriter doesn’t allowing sending arbitrary 1xx responses</a></li><li><a href="https://github.com/golang/go/issues/36734">net&#x2F;http: support status code 102 (Processing) in ResponseWriter</a></li><li><a href="https://github.com/golang/go/issues/26088">net&#x2F;http&#x2F;httputil: make ReverseProxy forward 1xx responses</a></li></ul><p>Goの改善内容の詳細を紹介する前に 1xx のステータスコードがどういうものであるか、どのような挙動になるか簡単におさらいしておきます。</p><h3 id="1xx-のステータスコード"><a href="#1xx-のステータスコード" class="headerlink" title="1xx のステータスコード"></a>1xx のステータスコード</h3><p>1xx は情報レスポンスと呼ばれています。</p><blockquote><p>The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. 1xx responses are terminated by the first empty line after the status-line (the empty line signaling the end of the header section).  Since HTTP&#x2F;1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP&#x2F;1.0 client.</p></blockquote><p><a href="https://httpwg.org/specs/rfc7231.html">Hypertext Transfer Protocol (HTTP&#x2F;1.1): Semantics and Content</a> より</p><p>ポイントは以下の3つです。</p><ol><li>要求されたアクションを完了し最終的なレスポンスを送信する前に、コネクションの状態やレスポンスの進捗状況を伝えるための中間的なレスポンスである</li><li>1xx レスポンスは、ステータス行の後の最初の空行(ヘッダーセクションの終わりを示す空行)で終了する</li><li>HTTP&#x2F;1.0 では定義されていないため、サーバーは HTTP&#x2F;1.0 クライアントに 1xx レスポンスを送信してはいけない</li></ol><p>この挙動は具体的にどのようになるのか 1xx 系のステータスコードの一つである <a href="https://httpwg.org/specs/rfc8297.html">103 Early Hints</a> を使って確認しておきます。</p><h3 id="103-Early-Hints"><a href="#103-Early-Hints" class="headerlink" title="103 Early Hints"></a>103 Early Hints</h3><p>103 Early Hints はクライアントが最終的なレスポンスを処理するために役立つヒントを伝えるために使用できるHTTP ステータスコードです。ヘッダだけを送る目的で使われます。リソース配信の最適化に役に立つ、と考えられています。RFCのステータスは EXPERIMENTAL であり、実験的な仕様です。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p>103 Early Hints のレスポンスをクライアントが解釈する場合&#x2F;しない場合のそれぞれの挙動を補足します。</p><ul><li>103 Early Hints を解釈する場合の挙動</li></ul><img src="/images/20220804a/3.png" alt="3.png" width="654" height="520" loading="lazy"><p>イメージ図は日本経済新聞社さんのブログ記事「<a href="https://hack.nikkei.com/blog/advent20201220/">ChromeとFastlyのEarly Hintsの効果計測に貢献する</a>」より引用しています。</p><p>図左のクライアントが図右のサーバーに対して <code>GET /index.html</code> のリソースをリクエストしたときに、そのレスポンスが返却される前にサーバーから 103 Early Hints と <code>link</code> ヘッダーがレスポンスされます。 103 Early Hints のレスポンスを受け取ったクライアントは <code>GET /index.html</code> のレスポンスを待たずして <code>link</code> ヘッダーに記載があるリソース <code>/main.css</code> にリクエストできます。<code>GET /main.css</code> とリクエストすることで、最終的な <code>/index.html</code> で必要なリソース <code>/main.css</code> を予め取得できます。</p><ul><li>103 Early Hints を解釈しない場合の挙動</li></ul><img src="/images/20220804a/2.png" alt="2.png" width="589" height="520" loading="lazy"><p>103 Early Hints を解釈しないクライアントの場合、以下のような挙動になります。クライアントは <code>GET /index.html</code> のレスポンスが返却された後に <code>GET /main.css</code> とリクエストして最終的なレスポンスに必要なリソースを取得します。</p><h3 id="net-http-の挙動の変化"><a href="#net-http-の挙動の変化" class="headerlink" title="net/http の挙動の変化"></a><code>net/http</code> の挙動の変化</h3><p>前置きが少し長くなりました。先程紹介した 103 Early Hints と 200 OKを返却するようなHTTPサーバを <code>net/http</code> を使って実装する場合、以下のようなコードが一例として考えられます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">earlyHintHandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">h := w.Header()</span><br><span class="line">h.Add(<span class="string">&quot;Link&quot;</span>, <span class="string">&quot;&lt;/main.css&gt;; rel=preload; as=style&quot;</span>)</span><br><span class="line">w.WriteHeader(http.StatusEarlyHints)</span><br><span class="line"></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.Handle(<span class="string">&quot;/&quot;</span>, earlyHintHandler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, mux))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 1.18までは <code>WriteHeader()</code> は任意の 1xx 系のステータスコードをサポートしていませんでした。このことは <a href="https://pkg.go.dev/net/http@go1.18.5#ResponseWriter.WriteHeader">WriteHeader</a> のドキュメントにも記載があります。</p><blockquote><p>Go does not currently support sending user-defined 1xx informational headers, with the exception of 100-continue response header that the Server sends automatically when the Request.Body is read.</p></blockquote><p>そのため、上記の実装を Go 1.18 でビルド&amp;起動したサーバに、クライアントからHTTPリクエストしても機能しません。103 Early Hints のレスポンスはクライアントとのコネクションに書き込まれますが、200 OK のレスポンスはサーバーから書き込まれません。<code>curl</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> のクライアントではサーバーからのレスポンスを待ち続けます。</p><figure class="highlight bash"><figcaption><span>Go 1.18のHTTPサーバの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -LIXGET localhost:8080</span><br><span class="line">HTTP/1.1 103 Early Hints</span><br><span class="line">Link: &lt;/main.css&gt;; rel=preload; as=style</span><br><span class="line">Date: Tue, 02 Aug 2022 03:39:40 GMT</span><br><span class="line"></span><br><span class="line">... (レスポンスを待ち続ける) ...</span><br></pre></td></tr></table></figure><p>一方、Go 1.19 でビルド&amp;起動すると、想定どおり 103 Early Hints と 200 OK の両方のレスポンスが得られます。想定どおり機能していることがわかります。なお <code>Link</code> ヘッダーは最終的なレスポンスにも含まれることに注意してください。</p><figure class="highlight bash"><figcaption><span>Go 1.19のHTTPサーバの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -LIXGET localhost:8080</span><br><span class="line">HTTP/1.1 103 Early Hints</span><br><span class="line">Link: &lt;/main.css&gt;; rel=preload; as=style</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Link: &lt;/main.css&gt;; rel=preload; as=style</span><br><span class="line">Date: Tue, 02 Aug 2022 03:46:01 GMT</span><br><span class="line">Content-Length: 5</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure><h3 id="Goのパッチ内容"><a href="#Goのパッチ内容" class="headerlink" title="Goのパッチ内容"></a>Goのパッチ内容</h3><p>パッチは <a href="https://go-review.googlesource.com/c/go/+/269997">269997: net&#x2F;http: allow sending 1xx responses</a> で進められていました。<code>WriteHeader()</code> でステータスコードを書き込むときにステータスコードが 1xx のときはHTTPヘッダーと改行をバッファに書き込んで、それをフラッシュする、ということが主です。</p><figure class="highlight diff"><figcaption><span>net/http/server.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">func (w *response) WriteHeader(code int) &#123;</span><br><span class="line">if w.conn.hijacked() &#123;</span><br><span class="line">caller := relevantCaller()</span><br><span class="line">w.conn.server.logf(&quot;http: response.WriteHeader on hijacked connection from %s (%s:%d)&quot;, caller.Function, path.Base(caller.File), caller.Line)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if w.wroteHeader &#123;</span><br><span class="line">caller := relevantCaller()</span><br><span class="line">w.conn.server.logf(&quot;http: superfluous response.WriteHeader call from %s (%s:%d)&quot;, caller.Function, path.Base(caller.File), caller.Line)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">checkWriteHeaderCode(code)</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// Handle informational headers</span></span><br><span class="line"><span class="addition">+if code &gt;= 100 &amp;&amp; code &lt;= 199 &#123;</span></span><br><span class="line"><span class="addition">+// Prevent a potential race with an automatically-sent 100 Continue triggered by Request.Body.Read()</span></span><br><span class="line"><span class="addition">+if code == 100 &amp;&amp; w.canWriteContinue.isSet() &#123;</span></span><br><span class="line"><span class="addition">+w.writeContinueMu.Lock()</span></span><br><span class="line"><span class="addition">+w.canWriteContinue.setFalse()</span></span><br><span class="line"><span class="addition">+w.writeContinueMu.Unlock()</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+writeStatusLine(w.conn.bufw, w.req.ProtoAtLeast(1, 1), code, w.statusBuf[:])</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// Per RFC 8297 we must not clear the current header map</span></span><br><span class="line"><span class="addition">+w.handlerHeader.WriteSubset(w.conn.bufw, excludedHeadersNoBody)</span></span><br><span class="line"><span class="addition">+w.conn.bufw.Write(crlf)</span></span><br><span class="line"><span class="addition">+w.conn.bufw.Flush()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+return</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line">w.wroteHeader = true</span><br><span class="line">w.status = code</span><br><span class="line"></span><br><span class="line">if w.calledHeader &amp;&amp; w.cw.header == nil &#123;</span><br><span class="line">w.cw.header = w.handlerHeader.Clone()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if cl := w.handlerHeader.get(&quot;Content-Length&quot;); cl != &quot;&quot; &#123;</span><br><span class="line">v, err := strconv.ParseInt(cl, 10, 64)</span><br><span class="line">if err == nil &amp;&amp; v &gt;= 0 &#123;</span><br><span class="line">w.contentLength = v</span><br><span class="line">&#125; else &#123;</span><br><span class="line">w.conn.server.logf(&quot;http: invalid Content-Length of %q&quot;, cl)</span><br><span class="line">w.handlerHeader.Del(&quot;Content-Length&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②MaxBytesReader-が読み取り制限を超過した場合に-MaxBytesError-を返却するようになった"><a href="#②MaxBytesReader-が読み取り制限を超過した場合に-MaxBytesError-を返却するようになった" class="headerlink" title="②MaxBytesReader が読み取り制限を超過した場合に MaxBytesError を返却するようになった"></a>②<code>MaxBytesReader</code> が読み取り制限を超過した場合に <code>MaxBytesError</code> を返却するようになった</h2><p>Go 1.18 で追加になった<a href="https://pkg.go.dev/net/http#MaxBytesReader">MaxBytesReader</a> でエラーが発生した場合のエラーハンドリングが行いやすくなりました。Go1.18 ではリクエストが大きすぎる場合に <code>errors.New(&quot;http: request body too large&quot;)</code> としてAPIのクライアントにエラーを返却していました。このエラー固有のエラーハンドリングを行いたい場合、以下のように文字列で比較してエラーハンドリングする必要がありました。</p><figure class="highlight go"><figcaption><span>リクエストボディが大きすぎる場合のエラーハンドリング例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b, err := io.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err.Error() == <span class="string">&quot;http: request body too large&quot;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 1.19ではユーザーがエラーハンドリングしやすいように新たに <code>MaxBytesError</code> 型という <code>error</code> インターフェースを満たした型を返却するようになりました。元のIssueは <a href="https://github.com/golang/go/issues/30715">net&#x2F;http: add MaxBytesError #30715</a> です。</p><ul><li>パッチ内容の一部</li></ul><figure class="highlight diff"><figcaption><span>net/http/request.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+// MaxBytesError is returned by MaxBytesReader when its read limit is exceeded.</span></span><br><span class="line"><span class="addition">+type MaxBytesError struct &#123;</span></span><br><span class="line"><span class="addition">+Limit int64</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+func (e *MaxBytesError) Error() string &#123;</span></span><br><span class="line"><span class="addition">+// Due to Hyrum&#x27;s law, this text cannot be changed.</span></span><br><span class="line"><span class="addition">+return &quot;http: request body too large&quot;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">type maxBytesReader struct &#123;</span><br><span class="line">w   ResponseWriter</span><br><span class="line">r   io.ReadCloser // underlying reader</span><br><span class="line"><span class="addition">+i   int64         // max bytes initially, for MaxBytesError</span></span><br><span class="line">n   int64         // max bytes remaining</span><br><span class="line">err error         // sticky error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私が興味深く思ったことは、わざわざ新しく <code>maxBytesReader</code> 型でバイトの初期サイズを非公開フィールド <code>i</code> として保持するようにしているが、エラーメッセージを変更していない点です。<code>Error()</code> メソッドのコメントによると「Hyrumの法則」に基づくためとのことです。<code>errors.New()</code> で返却する文字列はGo Docとして公開しているわけではないが、Go 1.18で観測可能なエラー発生時の文字列によりエラーハンドリングを行っているユーザーへの配慮を感じました。なお、Hyrumの法則は『<a href="https://www.oreilly.co.jp/books/9784873119656/">Googleのソフトウェアエンジニアリング</a>』の1章にて以下のように紹介されています。</p><ul><li>Hyrumの法則</li></ul><blockquote><p>あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何かを約束しているかは重要ではない。作られたシステムが持つあらゆる観察可能（observable）な挙動に関して、それに依存するユーザーが出てくるものである。</p></blockquote><h2 id="③Location-ヘッダーのない-3xx-系のレスポンスをエラーとして扱わないようになった"><a href="#③Location-ヘッダーのない-3xx-系のレスポンスをエラーとして扱わないようになった" class="headerlink" title="③Location ヘッダーのない 3xx 系のレスポンスをエラーとして扱わないようになった"></a>③<code>Location</code> ヘッダーのない 3xx 系のレスポンスをエラーとして扱わないようになった</h2><p>Go1.18 までは 3xx 系のレスポンスコードで <code>Location</code> ヘッダーがない場合はエラーとして扱っていました。</p><p>一方 <a href="https://httpwg.org/specs/rfc7231.html#status.301">RFC7231 Hypertext Transfer Protocol (HTTP&#x2F;1.1): Semantics and Content</a> ではステータスコード 301 における <code>Location</code> ヘッダーは <code>SHOULD</code> の項目になります。<a href="https://www.rfc-editor.org/rfc/rfc2119.html">RFC2119 Key words for use in RFCs to Indicate Requirement Levels</a> にあるように <code>MUST</code> であれば、絶対的に含めるべき項目になりますが、<code>SHOULD</code> は推奨される項目です。RFC上は <code>Location</code> ヘッダーが含まれないことも許容されます。</p><p>このことから Go の実装としても <code>Location</code> ヘッダーがなくてもエラーとせずにレスポンスをAPIの呼び出し元に返却するように改善しました。</p><p>リアルワールドでは <a href="https://github.com/golang/go/issues/49281">net&#x2F;http: can’t read 301 response without a Location header #49281</a> という課題がありました。AWSが提供するS3のURLにHTTPリクエストしたときにレスポンスコード 301 で返却されたが <code>Location</code> ヘッダーが含まれないためにGoのエラーが発生する。レスポンスヘッダー <code>x-amz-bucket-region</code> から想定するリージョンを取得できず、困っていた、とのことです。この挙動は Go1.19 で改善されます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBucketRegion</span><span class="params">(bucket <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// Construct client that makes one request and does not follow redirects</span></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.ErrUseLastResponse</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">&quot;https://&quot;</span> + bucket + <span class="string">&quot;.s3.us-west-1.amazonaws.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err <span class="comment">// &lt;-- function will return here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;us-west-1&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> resp.StatusCode == <span class="number">404</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;Bucket does not exist.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp.Header.Get(<span class="string">&quot;x-amz-bucket-region&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">region, err := getBucketRegion(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;region: %s\n&quot;</span>, region)</span><br><span class="line">fmt.Printf(<span class="string">&quot;err: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p><code>net/http</code> のアップデートはリリースノートではさらっと3行記載があるだけですが、それぞれの背景やパッチ内容を含めて紹介しました。リアルワールド感あふれる課題やニーズを感じることでき、とてもわくわくしました。</p><p>本記事では <code>net/http</code> のアップデートを紹介しました。その他にも <code>net/url</code> で <a href="https://pkg.go.dev/net/url@go1.19#JoinPath">JoinPath</a> と <a href="https://pkg.go.dev/net/url@go1.19#URL.JoinPath">URL.JoinPath</a> が追加になっています。HTTPはもちろんですが、その他のプロトコルにおいても、便利にURLを組み立てられるようになっています。</p><p>最後まで読んでいただき、ありがとうございました！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">なお2022年8月2日にGo1.19 rc2で調べています。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">Chrome と Fastly による実装実験が始まっています。<a href="https://www.fastly.com/jp/blog/beyond-server-push-experimenting-with-the-103-early-hints-status-code">https://www.fastly.com/jp/blog/beyond-server-push-experimenting-with-the-103-early-hints-status-code</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">curlのバージョンは7.83.1を使っています。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/HTTP/">HTTP</category>
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      
      <comments>https://future-architect.github.io/articles/20220804a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go1.19で追加されたAppend系メソッド</title>
      <link>https://future-architect.github.io/articles/20220803a/</link>
      <guid>https://future-architect.github.io/articles/20220803a/</guid>
      <pubDate>Tue, 02 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220803a/eyecatch.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;486&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220803a/eyecatch.png" alt="" width="1200" height="486" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG&#x2F;DXユニットの宮永です。</p><p><a href="/articles/20220801a/">Go 1.19リリース連載</a>の3本目です。本記事ではGo1.19のライブラリマイナーチェンジの中でも、Append系メソッドに注目して紹介します。</p><p>Go1.19でAppend系のメソッドが追加されたのは以下2つのライブラリです。<br>それぞれのProposalのリンクを添付します。</p><ul><li>encoding&#x2F;binary<ul><li><a href="https://github.com/golang/go/issues/50601">encoding&#x2F;binary: add AppendByteOrder (#50601)</a></li><li><a href="https://github.com/golang/go/issues/51644">encoding&#x2F;binary: add AppendUvarint and AppendVarint (#51644)</a></li></ul></li><li>fmt<ul><li><a href="https://github.com/golang/go/issues/47579">fmt: add Append, Appendf, Appendln (#47579)</a></li></ul></li></ul><p>順に説明します。</p><h1 id="encoding-x2F-binary"><a href="#encoding-x2F-binary" class="headerlink" title="encoding&#x2F;binary"></a>encoding&#x2F;binary</h1><blockquote><p><em>The new interface AppendByteOrder provides efficient methods for appending a uint16, uint32, or uint64 to a byte slice. BigEndian and LittleEndian now implement this interface.<br>Similarly, the new functions AppendUvarint and AppendVarint are efficient appending versions of PutUvarint and PutVarint.<br><a href="https://tip.golang.org/doc/go1.19#:~:text=The%20new%20interface,and%20PutVarint.">Go 1.19 Release Notesより引用</a></em></p></blockquote><p>encoding&#x2F;binaryパッケージにはAppendByteOrder、AppendUvarint、 AppendVarint、が新たに追加されました。</p><p><a href="https://github.com/golang/go/issues/50601">(#50601)</a>では、AppendByteOrderインターフェースの導入が提案され、BigEndian 型と LittleEndian 型に新たにAppendUint16、AppendUint32、AppendUint64が実装されています。<br><a href="https://github.com/golang/go/issues/51644">(#51644)</a>では<a href="https://github.com/golang/go/issues/50601">(#50601)</a>にてAppendByteOrderを導入した関連でAppendUvarint、 AppendVarintを実装しています。この2つのメソッドは型への紐づけは行われておらずそれぞれ<code>uint64</code>、<code>int64</code>を引数に持ちます。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>byte型のスライスに整数型をさらに追加する場合、使用します。</p><p>Go1.18以前で上記を達成する場合、以下の様な実装をする必要がありました。</p><div class="note info" style="background: #e5f8e2; padding: 16px;">  <span class="fa fa-fw fa-check-circle"></span>  <p>✅利用方法という観点では、今回導入されたメソッドはどれも同じ様な使われ方のため、AppendUint16に注目して解説します。</p></div><br><p>▶<a href="https://go.dev/play/p/1txJEaI7FdK">playground</a></p><figure class="highlight go"><figcaption><span>go1.18以前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := []<span class="type">uint16</span>&#123;<span class="number">102</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">103</span>&#125;</span><br><span class="line">out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(in))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> in &#123;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">binary.LittleEndian.PutUint16(arr[:], v)</span><br><span class="line">out = <span class="built_in">append</span>(out, arr[:]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;raw: %v \n&quot;</span>, out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %s \n&quot;</span>, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▼実行結果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw: [102 0 117 0 116 0 117 0 114 0 101 0 32 0 116 0 101 0 99 0 104 0 45 0 98 0 108 0 111 0 103 0]</span><br><span class="line">str: future tech-blog</span><br></pre></td></tr></table></figure><p>今回導入されたAppendUintメソッドを使用すればより端的に実装することができます。</p><p>▶<a href="https://go.dev/play/p/Rvp0_2vONlp?v=gotip">playground</a></p><figure class="highlight go"><figcaption><span>go1.19以降</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := []<span class="type">uint16</span>&#123;<span class="number">102</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">103</span>&#125;</span><br><span class="line">out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(input))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">out = binary.LittleEndian.AppendUint16(out, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;raw: %v \n&quot;</span>, out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %s \n&quot;</span>, out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>▼実行結果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw: [102 0 117 0 116 0 117 0 114 0 101 0 32 0 116 0 101 0 99 0 104 0 45 0 98 0 108 0 111 0 103 0]</span><br><span class="line">str: future tech-blog</span><br></pre></td></tr></table></figure><p>Appendで実装することにより記述行数が減り、可読性もぐっと上がりました。</p><p>AppendUint32、AppendUint64も基本的な利用方法は同じです。</p><h1 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h1><blockquote><p><em>The new functions Append, Appendf, and Appendln append formatted data to byte slices.<br><a href="https://tip.golang.org/doc/go1.19#:~:text=The%20new%20functions%20Append%2C%20Appendf%2C%20and%20Appendln%20append%20formatted%20data%20to%20byte%20slices.">Go 1.19 Release Notesより引用</a></em></p></blockquote><p>fmtパッケージにもAppend系のメソッドが導入されました。<br>こちらもbyte型のスライスを戻り値に持つメソッドです。</p><p>こちらのメソッドの導入経緯はproposalにも記載されています</p><blockquote><p><em>fmt.Sprintf is an allocator that produces a string, but there are times when you want formatted-output, but want to write into a []byte. And you can do that with bytes.Buffer and fmt.Fprintf<br>…(中略)<br>What I want: Something like Sprintf, but that can write into a []byte, and can fail gracefully if there’s not enough space to write things.<br><a href="https://github.com/golang/go/issues/47579">fmt: add Append, Appendf, Appendln (#47579)より引用</a></em></p></blockquote><p>フォーマットされた出力で[]byteに書き込みを行う場合、これまではbytes.Bufferとfmt.Fprintfを組み合わせて実装することができました。Appendfの導入によりこれを気軽に利用することができます。</p><h2 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h2><p>Sprintfと比較すると利用方法がわかりやすいと思います。<br>fmtにはSprintfメソッドが定義されています。これは任意の型をフォーマットし、文字列で返すメソッドです。</p><p>Appendfでは引数にbyte型スライスを持ち、Sprintfとは異なり、戻り値にbyte型スライスを持ちます。<br>つまり、任意の型をフォーマットをした後、引数に与えられたbyte型スライスに値を追加し、返却します。</p><p>SprintfとAppendfの実装を見たほうがわかりやすいと思いますので、以下比較を行います。</p><figure class="highlight go"><figcaption><span>fmt.Sprintf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sprintf formats according to a format specifier and returns the resulting string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintf(format, a)</span><br><span class="line">s := <span class="type">string</span>(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>fmt.Appendf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appendf formats according to a format specifier, appends the result to the byte</span></span><br><span class="line"><span class="comment">// slice, and returns the updated slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Appendf</span><span class="params">(b []<span class="type">byte</span>, format <span class="type">string</span>, a ...any)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintf(format, a)</span><br><span class="line">b = <span class="built_in">append</span>(b, p.buf...)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>細かな点で異なりますが、2つのメソッドの本質的な差分は以下の1行のみです。</p><figure class="highlight diff"><figcaption><span>diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-   s := string(p.buf)</span></span><br><span class="line"><span class="addition">+b = append(b, p.buf...)</span></span><br></pre></td></tr></table></figure><p>では実際に使用してみます。</p><p><code>in:=tech-blog</code>を<code>%s</code>でフォーマットして、空のbyte型スライスに追加します。</p><p>▶<a href="https://go.dev/play/p/mWlytnqwn5a?v=gotip">playground</a></p><figure class="highlight go"><figcaption><span>fmt.Appendf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := <span class="string">&quot;tech-blog&quot;</span></span><br><span class="line">out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">out = fmt.Appendf(out, <span class="string">&quot;future %s&quot;</span>, in)</span><br><span class="line">fmt.Printf(<span class="string">&quot;raw: %v \n&quot;</span>, out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %s \n&quot;</span>, out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>▼実行結果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw: [102 117 116 117 114 101 32 116 101 99 104 45 98 108 111 103]</span><br><span class="line">str: future tech-blog</span><br></pre></td></tr></table></figure><p>空だったbyte型スライスoutに要素が追加されていますね。</p><p>Appendはフォーマットは行わず、要素の追加のみ行います。</p><p>▶<a href="https://go.dev/play/p/esdszlv900P?v=gotip">playground</a></p><figure class="highlight go"><figcaption><span>fmt.Append</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := <span class="string">&quot;tech-blog&quot;</span></span><br><span class="line">out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">out = fmt.Append(out, in)</span><br><span class="line">fmt.Printf(<span class="string">&quot;raw: %v \n&quot;</span>, out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %s \n&quot;</span>, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▼実行結果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw: [116 101 99 104 45 98 108 111 103]</span><br><span class="line">str: tech-blog</span><br></pre></td></tr></table></figure><p>AppendlnはAppendした後に改行を挿入します。<br>先程のコードに<code>out = fmt.Appendln(out, &quot;future&quot;)</code>を加えます。</p><p>▶<a href="https://go.dev/play/p/esdszlv900P?v=gotip">playground</a></p><figure class="highlight go"><figcaption><span>fmt.Appendln</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := <span class="string">&quot;tech-blog&quot;</span></span><br><span class="line">out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">out = fmt.Appendln(out, <span class="string">&quot;future&quot;</span>)</span><br><span class="line">out = fmt.Append(out, in)</span><br><span class="line">fmt.Printf(<span class="string">&quot;raw: %v \n&quot;</span>, out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %s \n&quot;</span>, out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>▼実行結果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raw: [102 117 116 117 114 101 10 116 101 99 104 45 98 108 111 103]</span><br><span class="line">str: future</span><br><span class="line">tech-blog</span><br></pre></td></tr></table></figure><p>期待どおり、Appendlnで追加した<code>future</code>で改行が挿入されていますね。</p><h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>今回はGo1.19でリリースされた各種ライブラリのマイナーチェンジの中でもAppend系のメソッドに注目しました。<br>今回のリリースには含まれていませんが、<a href="https://github.com/golang/go/issues/53693">proposal: encoding: provide append-like variants #53693</a>では<code>encoding/hex</code>,<code>encoding/base32</code>,<code>encoding/base64</code>に対してAppend系のメソッドを追加しようという提案がされており、今後もencoding周りのAPIはマイナーリリースが続きそうです。</p><p><a href="https://github.com/golang/go/issues/53693">(#53693)</a>以外にも、以下のようなProposalでAppend-likeなメソッド追加が提案されています。</p><ul><li><a href="https://github.com/golang/go/issues/24630">proposal: encoding: BinaryMarshaler should be an append API #24630</a></li><li><a href="https://github.com/golang/go/issues/54078">proposal: compress: add AppendEncoded and AppendDecoded #54078</a></li></ul><p>普段とは異なる切り口で公式リポジトリを眺めていましたが、特定のパッケージやAPIに注目するとパッケージの役割や関数の命名に非常に慎重に議論が進められている事に気が付きます。<br>Goの思想や質の高いコーディングを学ぶという点で今回の連載は非常に良い体験でした。</p><p>最後までお付き合いただきありがとうございました。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      
      <comments>https://future-architect.github.io/articles/20220803a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go1.19 encoding/csv のアップデート</title>
      <link>https://future-architect.github.io/articles/20220802a/</link>
      <guid>https://future-architect.github.io/articles/20220802a/</guid>
      <pubDate>Mon, 01 Aug 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220802a/go1.19csv.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;447&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220802a/go1.19csv.png" alt="" width="800" height="447"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>TIG真野です。<a href="/articles/20220801a/">Go 1.19リリース連載</a>の2本目です。</p><p>encoding&#x2F;csv のアップデート内容について紹介します。 <a href="/articles/20210811a/">Go 1.17のときも encoding&#x2F;csv</a> を取り上げたので2回目です。</p><p>ちなみにその時に説明した<code>FieldPos()</code> ですが、類似のメソッドがGo 1.19の <code>encoding/xml</code> にも追加されています。隣のパッケージに類似の展開がされているのは面白いですね。</p><blockquote><p><code>encoding/xml</code><br>The new method <code>Decoder.InputPos</code> reports the reader’s current input position as a line and column, analogous to encoding&#x2F;csv’s <code>Decoder.FieldPos</code>.<br>readerの現在入力位置の行と列を示すを取得します。 <code>encoding/csv</code> の <code>Decoder.FieldPos</code> と同様です。</p></blockquote><h2 id="アップデート内容について"><a href="#アップデート内容について" class="headerlink" title="アップデート内容について"></a>アップデート内容について</h2><p>さて、<code>encoding/csv</code> のアップデートについてです。</p><p><a href="https://tip.golang.org/doc/go1.19">Go 1.19 Release Notes</a> に1行だけ書いてあります。</p><blockquote><p>The new method Reader.InputOffset reports the reader’s current input position as a byte offset, analogous to encoding&#x2F;json’s Decoder.InputOffset.<br>新しい <code>Reader.InputOffset</code> メソッドは、現在の入力位置をバイトオフセットとして取得します。encoding&#x2F;jsonの <code>Decoder.InputOffset</code> と類似しています。</p></blockquote><p>追加された関数は<a href="https://pkg.go.dev/encoding/csv@master#Reader.InputOffset">GoDocs</a>に次のように書かれています。</p><figure class="highlight go"><figcaption><span>追加されたメソッド</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span></span> InputOffset() <span class="type">int64</span></span><br></pre></td></tr></table></figure><p>これであーこれで便利になるねってピンと来る人は、そこそこディープな <code>encoding/csv</code> のファンではないでしょうか？説明していきます。</p><h2 id="まずどういうAPIか動かしましょう"><a href="#まずどういうAPIか動かしましょう" class="headerlink" title="まずどういうAPIか動かしましょう"></a>まずどういうAPIか動かしましょう</h2><p>以下のバージョンで動かしています。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;go version</span><br><span class="line">go version go1.19rc2 windows/amd64</span><br></pre></td></tr></table></figure><p>改行を含むCSVデータで動かしてみます。</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/csv&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">`aaa,&quot;b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bb&quot;,ccc</span></span><br><span class="line"><span class="string">ddd,eee,fff</span></span><br><span class="line"><span class="string">zzz,yyy,xxx</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">r := csv.NewReader(strings.NewReader(s))</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;input offset:%d: &quot;</span>, r.InputOffset())</span><br><span class="line"></span><br><span class="line">record, err := r.Read()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err) <span class="comment">// 何かしらのエラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>結果は次のようになります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;go run main.go</span><br><span class="line">input offset:0: []string&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;b\n\nbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;</span><br><span class="line">input offset:16: []string&#123;<span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;eee&quot;</span>, <span class="string">&quot;fff&quot;</span>&#125;</span><br><span class="line">input offset:28: []string&#123;<span class="string">&quot;zzz&quot;</span>, <span class="string">&quot;yyy&quot;</span>, <span class="string">&quot;xxx&quot;</span>&#125;</span><br><span class="line">input offset:40:</span><br></pre></td></tr></table></figure><p>最初は0で <code>r.Read()</code> が呼び出されるとバイト位置が進み、呼び出されるたびにddd、zzz項目の直前まで先に進んでいることがわかります。バイト位置的にどこまで進んだかがわかります。</p><h2 id="Issue上でのやり取り"><a href="#Issue上でのやり取り" class="headerlink" title="Issue上でのやり取り"></a>Issue上でのやり取り</h2><p><a href="https://github.com/golang/go/issues/43401">encoding&#x2F;csv: add Reader.InputOffset method #43401</a> が該当のIssueですが、<code>encoding/json.Decoder</code> という前例があるからか割りとすんなり提案から受け入れられています。</p><p>議論があったポイントは以下程度。</p><ul><li><code>encoding/json</code> の <code>Decoder.InputOffset</code> はJSONバイナリをどこまで読み取ったか知るすべが無いので有効である<ul><li>CSVの場合は行ベースなので、不要では？<ul><li>いやいや、ランダムアクセスが必要なケースもあるし必要。例えば CSVに対して転置インデックスを作成し、オフセットから特定の行を読み取りたいケースがある</li><li>（筆者補足）あと、CSVは項目の改行が許容されているので必ずしも読み取った行でポジションが分かるわけでもない</li></ul></li></ul></li></ul><p>ちなみに、前例とされている <code>encoding/json.Decoder</code> は2020年2月25日の <a href="https://go.dev/doc/go1.14#:~:text=The%20Decoder%20type%20supports%20a%20new%20method%20InputOffset%20that%20returns%20the%20input%20stream%20byte%20offset%20of%20the%20current%20decoder%20position.">Go 1.14</a>に追加されたメソッドです。</p><h2 id="追加された関数の内容は分かるけど、どういう時に嬉しいのか"><a href="#追加された関数の内容は分かるけど、どういう時に嬉しいのか" class="headerlink" title="追加された関数の内容は分かるけど、どういう時に嬉しいのか"></a>追加された関数の内容は分かるけど、どういう時に嬉しいのか</h2><p>Issueのくだりで触れられていますが、主要なユースケースは2つ思いつきます。</p><ol><li>CSVをデコード時に不正な入力が合った場合、どのバイト位置で失敗したか知らせたい<ol><li>通常はこちらの用途が多いのではと思いますが…さていかに。</li></ol></li><li>（巨大な）CSVファイルに対してランダムアクセスをさせるため、正確な位置を知りたい場合<ol><li>どういうケースで必要になるかイメージがわかないですが(私が扱うような業務システム領域だとRDBとかElasticsearchに突っ込んじゃうので..)、 <a href="https://stackoverflow.com/questions/22875018/read-random-lines-off-a-text-file-in-go">Read random lines off a text file in go - Stack Overflow</a> にある通り、需要はあるようです</li></ol></li></ol><p>それぞれどんな感じになるか簡易実装で紹介します。</p><h3 id="不正なCSV入力例"><a href="#不正なCSV入力例" class="headerlink" title="不正なCSV入力例"></a>不正なCSV入力例</h3><p>試しに不正なクウォートを混入させてみます。 ee<code>&quot;</code>e が該当の部分です。</p><figure class="highlight go"><figcaption><span>main.goのCSVに不正なクォートを混入させる</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`aaa,&quot;b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bb&quot;,ccc</span></span><br><span class="line"><span class="string">ddd,ee&quot;e,fff</span></span><br><span class="line"><span class="string">zzz,yyy,xxx</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>動かしてみると、次のメッセージが取得できます。</p><figure class="highlight sh"><figcaption><span>実行結果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;go run main.go</span><br><span class="line">input offset:0: []string&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;b\n\nbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;</span><br><span class="line">input offset:16: 2022/08/02 12:17:52 parse error on line 4, column 7: bare <span class="string">&quot; in non-quoted-field</span></span><br><span class="line"><span class="string">exit status 1</span></span><br></pre></td></tr></table></figure><p>やってみて気がついたんですが、CSVパースエラーの場合は行番号も列位置も出ているため、 <code>InputOffset()</code> をわざわざ出さなくても良いかなとは思いました。</p><p>信頼できない連携先とのやり取りで、不正値を混入することを考慮して、 <code>InputOffset()</code> を表示しなくてもまぁ大丈夫かなということが分かりました。</p><h3 id="巨大なCSVに対するランダムアクセス例"><a href="#巨大なCSVに対するランダムアクセス例" class="headerlink" title="巨大なCSVに対するランダムアクセス例"></a>巨大なCSVに対するランダムアクセス例</h3><p>ということで、巨大なCSVのランダムアクセスです。データは<a href="https://www.e-stat.go.jp/stat-search/files?page=1&layout=datalist&toukei=00200521&tstat=000001011777&cycle=0&tclass1=000001094741&cycle_facet=tclass1&tclass2val=0">国勢調査 - 年齢（５歳階級），男女別人口－都道府県（大正９年～平成27年）</a> から取得したCSVを使っています（<code>c03.csv</code> という名称もそのままです）。1.7万行ほどで1MBほどなのでメモリに載せれるほどですが、いったんこれが1000TBくらいあると仮定します。</p><p>最初に対象となる巨大なCSVファイルを読み取り、後で検索したいレコードが登場したらそのオフセット位置を覚えておきます（この情報を後でファイルに出力しても良いですね）。</p><p>その後、<code>fetchFirstLine()</code> で覚えておいたオフセット位置をもとに巨大なファイルを <code>f.Seek()</code> を用いてその位置から1行だけCSVを読み込みます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/csv&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 都道府県ごとのオフセット位置を `indexMap` に格納する</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;c03.csv&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">indexMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span><br><span class="line">r := csv.NewReader(f)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prefectureCD <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">offset := r.InputOffset()</span><br><span class="line">record, err := r.Read()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> record[<span class="number">0</span>] != prefectureCD &#123;</span><br><span class="line">prefectureCD = record[<span class="number">0</span>]</span><br><span class="line">indexMap[record[<span class="number">1</span>]] = offset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err) <span class="comment">// 何かしらのエラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// オフセット位置を表示</span></span><br><span class="line">fmt.Println(<span class="string">&quot;北海道&quot;</span>, indexMap[<span class="string">&quot;北海道&quot;</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;神奈川県&quot;</span>, indexMap[<span class="string">&quot;東京都&quot;</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;沖縄県&quot;</span>, indexMap[<span class="string">&quot;沖縄県&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 該当の最初の1行を取得（ランダムアクセスを想定）</span></span><br><span class="line">line, err := fetchFirstLine(indexMap, <span class="string">&quot;東京都&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchFirstLine</span><span class="params">(indexMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>, key <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">f, err := os.Open(<span class="string">&quot;c03.csv&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">_, err = f.Seek(indexMap[key], <span class="number">0</span>) <span class="comment">//特定の位置から読む</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := csv.NewReader(f)</span><br><span class="line"><span class="keyword">return</span> r.Read()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行するとこういう感じです。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;go run main.go</span><br><span class="line">北海道 146</span><br><span class="line">神奈川県 262340</span><br><span class="line">沖縄県 1006890</span><br><span class="line">[]string&#123;<span class="string">&quot;13&quot;</span>, <span class="string">&quot;東京都&quot;</span>, <span class="string">&quot;総数&quot;</span>, <span class="string">&quot;大正&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;1920&quot;</span>, <span class="string">&quot;3699428&quot;</span>, <span class="string">&quot;1952989&quot;</span>, <span class="string">&quot;1746439&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>こういった用途に関しては、 <code>f.Seek()</code> を使ってファイルの特定位置から読み込むためには、従来の行番号などでは不適切です。なぜなら100万行目から読み込む必要があると分かっても、ファイルの先頭から改行コードをカウントする必要があり、アクセスしたい行番号が大きければ大きいほど時間がかかってしまいます。</p><p>このようにして、 <code>InputOffset()</code> で取得したバイト位置をもとに、巨大なファイルに対してランダムアクセスのようなことができます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>新しく追加された <code>InputOffset()</code> について調べました。リリースノートの内容だけ見ると不正な入力値に対するトレース用途に用いるのかなと思っていましたが、どちらかといえばもう少しテクニカルな用途での利用を想定していそうです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      <category domain="https://future-architect.github.io/tags/CSV/">CSV</category>
      
      
      <comments>https://future-architect.github.io/articles/20220802a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title> Go 1.19リリース連載始まります GoDoc/ツール周りのアップデート</title>
      <link>https://future-architect.github.io/articles/20220801a/</link>
      <guid>https://future-architect.github.io/articles/20220801a/</guid>
      <pubDate>Sun, 31 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20200521/go1.19.png&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;

&lt;p&gt;Go</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20200521/go1.19.png" alt="" width="" height=""><p>Go 1.18のジェネリクス導入の大規模リリースと比べると比較的小さな1.19ですが、それでもさまざまな変更があります。今回ももちろん、恒例行事になりつつある、このテックブログでリリース連載をやります。特に、網羅性とか考えずに書きたい人が書きたいテーマをピックアップしています。もし、「このテーマについて語らせろ！」という方がいましたら、社外からも飛び込み参加可能ですので、ぜひどうぞ。</p><p>なお、正式リリースはおそらく8月中旬になるかと思います。現時点の<a href="https://tip.golang.org/doc/go1.19">最新版のリリースノート</a>を参考にしているため、もしかしたら正式版で変更があるかもしれません。その場合は補足を行う予定です。</p><div class="scroll"><table><thead><tr><th align="center">Date</th><th align="center">Title</th><th align="center">Author</th></tr></thead><tbody><tr><td align="center">8&#x2F;1 (月)</td><td align="center">Docコメント&#x2F;ツール周りのアップデート</td><td align="center">澁川喜規</td></tr><tr><td align="center">8&#x2F;2 (火)</td><td align="center"><a href="/articles/20220802a/">encoding&#x2F;csv</a></td><td align="center">真野隼記さん</td></tr><tr><td align="center">8&#x2F;3 (水)</td><td align="center"><a href="/articles/20220803a/">encoding&#x2F;byte, fmtのAppend系メソッド</a></td><td align="center">宮永崇史さん</td></tr><tr><td align="center">8&#x2F;4 (木)</td><td align="center"><a href="/articles/20220804a/">net&#x2F;http</a></td><td align="center">辻大志郎さん</td></tr><tr><td align="center">8&#x2F;5 (金)</td><td align="center"><a href="/articles/20220805a/">ジェネリクス</a></td><td align="center">村上知優さん</td></tr><tr><td align="center">8&#x2F;8 (月)</td><td align="center"><a href="/articles/20220808a/">メモリ周り</a></td><td align="center">澁川喜規</td></tr><tr><td align="center">8&#x2F;9 (火)</td><td align="center">tbd</td><td align="center"></td></tr><tr><td align="center">8&#x2F;10 (水)</td><td align="center">tbd</td><td align="center"></td></tr></tbody></table></div><p>まずは、GoDocと、その他ツール周りのアップデートの紹介です。</p><h1 id="Docコメントの更新"><a href="#Docコメントの更新" class="headerlink" title="Docコメントの更新"></a>Docコメントの更新</h1><p>以前、Qiitaの方に、<a href="https://qiita.com/shibukawa/items/8c70fdd1972fad76a5ce">チョットできるGoプログラマーになるための詳解GoDoc</a>という記事を掲載しました。</p><p><a href="https://qiita.com/shibukawa/items/8c70fdd1972fad76a5ce">https://qiita.com/shibukawa/items/8c70fdd1972fad76a5ce</a></p><p>GoDocの書き方の詳細ですが、以前は空行をあけて段落、インデントをしてフォーマット済みテキスト、URLがあればリンク、という程度のマークアップしかなく、とてもシンプルでした。GitHub FlavorなMarkdownとまでもいかなくても、もうちょっとマークアップが高機能になってほしい、せめてリストだけでも・・・と思っていた日本全国1億2000万のGoプログラマーにとって待望のアップデートが1.19で入りました。</p><ul><li>セクションタイトル</li><li>リンク</li><li>リスト</li></ul><p>また、gofmtが改善され、Docコメントでよくある間違いがチェックされるようになりました。詳しくは<a href="https://tip.golang.org/doc/comment">Go Doc Comments</a>というドキュメントを参照してください。</p><p>Docコメントはpkg.go.devで公開されるだけではなく、IDEでマウスオーバーしたときに表示されたりもするため、丁寧なドキュメントは利用者への助けとなります。</p><h2 id="セクションタイトル（heading）"><a href="#セクションタイトル（heading）" class="headerlink" title="セクションタイトル（heading）"></a>セクションタイトル（heading）</h2><p>セクションタイトルはMarkdownと同じく、 <code>#</code> 記号＋スペース＋テキストという形式で書きます。なお、他のマークアップでは、HTMLにあわせてか、6階層まで書けるのですが、Goの場合は1階層のタイトルしか書けません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package strconv implements conversions to and from string representations</span></span><br><span class="line"><span class="comment">// of basic data types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// # Numeric Conversions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The most common numeric conversions are [Atoi] (string to int) and [Itoa] (int to string).</span></span><br></pre></td></tr></table></figure><h2 id="リンクの書き方"><a href="#リンクの書き方" class="headerlink" title="リンクの書き方"></a>リンクの書き方</h2><p>まずリンクですが、URLを設定したい場合は、次のような <code>[ ]</code> でくくったテキストを書き、その下の注釈のようにリンクを書きます。書籍に書くような書き方ですね。あるいはreStructuredTextの、あまり使われない方の書き方。リンク定義のブロックは通常のパラグラフと空行で空けて書きます。gofmtはリンク定義のブロックは全自動で末尾に移動してくれるとのこと。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package json implements encoding and decoding of JSON as defined in</span></span><br><span class="line"><span class="comment">// [RFC 7159]. The mapping between JSON and Go values is described</span></span><br><span class="line"><span class="comment">// in the documentation for the Marshal and Unmarshal functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For an introduction to this package, see the article</span></span><br><span class="line"><span class="comment">// “[JSON and Go].”</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [RFC 7159]: https://tools.ietf.org/html/rfc7159</span></span><br><span class="line"><span class="comment">// [JSON and Go]: https://golang.org/doc/articles/json_and_go.htmlpackage json</span></span><br></pre></td></tr></table></figure><p>それ以外に、リファレンスの中で相互リンクも書けるようになります。パッケージ名（階層があるならencoding&#x2F;jsonのようにスラッシュ付きで）、構造体のようなトップの要素、それらの子供の要素などをピリオドでつないで書くとのこと。オプションでアスタリスクを前につけて、 <code>[*bytes.Buffer]</code>のようにもできるとのことです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadFrom reads data from r until EOF and appends it to the buffer, growing</span></span><br><span class="line"><span class="comment">// the buffer as needed. The return value n is the number of bytes read. Any</span></span><br><span class="line"><span class="comment">// error except [io.EOF] encountered during the read is also returned. If the</span></span><br><span class="line"><span class="comment">// buffer becomes too large, ReadFrom will panic with [ErrTooLarge].</span></span><br></pre></td></tr></table></figure><h2 id="リスト"><a href="#リスト" class="headerlink" title="リスト"></a>リスト</h2><p>リストは、今までのコードブロックの派生という感じで、リストの前の段落の末尾のコロンと、リストのインデントが必要な点に要注意です。</p><p>バレットリストと数字つきの2つがあります。バレットリストはマイナス記号やアスタリスクなど複数の記号に対応しているとのことですが、gofmtにかけると、空白スペース2個＋マイナス＋スペースに整列しちゃうとのことで、マイナスだけ覚えておけば良さそう。</p><p>数字は他のマークアップでもよくある形式ですが、スペースが前に1個入るのが正式とのこと（gofmtがそのように整形する）。</p><p>ただし、ネストなどはできませんし、リストの中にコードブロックなども書けません。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PublicSuffixList provides the public suffix of a domain. For example:</span></span><br><span class="line"><span class="comment">//   - the public suffix of &quot;example.com&quot; is &quot;com&quot;,</span></span><br><span class="line"><span class="comment">//   - the public suffix of &quot;foo1.foo2.foo3.co.uk&quot; is &quot;co.uk&quot;, and</span></span><br><span class="line"><span class="comment">//   - the public suffix of &quot;bar.pvt.k12.ma.us&quot; is &quot;pvt.k12.ma.us&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Clean returns the shortest path name equivalent to path</span></span><br><span class="line"><span class="comment">// by purely lexical processing. It applies the following rules</span></span><br><span class="line"><span class="comment">// iteratively until no further processing can be done:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Replace multiple slashes with a single slash.</span></span><br><span class="line"><span class="comment">//  2. Eliminate each . path name element (the current directory).</span></span><br><span class="line"><span class="comment">//  3. Eliminate each inner .. path name element (the parent directory)</span></span><br><span class="line"><span class="comment">//     along with the non-.. element that precedes it.</span></span><br><span class="line"><span class="comment">//  4. Eliminate .. elements that begin a rooted path:</span></span><br><span class="line"><span class="comment">//     that is, replace &quot;/..&quot; by &quot;/&quot; at the beginning of a path.</span></span><br></pre></td></tr></table></figure><h2 id="コードブロック"><a href="#コードブロック" class="headerlink" title="コードブロック"></a>コードブロック</h2><p>これは前からあったものです。前の段落の末尾のコロン＋インデントで、スペースなどが維持された形で表示されます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search uses binary search...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As a more whimsical example, this program guesses your number:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  func GuessingGame() &#123;</span></span><br><span class="line"><span class="comment">//      var s string</span></span><br><span class="line"><span class="comment">//      fmt.Printf(&quot;Pick an integer from 0 to 100.\n&quot;)</span></span><br><span class="line"><span class="comment">//      answer := sort.Search(100, func(i int) bool &#123;</span></span><br><span class="line"><span class="comment">//          fmt.Printf(&quot;Is your number &lt;= %d? &quot;, i)</span></span><br><span class="line"><span class="comment">//          fmt.Scanf(&quot;%s&quot;, &amp;s)</span></span><br><span class="line"><span class="comment">//          return s != &quot;&quot; &amp;&amp; s[0] == &#x27;y&#x27;</span></span><br><span class="line"><span class="comment">//      &#125;)</span></span><br><span class="line"><span class="comment">//      fmt.Printf(&quot;Your number is %d.\n&quot;, answer)</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Go-Doc-Commentsドキュメントは必読"><a href="#Go-Doc-Commentsドキュメントは必読" class="headerlink" title="Go Doc Commentsドキュメントは必読"></a>Go Doc Commentsドキュメントは必読</h2><p>今回はメモリやGCに加えて、Doc Commentsのドキュメントが追加されました。上記のサンプルはここからの引用でした。</p><p>なお、このドキュメントは単に文法の書き方だけではなく、パッケージ、コマンド、型、関数、定数、変数といった要素へのドキュメントの書き方のベストプラクティスが前半の半分を占めています。</p><p>例えば、ゼロ値が目的を持っている場合は書け、とか関数の場合は名前付きの返り値との併用で読みやすくなるぞ、とか、並列実行でユーザーの期待と違う場合（型の場合はデフォルト並列不可、関数の場合は並列可能、というのが期待のライン）はきちんと明示的に説明しよう、とかですね。</p><p>この前半部分、Go特有の内容もありますが、JavaとかTypeScriptとか使っている人にも役立つと思うので、社内で勉強会をしているのであれば、軽くみんなで読む教材として取り上げてもよいかと思います。</p><p>また、最後にはよくある間違いについての説明もあります。</p><h1 id="その他のツールの更新"><a href="#その他のツールの更新" class="headerlink" title="その他のツールの更新"></a>その他のツールの更新</h1><p>その他気になる改善としては、コンパイラの更新がいくつかありました。</p><h2 id="unix-というbuild-constraintが追加"><a href="#unix-というbuild-constraintが追加" class="headerlink" title="unix というbuild constraintが追加"></a><code>unix</code> というbuild constraintが追加</h2><p>Go 1.17でsignal_unix.goは次のようなbuild constraintがついていました。</p><figure class="highlight go"><figcaption><span>os/signal/signal_unix.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build aix || darwin || dragonfly || freebsd || (js &amp;&amp; wasm) || linux || netbsd || openbsd || solaris || windows</span></span><br></pre></td></tr></table></figure><p>それがこんなにコンパクトになりますよっと。いいですね。</p><figure class="highlight go"><figcaption><span>os/signal/signal_unix.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build unix || (js &amp;&amp; wasm) || windows</span></span><br></pre></td></tr></table></figure><h2 id="コンパイラの改良でswitch文が高速化"><a href="#コンパイラの改良でswitch文が高速化" class="headerlink" title="コンパイラの改良でswitch文が高速化"></a>コンパイラの改良でswitch文が高速化</h2><p>数値と文字列を対象にジャンプテーブルを使うように改良されたため、20%ほど高速化されたとのことです。</p><h2 id="ELF環境でリンカーが圧縮形式のデバッグ情報を持つようになった"><a href="#ELF環境でリンカーが圧縮形式のデバッグ情報を持つようになった" class="headerlink" title="ELF環境でリンカーが圧縮形式のデバッグ情報を持つようになった"></a>ELF環境でリンカーが圧縮形式のデバッグ情報を持つようになった</h2><p>レガシーな.zdebugから、SHF_COMPRESSEDに変わったとのことでした。Hello Worldの短いプログラムを作ってサイズを比較してみました（M2 Air上でGOOS&#x3D;linux go build)。</p><div class="scroll"><table><thead><tr><th align="center">1.18</th><th align="center">1.19rc2</th></tr></thead><tbody><tr><td align="center">1799875</td><td align="center">1821715</td></tr></tbody></table></div><p>うーむ。増えてる？とはいえ、Mach-OなmacOSネイティブでやった場合はもうちょっと(70KB)増えていたので他の増加分が打ち消された、と考えれば良さそう。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Go/">Go</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88/">ドキュメント</category>
      
      <category domain="https://future-architect.github.io/tags/Go1-19/">Go1.19</category>
      
      <category domain="https://future-architect.github.io/tags/GoDoc/">GoDoc</category>
      
      
      <comments>https://future-architect.github.io/articles/20220801a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringBootで動的な条件をもとにDIしたい</title>
      <link>https://future-architect.github.io/articles/20220729a/</link>
      <guid>https://future-architect.github.io/articles/20220729a/</guid>
      <pubDate>Thu, 28 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;SpringBootのDependency</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>SpringBootのDependency Injection（DI）は便利ですよね？利用する側にコンストラクタインジェクションやら、フィールドインジェクションやらセッターインジェクションやらの形式で書いておくと、DIコンテナが勝手に実行時に対象となるクラスをもってきてインスタンスの生成をしてくれますし、インスタンスのライフサイクルをインジェクションされるクラス側に書けます。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDI</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseDI</span><span class="params">(MyService myService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DIコンテナがnewしてくれたよ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行時にDIしてくれるとはいっても、コンストラクタのパラメータとかクラスのフィールドはコンパイル前にソースコードにハードコードされてしまいます。本当に実行時に決まるような値をもとに動的に生成するクラスを変えたいという要件があったのでやり方を調べてみました。SpringBoot上だったので、汎用的な仕組みではなくてSpringBootの仕組みに乗っかるようにしています。</p><p>動的というのは、例えば、リクエストしてくるユーザーのランクを見て、VIPユーザー用ロジックを選択したい、みたいなストラテジーパターンです。ユーザーのランクの種類は動的に増えたりするのでハードコードしたくない、みたいな感じの要件だとします。</p><img src="/images/20220729a/名称未設定ファイル.drawio.png" alt="名称未設定ファイル.drawio.png" width="460" height="191" loading="lazy"><h1 id="まずはロジックの登録機構"><a href="#まずはロジックの登録機構" class="headerlink" title="まずはロジックの登録機構"></a>まずはロジックの登録機構</h1><p>やはりDIするにはアノテーションですよね。 <code>@UserRank</code>アノテーションを作ります。1つだけ引数を持つ単一値アノテーションとします。で、アノテーションの合成を使って、<code>@Component</code>もつけています。これは、このアノテーションをつけたら、即座にDI対象（別途<code>@Service</code>やら<code>@Component</code>やら<code>@Bean</code>をつける必要はない）とするためのものです。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/annotations/UserRank.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.annotations;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.TYPE,</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// ここに並べると合成となって、UserRankアノテーションをつけたものにComponentをつけたのと同じ効果も付与される</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserRank&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>String value()</code>のところが引数で、<code>value</code>という名前であれば、<code>@UserRank(&quot;VIP&quot;)</code>と書けますが、仮に<code>type</code>だと、<code>@UserRank(type=&quot;VIP&quot;)</code>とする必要があります。また、複数個パラメータをつけることも可能です。VIPになった勤続回数でも選択したいが、特別な場合以外は省略したい場合、<code>int streak() default 0;</code>みたいに<code>default</code>をつけると省略可能になります。</p><p>これで、ロジック側に動的にフィルタリングするためのアノテーションが作れました。</p><p>実際にはアノテーションを使わないでも、特定インタフェースを実装しているものとか、クラス名でなどの条件でコンポーネントは探せるのですが、やはりアノテーションのほうがアスペクト指向っぽい感じで、ロジックの中身と探索ルールを切り離して表現できるのでアノテーションにしています。</p><h1 id="動的に選択したいサービスクラスを実装する。"><a href="#動的に選択したいサービスクラスを実装する。" class="headerlink" title="動的に選択したいサービスクラスを実装する。"></a>動的に選択したいサービスクラスを実装する。</h1><p>まずは実装につけるインタフェースを作っておきます。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/UserService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実装を2つ作ります。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/services/VIPService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.annotations.UserRank;</span><br><span class="line"><span class="keyword">import</span> com.example.UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP用ロジック</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UserRank(&quot;VIP&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPService</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;VIP用ロジック&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VIP&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>src/main/java/com/example/services/GenericUserService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.annotations.UserRank;</span><br><span class="line"><span class="keyword">import</span> com.example.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一般用ロジック</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@UserRank(&quot;一般&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralUserService</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一般人用ロジック&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一般人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="コンポーネントをスキャンしてコンポーネントのマップを作る"><a href="#コンポーネントをスキャンしてコンポーネントのマップを作る" class="headerlink" title="コンポーネントをスキャンしてコンポーネントのマップを作る"></a>コンポーネントをスキャンしてコンポーネントのマップを作る</h1><p>ちょっと長いですが、コンポーネントのマップを作るクラスが以下の通りです。</p><p><code>ClassPathScanningCandidateComponentProvider</code>クラスを使うと特定のパッケージ以下のクラス群を取得できます。取得時には名前とかいろいろフィルタが設定できるのですが、ここでは<code>UserRank</code>というアノテーションがついているクラスを全取得しています。一度スキャンしたらその結果使いまわしたいので<code>static</code>な<code>Map</code>に入れています。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/UserServiceFactory.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AnnotationTypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.annoatations.UserRank;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ユーザーランクごとのサービスのマップをキャッシュし、必要に応じてインスタンスを作成する。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * コンポーネントスキャンするパッケージ。デフォルト値は与えているが、設定したい場合はmainでこれを呼ぶこと。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> String[] scanTargets = &#123;<span class="string">&quot;com.example&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * コンポーネントをスキャンするパッケージを設定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScanTarget</span><span class="params">(String[] packages)</span> &#123;</span><br><span class="line">scanTargets = packages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * プログラム中に含まれるすべてのサービスを集めたもの</span></span><br><span class="line"><span class="comment"> * 初期の取得時に初期化を行う</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; services = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * サービスのMapを作成する</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">initServiceMap</span><span class="params">()</span> &#123;</span><br><span class="line">services = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathScanningCandidateComponentProvider</span>(<span class="literal">false</span>);</span><br><span class="line">provider.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(UserService.class));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> scanTarget : scanTargets) &#123;</span><br><span class="line"><span class="type">var</span> <span class="variable">beanSet</span> <span class="operator">=</span> provider.findCandidateComponents(scanTarget);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> def : beanSet) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(def.getBeanClassName());</span><br><span class="line"><span class="type">var</span> <span class="variable">annotation</span> <span class="operator">=</span> (UserRank)clazz.getAnnotation(UserRank.class);</span><br><span class="line">services.put(annotation.value(), clazz);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// 取得した名前でクラスをその場で取り出しているだけなのでClass.forNameがこの例外を投げることはない見込み</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="インスタンス作成機構の追加"><a href="#インスタンス作成機構の追加" class="headerlink" title="インスタンス作成機構の追加"></a>インスタンス作成機構の追加</h1><p>インスタンス作成はSpringBootの提供するDIコンテナの機構を使います。そうすれば、サービスクラスが何かしらの外部依存を持っていてもそれのDIも一緒に行えます。</p><p>DIのファクトリーは<code>BeanFactory</code>を使うのですが、これ自身はDIでインジェクションしてもらえばOKです。クラスの定義は前のコードで取得できていますので、あとは名前をもとにクラスをもってきて、<code>beanFactory.getBean()</code>を呼んでインスタンス化するだけです。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/UserServiceFactory .java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line"><span class="comment">// インスタンス生成に使うファクトリー</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ランクをもとにサービスを取得する</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rank ランク</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UserService <span class="title function_">findService</span><span class="params">(String rank)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (services == <span class="literal">null</span>) &#123;</span><br><span class="line">initServiceMap(); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">var</span> <span class="variable">clazz</span> <span class="operator">=</span> services.get(rank);</span><br><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (UserService) beanFactory.getBean(clazz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使ってみる"><a href="#使ってみる" class="headerlink" title="使ってみる"></a>使ってみる</h1><p>それではコントローラに組み込んでみます。</p><figure class="highlight java"><figcaption><span>src/main/java/com/example/MyController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CookieValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserServiceFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyController</span><span class="params">(UserServiceFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory= factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doService</span><span class="params">(<span class="meta">@CookieValue(&quot;rank&quot;)</span> String rank)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">service</span> <span class="operator">=</span> factory.findService(rank); <span class="comment">// 名前でインスタンスを取得</span></span><br><span class="line">        <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;不正なランク&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service.execute();                <span class="comment">// ランクごとのロジック実行</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>はい。これで動的にインスタンスをとってきて実行するより動的なDIコンテナが実装できました。</p><h1 id="もっと簡単な実装もあるよ"><a href="#もっと簡単な実装もあるよ" class="headerlink" title="もっと簡単な実装もあるよ"></a>もっと簡単な実装もあるよ</h1><p><a href="https://twitter.com/ryushi">@ryushi</a>さんに<a href="https://www.baeldung.com/spring-dynamic-autowire">教えてもらった記事</a>ではもっと簡単なやり方が書いてありました。</p><p>SpringBootのDIコンテナに自身に、コンポーネントに文字列で名前をつけて、その文字列を使ってインスタンス化を行う機構があります。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;GBregionService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GBRegionService</span> <span class="keyword">implements</span> <span class="title class_">RegionService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このようにDIのためのアノテーションに文字列をつけてあげて、<code>getBean()</code>にその名前を渡すと絞り込みを行ってくれるというものです（ちょっとサンプルを短くなるように改変しています）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryDynamicAutowireService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_NAME_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;regionService&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactoryDynamicAutowireService</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isServerActive</span><span class="params">(String isoCountryCode, <span class="type">int</span> serverId)</span> &#123;</span><br><span class="line">        <span class="type">RegionService</span> <span class="variable">service</span> <span class="operator">=</span> beanFactory.getBean(isoCountryCode + SERVICE_NAME_SUFFIX,</span><br><span class="line">          RegionService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> service.isServerActive(serverId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初の実装も今回はサンプルのためにだいぶシンプル化していますが、要件としてはDI対象を探すロジックは本当はもうちょっと複雑で、マッチしなかったときのフォールバックとかもやろうと思っていたので、このシンプルな実装とは別の<code>ClassPathScanningCandidateComponentProvider</code>でとってきたクラスリストをMapに入れて、いろいろな検索が行えるような実装にしました。<br>シンプルな機構で特殊な検索条件を実現するためには、アノテーションに入れるリテラルの名前のルールを作り、それを実装者が守る必要がありますが、たんなる文字列リテラルで複雑なルールを作ってもコンパイル時のチェックとかも効かないので不親切かなという点がネックでした。独自アノテーション作成時に<code>@AliasFor</code>で親のアノテーションに値を渡すときにパラメータの加工とか合成とかいろいろコードが書ければ実現できそうでしたが、そういうのはできなそうでしたので。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>独立性の高いロジックをどかどか追加して、それを動的な条件をもとに選択して実行する、みたいなときに使える機構を作ってみました。</p><p>アノテーション単独での実装方法は調べるとすぐ出てきたのですが、その情報をもとにクラス一覧を取得してくるコード、またそのアノテーションの引数をもとにマップを作って、動的に選択してインスタンスを作るところなど、つなぎ合わせのサンプルは出てこなかったので、いろいろ調べながら書いてみました。</p><p>このようなロジックを実装したライブラリとかあるかもしれませんが、Javaのメタプログラミング的なところをいろいろ知れて楽しかったです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Java/">Java</category>
      
      <category domain="https://future-architect.github.io/tags/SpringBoot/">SpringBoot</category>
      
      <category domain="https://future-architect.github.io/tags/DI/">DI</category>
      
      
      <comments>https://future-architect.github.io/articles/20220729a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>デザイン思考におけるViabilityとFeasibilityの壁</title>
      <link>https://future-architect.github.io/articles/20220727a/</link>
      <guid>https://future-architect.github.io/articles/20220727a/</guid>
      <pubDate>Tue, 26 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;TIG</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DX-Unitのミンです。</p><p>DXアプローチ連載2本目として本記事では、デザインワークを用いたサービス設計・プロダクト設計をする際に考慮すべき3つの観点についてご紹介し、その文脈の中で<a href="/articles/20220706a/">フューチャーのデザインワーク</a>はどういう立ち位置にいるのかについて考えてみたいと思います。</p><h2 id="Desirability-Viability-Feasibility"><a href="#Desirability-Viability-Feasibility" class="headerlink" title="Desirability, Viability, Feasibility"></a>Desirability, Viability, Feasibility</h2><img src="/images/20220727a/スライド1.PNG" alt="" width="1200" height="675" loading="lazy"><p>デザイン思考は、Desirability（有用性）・Viability（持続可能性）・Feasibility（実現可能性）の3要素を全て満たすソリューションを生み出すことがゴールだと言われています<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p>ユーザのニーズに応え、ビジネス的に実行・持続可能で、技術的にも実現可能なサービス・プロダクトこそ、誰もが追求するアイデアの理想像だと言えるのではないでしょうか。逆に、常にこの３つの観点からアイデアを策定・検証してい行かないと、アイデア具現化の過程におけるコストや失敗のリスクを増加させることになってしまいます。</p><h3 id="1-Desirability（有用性）"><a href="#1-Desirability（有用性）" class="headerlink" title="1. Desirability（有用性）"></a>1. Desirability（有用性）</h3><img src="/images/20220727a/スライド2.PNG" alt="" width="1200" height="675" loading="lazy"><p>「ユーザに必要とされているサービス・商品なのか？」、「誰かの課題を解決しているのか？」、「他に良い既存商品やアイデアないのか？」等の質問に答えるのが最初の観点である「Desirability」（有用性）の役割です。</p><p>有用性のないサービス・商品は市場価値もなく、人々から求められないので、もちろん売れません。サービスデザイン・プロダクトデザインは「こんなものがあったらいいな」等のニーズや需要から始まることが多く、有用性の検証がデザインワークの起点になると言っても過言ではないでしょう。そのため、必然的にデザインプロセスの多くは、市場調査やユーザインタビュー等、UXデザインプロセスでいう「Understand」（理解）や「Empathize」（共感）のフェーズから行われます。</p><img src="/images/20220727a/image.png" alt="" width="555" height="365" loading="lazy"><blockquote><p>アボカドトーストをどこでもいつでも… どれぐらいニーズがあるのでしょうか？（個人的には欲しい）<br>出展：@UNNECESSARYINVENTIONS&#x2F;INSTAGRAM</p></blockquote><h3 id="2-Viability（持続可能性）"><a href="#2-Viability（持続可能性）" class="headerlink" title="2. Viability（持続可能性）"></a>2. Viability（持続可能性）</h3><img src="/images/20220727a/スライド3.PNG" alt="" width="1200" height="675" loading="lazy"><p>直訳すると「実行可能性」、少し捉え方を変えると「持続可能性」とも言える「Viability」は商品・サービスが問題なく展開でき、継続的に価値を提供できるかどうかを考察する観点です。</p><p>利益を確保できるビジネスモデルの設計や各ステークホルダーの理解を得る等、ビジネス観点からの短期的な考察はもちろん、「ターゲットユーザにとって現実的なプライシングになっているのか」、「社会・自然環境への負担はどれぐらいあるのか？」等、顧客や社会的評価の視点からも考えたうえで、長期的な持続可能性の確保が必要です。</p><img src="/images/20220727a/image_2.png" alt="" width="1200" height="358" loading="lazy"><blockquote><p>若い利用者のメンタルヘルスに悪影響を及ぼすと指摘されたInstagram… 持続可能なビジネスモデルか？<br>出展：ROYAL SOCIETY FOR PUBLIC HEALTH</p></blockquote><p>「ユーザのニーズには確実に応えられているけど、ビジネスとしてmake senseしてるんだっけ？」と、「Desirability」を担保した後、最初に直面する壁の一つだと言えるのではないでしょうか。</p><p>例えば、ユーザ観点から見るとどれも「お得にサービスを利用できる」クーポン、ポイントとロイヤリティの仕組みですが、ビジネス観点から見た場合、企業の状況・商品の性質によってどれを採用した方が新規ビジネスとしての「持続可能性」を確保できるかが変わってきます。</p><p>一般的に、クーポンやポイント還元は新規顧客獲得に効果的と言われていますが、商品が安く見えてしまうデメリットがあります。クーポンやポイント還元の販促手段を使えば短期間での新規顧客獲得、売上増加を実現できるかもしれませんが、その商品・サービスの売りがブランド・高級感だった場合、もしかしたらロイヤリティの仕組みでより優越感を得ることができるインセンティブ（例えばヘビーユーザーだけに案内される特別なサービスを受けられる等）を提供した方が長期的な「持続可能性」に繋がるかもしれません。</p><h3 id="3-Feasibility（実現可能性）"><a href="#3-Feasibility（実現可能性）" class="headerlink" title="3. Feasibility（実現可能性）"></a>3. Feasibility（実現可能性）</h3><img src="/images/20220727a/スライド4.PNG" alt="" width="1200" height="675" loading="lazy"><p>最後の観点である、「Feasibility」はアイデアを実現するためのリソース・技術が十分であるかを確認するための「実現可能性」です。</p><p>「ビジネスアイデアを形にするための技術は存在するか」、「開発するための人材が揃っているか」、「開発技術にかかるコストはどの程度か」等、アイデア具現化の段階で明らかにしないといけない技術的な課題は多くあります。デザインプロセス開始直後は、技術的な制約に囚われすぎずに、アイデアを発散させることは重要です。その一方で、後続のステップで発生するリスクとコストをミニマムに抑えるには、早い段階からアイデアの実現可能性を把握することは不可欠だと言えます。</p><img src="/images/20220727a/image_3.png" alt="" width="1200" height="600" loading="lazy"><blockquote><p>瞬間移動、実現したいですね<br>出展：COKADA&#x2F;GETTY IMAGES</p></blockquote><p>筆者の経験上、多くのコンシューマー向けのビジネスアイデアは、瞬間移動等SF的な技術さえ要しなければ、理論上大抵は実現可能です・・・お金と時間が無限にあれば。そのため、殆どの場合、デザイン段階での「実現可能性」に関する問は、「物理的に実現できるのか？」というピュアな意味合いよりも、「実現するにはどのぐらいコストがかかるのか？」や「費用対効果はどの程度なのか？」等、Viabilityへの影響に絡んだ側面の方が強いと感じます。</p><p>例えば、「ガソリンスタンドでの決済が手間」というペインポイントに対して、「生体認証を用いた決済方法」というソリューションを提案した場合、「実現可能か？」と言われたら、それはもちろん技術的には実現可能です。</p><p>しかし、それよりも「生体認証を導入するためのコストはどれぐらいか？」、「スタンドの既存システム、ユーザの既存アプリを活用した場合リリースを早めることはできるか？」等の問を起点に検証した方が、「生体認証」が「決済の手間」に対しての最適なアイデアかどうか、見極めやすいでしょう。</p><h2 id="ViabilityとFeasibilityの壁"><a href="#ViabilityとFeasibilityの壁" class="headerlink" title="ViabilityとFeasibilityの壁"></a>ViabilityとFeasibilityの壁</h2><img src="/images/20220727a/スライド5.PNG" alt="" width="1200" height="675" loading="lazy"><p>前段で申し上げた通り、サービス設計の前半はUXデザインプロセス等を通して「<a href="#1-desirability%E6%9C%89%E7%94%A8%E6%80%A7">Desirability</a>」（有用性）を担保できることが多いと思います。ただ、プロジェクトが後半に進むにあたり、「<a href="#2-viability%E6%8C%81%E7%B6%9A%E5%8F%AF%E8%83%BD%E6%80%A7">Viability</a>」（持続可能性）と「<a href="#3-feasibility%E5%AE%9F%E7%8F%BE%E5%8F%AF%E8%83%BD%E6%80%A7">Feasibility</a>」（実現可能性）の確保に苦しまれるチーム・企業は少なくないのでは。</p><p>それもそのはずで、「<a href="#1-desirability%E6%9C%89%E7%94%A8%E6%80%A7">Desirability</a>」の検証はその企業が既存で持っている業界の知見やユーザ基盤があれば、ある程度推進できます。しかし、「<a href="#3-feasibility%E5%AE%9F%E7%8F%BE%E5%8F%AF%E8%83%BD%E6%80%A7">Feasibility</a>」を策定・検証するためのノウハウや、アイデアを実現するための人材・技術力は誰もが持っているわけではありません。そして、「<a href="#3-feasibility%E5%AE%9F%E7%8F%BE%E5%8F%AF%E8%83%BD%E6%80%A7">Feasibility</a>」を確認できなければもちろん、アイデアの実現性・説得性は下がり、「<a href="#2-viability%E6%8C%81%E7%B6%9A%E5%8F%AF%E8%83%BD%E6%80%A7">Viability</a>」の検証と確保も困難になります。</p><p>実際に、筆者が過去一年間で携わったデザインワークプロジェクトの内、凡そ半数が「Desirabilityは自社で確保したが、先に進められない」状態でお客さまからご相談を受けました。</p><h2 id="フューチャーが実施するデザインワークの強み"><a href="#フューチャーが実施するデザインワークの強み" class="headerlink" title="フューチャーが実施するデザインワークの強み"></a>フューチャーが実施するデザインワークの強み</h2><p>フューチャーでは「一気通貫」という言葉が提案の場だけではなく、社内の会話でも良く飛び交います。<br>筆者自身、あまりこの言葉を安易に使わないようにしていますが、デザインワークの段階でビジネスとアーキテクチャ両軸でのアプローチができることこそ、グランドデザインからシステム設計・開発・運用保守までできるフューチャーが実施するデザインワークの最大の強みだと言えます。</p><h3 id="技術のバックボーンによる実現性の高いビジネス設計"><a href="#技術のバックボーンによる実現性の高いビジネス設計" class="headerlink" title="技術のバックボーンによる実現性の高いビジネス設計"></a>技術のバックボーンによる実現性の高いビジネス設計</h3><p>フューチャーのデザインワークは、ユーザが触れる表面的な部分だけではなくシステム全体の根幹であるアーキテクチャまで策定しながら進めるため、UXデザインの各過程で実現性に意識を配りながら創出したアイデアの具現化ができます。また、フューチャーは技術的チャレンジに対するフットワークが軽く、必要に応じて技術検証を通して実現可能性を高められます。</p><p>この技術のバックボーンにより、実現性の担保されたサービス設計が可能になり、リスクをミニマムに抑えることができるというのが一つ大きなポイントだと考えます。</p><h3 id="システム導入までに持っていけるスピード感"><a href="#システム導入までに持っていけるスピード感" class="headerlink" title="システム導入までに持っていけるスピード感"></a>システム導入までに持っていけるスピード感</h3><p>筆者が参加したデザインワークプロジェクトの殆どは、単にビジネスのビジョンを構想するだけではなく、実際に同時並行してアーキテクチャ（非機能・機能）も考えて進めます。</p><p>既存システム（基幹システムや周辺システム）の把握と活用も考慮し、全体最適の観点でデザインワークを推進するため、ビジネス検討からシステム導入へと移るコストと時間を抑えることができます。</p><h3 id="サービスを立ち上げて終わりではなく、中長期的観点での支援"><a href="#サービスを立ち上げて終わりではなく、中長期的観点での支援" class="headerlink" title="サービスを立ち上げて終わりではなく、中長期的観点での支援"></a>サービスを立ち上げて終わりではなく、中長期的観点での支援</h3><p>デザインワークのスタートラインからお客さまと同じ船に乗り、保守運用を見据えたサービス設計ができるのも、一気通貫だからこそできるフューチャーの強みの一つだと思います。</p><p>サービス策定の時点からサービス開始後に必要な観点の考慮と洗い出しを実施し、サービス開始後も必要に応じてサービス・システムの維持・拡大を支援していきます。</p><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>筆者が実際に携わった案件の中では、自分たちでサービス設計したけどなかなか具体化まで行けなかったり、他社のコンサルファームさんにサービス計画を立ててもらったがなかなか「システム化・サービス展開に繋げられない」、「社内のステークホルダーと合意が取れない」等の理由でフューチャーに相談いただいて始まった案件が数多くあります。これこそ、前段で申し上げた「ViabilityとFeasibilityの壁」を乗り越える難しさの証だと考えます。</p><p>そういった経験からも、「技術的な知見を活かしながら地に足の着いたサービス設計ができ、スムーズにシステム構築に移っていける」、これが0から1を構想し、1から10に仕組みを作り上げることができるフューチャーが実施するデザインワークの強みだと言えます。</p><p>最後になりますが、当社が運営するポッドキャストでもデザインワークについてトークさせていただきました。</p><p>具体的なプロセスや事例についてもざっくばらんに話しているので興味のある方は是非！</p><p>Future Tech Cast<br>#26 【DXアプローチ】デザインワークって何?</p><ul><li><a href="https://open.spotify.com/episode/3jSrMzDmviOanNXWdJUTZl?si=FrxB4p5NTZiUsApn80ZnkA">前編（Spotify）</a></li><li><a href="https://open.spotify.com/episode/3nNafUcBkKLR9UAHVeHAdB?si=94PzEa9vQpmfobGtMQLntQ">後編（Spotify）</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;"><a href="https://www.ideou.com/pages/design-thinking">https://www.ideou.com/pages/design-thinking</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Business/">Business</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9/">ビジネス</category>
      
      <category domain="https://future-architect.github.io/tags/UX/">UX</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%AF%E3%83%BC%E3%82%AF/">デザインワーク</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E6%80%9D%E8%80%83/">デザイン思考</category>
      
      
      <comments>https://future-architect.github.io/articles/20220727a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Plus Codeについて調べた</title>
      <link>https://future-architect.github.io/articles/20220726a/</link>
      <guid>https://future-architect.github.io/articles/20220726a/</guid>
      <pubDate>Mon, 25 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p><a href="/articles/20220719a/">地図・GIS・位置特定テーマの連載</a>の最後となる6本目です。</p><p>TIG真野です。緯度・経度をコード化する技術に興味があったのでOpen Location Code（Plus Code）について調べました。<a href="/articles/20220721a/">澁川さんのRedis記事</a>にもあったGeoHashのように、位置を特定するようなコード化はなぜかワクワクします。</p><h2 id="Open-Location-Code（Plus-Codes）とは"><a href="#Open-Location-Code（Plus-Codes）とは" class="headerlink" title="Open Location Code（Plus Codes）とは"></a>Open Location Code（Plus Codes）とは</h2><p>Google Mapのヘルプが簡易的でわかりやすかったため引用します。</p><blockquote><p>plus code は、番地と同じように使えるコードです。住所代わりの簡略なコードとして使用できるほか、通常の住所だけでは絞り込めない具体的な地点の指定にも役立ちます。<br>たとえば同じ建物に入口が複数ある場合に、plus code を使えば入口も含めて指定できます。<br>plus code は緯度と経度に基づいています。シンプルなグリッド方式のコードで、20 種類の英数字（混同しやすい「1」と「I」などをあらかじめ除外したもの）の組み合わせで表現されます。</p></blockquote><p>Google Mapを開くと出てくる、<code>JPCG+XX 品川区、東京都</code> コードのことです（図はフューチャーの本社がある大崎アートヴィレッジタワー）の位置情報です。Google Map上で表示・及び検索で使えるのは便利です。</p><img src="/images/20220726a/image.png" alt="image.png" width="1200" height="761" loading="lazy"><p>Open Location Codeは<a href="https://github.com/google/open-location-code">google&#x2F;open-location-code</a>で実装も<a href="https://github.com/google/open-location-code/blob/main/docs/specification.md">仕様</a>もApache License 2.0で公開されています。変換はこれらの実装を用いればオフラインで可能です。</p><p>2015年にリリースされたようです。</p><ul><li><a href="https://internet.watch.impress.co.jp/docs/column/chizu/720142.html">【地図ウォッチ】 Google、地球上の場所をピンポイントで示すコード「OLC」を生成できるサイト「plus+codes」公開 - INTERNET Watch</a></li><li><a href="https://japan.cnet.com/article/35068908/">グーグル、地球上のあらゆる地点をコード化する「plus+codes」リリース - CNET Japan</a></li></ul><p>公式ページは<a href="https://maps.google.com/pluscodes/">Plus Codes</a> です。Plus Codeを生成する仕組みがOpen Location Code（OLC）で、ロケーションコードを生成するオープンな仕組みのためこの名前になったそうです。そもそも、なんでPlus Codeかというと、生成されるコードにプラス記号が含まれているためだそうです（なるほど！）。</p><h2 id="なぜ生まれたか"><a href="#なぜ生まれたか" class="headerlink" title="なぜ生まれたか"></a>なぜ生まれたか</h2><p><a href="https://maps.google.com/pluscodes/learn/">公式のLearnタブ</a>にどういう用途で使われることを想定しているかが短くまとめてくれています。</p><ul><li>個人用途: 通りの名前や通りがない場合でも、自宅、店舗、待ち合わせ場所など、あらゆる場所を共有できる</li><li>企業: 顧客が店舗を探しやすく、また商品を配達する場合に通りの名前や番号がなくても場所を得的できる<ul><li>正確な集荷・降車場所を取得する</li></ul></li><li>救急: 救助活動を迅速化する</li><li>政府: どこにすんでいても、郵便・社会扶助・投票などの市民サービスを提供できるように</li><li>NGO: 人道的・災害救援を提供し、地図データが不完全な地域を支援する。サービスの記録管理と追跡を改善する</li></ul><p>読めば分かる通り、どちらかと言えば通りに名前がないとか災害時にも活用できるような意図が感じられます。</p><p>気になったので、<a href="https://github.com/google/open-location-code/wiki/Evaluation-of-Location-Encoding-Systems">Evaluation-of-Location-Encoding-Systems</a>を読んでみるとまさにそのような意図が最初に書いてあります。</p><ul><li>世界の多くの地域・世界都市人口の半分以上が住所が無い（出典が2005年世界銀行の<a href="https://www.citiesalliance.org/sites/default/files/CA_Images/Street_Addressing_Manual.pdf">Street Addressing and the Management of Cities</a>だったので改善していると思いたいですが..）<ul><li>都市部でも多くの道路に名前が無いため、それらの道路沿いの場所には住所が無い（！）<ul><li>住所にStreet Addressが出てくる、文化の違いを感じる説明だなと感じますね</li></ul></li></ul></li><li>スマートフォンの価格の下落と普及により、GPSを落ちいてアドレスとして利用できるソリューションが求められる</li><li>要求事項（抜粋）<ul><li>コードは短く覚えられるように</li><li>コードにはなるべくどの言語の単語も含めない</li><li>2つのコードを見て、近いか遠いか、方向も判断したい</li><li>オフラインでエンコード&#x2F;デコードができる（モバイル通信が発生すると安価ではない）</li><li>アルゴリズムは公開され自由に使える。1つのプロバイダーに依存しない</li></ul></li></ul><h3 id="緯度・経度じゃダメなのか？"><a href="#緯度・経度じゃダメなのか？" class="headerlink" title="緯度・経度じゃダメなのか？"></a>緯度・経度じゃダメなのか？</h3><p>この手のソリューションでたまに思う、（GeoHashのように文字列プレフィックスで検索するのではないなら）緯度・経度を生で共有すればよいじゃないか？に関しても記載がありました。まとめます。</p><ul><li>緯度・経度は順序が重要で逆にすると異なる場所を示す</li><li>約10m精度で表現すると、15〜20文字のテキスト文字（「0.39122,9.45225」〜「-43.95134、-176.55053」）が必要。一般的な電話番号の約2倍の長さ</li><li>緯度・経度はポイント（点）を示すので、公園といった領域を示すのには不適。　緯度・経度の精度を切り捨て≒場所の移動 である</li></ul><p>極論、自分の住所を町名・番地とかじゃなくて緯度経度で覚えているの？って言われた気持ちになりました。確かに覚えられないですし扱いにくいですね。</p><h3 id="GeoHashじゃダメなのか？"><a href="#GeoHashじゃダメなのか？" class="headerlink" title="GeoHashじゃダメなのか？"></a>GeoHashじゃダメなのか？</h3><p>同様にGeoHashとの相違点についても触れていました。</p><ul><li>GeoHashはA, I, L, Oを除く0-9A-Zの32文字を利用するため、アルファベットのO,Iに似た数値の0,1を利用できてしまう</li><li>単語（例として”DRUGGED”）とか、ほぼ単語に見える（”ZUR1CH”）などが生成されてしまう<ul><li>（筆者補足）システム的に内部で検索キーとして持つのであればこの特性は全く問題ないですが、エンドユーザーに住所として利用可能とする（露出させる）前提では問題あるということです</li></ul></li><li>経度180、経度0、赤道、および北極と南極で5つの不連続性（近くの場所に異なるジオハッシュコードがある場所）が出てくる。赤道と経度0は人口密集地帯があり許容できない</li><li>たとえば、「c216ne4」と「c216new」（およびその他）は同じ座標（45.37 -121.7）にデコードされるといったことができる</li></ul><p>他にも要求事項に沿った既存サービス・規格がなかったため生まれたと書かれています。</p><h2 id="コード体系"><a href="#コード体系" class="headerlink" title="コード体系"></a>コード体系</h2><p>さきほど見せたPlus Codeは <code>JPCG+XX 品川区、東京都</code> でしたが、これがどのようなルールで構成されるか見ていきましょう。</p><ul><li>利用可能な文字は20<ul><li>すでに共有済みですが数字0,1,2,5と似ているアルファベットO,I,Z,Sは利用しない。単語の利用頻度が高いA, B, D, E, K, L, N, T, U, Yも利用しない）</li><li>23456789CFGHJMPQRVWX</li><li>ドキュメントにもよく書かれていますが、W9とWCは隣接するという、わかりにくさがあります</li></ul></li><li>桁数<ul><li>最小2桁～最大15桁</li><li>デフォルト10桁</li><li>10桁未満では、偶数のみが有効</li></ul></li><li>書式<ul><li>区切り文字の「+」は8桁の後に挿入する</li></ul></li><li>精度<ul><li>プラスコードの精度は、「+」記号の後の桁数で表現される<ul><li>プラス記号の後の2桁: およそ13.7x13.7メートルの領域</li><li>プラス記号の後の3桁: 約2.7x3.5メートルの領域</li><li>プラス記号の後の4桁: 約0.5x0.8メートルの領域</li></ul></li><li>細かい精度表は<a href="https://github.com/google/open-location-code/blob/main/docs/specification.md#code-precision">こちら</a></li></ul></li></ul><p><code>JPCG+XX 品川区、東京都</code>が、「+」が挿入されるオフセット位置が異なるとか、後ろの <code>品川区、東京都</code> って何って思われた方も多いかと思います。</p><p>じつはPlus Codeには <strong>ショートコード</strong> と呼ばれる省略版が存在します。省略しないものはオープンロケーションコードと呼ばれます。</p><ul><li>ショートコード<ul><li>現在の位置（GPSなどから取得）を基準にして、最も近い位置にある場所を特定する</li><li>例えば、 <code>CG+XX</code> という略称も可能です</li><li>現在位置の代わりに、 <code>品川区、東京都</code> といった都市名を入れることもできます</li><li>ローカルコードとも呼ばれます</li></ul></li><li>オープンロケーションコード<ul><li>先程のショートコードなプラスコードを、オープンロケーションコードにすると<a href="https://plus.codes/8Q7XJPCG+XX">8Q7XJPCG+XX</a>です</li><li>グローバルコードとも呼ばれます</li><li>ためしに、 <code>JPCG+XX ギリシャ</code> などとすると、山の中？が特定されます</li></ul></li></ul><img src="/images/20220726a/image_2.png" alt="image.png" width="1200" height="751" loading="lazy"><h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><p>オフラインでも使えるライブリが公開されていますが、まずplus.codes のWeb APIを使ってみます。<br><a href="https://github.com/google/open-location-code/wiki/Plus-codes-API">ドキュメント</a>から、Google APIキーなしだと以下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://plus.codes/api?address=35.62253406128506,139.72745939860533&amp;email=YOUR_EMAIL_HERE</span><br><span class="line">https://plus.codes/api?address=8Q7XJPCG%2BXX&amp;email=YOUR_EMAIL_HERE</span><br></pre></td></tr></table></figure><p>どちらも以下のようなJSONを取得できます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;plus_code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;global_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8Q7XJPFG+2X&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;northeast&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">35.622624999999985</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;lng&quot;</span><span class="punctuation">:</span> <span class="number">139.72749999999996</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;southwest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">35.62249999999999</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;lng&quot;</span><span class="punctuation">:</span> <span class="number">139.72737499999994</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">35.62256249999999</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lng&quot;</span><span class="punctuation">:</span> <span class="number">139.72743749999995</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>boundsのnortheast, southwestは書いているママですが、北東と南西の座標です。locationはその中心を提供座標です。Google APIキーを用いればlocalityの部分に論理的な住所情報も取得できますし、ショートコードでの変換もできるようです。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;locality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shinagawa, Tokyo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="Go-SDK"><a href="#Go-SDK" class="headerlink" title="Go SDK"></a>Go SDK</h2><p>主要な言語のライブラリは揃っています（PL&#x2F;SQLまである）。せっかくなのでGoで遊んでみます。</p><ul><li><a href="https://github.com/google/open-location-code">https://github.com/google/open-location-code</a></li><li><a href="https://pkg.go.dev/github.com/google/open-location-code/go">https://pkg.go.dev/github.com/google/open-location-code/go</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/open-location-code/go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 緯度経度 -&gt; OLC</span></span><br><span class="line">locationCD := olc.Encode(<span class="number">35.622375</span>, <span class="number">139.727375</span>, <span class="number">10</span>) <span class="comment">//緯度(float64),経度(float64),OLCの桁数(int)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;緯度経度-&gt;ロケーションコード: %s\n&quot;</span>, locationCD)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OLC -&gt; 緯度経度</span></span><br><span class="line">area, err := olc.Decode(<span class="string">&quot;8Q7XJPCG+XX&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ロケーションコード-&gt;緯度経度: %v\n&quot;</span>, area)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横浜駅の緯度経度を指定して、ショートコード　-&gt; ロケーションコードの復元</span></span><br><span class="line">nearest, err := olc.RecoverNearest(<span class="string">&quot;JPCG+XX&quot;</span>, <span class="number">35.466260702365226</span>, <span class="number">139.62208345627434</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ショートコード-&gt;ロケーションコード: %s\n&quot;</span>, nearest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横浜駅の緯度経度を指定して、ロケーションコード -&gt; ショートコード</span></span><br><span class="line">shorten, err := olc.Shorten(<span class="string">&quot;8Q7XJPCG+XX&quot;</span>, <span class="number">35.466260702365226</span>, <span class="number">139.62208345627434</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// エラーハンドリング</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ロケーションコード-&gt;ショートコード: %s\n&quot;</span>, shorten)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>実行結果です。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;go run main.go</span><br><span class="line">緯度経度-&gt;ロケーションコード: 8Q7XJPCG+XX</span><br><span class="line">ロケーションコード-&gt;緯度経度: &#123;35.622375 139.727375 35.6225 139.7275 10&#125;</span><br><span class="line">ショートコード-&gt;ロケーションコード: 8Q7XJPCG+XX</span><br><span class="line">ロケーションコード-&gt;ショートコード: JPCG+XX</span><br></pre></td></tr></table></figure><p>ショートコードの場合は、「品川区、東京」の代わりに、現在位置を示した緯度経度を指定すると、近隣のコードを探してくれるのが便利だなと思いました。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Plus Codeとは何か、どういう意図で作られたかについてまとめました。調べるまではGeoHash（やQuadKey）との違いはなんだろうか？と疑問でしたが、背景を抑えていくと使い分けも分かってくると思います。GoのSDKも中身の実装までは軽くしか見れていませんが、コア部分はコンパクトに見えます。少なくてもSDKのAPIを見てみると、どこまでがアルゴリズムで、どこからはGoogle Map APIのジオコーディングで行われているかイメージが湧きます。</p><p>最後まで読んでいただきありがとうございました。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E4%BD%8D%E7%BD%AE%E7%89%B9%E5%AE%9A/">位置特定</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%9C%B0%E5%9B%B3/">地図</category>
      
      <category domain="https://future-architect.github.io/tags/GoogleMap/">GoogleMap</category>
      
      <category domain="https://future-architect.github.io/tags/PlusCode/">PlusCode</category>
      
      
      <comments>https://future-architect.github.io/articles/20220726a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Bluetoothで位置推定</title>
      <link>https://future-architect.github.io/articles/20220725a/</link>
      <guid>https://future-architect.github.io/articles/20220725a/</guid>
      <pubDate>Sun, 24 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h1&gt;&lt;p&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p><a href="/articles/20220719a/">地図・GIS・位置特定に関する連載</a>の6日目のエントリーです。<br>マイコンとか電子工作などIoT関連が好きで、Bluetooth信号を使った位置推定手法について調査したことがあったので、紹介します。</p><h1 id="Bluetoothとは"><a href="#Bluetoothとは" class="headerlink" title="Bluetoothとは"></a>Bluetoothとは</h1><p>数メートルから長いものでは数十メートル程度の距離の情報機器間で、電波を使いながら簡易な情報のやりとりを行うのに使用されます。<br>身近な例だと、</p><ul><li>イヤホン</li><li>マウス</li><li>キーボード</li><li>…etc.</li></ul><p>などはBluetooth信号で音の情報やキー・マウスが押された情報を伝えることで操作が行えるようになります。<br>近年では<a href="https://ja.wikipedia.org/wiki/Bluetooth_Low_Energy">BLE（Bluetooth Low Energy）</a>が主流になってきています。</p><h2 id="RSSI"><a href="#RSSI" class="headerlink" title="RSSI"></a>RSSI</h2><p>信号の強さを表す値として、RSSI（Received Signal Strength Indicator）が使われます。<br>大きいほど信号強度が強く、小さいほど信号強度が弱い状態を表します。<br>そして、発信源から距離が近いほど信号強度が強く、離れるにつれて段々と強度が弱くなっていきます。<br>つまり、このRSSIの値を使えばざっくりと位置推定ができるわけです。</p><h1 id="位置推定"><a href="#位置推定" class="headerlink" title="位置推定"></a>位置推定</h1><p>Bluetoothを使った位置推定では、主にビーコンを配置することで行います。<br>ビーコンはただひたすら、Bluetooth信号を発信し続けます。電池持ちの良いものだと数年持つそうです。</p><h2 id="ビーコン1つだけを使った位置推定"><a href="#ビーコン1つだけを使った位置推定" class="headerlink" title="ビーコン1つだけを使った位置推定"></a>ビーコン1つだけを使った位置推定</h2><p>まずは、ビーコンを1つだけ使った場合の位置推定手法です。<br><a href="https://qiita.com/shu223/items/7c4e87c47eca65724305">こちらの記事</a>で詳しく紹介されていますが、<code>ビーコン自体が発するBluetoothの強度TxPower</code>と<code>RSSI</code>の値の関係から位置を計算することができます。<br>ここでは、自由空間では受信信号強度は距離の二乗に反比例するという関係が使われます。<br>ただ記事内でも仰られている通り、実空間では床から反射したり、機器間に人間が居たり、完全な自由空間とは程遠いもので正確な距離を出すことはできません。<br>また、ビーコン一つだけだと、同心円上では図のように等しく<code>距離d</code>なので方向まではわかりません。<br><img src="/images/20220725a/8094da77-f209-e092-608f-42bcd0f26b49.png" alt="" width="483" height="543" loading="lazy"></p><p>こんなの使えないじゃん！ってなるところですが、実際は近くにいるかどうかわかれば良いという用途もあります。<br>例えば、ある商品棚の近くに来たときにプッシュ通知したり、ある店の前に通りかかったときにプッシュ通知してお得な情報をお知らせすることができます。<br><img src="/images/20220725a/9038109f-b428-09a6-1af6-36dd63e300fe.png" alt="" width="711" height="644" loading="lazy"></p><p>これを利用したものとして、<a href="https://developers.line.biz/ja/docs/messaging-api/using-beacons/">LINEビーコン</a>があります。<br>LINEビーコンで近くの人を検知、LINEでプッシュ通知という組み合わせです。<br>ちなみに<a href="https://qiita.com/mochan_tk/items/95573e99399d00e62409">こちらの記事</a>を参考に、ESP32を使ってLINEビーコンを作る事ができます。<br>また、<a href="https://developers.line.biz/ja/">LINE Developers</a>からLINEbotと組み合わせて、プッシュ通知を簡単に試すことが可能です。</p><h2 id="ビーコンを3つ以上使った位置推定"><a href="#ビーコンを3つ以上使った位置推定" class="headerlink" title="ビーコンを3つ以上使った位置推定"></a>ビーコンを3つ以上使った位置推定</h2><p>次に、ビーコンを複数使った位置推定手法になります。<br>ビーコン1つの場合でも距離はざっくりとわかりましたが、方向がわかりませんでした。これを解決するために3つ以上のビーコンを使う事で方向まで推定します。<br><img src="/images/20220725a/b5cf85ae-e7b1-4586-d814-126511066f71.png" alt="" width="640" height="672" loading="lazy"></p><p>図のように各ビーコンの位置は固定で、それぞれのビーコンには個別の識別番号を振っておくことで各ビーコンからの距離がわかります。<br>この時どこか<strong>基準点</strong>を決めて、その位置から各ビーコンの位置がどれだけ<code>x</code>方向と<code>y</code>方向に離れているか記録しておく必要があります。<br>それぞれの<code>x</code>、<code>y</code>座標を使って円の方程式を立て（距離<code>d1</code>、<code>d2</code>、<code>d3</code>が円の半径）、その連立方程式を解くことで交点を計算し、<strong>基準点</strong>に対する相対的な位置を推測できます。<br>これで距離も位置も決まった！と思いきや、Bluetoothは様々な干渉を受けるため<code>距離d</code>がざっくりとした値になり、連立方程式が解けずに位置が求まらないことが多発します。</p><h2 id="ビーコンを複数と機械学習を使った位置推定"><a href="#ビーコンを複数と機械学習を使った位置推定" class="headerlink" title="ビーコンを複数と機械学習を使った位置推定"></a>ビーコンを複数と機械学習を使った位置推定</h2><p>最後に、ビーコンを複数と機械学習を使った位置推定手法を紹介します。<br>簡潔に手法言うと、クラス分類モデルで位置を推定していきます。<strong>但し、このやり方だと正確な距離は推定することができません。</strong></p><h3 id="①推定したい場所をグリッドで区切る"><a href="#①推定したい場所をグリッドで区切る" class="headerlink" title="①推定したい場所をグリッドで区切る"></a>①推定したい場所をグリッドで区切る</h3><img src="/images/20220725a/34ef68e6-ac85-f74f-84e3-f12a3c048475.png" alt="" width="451" height="487" loading="lazy"><p>図のように部屋をグリッドで区切って番号を振ります。グリッド番号が位置を示します。<br>また、このグリッド番号をクラスとして分類モデルに学習させていきます。</p><h3 id="②ビーコンを配置する"><a href="#②ビーコンを配置する" class="headerlink" title="②ビーコンを配置する"></a>②ビーコンを配置する</h3><img src="/images/20220725a/6e20b812-7b5c-51df-6e1f-e008db678691.png" alt="" width="454" height="484" loading="lazy"><p>これはどの手法でも同じですが、Bluetooth信号を発するビーコンに固定の番号を振ってそれぞれ配置します。<br>配置位置は特に決まっていませんが、部屋に満遍なく配置したほうがいいでしょう。<br>またこの例だと各部屋1つの計4つですが、グリッドが大きい場合はもっとたくさんビーコンを置いて、部屋のどの位置にいてもBluetooth信号を捕まえられるようにしたほうがより正確な推定ができます。</p><h3 id="③各グリッドでBluetoothのRSSIを収集し、機械学習モデルを学習させる"><a href="#③各グリッドでBluetoothのRSSIを収集し、機械学習モデルを学習させる" class="headerlink" title="③各グリッドでBluetoothのRSSIを収集し、機械学習モデルを学習させる"></a>③各グリッドでBluetoothのRSSIを収集し、機械学習モデルを学習させる</h3><img src="/images/20220725a/d1acd8bc-3ac5-4d85-d865-9c4366dae2b4.png" alt="" width="805" height="564" loading="lazy"><p><strong>※図の吹き出しに記載している値はRSSIの大きさ</strong><br>各グリッドの位置でそれぞれのビーコンから送られてくるRSSIの値を収集します。<br>収集したRSSIの値をグリッド番号推定用の機械学習モデルの学習データとして使うので、なるべく多めに収集しておいたほうが良いです。</p><p>そして、収集したRSSIの値に対するグリッド番号（位置）をモデルに学習させます。<br>機械学習モデルでは収集したRSSIの値を元にグリッド番号をクラス分類するように学習していきます。</p><h3 id="④位置推定する"><a href="#④位置推定する" class="headerlink" title="④位置推定する"></a>④位置推定する</h3><img src="/images/20220725a/b11df6af-4e01-f552-67d1-1c6e15327790.png" alt="" width="808" height="593" loading="lazy"><p>学習させたモデルを使って現在のRSSI値からグリッド番号を推定することで位置がわかります。<br>推定された位置はDBに格納するなりして、アプリケーションにて可視化することでユーザーの現在位置が把握できます。</p><p>ただ、新しいグリッドができた場合やビーコンを新たに追加した場合、学習データを収集し直す必要があります。<br>また、グリッドが多いと学習データの収集が非常に大変です。</p><h1 id="おまけ"><a href="#おまけ" class="headerlink" title="おまけ"></a>おまけ</h1><h2 id="v-s-GPS"><a href="#v-s-GPS" class="headerlink" title="v.s. GPS"></a>v.s. GPS</h2><p>無線通信を使った位置推定手法にはGPS（Global Positioning System）、全地球測位システムも存在します。<br>GPSは上空にある複数の衛星（3個以上は必須）から信号を受け取り、現在位置を知ることができるシステムです。こちらも身近な位置推定手法で、</p><ul><li>スマホ</li><li>カーナビ</li></ul><p>などに搭載されています。<br>GPS自体の入手は比較的容易で、<a href="https://www.switch-science.com/catalog/list/?keyword=GPS">Switch Sicense</a>さんでも受信機自体を多数見つけることができます。<br>結構簡単に使うことができ、井上さんの過去記事<a href="/articles/20220406a/">プロトタイピングの勧め</a>の中でもGPSユニットが使われています。</p><p>Bluetoothと比較した利点・欠点としては、</p><ul><li>広域で見るとかなり精度が良く、位置情報が安定している</li><li>信号の発信機を設置する必要がない</li><li>遮蔽物に弱い</li></ul><p>が挙げられます。屋外で使う分には力を発揮しますが、3個以上の信号を受信する必要があるため、遮蔽物があると信号を受信できずに位置を測位できません。</p><p>そのため、ある商品棚の近くや、ある部屋に居るなどの狭い範囲の位置推定や屋内だとBluetoothの方に分があります。</p><h2 id="v-s-タグ"><a href="#v-s-タグ" class="headerlink" title="v.s. タグ"></a>v.s. タグ</h2><p>こちらは無線ではありませんが、カメラでバーコードのようなタグを認識することで位置を認識する手法があります。<br>（もちろんタグだけでは移動できないので、LiDARなどを用いてSLAM（自己位置推定）を併用しながら移動します）<br>近年では飲食店でのロボットの導入が進んでおり、狭い範囲で決まった位置への移動を繰り返すロボットにとってはタグは非常に有効な手法になります。</p><p>また、タグを天井に配置することができるためタグを隠す障害物の心配もなく、さらに飲食店の景観を損ねずに済みます。<br>余談ですが、羽田空港にある<a href="https://ai-scape.jp/">AI_SCAPE</a>ではシェフもウェイターもロボットらしく、今回紹介したタグによる位置認識も導入されているようなので今度行ってみようと思います。</p><p>用途が違うので比較するのもおかしい話ですが、Bluetoothと比較した利点・欠点としては、</p><ul><li>位置推定ではなく、マーカーによって位置を認識しているので正確</li><li>マーカーに電源が要らない</li><li>人間の位置推定には向かない</li></ul><p>が挙げられます。</p><p>カメラ取り付けたヘルメット被ってもらって、天井にマーカー配置すれば人間も位置認識できなくはなさそうですね。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>以上、3種類のBluetoothを用いた位置推定手法を紹介させて頂きました。<br>個人的には、ビーコンを1つのみ使って近くにいるかどうかのみを判断する手法の方が手間がかからず、コスト的にも安く抑えられるのかなと思います。</p><p>次は真野さんの<a href="/articles/20220726a/">Plus Codeについて調べた</a> です。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E9%9B%BB%E5%AD%90%E5%B7%A5%E4%BD%9C/">電子工作</category>
      
      <category domain="https://future-architect.github.io/tags/bluetooth/">bluetooth</category>
      
      <category domain="https://future-architect.github.io/tags/%E4%BD%8D%E7%BD%AE%E6%8E%A8%E5%AE%9A/">位置推定</category>
      
      
      <comments>https://future-architect.github.io/articles/20220725a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>住所情報から経路を探索する&quot;そこそこ&quot;な方法</title>
      <link>https://future-architect.github.io/articles/20220722a/</link>
      <guid>https://future-architect.github.io/articles/20220722a/</guid>
      <pubDate>Thu, 21 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;SAIG(Strategic AI Group)の塚本です。&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>SAIG(Strategic AI Group)の塚本です。<a href="/articles/20220719a/">地図・GIS・位置特定</a>連載の4本目です。</p><p>私はAIチームにてアルゴリズム案件に携わっているのですが、アルゴリズム案件の代表的な課題のひとつに経路最適化があります。経路最適化自体の方法は<a href="/articles/20211201a/">以前の記事</a>を参照下さい。</p><p>本記事ではユーザ等から登録された住所情報から、ある程度精度を犠牲にすることで安価に経路を探索できる状態する、つまり”そこそこ”な方法について紹介します。なお紹介する内容は当社でアルバイトとして活躍している大森さん・高倉さんの協力を得ています。</p><h2 id="経路を探索できる状態ができるまで"><a href="#経路を探索できる状態ができるまで" class="headerlink" title="経路を探索できる状態ができるまで"></a>経路を探索できる状態ができるまで</h2><p>複数の住所を順番に訪れる経路を探索するには、各訪問先をノード、訪問先と訪問先の最短の道をエッジとしたグラフネットワーク構造で表す必要があります。<br><img src="/images/20220722a/image.png" alt="" width="595" height="488" loading="lazy"></p><p>入力情報がすでに構造化されたデータであれば良いのですが、実際は絶対的な位置である緯度経度ですら記録されておらず、曖昧な住所情報という形で記録されている事が多いです。<br>そのため、住所情報から経路探索をするために、以下のstepが必要です。</p><ol><li>文字列である住所情報から緯度経度を求める</li><li>求めた緯度経度同士をつなぐ最短の道の長さを求める</li></ol><p>各stepの実現方法を以下で紹介します。なお、本記事では地図情報を Google Map API にて取得します。</p><h3 id="1-文字列である住所情報から緯度経度を求める"><a href="#1-文字列である住所情報から緯度経度を求める" class="headerlink" title="1. 文字列である住所情報から緯度経度を求める"></a>1. 文字列である住所情報から緯度経度を求める</h3><p>多くの場合、住所は文字で書かれており表記に揺れがあります。また、住所としては正しくても、地図情報中に存在しなかったり、複数の可能性が発生することは珍しくありません。実際の住所情報をもとに説明します。<br>なお、以下はWebページでの Google Map の結果を記載しておりますが、APIでの結果も同様の傾向にあります。</p><p>例えば、当社の下記住所を Google Map に入力すると、その所在は一意に求まります。<a href="https://www.google.com/maps/place/%E3%82%A2%E3%83%BC%E3%83%88%E3%83%B4%E3%82%A3%E3%83%AC%E3%83%83%E3%82%B8%E5%A4%A7%E5%B4%8E%E3%82%BB%E3%83%B3%E3%83%88%E3%83%A9%E3%83%AB%E3%82%BF%E3%83%AF%E3%83%BC/@35.6223814,139.7252707,17z/data=!3m2!4b1!5s0x60188af7290db429:0x256fd7e2182150d7!4m5!3m4!1s0x60188af729b7a60d:0xc6703259ca319f2f!8m2!3d35.6223771!4d139.7274594">Google Map</a><br><code>東京都品川区大崎1-2-2アートヴィレッジ大崎セントラルタワー</code></p><img src="/images/20220722a/image_2.png" alt="" width="545" height="309" loading="lazy"><p>ところが、この住所を少し変えると、複数の候補がサジェストされます。<a href="https://www.google.com/maps/search/%E6%9D%B1%E4%BA%AC%E9%83%BD%E5%93%81%E5%B7%9D%E5%8C%BA%E5%A4%A7%E5%B4%8E1-2-2%E3%82%A2%E3%83%BC%E3%83%88%E3%83%B4%E3%82%A3%E3%83%AC%E3%83%83%E3%82%B8/@35.6226561,139.7249502,17z/data=!3m1!4b1">Google Map</a><br><code>東京都品川区大崎1-2-2アートヴィレッジ</code></p><img src="/images/20220722a/image_3.png" alt="" width="543" height="309" loading="lazy"><p>一方、建物名を除外するとまた一意に求まります。<a href="https://www.google.com/maps/place/%E3%80%92141-0032+%E6%9D%B1%E4%BA%AC%E9%83%BD%E5%93%81%E5%B7%9D%E5%8C%BA%E5%A4%A7%E5%B4%8E%EF%BC%91%E4%B8%81%E7%9B%AE%EF%BC%92%E2%88%92%EF%BC%92/@35.6223196,139.7249758,17z/data=!3m1!4b1!4m5!3m4!1s0x60188af728214857:0xea57823db5ffb40a!8m2!3d35.6223153!4d139.7271645">Google Map</a><br><code>東京都品川区大崎1-2-2</code></p><img src="/images/20220722a/image_4.png" alt="" width="544" height="308" loading="lazy"><p>例として説明した「アートヴィレッジ大崎セントラルタワー」は、商業ビルであり建物自体が Google Map に登録されていますが、これが小さなマンションや個人宅等になると未登録や、表記ゆれで一意に求めることが困難になります。先の例はそれほど距離が離れてませんが、実際の住所データで検証した所、1駅以上離れた候補が複数サジェストされる状況はよく発生し、複数の所在からどれを正しいものと選択するかによって経路が大きく変わってしまいます。</p><p>そこで、私は住所情報から所在がわからなかったり複数サジェストされた場合、後ろから記載を削り経路に大きく影響を及ぼさない<strong>番地</strong>までの所在を求められるよう、加工処理を加えるようにしています。<a href="https://www.google.com/maps/place/%E3%80%92141-0032+%E6%9D%B1%E4%BA%AC%E9%83%BD%E5%93%81%E5%B7%9D%E5%8C%BA%E5%A4%A7%E5%B4%8E%EF%BC%91%E4%B8%81%E7%9B%AE%EF%BC%92/@35.6225215,139.7253501,17z/data=!3m1!4b1!4m5!3m4!1s0x60188af7262641f1:0xd7cfc3a7a3c0382c!8m2!3d35.6223847!4d139.727363">Google Map</a><br><code>東京都品川区大崎1-2</code></p><img src="/images/20220722a/image_5.png" alt="" width="545" height="310" loading="lazy"><p>住所情報からの所在特定は地域性に大きく左右されるのですが、実際にあった顧客リストの住所情報をそのまま Google Map API を用いて所在を特定しようとした所、無加工の場合全体の80%程度しか取得ができませんでしたが、上記工夫を入れることで90%超の所在特定ができました。</p><h3 id="2-求めた緯度経度同士をつなぐ最短の道の長さを求める"><a href="#2-求めた緯度経度同士をつなぐ最短の道の長さを求める" class="headerlink" title="2. 求めた緯度経度同士をつなぐ最短の道の長さを求める"></a>2. 求めた緯度経度同士をつなぐ最短の道の長さを求める</h3><p>step1 で求めた所在(緯度経度)について、全ての地点を結ぶ最短の道の長さを Google Map API を用いて取得する事は現実的でありません。有料のサービスであるため、金額的にもなるべく少ない取得回数で妥当な結果を得たいです。</p><p>実世界の特に日本では、訪問先までの最短路の長さは2点間の直線距離に比例すると期待できます。そこで、どの程度の精度で近似できるのか、実際に下図で示したエリアにランダムに点を打ち、各2点間を結ぶ距離と、Google Map API による実際の最短路の長さの誤差を検証します。</p><img src="/images/20220722a/plot.png" alt="" width="640" height="640" loading="lazy"><p>初めに打った20点から、各2点の直線距離(ユークリッド距離)とGoogle Map API による実際の最短路の長さを比較し、最小二乗法にて誤差最小となる相関係数 <em>C</em> を求めます。</p><p>再度ランダムに20点打ち、ユークリッド距離に相関係数 <em>C</em> を書けた値と、Google Map API による実際の最短路の長さを比較したグラフが下図です。近距離の場合は誤差が大きいですが、それ以外は1.2～0.8倍に収まっており、それほど悪くない精度です。</p><img src="/images/20220722a/2.png" alt="" width="589" height="232" loading="lazy"><p>上記結果より、緯度経度から求められるユークリッド距離にて経路の候補を探索し、上位数点の候補のみ実際に Google Map API にて最短路を取得することで、API使用頻度を落としつつ、それなりの解を得ることができます。</p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>本記事では住所情報から経路を探索を実現するために、住所の加工による所在特定成功率の向上と地点間の最短路の長さを近似する、”そこそこ”な方法について、実際の Google Map API の動作を交えて紹介しました。世の中にはすでに優れたルート最適化サービスが存在する一方、利用シーンやコスト対効果に合致しない場面も多いかと思います。そのような場合に簡易な処理と安価な汎用サービスの組み合わせでは、どの程度の精度で実現できるかの指標となれば幸いです。</p><p>次は岸下さんによる<a href="/articles/20220725a/">Bluetoothで位置推定</a> です。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/DataScience/">DataScience</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E5%9C%B0%E5%9B%B3/">地図</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85/">初心者</category>
      
      <category domain="https://future-architect.github.io/tags/GoogleMap/">GoogleMap</category>
      
      
      <comments>https://future-architect.github.io/articles/20220722a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Software Design 2022年8月号 執筆記</title>
      <link>https://future-architect.github.io/articles/20220721b/</link>
      <guid>https://future-architect.github.io/articles/20220721b/</guid>
      <pubDate>Wed, 20 Jul 2022 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220721b/TH320_642208.jpg&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;452&quot;&gt;

&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220721b/TH320_642208.jpg" alt="" width="320" height="452"><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>TIG DX Unitの武田です。</p><p>先日（2022年7月15日）発売された技術評論社の <a href="https://gihyo.jp/magazine/SD/archive/2022/202208">Software Design 2022年 8月号</a> に寄稿させていただきました。<br>まずはじめに、このような寄稿の機会をくださった技術評論社の方々には、心からお礼申し上げます。</p><p>具体的には、第1特集の「Web APIの作り方」という4章構成の特集の「第4章 OpenAPIを使ったWeb API開発の実際」という部分を、私と弊社エンジニアの宮崎、大岩の3名で担当いたしました。</p><p>3名とも技術商業誌への寄稿は今回が初めてとなりますが、執筆を進める中で苦労した部分や、意識した部分など本記事でお伝えできればと思います。</p><h2 id="Software-Design-とは"><a href="#Software-Design-とは" class="headerlink" title="Software Design とは"></a>Software Design とは</h2><p>技術評論社が出版している月刊の技術情報誌となります。<br>ソフトウェア業界のエンジニアにとっては説明不要と言っていいくらい鉄板です。</p><p>毎月様々なテーマについて特集を組んで取り扱っており、プログラミングだけでなく、OSやネットワークまで、その内容は多岐に渡ります。<br>入門者・初心者向けの内容から実践的な内容も多く含まれているので、新人からベテランまであらゆるエンジニアにおすすめできる雑誌です。</p><h2 id="執筆のきっかけ"><a href="#執筆のきっかけ" class="headerlink" title="執筆のきっかけ"></a>執筆のきっかけ</h2><p>Future Tech BlogでOpenAPIをテーマとして取り扱った記事を見ていただき、OpenAPIを活用した開発事例を取り上げたいとのことで会社宛に依頼をいただきました。</p><p>自社のブログがきっかけとなってこのような依頼がくるのは大変ありがたいことですね。<br>これからも積極的に社外に情報を発信していこうというモチベーションにもなります。</p><p>きっかけとなった記事を含め、OpenAPIについて触れている記事を紹介しておきますので気になる方はぜひ読んでみてください。</p><ul><li><a href="https://future-architect.github.io/articles/20220622b/">Open API Specification 3.1と気になる仕様策定</a></li><li><a href="https://future-architect.github.io/articles/20191008/">本当に使ってよかったOpenAPI (Swagger) ツール</a></li><li><a href="https://future-architect.github.io/articles/20211028b/">OpenAPIにおけるundefinedとnullの設計</a></li><li><a href="https://future-architect.github.io/articles/20210427c/">GoにおけるAPIドキュメントベースのWeb API開発について登壇しました</a></li><li><a href="https://future-architect.github.io/articles/20210410/">OpenAPIからモックサーバを建てられるPrismを実際のプロジェクトに導入してみた</a></li><li><a href="https://future-architect.github.io/articles/20211028b/">Flutter Swagger統合</a></li></ul><h2 id="執筆文量"><a href="#執筆文量" class="headerlink" title="執筆文量"></a>執筆文量</h2><p>8ページ程度（1ページあたり最大1,680字）の文量で依頼をいただき、結果としては11ページ、約15,000字となりました。</p><h2 id="執筆のフロー"><a href="#執筆のフロー" class="headerlink" title="執筆のフロー"></a>執筆のフロー</h2><p>執筆作業はおおよそ下記のようなスケジュールで進めていく形となりました。<br>黒塗りしている矢羽の「原稿作成」と「誌面修正」が弊社の担当となります。</p><img src="/images/20220721b/Schedule.png" alt="Schedule.png" width="1162" height="202" loading="lazy"><p>原稿の作成期間はおおよそ3週間程度というスケジュールでした。<br>おそらく通常のスケジュールと比べると若干タイトなのかもしれませんが、依頼いただいた8ページという文量を考えると無理のないスケジュールだと思います。<br>何より技術評論社の方には、我々の本業の状況も考慮してスケジュールについて大変丁寧にお気遣いいただき、とても感謝しております。</p><p>以下、「執筆依頼を受けてから打合せまでの進め方」「原稿作成の進め方」「誌面修正の進め方」という3部構成で詳細について説明していきます。</p><h3 id="執筆依頼を受けてから打合せまでの進め方"><a href="#執筆依頼を受けてから打合せまでの進め方" class="headerlink" title="執筆依頼を受けてから打合せまでの進め方"></a>執筆依頼を受けてから打合せまでの進め方</h3><p>執筆依頼を受けてから、まずは社内でOpenAPI関連のブログを投稿しているエンジニアをはじめとしてフラットに執筆者を募りました。<br>8ページという文量を考慮すると1-2名が適正人数かなというところですが、ちょうど中堅、若手からそれぞれ1名手が挙がったので、ベテランの私率いる3名で執筆させていただくことにしました。</p><p>Software Designは入門者から経験者まで幅広い読者層をターゲットとしていると思いますので、ベテラン、中堅、若手のそれぞれの視点で内容を精査できたのは結果的に良かったのではないかと思っています。</p><h3 id="原稿作成の進め方"><a href="#原稿作成の進め方" class="headerlink" title="原稿作成の進め方"></a>原稿作成の進め方</h3><h4 id="見出しの作成"><a href="#見出しの作成" class="headerlink" title="見出しの作成"></a>見出しの作成</h4><p>まずは見出しの作成です。<br>技術評論社の方からいただいた大枠の見出し案をベースに、3名でアウトラインについて叩きを持ち寄りディスカッションして決定しました。<br>意識したのは、依頼を受けた4章の中だけでなく、1章 ~ 3章の前章の見出しを踏まえた上で、整合性が取れているか、重複する部分がないかということです。幸いにも見出し案を考える際に、前章の見出し案を共有いただけたのでこの辺りはスムーズに進めることができました。</p><p>また技術評論社の方に見出しを提出する際は、見出しだけでなく、どのような内容をどの程度の文量記載する予定かを可能な限り共有することで、手戻りのリスクを極力小さくするようにしました。</p><p>こうして約3日程度で見出しの確定に至りました。</p><h4 id="分担・内部スケジュールの決定"><a href="#分担・内部スケジュールの決定" class="headerlink" title="分担・内部スケジュールの決定"></a>分担・内部スケジュールの決定</h4><p>見出しが決まったら、次に誰がどの部分を執筆するか分担を決定します。<br>今回は見出し別にそれぞれ知識や実務経験のある領域をベースに、ブログなどの執筆経験値や業務状況なども踏まえて分担を決定しました。</p><p>内部のスケジュールとしては、原稿の締め切りをゴールとして、1週間で各自担当部分を執筆、1週間でマージ及び全体の推敲、残り1週間をバッファとして組み立てました。<br>個人での執筆と異なり、複数人での執筆は、各担当部分をマージしてから全体として文章のゆれがないか、整合性がとれているかを確認するのに時間を要するため、スケジュールに余裕を持たせておいて結果的に正解でした。</p><p>TIPsですが、業務外の作業として土日にゆっくり時間をとって作業をするケースが多いと思うので、進捗確認などのミーティングは月曜日にしておくと効果的です。</p><h4 id="個別原稿執筆"><a href="#個別原稿執筆" class="headerlink" title="個別原稿執筆"></a>個別原稿執筆</h4><p>分担とスケジュールが決まったら各自執筆作業に移ります。<br>執筆のツールは基本的に自由ですが、全員マークダウンに慣れ親しんでいることもあり、Qiitaの限定共有機能を利用してマークダウンで作成した記事を共有する形を取りました。<br>各自が作成した原稿のマージ作業は、私が手作業で行いましたが、文量や人数がこれよりも多くなる場合は、共同編集ツールを使うと良いでしょう。（この辺りは弊社内の事情もあり、今回は利用を見送りました。）</p><p>作成した記事のレビューは私が中心となって行いましたが、その際に意識したのは下記の4点です。</p><ul><li><strong>用語の使い分け方を明確にし、表記ゆれをなくす</strong><br>OpenAPIに関連する用語はいくつかあり（OpenAPI, OAS, OpenAPIドキュメント, OpenAPI定義など）全体としてどのような意図で用語を使い分けるのかを内部で認識を合わせ、統一しました。</li><li><strong>やってみた系の内容に終始していないか</strong><br>執筆テーマが「OpenAPIを使ったWeb API開発の実際」ということで、OpenAPI関連のツールを使用した設計手法や開発手法を紹介する形になるのですが、ツールの利用手順などは極力ライトにし、内容としては苦労点や工夫点が盛り込まれた現場感の強い内容を盛り込めるよう意識しました。</li><li><strong>文量を削るのは後回し</strong><br>事前に見出し単位でおおよその文量は定めていますが、文章を削る作業は全体をマージした後の段階とし、個別に原稿を書く際には無理に文章を削りすぎないことを全員で意識するようにしました。<br>理由としては、初めから文章を削ってしまうと各見出しごとの内容が満遍なく薄くなってしまう可能性があり、全体としてみた時にメリハリのない記事になってしまう可能性があるため、これを避けることを意図しています。</li><li><strong>他社の権利を侵害するような内容が含まれていないか</strong><br>文章やソースコードを引用する場合は、適切に行われているか。特に図を挿入する場合に、利用しているアイコンや画像など著作権違反となるものがないか、を入念にチェックしました。アイコンや画像については商用利用可能なものであっても、著作権表示が義務付けられているものもあるので、この辺りは要注意です。<br>原稿の図については提出後に技術評論社の方で改めて作図する形になるため、最終的には問題は発生しないと思われますが、我々としては原稿の段階からパブリックドメインのアイコンで統一するように意識しました。</li></ul><p>このようなことを意識しながらレビューをしていて、私が常々思うのは、魂込めて書いた文章を指摘するというのは、指摘する方もされる方も精神衛生上あまり良いものではありません。<br>特に明確な誤りを正すような指摘であれば良いのですが、文章のテイストや書きっぷりなど個人の好みが現れる部分に対して、全体での統一感を意識した結果、指摘を行わなければならないケースについては、どうしてもレビュワーの想いが強くなってしまう傾向があります。<br>この辺りは、自分自身の考えや想いを明確にした上で、執筆者本人の想いも最大限尊重しつつ丁寧にコミュニケーションを取りながらすり合わせることで、モチベーションを低下させないようケアしながら進めていくことが大切だと考えています。</p><h4 id="個別原稿のマージ・全体推敲"><a href="#個別原稿のマージ・全体推敲" class="headerlink" title="個別原稿のマージ・全体推敲"></a>個別原稿のマージ・全体推敲</h4><p>個々の原稿が仕上がったら、全体として1つの原稿にマージした上で推敲を行います。<br>この段階で意識したのは、なるべく早めに技術評論社の方にドラフトの原稿を共有しフィードバックをいただくことです。<br>今回は完成原稿を提出するまでに、前半部のドラフト、後半部のドラフトの2回に分けてドラフトを共有させていただきました。</p><p>実際の誌面にした際のページ数や他の章との内容の重複についてこの段階で確認できるため、ここでのフィードバックをもとに全体原稿をブラッシュアップしていきます。<br>最終的には11ページの文量に着地する形となりましたが、11ページという文量はいざ書いてみると思ったより少なく、内容が薄くならないよう文章を濃縮していく作業は想像よりも大変です。</p><p>Software Designはページ数こそ薄いものの、内容が濃いものになっているのは、世の中のエンジニアが試行錯誤してエッセンスを詰め込んでいる賜物なのだと気づき、改めて素晴らしい技術誌だと実感しました。</p><h3 id="誌面修正の進め方"><a href="#誌面修正の進め方" class="headerlink" title="誌面修正の進め方"></a>誌面修正の進め方</h3><p>原稿を提出した後は、技術評論社の方で編集・レイアウトが行われ、完成した誌面PDFが共有されます。<br>（私は発売日よりも、誌面をみたときが一番テンションが上がりました。）</p><p>インターネット上のブログであれば後から修正ができますが、紙媒体の雑誌はそれができないということもあり、文章のチェックはいつもよりも時間をかけて、執筆者全員で2回、3回と行いました。</p><p>特に誤字・脱字をはじめとし、利用しているライブラリやツールのバージョンは合っているか、リンクが適切かどうか、記載したプログラムは実際に動くものになっているか、など細かい部分まで確認を怠らないようにしました。</p><h3 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h3><p>以上のプロセスを経て、無事 Software Design 8月号の発売を見届けることができました。<br>通常書いているブログとは異なり、複数人で協力しながら作り上げていくチーム感であったり、限られたページ数での記載内容の取捨選択であったり、いつもとは違う刺激を感じながら、楽しく執筆をさせていただくことができました。</p><p>実際の内容については本記事では触れていませんが、実際の現場でOpenAPIを使ってどのように設計・開発・テストを進めているのか、具体的な事例とともに紹介していますので、気になる方はぜひ手にとっていただけると幸いです。</p><p>また今後執筆の機会がありましたら、ぜひとも積極的に関与させていただきたいと思っておりますので、弊社のブログなどを見て気になった方はぜひお声がけいただけますと幸いです。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E5%87%BA%E7%89%88/">出版</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%9B%B8%E7%B1%8D/">書籍</category>
      
      <category domain="https://future-architect.github.io/tags/OpenAPI/">OpenAPI</category>
      
      <category domain="https://future-architect.github.io/tags/SoftwareDesign/">SoftwareDesign</category>
      
      
      <comments>https://future-architect.github.io/articles/20220721b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redisのジオメトリ機能</title>
      <link>https://future-architect.github.io/articles/20220721a/</link>
      <guid>https://future-architect.github.io/articles/20220721a/</guid>
      <pubDate>Wed, 20 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220721a/Logo-redis.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;239&quot;&gt;

&lt;p&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220721a/Logo-redis.png" alt="" width="700" height="239"><p><a href="/articles/20220719a/">地図・GIS・位置特定に関する連載</a>の4日目のエントリーです。最初はブラウザの座標を取得するAPIとか、IPアドレスから場所を推定するGeoIPを使って、近い場所の人を探すサービスでも作ってみようかと思っていました。Quad-Treeみたいなゲームでよくある座標系を収めるデータ構造を使って、近くのメンバーを探す機能とかを作ろうと思っていましたが、ふと「座標系をそのまま格納して検索できるデータベースとかありそうだな」と思って調べたところRedisがヒットして横道にそれてしまったのでそのまま横道を突き進んでみました。</p><p>Redisは<a href="http://redis.shibu.jp/">2010年ぐらいに有志でドキュメント翻訳したり</a>したりして、チョットワカル程度でしたが、久々にドキュメントを見ていたら座標情報を保持したり検索したりするコマンドが増えていました。その辺りを少し調べてみました。</p><h1 id="Redisのジオメトリ機能"><a href="#Redisのジオメトリ機能" class="headerlink" title="Redisのジオメトリ機能"></a>Redisのジオメトリ機能</h1><p>Redisの<a href="https://redis.io/commands/?group=geo">ジオメトリ関係のコマンド</a>は10個ほどあります。</p><ul><li>GEOADD: 座標つきでメンバーを登録</li><li>GEODIST: 登録したメンバーの距離を計測</li><li>GEOPOS: 登録したメンバーの座標を取得</li></ul><p>メインの検索機能はこちら</p><ul><li>GEOSEARCH: 指定の座標&#x2F;メンバーから範囲内（矩形、もしくは半径）のメンバー一覧を返す</li></ul><p>メインの検索機能を便利にするメソッドはこちら</p><ul><li>GEOSEARCHSTORE: GEOSEARCHの結果をsorted setに保存</li><li>GEORADIUS: GEOSEARCHの座標→半径計算特化版。STOREも可能。</li><li>GEORADIUS_RO: GEOSEARCHの座標→半径計算特化版。STOREなし。</li><li>GEORADIUSBYMEMBER: GEOSEARCHのメンバー→半径計算特化版。STOREも可能。</li><li>GEORADIUSBYMEMBER_RO: GEOSEARCHのメンバー→半径計算特化版。STOREも可能。</li></ul><p>なお、これらはネイティブなデータ構造になっているわけではなく、次のコマンドを使ってGeoHashというキーを生成し、sorted setに格納されています。登録したメンバーの一覧を取得や、メンバーの数の取得、メンバーの削除はsorted setのコマンドをそのまま使うことになっています。</p><ul><li>GEOHASH: 緯度・経度をgeohashというアルゴリズムでハッシュキー化します。</li></ul><p>Redisのドキュメントから持ってきたサンプルは以下の通りです。</p><p>このサンプルのSicilyというのはsorted setの名前です。地球の座標系、火星の座標系など、複数のスペースを分けて使います。GEOADDは複数の要素を一括で入れられて、緯度・経度・キーをセットで入れます。GEODISTは登録したメンバー同士の距離を返す機能で、GEORADIUSは特定の座標から一定距離内のメンバー一覧を返しています。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis:6379&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis:6379&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">&quot;166274.1516&quot;</span></span><br><span class="line">redis:6379&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">&quot;Catania&quot;</span></span><br><span class="line">redis:6379&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">2) <span class="string">&quot;Catania&quot;</span></span><br></pre></td></tr></table></figure><h1 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h1><p>このジオメトリ機能の肝は<a href="https://en.wikipedia.org/wiki/Geohash">GeoHash</a>です。パブリックドメインなアルゴリズムです。たとえば、13.361389 38.115556という座標は<code>sqc8b49rny0</code>というキーになります。</p><p>Redisは経度としては±180度、緯度は±85.05112878度までをサポートしています。北極点、南極点から555kmの範囲は表現できなそうですね。</p><p>GeoHashは長さが長くなればなるほど精度があがって細かい座標も表現できるというモデルになっています。<code>sqc8b49rny0</code>の末尾の文字列を削ってもだいたい同じ位置になるが、丸められてしまう、みたいな欠損してもvalidな面白いデータ構造になっています。</p><p>GeoHashの各文字はbase32にエンコードされた数値です。1文字で5ビットあります。奇数文字列目は3ビットの経度＋2ビットの緯度、偶数文字列目は2ビットの経度＋3ビットの緯度で表現されます。Redisは11文字の文字列で表現されるので、55ビットと思いきや、内部的には<a href="https://redis.io/commands/geohash/">52ビット</a>となるようです。なので、おそらく、緯度・経度ともに26ビットの精度になると思われます。本来のGeoHashはRedisと違って緯度は±90度なので、ちょっと計算は違うかもしれませんが、Wikipediaの計算をもとにすると、誤差は30cm程度。十分な精度ですね。</p><p>ちなみに、これらは地球上の座標として表現されているので、Redisで火星の座標系とかを表現しようとすると、補正が必要ですね。</p><h1 id="ベンチマーク"><a href="#ベンチマーク" class="headerlink" title="ベンチマーク"></a>ベンチマーク</h1><p>Redis 7.0.3、Go 1.18.4、ドライバとしてgithub.com&#x2F;go-redis&#x2F;redis&#x2F;v9を使って、M2 MacBook Airでベンチマークを取ってみました。RedisのドキュメントにはO(N+log(M)) (Nは検索範囲のバウンディングボックスの中のメンバー数、Mはその図形の中のメンバー数)とドキュメントにはあるのですが、実際にかかる時間の肌感覚を知りたかったので。コードは次のところにあります。</p><p><a href="https://gist.github.com/shibukawa/2cf8fc518d58f5031619798d3d43ceb7">https://gist.github.com/shibukawa/2cf8fc518d58f5031619798d3d43ceb7</a></p><p>要素数は以下の通りで、関東の範囲(東経139-141, 北緯35-37)にランダムにメンバーを登録して、検索をかけてみました。要素数は以下のケースで検証してみました。</p><ul><li>1000: (<a href="https://mitok.info/?p=107992">関東のマクドナルドの店舗数</a>の1377と同じぐらいのオーダー</li><li>10000: (<a href="https://www.post.japanpost.jp/newsrelease/storeinformation/pdf/02_87.pdf">関東の郵便局数</a>の4627と<a href="https://uub.jp/pdr/m/c.html">関東のコンビニの店舗数</a>20779の間ぐらいのオーダー</li><li>100000: (<a href="https://www.npa.go.jp/bureau/traffic/seibi2/annzen-shisetu/hyoushiki-shingouki/pdf/R02kazu.pdf">関東の信号の数</a>の59188よりもちょっと多いオーダー)</li></ul><p>ちなみに、100000件データを入れても、Redisの消費メモリは16MB程度、Redisが生成したファイルが1.2MB程度で想像よりも遥かに少ないです。</p><p>結果は以下の通りで、このぐらいの検索だと誤差の範囲ぐらいですね、というか本当かよ？と思うぐらいの高パフォーマンス。一番最後のやつで40件近くヒットしていて、動作上は肌感覚的に間違ってなさそうな結果は出ています。要素数が増えても、検索対象を賢く絞ってパフォーマンスが落ちないような工夫がされていそうです。</p><div class="scroll"><table><thead><tr><th align="center">要素数</th><th align="center">検索条件</th><th align="center">時間</th></tr></thead><tbody><tr><td align="center">1000</td><td align="center">1辺1kmの矩形</td><td align="center">24μs</td></tr><tr><td align="center">1000</td><td align="center">半径1kmの円</td><td align="center">22μs</td></tr><tr><td align="center">1000</td><td align="center">1辺2kmの矩形</td><td align="center">23μs</td></tr><tr><td align="center">1000</td><td align="center">半径2kmの円</td><td align="center">23μs</td></tr><tr><td align="center">10000</td><td align="center">1辺1kmの矩形</td><td align="center">23μs</td></tr><tr><td align="center">10000</td><td align="center">半径1kmの円</td><td align="center">24μs</td></tr><tr><td align="center">10000</td><td align="center">1辺2kmの矩形</td><td align="center">24μs</td></tr><tr><td align="center">10000</td><td align="center">半径2kmの円</td><td align="center">27μs</td></tr><tr><td align="center">100000</td><td align="center">1辺1kmの矩形</td><td align="center">26μs</td></tr><tr><td align="center">100000</td><td align="center">半径1kmの円</td><td align="center">33μs</td></tr><tr><td align="center">100000</td><td align="center">1辺2kmの矩形</td><td align="center">33μs</td></tr><tr><td align="center">100000</td><td align="center">半径2kmの円</td><td align="center">52μs</td></tr></tbody></table></div><p>GeoHashがすごいのは、文字列長さによって精度が変わることと、1次元にマッピングしていること。つまり、探したい座標と範囲が分かれば先頭一致で要素が絞れます。2次元を1次元で表現する方法は昔考えたことがあるものの、なかなか思いつかなかったのですが、コンピューターサイエンスの勝利というか、久々に胸が熱くなるものを見つけました。あらかじめQuadTreeの深さとかパラメータを調整する必要もないですしね。<a href="https://future-architect.github.io/articles/20210701a/">LOUDS</a>みたいなデータ構造との相性も良いですしね。夢が広がります。</p><h1 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h1><p>こちらの機能としてはウェブサービスを作る時とかに便利に使えそうですよね。座標はブラウザの機能とか使えば簡単にとれます。Redis側にあらかじめいろんな場所情報を入れてあげて、ブラウザから取得した座標を投げ込めば簡単に近隣のスポットを探す、というサービスが作れそうです。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API">https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>. <span class="title function_">getCurrentPosition</span>(<span class="function">(<span class="params">pos: GeolocationPosition</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pos.<span class="property">coords</span>);</span><br><span class="line">    <span class="comment">// &#123;latitude: 35.0, longitude: 135.0, altitude: null&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SQLiteでマスターを配布するような感じで、Redisも読み込み専用で使ってあげるとかも面白い気がします。ビジネス利用がいろいろ考えられますね。</p><p>今回はRedisを調べただけですが、座標周りのロジックにはいろいろあります。</p><ul><li>IPアドレスから座標を推定するGeoIP</li><li>場所から座標を調べるジオロケーション</li><li>座標から場所を調べる逆ジオロケーション</li></ul><p>人間にわかりやすいコード体系やら機械にわかりやすいコード体系、それぞれの変換など、「場所」の世界は奥深いですね。これらを組み合わせると場所を使った面白いサービスが作れそうです。</p><p>次は塚本さんの<a href="/articles/20220722a/">住所情報から経路を探索する”そこそこ”な方法</a>です。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/Redis/">Redis</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%B8%E3%82%AA%E3%83%A1%E3%83%88%E3%83%AA/">ジオメトリ</category>
      
      
      <comments>https://future-architect.github.io/articles/20220721a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Foursquare - Location Matching 参加記 (7th / 1083)</title>
      <link>https://future-architect.github.io/articles/20220720a/</link>
      <guid>https://future-architect.github.io/articles/20220720a/</guid>
      <pubDate>Tue, 19 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;本記事は&lt;a href=&quot;/articles/20220719a/&quot;&gt;「地図・GIS・位置特定に関する連載」&lt;/a&gt;二日目の記事です。昨日の&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>本記事は<a href="/articles/20220719a/">「地図・GIS・位置特定に関する連載」</a>二日目の記事です。昨日の<a href="/articles/20220719b/">「郵便番号・住所・緯度経度の体系について」</a>の記事も、今回の記事とは直接つながってはいませんが、参考になる部分もあるのでぜひご覧ください。</p><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは、Strategic AI Group所属の金子です。普段は推薦に関連する実装やデータ分析を行っています。</p><p>先日Kaggleで開催された<a href="https://www.kaggle.com/competitions/foursquare-location-matching/overview">「Foursquare - Location Matching」コンペ</a>(以下4sqコンペ)に社外の知人共にチームで参加し、1083チーム中7位をとりました。（初の金メダルでKaggle Competitions Masterになりました！)</p><p>本記事では参加記として以下の内容を紹介します。</p><ul><li>4sqコンペ概要</li><li>解法のサマリ</li><li>解法の詳細</li><li>テクニック集</li><li>リーク問題について</li><li>謝辞</li></ul><h1 id="4sqコンペ概要"><a href="#4sqコンペ概要" class="headerlink" title="4sqコンペ概要"></a>4sqコンペ概要</h1><h2 id="タスク概要"><a href="#タスク概要" class="headerlink" title="タスク概要"></a>タスク概要</h2><p>Foursquareは位置を共有するSNS等を提供する企業です。現在はあるPOI(Points-of-Interest, 同じ地図上の特定のポイント)について口コミ等を検索する「Foursquare」アプリや、あるPOIにチェックインし、それをシェアすることに特化した「Swarm」アプリなどを公開しています。これらに登録されているPOIはユーザーによって登録されます。</p><p>4sqコンペではFoursquareの持つPOIとそれに関連するデータが提供されました。そして、このデータに対し一定の実行環境内で同じPOIのIDをもつ行同士のマッチングを時間内に行うコードを提出することが求められました。</p><p>データとしては以下の情報が欠損値を含む状態で渡されました。</p><ul><li>名称(name)</li><li>住所(country, state, city, address)</li><li>緯度経度(latitude, longitude)</li><li>カテゴリ(categories, 一つのレコードに0~複数個紐づく)</li><li>URLや電話番号、郵便番号</li></ul><p>下記の表は私がつくったデータの見本です。「フューチャー株式会社」・「Future Corporation」・「フューチャー」はすべて同じPOIですが、欠損や表記ゆれを含んだ状態でデータセットの中に散在しています。訓練データは約110万件、テストデータは約60万件あり、テストデータではPOIが隠された状態で渡されていました。提出は各行のIDに対して同じPOIであるIDを連結したmatchesの出力を求められました。<br><img src="/images/20220720a/データの例.png" alt="データの例" width="1200" height="117" loading="lazy"></p><p>評価はmatchesに対し (正解のラベルと予測ラベルの積集合の数) &#x2F; (正解のラベルと予測ラベルの和集合の数) で求められるIoUの平均で計算されました。</p><h2 id="この問題が解けると何がうれしいか"><a href="#この問題が解けると何がうれしいか" class="headerlink" title="この問題が解けると何がうれしいか"></a>この問題が解けると何がうれしいか</h2><p>今回のコンペのデータは意図的にノイズを加えたデータで、実務のデータとは異なるようでした。しかし、名前や住所・商品名の表記ゆれというのは至る所で発生する問題で、今回のコンペで用いられた手法は実務でこのようなゆれと向き合うにあたって有用であると考えられます。</p><h1 id="解法のサマリ"><a href="#解法のサマリ" class="headerlink" title="解法のサマリ"></a>解法のサマリ</h1><p>前回紹介した<a href="https://future-architect.github.io/articles/20220602b/">H&amp;Mコンペ</a>でもそうでしたが、600,000 x 600,000 の組み合わせについてすべて正確に評価することは難しいです。<br>そこで、今回は以下の三つのパートで予測を行いました。</p><ul><li>全候補から大まかに候補を絞り込むretrieval part</li><li>二点間のペアに対して正確な予測を行うpredict part</li><li>ペアをグラフとして扱い後処理で精度を上げるpostprocess part</li></ul><img src="/images/20220720a/4sq_overview.png" alt="4sq_overview" width="851" height="432" loading="lazy"><h1 id="解法の詳細"><a href="#解法の詳細" class="headerlink" title="解法の詳細"></a>解法の詳細</h1><p>上記の三つのパートに各データの前処理について加え、前処理から順に説明していきます。</p><h2 id="前処理パート"><a href="#前処理パート" class="headerlink" title="前処理パート"></a>前処理パート</h2><p>前処理では機械学習モデルがデータを解釈しやすいよう、データをカテゴリ変数とembeddingに変換することを目的にしました。<br>そのために、NNが扱いやすいような形に自然言語を処理し、欠損値を埋め、無数にあるカテゴリを学習できる種類にまで減らすこと意識しました。</p><h3 id="自然言語の前処理"><a href="#自然言語の前処理" class="headerlink" title="自然言語の前処理"></a>自然言語の前処理</h3><h4 id="文字の正規化"><a href="#文字の正規化" class="headerlink" title="文字の正規化"></a>文字の正規化</h4><p>nameについてはたくさんの言語が混じっており、かつ日本語・中国語・タイ語のような分かち書きが必要な言語も多く混じっていました。そこでname, addressについては、文字単位で比較する用、単語同士で比較する用、NNに入れる用の三種類に向けた前処理を行いました。</p><p>「大崎一丁目2-2 アートヴィレッジ大崎セントラルタワー」であれば</p><div class="scroll"><table><thead><tr><th>処理番号</th><th>処理の目的</th><th>処理内容</th></tr></thead><tbody><tr><td>1</td><td>文字単位の比較用</td><td>Unicode正規化</td></tr><tr><td>2</td><td>単語同士の比較用</td><td>1.に対し分かち書きの実施、小文字化・カタカナ化、数字を表す単語の数字化(e.g. 一丁目→1丁目)、一部記号の除去</td></tr><tr><td>3</td><td>NNへの入力用</td><td>2.に対し正規表現で[0-9a-z&amp; ]のみが残るようローマ字化</td></tr></tbody></table></div><p>の三種類の処理を行い、</p><div class="scroll"><table><thead><tr><th>処理番号</th><th>処理結果</th></tr></thead><tbody><tr><td>1</td><td>大崎一丁目2-2 アートヴィレッジ大崎セントラルタワー</td></tr><tr><td>2</td><td>オオサキ 1 チョウメ 2 - 2 アート ヴィレッジ オオサキ セントラル タワー</td></tr><tr><td>3</td><td>oosaki 1 choume 2 2 aato virejji oosaki sentoraru tawaa</td></tr></tbody></table></div><p>となるように変換しました。</p><h4 id="addressの欠損値の補完"><a href="#addressの欠損値の補完" class="headerlink" title="addressの欠損値の補完"></a>addressの欠損値の補完</h4><p>addressについては3.についてのみ、NNモデルに入れるため欠損値の補完を行いました。<br>具体的には全レコードについて、addressがNaNでないものからhaversine距離で近傍3か所のaddressを連結して、embedding学習用の前処理としました。</p><h3 id="地名のカテゴリ変数化と前処理"><a href="#地名のカテゴリ変数化と前処理" class="headerlink" title="地名のカテゴリ変数化と前処理"></a>地名のカテゴリ変数化と前処理</h3><p>city, state, countryはカテゴリ変数として扱うことにしました。countryは欠損値を”NAN”で埋めたうえでカテゴリ変数化、cityとstateについては出現回数上位約2000を代表として平均の緯度経度を計算し、欠損値、もしくは上位2000以外のcityとstateを上位2000との近傍で埋めました。</p><p>また、cities1000という1000人以上の人口がいる市を集めたデータセットを用いて緯度経度から地名を求め、geo_nameという名前のカテゴリ変数にしました。これもまた出現数上位2000のどれかに割り振られるよう調整を行いました。</p><h3 id="categoriesの前処理"><a href="#categoriesの前処理" class="headerlink" title="categoriesの前処理"></a>categoriesの前処理</h3><p>categoriesは一つの列にカンマ区切りで複数のカテゴリが入っていました。そこでカンマ区切りで分割し、RaggedTensorとして扱いました。また、categoriesに何も入っていない場合は”nan”のカテゴリで補完しました。後述のカテゴリ予測モデルを作った後は”nan”の行に予測を行い、カテゴリを一つ追加しました。</p><h3 id="URL-x2F-Phoneの正規化"><a href="#URL-x2F-Phoneの正規化" class="headerlink" title="URL&#x2F;Phoneの正規化"></a>URL&#x2F;Phoneの正規化</h3><p>URLについては<a href="https://docs.python.org/ja/3/library/urllib.parse.html">urllib</a>でネットワーク上の位置を示す部分抽出しました。<br>電話番号は国際通話用の+81等が付いた形式とそうでない形式が混じっていたため、<a href="https://pypi.org/project/phonenumbers/">phonenumbers</a>を用いて正規化を行い統一しました。</p><h3 id="embeddingの作成"><a href="#embeddingの作成" class="headerlink" title="embeddingの作成"></a>embeddingの作成</h3><h4 id="サブワードへの分割"><a href="#サブワードへの分割" class="headerlink" title="サブワードへの分割"></a>サブワードへの分割</h4><p>3で処理したローマ字について<a href="https://github.com/google/sentencepiece">SentencePiece</a>でサブワード分割を学習しました。サブワードは単語をさらに分割したもので、例えば「競プロer」という未知の単語が出てきた際、「競プロ」をする「er」なんだなと解釈できるようになります。単語をすべて[0-9a-z&amp; ]の範囲にしたのもsentence pieceで使える語彙をより有意義なものにするためです。nameとaddressについてそれぞれ32000のサブワードで表すようSentencePieceを別々に学習しました。</p><h4 id="embeddingの学習"><a href="#embeddingの学習" class="headerlink" title="embeddingの学習"></a>embeddingの学習</h4><p>学習にはname, address, categoriesと、カテゴリ変数にしたcountry, city, state, geo_nameを用い以下の三つのタスクを行いました。</p><ol><li>同じname内の単語の共起情報からembeddingを学習するSkip-Gramベースのタスク</li><li>categories以外からcategoriesを予測するmetric learningタスク</li><li>それぞれのembeddingを<a href="https://arxiv.org/abs/2201.09792">ConvMixer</a>のように混ぜてmix embeddingとし、<a href="https://arxiv.org/abs/2104.08821">SimCSE</a>で自己教師あり対照学習を行うタスク</li></ol><p>1.と3.のタスクについてはバッチ内の他サンプルを負例とするのほかに、距離の近さを辺の重みとしたrandom walkによるnegative hard samplingによって、難易度の高い負例をサンプルごとに用意しました。これによりembeddingの質が大きく向上しました。</p><p>なお、1のSkip-Gramタスクの学習はコンペ中<a href="https://www.kaggle.com/code/nadare/w2v-haversine-nn-baseline-training-inference">W2V &amp; haversine NN baseline[Training&#x2F;Inference]</a>というノートブックで公開しています。</p><h4 id="embeddingの評価"><a href="#embeddingの評価" class="headerlink" title="embeddingの評価"></a>embeddingの評価</h4><p>embeddingの評価としてデータごとに近傍を取得し、precision@16 (≒ maxIoU)を計算して評価を行いました。<br>ベースラインとしてUniversal Sentence Encoderでのコサイン類似度の近傍と、haversine距離の近傍を用意しました。</p><div class="scroll"><table><thead><tr><th>近傍の取得方法</th><th>precision@16</th><th>precision@32</th></tr></thead><tbody><tr><td>USE name embedding</td><td>0.7582</td><td>0.7879</td></tr><tr><td>haversine distance</td><td>0.8946</td><td>0.9160</td></tr></tbody></table></div><p>でしたが、上記の3つのタスクを解くことにより以下のようなembeddingを得られました。</p><div class="scroll"><table><thead><tr><th>近傍の取得方法</th><th>precision@16</th><th>precision@32</th></tr></thead><tbody><tr><td>name embedding</td><td>0.7738</td><td>0.8061</td></tr><tr><td>address embedding</td><td>0.8690</td><td>0.8811</td></tr><tr><td>mix embedding</td><td>0.8997</td><td>0.9120</td></tr></tbody></table></div><p>nameに関しては、Universal Sentence Encoderよりも高いprecisionで、非常に質の高いembeddingを作成することができました。</p><h3 id="K-means-amp-Word-Tour"><a href="#K-means-amp-Word-Tour" class="headerlink" title="K-means++ &amp; Word Tour"></a>K-means++ &amp; Word Tour</h3><p>embeddingをLightGBMのようなGBDTが解釈しやすい形にするため、球面K-means++と<a href="https://arxiv.org/abs/2205.01954">Word Tour</a>を組み合わせた手法で一次元に落とし込みました。Word Tourはembedding間の距離を元に巡回セールスマン問題(TSP)を解き、その順番でembeddingを並び替えるという手法で、これにより一次元上で距離の近い位置に似たembeddingが並ぶようになります。</p><p>これは決定木系の分割手法と相性がよく、<a href="https://www.kaggle.com/code/nadare/word-tour-experiment/notebook">Food101のデータセットでの検証を行った際</a>はPCAでの圧縮よりもはるかに高パフォーマンスに次元を圧縮することができました。また、Food101のラベルについてWord Tourを実施すると、ラベルは以下のように並ぶため、決定木との相性の良さがわかると思います。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eggs_benedict</span><br><span class="line">omelette</span><br><span class="line">lasagna</span><br><span class="line">pizza</span><br><span class="line">garlic_bread</span><br><span class="line">grilled_cheese_sandwich</span><br><span class="line">club_sandwich</span><br><span class="line">hamburger</span><br><span class="line">pulled_pork_sandwich</span><br><span class="line">lobster_roll_sandwich</span><br><span class="line">hot_dog</span><br></pre></td></tr></table></figure><p>巡回セールスマン問題はNP困難な問題であるのですが、私はこれに対し、K-means++で頂点数を減らしたうえで<a href="https://developers.google.com/optimization">OR-Tools</a>を用いることで手軽な実装で現実的な時間内にTSPの近似解を求めました。また、K-meansについてはcategoriesやnamesのembeddingだけでなくlatitudeとlongitudeでもK-means++を行いTSPで並び替えました。city, state, geo_nameなどのカテゴリもCountEncodingの他にhaversine距離に基づいてTSPを計算し並び替えを行いました。</p><p>K-means系の特徴量としては、Word Tourで並べなおしたK-meansのクラスタラベルと、各クラスタ中心までの距離をデータに紐づけました。</p><h2 id="retrieval-パート"><a href="#retrieval-パート" class="headerlink" title="retrieval パート"></a>retrieval パート</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>retrieval パートではGPU上で全組み合わせの計算ができる高速で簡単な手法で、取りこぼしが無いようモデルを構築しました。</p><h3 id="候補生成"><a href="#候補生成" class="headerlink" title="候補生成"></a>候補生成</h3><p>作成したembeddingやhaversine距離を元に一つのサンプルにつき32の候補を作成しLightGBMでの学習・予測に用いました。<br>候補生成は以下の五つの方法を用いました。これらはTensorFlowを用いてGPU上で計算を行ったので、全組み合わせについて愚直に計算することができました。</p><div class="scroll"><table><thead><tr><th>番号</th><th>処理の種類</th><th>取得数</th></tr></thead><tbody><tr><td>1</td><td>二点間のlatitude, longitudeから計算するhaversine距離による近傍</td><td>4</td></tr><tr><td>2</td><td>haversine距離とembeddingのコサイン類似度を用いた重回帰による近傍</td><td>12</td></tr><tr><td>3</td><td>nameの単語単位での一致度による近傍</td><td>4</td></tr><tr><td>4</td><td>nameの文字単位での一致度による近傍</td><td>8</td></tr><tr><td>5</td><td>nameのembeddingのコサイン類似度による近傍</td><td>4</td></tr></tbody></table></div><h4 id="haversine距離とembeddingのコサイン類似度を用いた重回帰による近傍"><a href="#haversine距離とembeddingのコサイン類似度を用いた重回帰による近傍" class="headerlink" title="haversine距離とembeddingのコサイン類似度を用いた重回帰による近傍"></a>haversine距離とembeddingのコサイン類似度を用いた重回帰による近傍</h4><p>2についてはhaversine距離の対数と各embeddingのコサイン類似度から重回帰を行いました。重回帰の学習はロジスティック回帰で行うよりも、正例がより高いスコアになるようランク学習を行うことでよりよい重回帰の係数を得ることができました。</p><h4 id="Bag-of-Words一致度による近傍"><a href="#Bag-of-Words一致度による近傍" class="headerlink" title="Bag of Words一致度による近傍"></a>Bag of Words一致度による近傍</h4><p>3, 4については単語単位、文字単位でのBag of Wordベクトルを作成し、コサイン類似度・precision・recallをもとめました。<br>precision・recallについては「フューチャー株式会社」をクエリ、「フューチャー」をターゲットとして文字単位で比較した際、<br>共通部分は「フューチャー」なので、以下のようになります。</p><ul><li>文字単位でのprecisionは len(フューチャー) &#x2F; len(フューチャー株式会社)で0.6、</li><li>文字単位でのrecallは len(フューチャー) &#x2F; len(フューチャー)で1.0</li></ul><p>このような手法を用いたのは、POIのペアとして「〇〇コンビニ」と「〇〇コンビニ　XXX店」のような組み合わせを多く見たからです。<br>Bag of Wordsベクトルをl2正規化した際のコサイン類似度と、precision, recallの大きい順に候補を取得し、同率の場合は重回帰のスコアで並べなおして上位を取得しました。</p><h4 id="候補生成の精度"><a href="#候補生成の精度" class="headerlink" title="候補生成の精度"></a>候補生成の精度</h4><p>この5つの手法で非対称な候補生成を行った結果、</p><div class="scroll"><table><thead><tr><th>近傍の取得方法</th><th>maxIoU(≒precision@32)</th></tr></thead><tbody><tr><td>retrievalのみ</td><td>0.9778</td></tr><tr><td>retrieval+postprocess</td><td>0.9935</td></tr></tbody></table></div><p>まで高めることができました。</p><h2 id="predict-パート"><a href="#predict-パート" class="headerlink" title="predict パート"></a>predict パート</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>predict パートでは、ある地点(query)とその候補(candidate)の1:1の間の特徴量を追加し、LightGBMで二値分類を行いました。<br>今回のデータはPOIのペアを持たないデータも多く、False Positiveが悪影響を与えやすかったので、それらを防ぐ工夫も検討しました。</p><h3 id="特徴量生成"><a href="#特徴量生成" class="headerlink" title="特徴量生成"></a>特徴量生成</h3><h4 id="query-candidateのそれぞれのカテゴリとword-tourの一次元の距離"><a href="#query-candidateのそれぞれのカテゴリとword-tourの一次元の距離" class="headerlink" title="query, candidateのそれぞれのカテゴリとword tourの一次元の距離"></a>query, candidateのそれぞれのカテゴリとword tourの一次元の距離</h4><p>IDごとにそれぞれのカテゴリやクラスタを計算し、queryとcandidateの両方のIDとマージしました。<br>また、Word Tourで求めたクラスタラベルについては一次元上での距離を計算しました。</p><h4 id="name-addressについてのゲシュタルトマッチング、レーベンシュタイン距離、ジャロ・ウィンクラー距離"><a href="#name-addressについてのゲシュタルトマッチング、レーベンシュタイン距離、ジャロ・ウィンクラー距離" class="headerlink" title="name, addressについてのゲシュタルトマッチング、レーベンシュタイン距離、ジャロ・ウィンクラー距離"></a>name, addressについてのゲシュタルトマッチング、レーベンシュタイン距離、ジャロ・ウィンクラー距離</h4><p>これらは文字列の類似度を計算する古典的な手法で、python内蔵の<a href="https://docs.python.org/ja/3/library/difflib.html">difflib</a>や、<a href="https://github.com/ztane/python-Levenshtein">Levenshtein</a>といったライブラリで計算することができます。CPUでの計算なので時間はかかりますが、有効な特徴量であったため、3種類の方法で加工したname, addressとname, addressの数字部分だけを抽出したものをこれらの手法で類似度を計算しました。</p><h4 id="name-addressについてのROUGE-N-ROUGE-L"><a href="#name-addressについてのROUGE-N-ROUGE-L" class="headerlink" title="name, addressについてのROUGE-N, ROUGE-L"></a>name, addressについてのROUGE-N, ROUGE-L</h4><p>ROUGEは文章要約タスクの良しあしを測るのにつかわれることが多い手法で、文章同士について一定の分割をした後、共通部分のprecision, recall, F値を計算します。ROUGE-NはN-gram、ROUGE-LはLCSを用いてROUGEを計算します。前者はTensorFlowのRaggedTensorを活用、後者はtensorflow-textにあるrouge_l関数を用いてGPU上で高速に計算しました。</p><h3 id="学習・予測"><a href="#学習・予測" class="headerlink" title="学習・予測"></a>学習・予測</h3><h4 id="学習データ"><a href="#学習データ" class="headerlink" title="学習データ"></a>学習データ</h4><p>学習はLightGBMを用い、特徴量の評価時はpidで分割した5foldでの計算、提出時は全データを用いてiteration数を決め打ちで学習を行いました。</p><h4 id="sample-weight"><a href="#sample-weight" class="headerlink" title="sample weight"></a>sample weight</h4><p>sample weightは他のPOIのペアをすべて当てられたうえで予測を間違えたときのIoUの損失をweightとしました。これは、前述のとおりTrue NegativeよりもFalse Positiveの方がスコアに対する悪影響が大きいからです。weightは正例で平均して0.8、負例で1.0になりました。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dev_data_df[<span class="string">&quot;weight&quot;</span>] = np.where(dev_data_df[<span class="string">&quot;label&quot;</span>],</span><br><span class="line">                                 <span class="number">1</span> - (dev_data_df[<span class="string">&quot;true_count&quot;</span>] - <span class="number">1</span>) / dev_data_df[<span class="string">&quot;true_count&quot;</span>],</span><br><span class="line">                                 <span class="number">1</span> - (dev_data_df[<span class="string">&quot;true_count&quot;</span>]) / (dev_data_df[<span class="string">&quot;true_count&quot;</span>]+<span class="number">1</span>))</span><br><span class="line">dev_data_df[<span class="string">&quot;weight&quot;</span>] = dev_data_df[<span class="string">&quot;weight&quot;</span>] / dev_data_df[<span class="string">&quot;weight&quot;</span>].mean()</span><br></pre></td></tr></table></figure><h4 id="LightGBMのハイパーパラメータ"><a href="#LightGBMのハイパーパラメータ" class="headerlink" title="LightGBMのハイパーパラメータ"></a>LightGBMのハイパーパラメータ</h4><p>LightGBMの基本的なハイパーパラメータはnum_leavesが2^12が最適で、学習率は0.1と高く、2000iterationsまで学習を行いました。これでもpidで分割したバリデーションデータでのAUCが上昇し続けました。</p><p>細かいパラメータとして、”max_bin_by_feature”を設定しました。LightGBMは学習の前に連続値をヒストグラムに変換し、最大でも255のbinにしてしまうのでそれ以上のカテゴリ数があると押しつぶされてしまいます。そこで、K-meansのラベルとcategoriesのラベルは255より大きな値になるように一部のカテゴリのmax_binを緩和するよう設定しました。”bin_construct_sample_cnt”は初期のヒストグラムを作るときのパラメータで、これを小さくすると精度が少し下がる代わりに学習前のヒストグラム構築におけるメモリと時間を節約できます。学習環境によってこれを変更しました。すべてのパラメータは以下の通りです。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lgb_params = &#123;</span><br><span class="line">    <span class="string">&quot;objective&quot;</span> : <span class="string">&quot;binary&quot;</span>,</span><br><span class="line">    <span class="string">&quot;metric&quot;</span> : <span class="string">&quot;auc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;boosting&quot;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;max_depth&quot;</span> : -<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_leaves&quot;</span> : <span class="number">2</span>**<span class="number">12</span> - <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;learning_rate&quot;</span> : <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&quot;bagging_freq&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;is_unbalance&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;max_bin_by_feature&quot;</span>: max_bin_by_feature,</span><br><span class="line">    <span class="string">&quot;bin_construct_sample_cnt&quot;</span>: <span class="number">200000</span>,</span><br><span class="line">    <span class="string">&quot;lambda_l1&quot;</span>: <span class="number">1.</span>,</span><br><span class="line">    <span class="string">&quot;lambda_l2&quot;</span>: <span class="number">1.</span>,</span><br><span class="line">    <span class="string">&quot;bagging_fraction&quot;</span> : <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;feature_fraction&quot;</span> : <span class="number">0.6</span>,</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="予測"><a href="#予測" class="headerlink" title="予測"></a>予測</h4><p>予測は500iterationのモデルを用いた時点で予測時に合計1時間以上かかることが分かったため、<a href="https://docs.rapids.ai/api/cuml/stable/api.html#cuml.ForestInference">cumlのForestInference</a>を活用しGPU上での予測を行いました。これにより100倍近くの高速化がされ、2000, 3000iterationのモデルを用いても実行時間内に予測を終えられました。LightGBMはfloat64で境界値やleaf valueを持つ一方、ForestInferenceはfloat32で計算を行うので若干の精度低下はあるものの、それ以上の高速化の恩恵を受けたため採用しました。</p><h2 id="Postprocess-パート"><a href="#Postprocess-パート" class="headerlink" title="Postprocess パート"></a>Postprocess パート</h2><p>Postpeocessパートでは、グラフとして予測されたペアをつなげることで拾いこぼしを拾って精度を上げました。</p><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><p>ペア同士の予測値を出した後は、一定の閾値を元にUnionFindで頂点同士を連結しグラフを構築しました。<br>各グラフに対して、NetworkXを用い、媒介中心性を元にした辺の排除を行った後、頂点間の距離が2以内の頂点のみを予測のペアとして出力を行いました。</p><h1 id="テクニック集"><a href="#テクニック集" class="headerlink" title="テクニック集"></a>テクニック集</h1><h2 id="メモリ増加のテクニック"><a href="#メモリ増加のテクニック" class="headerlink" title="メモリ増加のテクニック"></a>メモリ増加のテクニック</h2><p>Kaggleにコードを提出する際、実行には以下の二つの環境を選べます。</p><ul><li>4CPU 16GBRAM 9時間以内</li><li>2CPU 13GBRAM 1GPU 16GBRAM 9時間以内</li></ul><p>今回のコンペにとってはメモリが少なく、OOMを起こしやすい実行環境でした。<br>そこで私は以下の二つの工夫をしました。</p><ul><li>予測は10000行単位で特徴量生成→予測の流れで行う。</li><li>BoWの行列はTensorFlowのRaggedTensorやSparseTensorに変換し、embeddingと一緒にGPU RAMに配置する。</li></ul><p>embeddingをGPUに配置することで実質29GBのメモリを使えることになり余裕のある推論ができました。</p><h2 id="高速化のテクニック"><a href="#高速化のテクニック" class="headerlink" title="高速化のテクニック"></a>高速化のテクニック</h2><p>また、embeddingのコサイン類似度やROUGEの計算はGPUで行い、lgbmの推論もForestInferenceによるGPUでの推論を活用することで高速化できました。これのおかげで提出から結果が出るまでの時間はおよそ5時間で、4時間の余裕がありました。これを有効活用できなかったのは残念ですが、余裕をもって特徴量生成に集中することができました。</p><h2 id="各言語処理のテクニック"><a href="#各言語処理のテクニック" class="headerlink" title="各言語処理のテクニック"></a>各言語処理のテクニック</h2><p>中国語の分かち書きには<a href="https://tfhub.dev/google/zh_segmentation/1">zh_segmentation</a>、タイ語の分かち書き・ローマ字変換には<a href="https://pythainlp.github.io/">PyThaiNLP</a>を用いました。特にPyThaiNLPは機能とドキュメントが充実しており、タイ語の処理にはとても使いやすいなと感じました。<br>日本語の分かち書き・読み方の取得・ローマ字化は<a href="https://github.com/WorksApplications/SudachiPy">Sudachi</a>と<a href="https://github.com/miurahr/pykakasi">PyKakasi</a>を用いていて、特にSudachiについては日本語の表記ゆれの正規化まで取得できたのは利点でした。また、今回のタスクではSentencePieceの学習とSudachiのA mode(UniDic単位相当)の分割が相性良かったです。</p><h2 id="試したが効かなかったもの"><a href="#試したが効かなかったもの" class="headerlink" title="試したが効かなかったもの"></a>試したが効かなかったもの</h2><ul><li>Universal Sentence Encoderを用いたembedding特徴量の追加(LBが悪くなった)</li><li>Sentencepieceについてname, addressを同時に学習(precisionが下がった)</li><li>name, address embeddingへの畳み込みの追加(precisionが下がり、かつ遅くなった)</li><li>city, stateなどあまり質の高くないembeddingへのWord Tour(意味のある並びを得られなかった)<ul><li>Word Tourがうまくいくかはembeddingの質に大きく左右されます。</li></ul></li><li>転置インデックスを用いた候補生成(Pure Python実装だと遅かった)</li><li>LightGBMのTensorFlow実装(ForestInferenceを使う方がはるかに効率的だった)</li></ul><h1 id="リーク問題について"><a href="#リーク問題について" class="headerlink" title="リーク問題について"></a>リーク問題について</h1><p>今回のコンペは参加者が推論を行うコードを提出すると、参加者が直接見ることのできないtestデータで評価を行われPublicとPrivateのリーダーボードが更新されました。しかし、コンペ終了後運営のミスによってtestデータの67%がtrainデータと一致していた可能性が参加者から指摘されました。(trainデータのnameと緯度経度が完全一致するレコードについてLB上で検証が行われました。)7&#x2F;19時点で全提出について重複を排除したデータについて再評価が行われ、一部のチームに追加の賞金が支払われることが決まりました。</p><p>このリークにより金圏付近までの解法の良しあしの比較が困難になってしまいました。ただ、リークがあったにしろ上位の解法は納得のできるもので、私自身も自身の解法は他にも活用できる自信を持っています。このリークによって上位の解法の価値がなくなったわけではないことについて、理解が広まればいいなと考えています。</p><h1 id="謝辞"><a href="#謝辞" class="headerlink" title="謝辞"></a>謝辞</h1><p>今回のコンペは<a href="https://www.kaggle.com/takanobu0210">takapyさん</a>、<a href="https://www.kaggle.com/imazekishota">Shotaさん</a>、<a href="https://www.kaggle.com/matsumotoyuki">visionさん</a>、<a href="https://www.kaggle.com/koichirokamada">Kurutonさん</a>と一緒に参加しました。チームで協力してディスカッションやコードの整備、励ましあいを行ったおかげで、今回金メダルを獲得できたと思っています。まずはチームメンバーに強く感謝したいと思っています。</p><p>また、今回の解法に用いた技術やライブラリ、例えばSentencepieceやOR-Toolsは会社の勉強会等で教わり、SimCSEやWord Tourは日本語の勉強会で発表されたものを聞いて理解を深めていました。自分も積極的に発表を続け恩返しをしたいと思っています。</p><p>最後に、今回のコンペで一緒に戦い、ディスカッションを行ってくれたライバルたちにも感謝を込めて、本記事の終わりとさせていただきます。<br>連載の次の記事は 澁川さんの<a href="/articles/20220721a/">Redisのジオメトリ機能</a>です。お楽しみに！</p><h1 id="リンク"><a href="#リンク" class="headerlink" title="リンク"></a>リンク</h1><ul><li><a href="https://www.kaggle.com/competitions/foursquare-location-matching/discussion/335800">7th place solution(discussion)</a>: コンペ終了後に投稿したdiscussion、解法について質問があればこちらのdiscussionへどうぞ</li><li><a href="https://www.kaggle.com/code/nadare/7th-place-solution-inference">7th place solution inference(inference notebook)</a>: コンペで提出を行った推論用notebook</li><li><a href="https://www.kaggle.com/competitions/foursquare-location-matching/discussion/336148">Let’s discuss how to correspond to the name and address of each language!</a>: 各言語ごとの自然言語の前処理についてより詳しく説明したdiscussion</li><li><a href="https://www.kaggle.com/code/nadare/w2v-haversine-nn-baseline-training-inference">W2V &amp; haversine NN baseline[Training&#x2F;Inference]</a>: コンペ中に公開したsentencepieceを用いた候補生成のnotebook</li><li><a href="https://www.kaggle.com/code/nadare/word-tour-experiment">word tour experiment</a>: word tourをFood101で実験したnotebook</li></ul>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/Kaggle/">Kaggle</category>
      
      <category domain="https://future-architect.github.io/tags/TensorFlow/">TensorFlow</category>
      
      
      <comments>https://future-architect.github.io/articles/20220720a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>郵便番号・住所・緯度経度の体系について</title>
      <link>https://future-architect.github.io/articles/20220719b/</link>
      <guid>https://future-architect.github.io/articles/20220719b/</guid>
      <pubDate>Mon, 18 Jul 2022 15:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot; title=&quot;はじめに&quot;&gt;&lt;/a&gt;はじめに&lt;/h2&gt;&lt;p&gt;こんにちは。TIG DXユニット所属の今泉です。&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>こんにちは。TIG DXユニット所属の今泉です。<a href="/articles/20220719a/">地図・GIS・位置特定</a>連載の1本目です。</p><p>郵便番号・住所・緯度経度について調べる機会があり、自分なりに整理したものを記事にしてみます。<br>本記事ではシステム開発において、仕様レベルでの間違いを防ぐため「知っておいた方がいいだろうな」と思った内容をピックアップして紹介します。</p><h2 id="郵便番号"><a href="#郵便番号" class="headerlink" title="郵便番号"></a>郵便番号</h2><p>郵便番号は郵便物配送の分類に使用される番号で、日本では数字のみの7桁で表現されます。現在の郵便番号は1998年にそれまで5桁または3桁であった郵便番号を7桁に統一することで、町域までの指定ができるようになっています。</p><p>インターネットが普及した現在ではUX向上のため、郵便番号検索による住所補完などでも使用される機会が多いかと思います。本記事では詳しく取り上げませんが、郵便番号の一覧は「KEN_ALL.CSV」として公開されています。お世話になった方もいるのではないでしょうか？</p><p>日本郵便が公表している郵便番号マニュアルを確認してみましょう。</p><blockquote><p>けた数<br>7けたとします。（3けた目と4けた目の間にハイフンを入れます。）<br>使用文字<br>当分の間、算用数字のみを使用します。<br>郵便番号で表す範囲（図1参照）<br>ア<br>郵便番号は、町域（特別区又は市町村区域内の町又は字の区域をいいます。ただし、原則として、町の名称に「丁目」を使用している場合は、○丁目を除く部分が同一の区域とし、大字と小字に分かれている場合は、大字の区域とします。）および超高層ビルに設定します。<br>イ<br>小字又は通称には原則として、郵便番号は設定しません。ただし、当該小字又は通称が実質的に大字又は公称町名として扱われ、郵便物への記載が多い等必要な場合は、郵便番号を設定することがあります。  　</p></blockquote><p>※<a href="https://www.post.japanpost.jp/zipcode/zipmanual/p04.html">https://www.post.japanpost.jp/zipcode/zipmanual/p04.html</a> より　　　</p><p>ここで2点ほど注目しておきたい点があります。</p><p>1つが「<strong>当分の間</strong>、算用数字のみを使用」であることです。イギリスやカナダなどではZIPCODE(郵便番号)は6桁の英数字ですが、日本も将来的には算用数字以外が使用されることがあるかもしれません。</p><p>2つ目が町域以外にも<strong>高層ビルなどの建物</strong>に設定されることです。この場合、ビルの階ごとに郵便番号が割り振られているケースもあります。また、高層ビルに割り振られた郵便番号と混同しやすいもので配達数の多い<strong>大口事業所</strong>に個別に割り振られた<strong>大口事業所個別番号</strong>という郵便番号も存在します。</p><p>大口事業所個別番号は「KEN_ALL.CSV」にデータは存在せず、「jigyosyo.csv」として一覧データが公開されています。<br>※<a href="https://www.post.japanpost.jp/zipcode/dl/jigyosyo/readme.html">https://www.post.japanpost.jp/zipcode/dl/jigyosyo/readme.html</a></p><h3 id="郵便番号の構成要素"><a href="#郵便番号の構成要素" class="headerlink" title="郵便番号の構成要素"></a>郵便番号の構成要素</h3><p>郵便番号は基本的に以下のように構成されています。<br><img src="/images/20220719b/pic_01.png" alt="pic_01.png" width="979" height="406" loading="lazy"><br>※<a href="https://www.post.japanpost.jp/zipcode/zipmanual/p04.html">https://www.post.japanpost.jp/zipcode/zipmanual/p04.html</a> より　　</p><p>郵便区番号と呼ばれるものが旧3桁・5桁の郵便番号で、町域番号が7桁化に伴い付与されたものです。郵便区番号のうち上2桁を地域番号として使用し、原則1都道府県に1地域が割り当てられています。上2桁をみれば都道府県が特定できるのではないか？と思われるかもしれませんが、配送上の都合から別の番号が割り当てられている場合もあります。</p><p>※<a href="https://www.post.japanpost.jp/zipcode/dl/bangobo/zip_bgb.pdf">郵便番号簿</a>に地域番号の一覧が記載されています</p><p>また同様の理由や市区町村の合併などにより次のような郵便番号も存在します。</p><ul><li>都道府県を跨いで同じ郵便番号を持つ</li><li>市区町村を跨いで同じ郵便番号を持つ</li><li>1つの郵便番号で複数の町域を持つ</li></ul><p>※参考:<a href="https://qiita.com/_takwat/items/3a121656425fac7bb820">郵便番号や市区町村データを取り扱うときにはまったこと</a></p><h2 id="住所"><a href="#住所" class="headerlink" title="住所"></a>住所</h2><p>日本の住所は「東京都品川区大崎1丁目2番2号」という具合に広い地域から狭い地域の階層で表現するようになっています。</p><p>住所は私たちが日常的に使用する概念ではありますがその実、非常に複雑な階層構成となっており正規化が難しいです。というのも市区町村以下の住所階層については各自治体で取り決められていること、「住所」には2つのルールが存在することが原因です。</p><h3 id="住居表記と地番"><a href="#住居表記と地番" class="headerlink" title="住居表記と地番"></a>住居表記と地番</h3><p>住所の表示に当たっては「住居表示」と「地番」の二つの方法があります。</p><p>明治の地租改正以来、長らく日本の住所表記の役割を担っていたのは「地番」になります。しかし地番は本来課税や不動産投機のための土地の符号であり、それを住所の特定に流用されているもので特に市街地など建物が密集している土地においては不都合が多くありました。その解決策として導入されたのが1962年に制定された住居表示法に基づく住居表示制度です。住居表示は特に都市部に導入されており、政令指定都市では京都市を除いて採用されています。</p><h4 id="住居表示"><a href="#住居表示" class="headerlink" title="住居表示"></a>住居表示</h4><p>法務局に登記している土地の地番とは別に、各自治体が建物（施設）に対して住所をつける方法です。</p><p>一般的には1丁目1番1号のように表示しますが、〇丁目の部分にアルファベットが用いられたりと例外も多く存在します。</p><p>※有名な例では大阪市中央区上町は 1丁目,A, B, C で分かれています</p><h4 id="地番"><a href="#地番" class="headerlink" title="地番"></a>地番</h4><p>法務局に登記している土地の地番を使用します。</p><p>一般的には1番地111のようにすべて数字で表示されますが、1977年以前に採番された地番には漢字も使用されます。本記事ではほんの概要しか紹介しませんでしたが、これだけでも住所の正規化が非常に困難なものであることがご理解いただけるのではないでしょうか。住所データをシステムに落とし込む場合は十分配慮いただければと思います。また、郵便番号と住所に関わる様々なAPIを提供されている会社もあります。自身でのシステム化が難しいと感じたらこのようなサービスを利用されるのも一手です。</p><p>ケンオールさんは住所入力のつくり方について素晴らしい記事も書かれています。</p><ul><li><a href="https://kenall.jp/">ケンオール</a></li><li><a href="https://blog.kenall.jp/entry/address-form-best-practice">これだけは押さえよう！住所フォームの作り方</a></li></ul><p>住所については以下がより詳しく解説をされていますので、関心のある方はぜひ一読をおすすめします。</p><ul><li><a href="https://note.com/navitime_tech/n/n3e58f71fc97d">住所検索開発者が教える、知っておきたい日本の住所の話(第1回)</a></li><li>今尾恵介『住所と地名の大研究』 (新潮選書 2004)</li></ul><h2 id="緯度・経度"><a href="#緯度・経度" class="headerlink" title="緯度・経度"></a>緯度・経度</h2><p>まずは概念について整理しましょう。</p><ul><li>緯度<br>地球上のある地点が赤道からどれくらい北または南にはずれているかの度合を指します。その地点と地球の中心を結ぶ直線が赤道面となす角度によってあらわされます。<br>赤道を0度とし、赤道より北を北緯、南を南緯と表現し北極・南極がそれぞれ90度になります。</li><li>経度<br>地球上のある地点を含む経線と本初子午線のなす角度によってあらわされます。本初子午線よりも東側を東経、西側を西経と表現し、それぞれ180度まであります。<br>経度は時刻を定める基準ともなっており、日本の時刻の基準となる日本標準時（JST）は兵庫県明石市を通る東経135度の時刻です。</li></ul><h3 id="表記方法"><a href="#表記方法" class="headerlink" title="表記方法"></a>表記方法</h3><p>緯度経度の表記には度分秒表記と10進法表記の2種類があります。</p><h4 id="度分秒表記"><a href="#度分秒表記" class="headerlink" title="度分秒表記"></a>度分秒表記</h4><p>北緯35度(35°N),東経139度(139°E)のようにあらわします。ただしこの表記では大まかな地点しか表現できないため、より詳細な緯度経度を示す必要がある場合は「分」や「秒」に度数を分解します。</p><p>緯度経度の「1度」を1&#x2F;60に等分したものが「分」にあたり、「分」を1&#x2F;60したものが「秒」になります。ただし「秒」の小数点以下は10進法で表現します。</p><p>表記は「度」「分」「秒」の順に表記し、たとえば弊社の本社所在地は北緯35度37分20.494秒(35° 37’ 20.494”N),東経139度43分38.444秒(139° 43’ 38.444”E)となります。</p><h4 id="10進法表記"><a href="#10進法表記" class="headerlink" title="10進法表記"></a>10進法表記</h4><p>「度」だけで緯度経度を表した場合は10進法を使います。インターネット上のGISはこの表記を使用しています。この場合、方角を表すのに東西南北は使用せず、数の正負を利用します。</p><p>緯度は北緯をプラス、南緯をマイナスとします。<br>経度は東経をプラス、西経をマイナスとします。</p><p>先ほどの例ですと「35.62235961, 139.7273458」のように表現されます。</p><h4 id="表記の変換"><a href="#表記の変換" class="headerlink" title="表記の変換"></a>表記の変換</h4><p>以下の方法で変換可能です。</p><h5 id="度分秒⇒10進法"><a href="#度分秒⇒10進法" class="headerlink" title="度分秒⇒10進法"></a>度分秒⇒10進法</h5><p>「分」を60で、「秒」を3600で割り足し合わせることで変換できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：北緯35度37分22.3788秒</span><br><span class="line">35+(37 / 60) +(20.494 / 60 / 60) ≒35.622359</span><br></pre></td></tr></table></figure><h5 id="10進法⇒度分秒"><a href="#10進法⇒度分秒" class="headerlink" title="10進法⇒度分秒"></a>10進法⇒度分秒</h5><p>◆分<br>小数点以下に60を掛け（①）、整数部を使用<br>◆秒<br>①の小数部に60を掛けます</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：35.62235961</span><br><span class="line">度：35.62235961　⇒ 35度</span><br><span class="line">分：0.62235961 * 60 = 37.3415766 ⇒ 37分</span><br><span class="line">秒：0.3415766 * 60 = 20.494596‬秒</span><br></pre></td></tr></table></figure><h3 id="測地系"><a href="#測地系" class="headerlink" title="測地系"></a>測地系</h3><p>位置情報は一般的に緯度経度の座標を用いて表されますが、ある地点に対する緯度経度の値というは基準とする測量方法によって変わります。各基準によって測量された緯度経度座標系のことを「測地系」と呼びます。</p><p>現在日本が採用している測地系はVLBIやGNSSといった宇宙技術を活用して定められた「日本測地系2011(JGD2011)」で、ITRFITRF（国際地球基準座標系）に基づいた<strong>世界測地系</strong>です。</p><p>しかし2002年までは（旧）<strong>日本測地系</strong>と呼ばれる測地系を用いていました。これは世界測地系と比べると東京近辺で経度が約-12秒、緯度が約12秒変化しており、距離に換算すると北西へ450m程度のずれがあります。</p><p>※<a href="https://www.gsi.go.jp/sokuchikijun/datum-main.html#p1">国土地理院HP:日本の測地系</a></p><p>測地系の変換に当たっては<a href="https://vldb.gsi.go.jp/sokuchi/surveycalc/tky2jgd/main.html">国土地理院がサービスを提供しています</a>が、OSSも存在しますので参考にしてみてください。</p><p>※<a href="http://blog.livedoor.jp/g0031067/archives/51849093.html">GIS勉強会:測地系変換JavaScriptライブラリ(Proj4js)を使う</a></p><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>いかがでしたでしょうか？本記事では各概念についてほんの一部しか紹介できませんでしたが、少しでもお役に立てれば幸いです。<br>機会があれば次はPostGISやIMIコンポーネントツールあたりの記事も書いてみたいですね。</p><p>次は金子さんの<a href="/articles/20220720a/">Foursquare - Location Matching 参加記 (7th &#x2F; 1083) </a>です。</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Programming/">Programming</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E5%9C%B0%E5%9B%B3/">地図</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%88%9D%E5%BF%83%E8%80%85/">初心者</category>
      
      <category domain="https://future-architect.github.io/tags/%E9%83%B5%E4%BE%BF%E7%95%AA%E5%8F%B7/">郵便番号</category>
      
      <category domain="https://future-architect.github.io/tags/%E7%B7%AF%E5%BA%A6%E7%B5%8C%E5%BA%A6/">緯度経度</category>
      
      
      <comments>https://future-architect.github.io/articles/20220719b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>地図・GIS・位置特定に関する連載を始めます</title>
      <link>https://future-architect.github.io/articles/20220719a/</link>
      <guid>https://future-architect.github.io/articles/20220719a/</guid>
      <pubDate>Mon, 18 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220719a/location-g136a162ac_640.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;640&quot; loading=&quot;lazy&quot;&gt;


&lt;p&gt;TIG真野です。&lt;/p&gt;
&lt;p&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220719a/location-g136a162ac_640.png" alt="" width="640" height="640" loading="lazy"><p>TIG真野です。</p><p><a href="/articles/20220117a/">2022年のブログ連載予定を発表します</a>にあるように様々なブログ連載を開催していますが、すこしレイヤーを変えて「地図・GIS・住所・位置特定」周りをテーマにした企画を始めます。</p><h2 id="テーマについて"><a href="#テーマについて" class="headerlink" title="テーマについて"></a>テーマについて</h2><p>地理系の技術といえば、（GIS：Geographic Information System）が最もポピュラーかと思います。今回の連載のキッカケはどちらかといえば第1回目の今泉さんが「郵便番号周りについてめっちゃ調べる機会があった」という発言がトリガーでしたので、地図・住所など広めのテーマを採用としています。</p><img src="/images/20220719a/imaizumi.png" alt="" width="780" height="185" loading="lazy"><p>※連載のキッカケとなったコメント。技術ブログの種をシェア会というSlackチャネルにてネタを共有しています</p><h2 id="スケジュール"><a href="#スケジュール" class="headerlink" title="スケジュール"></a>スケジュール</h2><p>合計7名にて2週間かけて開催します。</p><div class="scroll"><table><thead><tr><th>Date</th><th>Title</th><th>Author</th></tr></thead><tbody><tr><td>2022&#x2F;7&#x2F;19（火）</td><td><a href="/articles/20220719b/">郵便番号・住所・緯度経度の体系について</a></td><td>今泉智義</td></tr><tr><td>2022&#x2F;7&#x2F;20（水）</td><td><a href="/articles/20220720a/">Foursquare - Location Matching 参加記 (7th &#x2F; 1083) </a></td><td>金子剛士</td></tr><tr><td>2022&#x2F;7&#x2F;21（木）</td><td><a href="/articles/20220721a/">Redisのジオメトリ機能 </a></td><td>澁川喜規</td></tr><tr><td>2022&#x2F;7&#x2F;22（金）</td><td><a href="/articles/20220722a/">住所情報から経路を探索する”そこそこ”な方法</a></td><td>塚本祥太</td></tr><tr><td>2022&#x2F;7&#x2F;25（月）</td><td><a href="/articles/20220725a/">Bluetoothで位置推定</a></td><td>岸下優介</td></tr><tr><td>2022&#x2F;7&#x2F;26（火）</td><td><a href="/articles/20220726a/">Plus Codeについて調べた</a></td><td>真野隼記</td></tr></tbody></table></div><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>フューチャー社内には「AWS相談室」や「Go相談室」といった様々な情報交換の場がありますが、2020年6月に「地図周りについて学ぶ部会」っていうチャットルームを作ったものの、有効活用できずモヤモヤしていました（やや作り逃げ的な…）。今回、こういった連載を始めるにあたって活用できたため嬉しく思います。後先考えずにやれるときはやるという動きもそこまで悪くないんだなと感じました。</p><img src="/images/20220719a/googlechat.png" alt="" width="294" height="60" loading="lazy"><p>※存在だけはしていたGoogle Chatグループ</p><p>今回の連載で、地図周りについて少しでも皆様に良い情報を共有できればと思います！この連載も定期的に開催できればと思います！</p><p>アイキャッチは<a href="https://pixabay.com/ja/users/megan_rexazin-6742250/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4496459">Megan Rexazin</a>による<a href="https://pixabay.com/ja/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4496459">Pixabay</a>からの画像です</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Infrastructure/">Infrastructure</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/">インデックス</category>
      
      <category domain="https://future-architect.github.io/tags/GIS/">GIS</category>
      
      <category domain="https://future-architect.github.io/tags/%E4%BD%8D%E7%BD%AE%E7%89%B9%E5%AE%9A/">位置特定</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%9C%B0%E5%9B%B3/">地図</category>
      
      
      <comments>https://future-architect.github.io/articles/20220719a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【メディア業界】新聞業界・基礎編</title>
      <link>https://future-architect.github.io/articles/20220715a/</link>
      <guid>https://future-architect.github.io/articles/20220715a/</guid>
      <pubDate>Thu, 14 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220715a/matthew-guay-Q7wDdmgCBFg-unsplash.jpg&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;596&quot; loading=&quot;lazy&quot;&gt;

&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220715a/matthew-guay-Q7wDdmgCBFg-unsplash.jpg" alt="" width="1200" height="596" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>こんにちは！2021年入社、TIGメディアユニット所属の岡田です。</p><p>この記事は<a href="/articles/20220616a/">「業界ドメインに詳しくなろう」シリーズ連載</a>の「メディア業界へのチャレンジ」基礎編です。</p><p>新聞業界を全く知らない方、これから関わるかもしれない方、ちょっとだけ興味がある方などなど、基礎編を一読すれば新聞業界を知る足がかりになるはずです。新聞業界（メディア業界）の変遷、新聞の種類と特徴、そして新聞の使命とは･･･新聞業界の基礎的要素を、新聞業界のDX実現に携わっているフューチャーの視点から紹介していきます。</p><h1 id="新聞業界（メディア業界）の変遷"><a href="#新聞業界（メディア業界）の変遷" class="headerlink" title="新聞業界（メディア業界）の変遷"></a>新聞業界（メディア業界）の変遷</h1><p>新聞業界（メディア業界）のこれまでを振り返ってみると、2000年以前、メディア影響力の観点ではメディア企業の記者数が資本であり、主役は新聞社でした。記者による書き手視点の記事が求められ、知識の深掘りによって蓄積してきたリソースが経営資源となっていました。</p><img src="/images/20220715a/メディアの変遷.jpg" alt="メディアの変遷" width="1200" height="499" loading="lazy"><p>2000年代に入ると、インターネットの普及に伴いメディアの情報量が増加し、誰でもコンテンツをつくれるようになりました。たくさんのコンテンツが集まるソーシャルメディアの台頭に伴い、インターネット上で大きな影響力をもつインフルエンサーが主役となりました。コンテンツ増加とソーシャルメディアに関する市場規模の拡大が進むこれからの時代におけるメディアは、コンテンツ自体が主導となり、コンテンツの質・量、そして読み手視点のコンテンツが求められます。</p><p>メディア影響力の変化が新聞業界へと波及する中、新聞は紙媒体だけでなく、様々な媒体に姿を変えて情報を発信しています。新聞社がソーシャルメディアを活用し、ユーザ起点で「読み手視点のコンテンツ」を実現した例として、朝日新聞社の「withnews」<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>があります。</p><p>withnewsは新聞を読まない世代を取り込むためのユーザ参加型ニュースサイトで、サイト上から取材リクエストを募り、実際に同社の記者が記事化を行います。また、ネット上で話題になっている情報の調査なども実施しています。</p><h1 id="新聞の種類と特徴"><a href="#新聞の種類と特徴" class="headerlink" title="新聞の種類と特徴"></a>新聞の種類と特徴</h1><p>新聞の種類は、新聞の発行範囲によって「全国紙」、「ブロック紙」、「地方紙」などに分類されます。（地方紙よりさらに狭い範囲では「地域紙」があります。）また、産業経済紙やスポーツ紙など専門紙・業界紙があります。</p><p>全国紙は基本的に全国共通のページと地域に関するページで構成されており、地方のニュースは地域版（地域面）に掲載されます。一方でブロック紙・地方紙は全国紙と違い、全国紙で扱うニュース（全国的なニュースや海外のニュース）については、主に共同通信社や時事通信社などの通信社から配信された記事を掲載します。地元取材に注力して、地域に密着したニュースを報じているのが特徴です。</p><p>新聞を製作している新聞社の事業は、ラジオやテレビ局、雑誌や書籍の出版、芸術・文化事業、プロ野球チームなど多岐に渡ります。</p><p>新聞と同じメディアでもテレビやラジオについては放送法で規制されており、許認可が必要であるため中立的な立場であると言われています。対して新聞は許認可が不要であり、取材に基づいた報道と、社説で新聞社としての意見も言及しています。社説において各新聞の個性や特徴が表れるといっても過言ではありません。</p><p>※参考「新聞の創刊年表」･･･全国紙・ブロック紙からピックアップして記載（岡田調べ）</p><p>興味のある方は、時代とともに歩んできた新聞の歴史をぜひ調べてみてください。<br><img src="/images/20220715a/新聞年表.jpg" alt="新聞年表" width="1200" height="675" loading="lazy"></p><h1 id="新聞の使命とは"><a href="#新聞の使命とは" class="headerlink" title="新聞の使命とは"></a>新聞の使命とは</h1><p>昨今、読者の減少に伴う新聞発行部数の減少についてはご存知の方が多いと思いますが、改めて新聞の使命について考えてみましょう。<br>本記事では、宮城県石巻市にある石巻日日新聞社の事例<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>を紹介します。</p><p>2011年の東日本大震災時、石巻日日新聞社は津波と停電被害で、新聞が発行できなくなりました。</p><p>石巻日日新聞社の方々は、「今こそ地域に役に立つ情報を発信しなければならない」と考え、手書きで壁新聞を6日間にわたって避難所に掲示しました。はじめは、主に被害情報を載せていましたが、被災した人々の気持ちに寄り添い、支援物資の情報やボランティア情報など「希望が持てる情報」を発信するようになりました。地域密着型で地域に寄り添う地方紙（地域紙）の一面を感じられる事例です。</p><p>石巻日日新聞社の事例から考えられる新聞の使命とは、「日々起きているニュースを報じること」です。特に災害時、情報を多くの人に伝えることが重要な使命だといえます。紙媒体である新聞は、災害時に大きな力を発揮します。インターネット上で様々な情報が飛び交うなか、新聞は取材に基づき、裏付けされた確かな情報を人々に届ける役割を担っているのではないでしょうか。</p><p>※もうひとつ参考として「犠牲者の行動記録」<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> を紹介します。東日本大震災から5年後、岩手日報社と首都大学東京の渡邊英徳研究室は岩手県における震災犠牲者1326人の地震発生時から津波襲来時までの避難行動をまとめ、航空写真・地図と組み合わせて可視化したデジタルアーカイブ「忘れない～震災犠牲者の行動記録」<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>を制作しました。津波襲来時の所在を遺族に取材して、データ収集を行っています。岩手日報紙面では、このアーカイブを活用して避難行動について分析・提言しています。</p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p>新聞業界（メディア業界）の基礎編、いかがだったでしょうか。</p><p>新聞の発行部数の減少、新たなメディアの台頭やデジタルビジネスへの出遅れなど、危機的状況から脱却するためにフューチャーが行った新聞業界（メディア業界）へのチャレンジとは･･･？</p><p>次回は、新聞社の編集業務、そしてフューチャーのメディア業界へのチャレンジと実際の取り組みについて紹介する予定です。</p><p>お楽しみに！</p><p>アイキャッチ画像は、<a href="https://unsplash.com/@maguay?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Matthew Guay</a> on <a href="https://unsplash.com/s/photos/media?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a> です。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">朝日新聞社「withnews」：<a href="https://withnews.jp/">https://withnews.jp/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="vertical-align: top; padding-right: 10px;">2.</span><span style="vertical-align: top;">被災地（ひさいち）に希望をあたえた壁（かべ）新聞 - NHK：<a href="https://www2.nhk.or.jp/school/movie/clip.cgi?das_id=D0005311033_00000">https://www2.nhk.or.jp/school/movie/clip.cgi?das_id=D0005311033_00000</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="vertical-align: top; padding-right: 10px;">3.</span><span style="vertical-align: top;">犠牲者の行動記録 | 岩手日報 IWATE NIPPO：<a href="https://www.iwate-np.co.jp/page/kodokiroku">https://www.iwate-np.co.jp/page/kodokiroku</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="vertical-align: top; padding-right: 10px;">4.</span><span style="vertical-align: top;">「忘れない～震災犠牲者の行動記録」：<a href="https://iwate.mapping.jp/index_jp.html">https://iwate.mapping.jp/index_jp.html</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Business/">Business</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E6%A5%AD%E7%95%8C/">メディア業界</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9/">ビジネス</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%A5%AD%E7%95%8C%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3/">業界ドメイン</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%96%B0%E8%81%9E%E6%A5%AD%E7%95%8C/">新聞業界</category>
      
      
      <comments>https://future-architect.github.io/articles/20220715a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【エネルギー業界】LPガス基礎part4 バルク配送入門</title>
      <link>https://future-architect.github.io/articles/20220713a/</link>
      <guid>https://future-architect.github.io/articles/20220713a/</guid>
      <pubDate>Tue, 12 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>はじめまして。Future・TechnologyInnovationGroup（TIG）の荒井です。</p><p>この記事はエネルギー業界のドメインに詳しくなろうという試みの一環で、<a href="/articles/20220519a" title="LPガス業界の超入門編">LPガス業界の超入門編</a>を踏まえて、バルク貯槽を用いたLPガス供給の入門編を紹介していきます。今回は、バルクとは何か、バルクによるガス供給の流れ、抱えている問題について紹介します。</p><h1 id="LPガスとその用途"><a href="#LPガスとその用途" class="headerlink" title="LPガスとその用途"></a>LPガスとその用途</h1><h3 id="LPガスとは"><a href="#LPガスとは" class="headerlink" title="LPガスとは"></a>LPガスとは</h3><p>「Liquefied Petroleum Gas」の頭文字をとってLPガスと呼ばれています。<br> 種類はプロパンとブタンの2種類があり、主に一般家庭ではプロパンが使われています。（ブタンの利用で身近なものは、例えばタクシーの燃料などに利用されたりします）</p><p> LPガスの消費者は民生&#x2F;産業用の大きく2種類に分けられ、民生向けは一般家庭以外にも飲食店や医療施設など、産業向けには自動車や造船などの加工・組立産業、太陽電池や半導体などエレクトロニクス産業など、様々な消費者へ供給しています。</p><img src="/images/20220713a/LPGとは.png" alt="LPGとは.png" width="457" height="328" loading="lazy"><p>※画像は<a href="https://www.lpgc.or.jp/images/LPgasgide2022.pdf">https://www.lpgc.or.jp/images/LPgasgide2022.pdf</a> より</p><h3 id="一般家庭での用途"><a href="#一般家庭での用途" class="headerlink" title="一般家庭での用途"></a>一般家庭での用途</h3><p>イメージしやすいところで、一般家庭での用途は、ガスコンロや給湯器といった生活に欠かせないエネルギーとして広く利用されています。</p><img src="/images/20220713a/身の回りのガス機器.png" alt="身の回りのガス機器.png" width="914" height="561" loading="lazy"><p>※画像は<a href="https://www.lpgc.or.jp/images/LPgasgide2022.pdf">https://www.lpgc.or.jp/images/LPgasgide2022.pdf</a> より</p><h3 id="LPガスの流通経路"><a href="#LPガスの流通経路" class="headerlink" title="LPガスの流通経路"></a>LPガスの流通経路</h3><p>このように様々な用途で利用されているLPガスはどのように流通しているのでしょうか。<br>LPガスの7～8割は海外から原油を輸入・精製し、二次基地や充填所などを経由して消費者に届けられます。</p><img src="/images/20220713a/img10.gif" alt="img10.gif" width="900" height="761" loading="lazy"><h3 id="LPガスを貯蔵する設備と供給方法"><a href="#LPガスを貯蔵する設備と供給方法" class="headerlink" title="LPガスを貯蔵する設備と供給方法"></a>LPガスを貯蔵する設備と供給方法</h3><p>LPガスを貯蔵する設備は主に2種類あります。</p><p>一つ目は、一般家庭でおなじみの「ボンベ」。二つ目は、なじみは薄いですが、集合住宅や飲食店などＬＰガスを多く利用する消費者に向けた「バルク」というものがあります。<br>この二つの大きな違いは、供給方法にあります。ボンベは空になると満タンのボンベと容器<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>ごと交換しますが、バルクは軒先に固定されているため交換ができません。バルクローリーという車両でガスを運び、直接補充（充填という）します。</p><p>【ボンベとバルク】</p><img src="/images/20220713a/ボンベとバルク.png" alt="ボンベとバルク.png" width="941" height="387" loading="lazy"><p>※画像は以下より <br><a href="http://godo-gas.co.jp/godo-gas/">http://godo-gas.co.jp/godo-gas/</a> <br><a href="http://www.nichidankyo.gr.jp/toku/chapter07/pdf/ch07_07.pdf">http://www.nichidankyo.gr.jp/toku/chapter07/pdf/ch07_07.pdf</a> </p><p>【バルクローリー】<br><img src="/images/20220713a/LPタンクローリー種類.png" alt="LPタンクローリー種類.png" width="961" height="674" loading="lazy"></p><p>※画像は<a href="https://www.khk.or.jp/Portals/0/resources/information/others/dl/2017LPpoint.pdf">https://www.khk.or.jp/Portals/0/resources/information/others/dl/2017LPpoint.pdf</a> より</p><h3 id="LPガス供給までの流れ"><a href="#LPガス供給までの流れ" class="headerlink" title="LPガス供給までの流れ"></a>LPガス供給までの流れ</h3><p>集合住宅を例にして、LPガスが消費者に届くまでの流れをイメージしてみます。<br>①はじめに、アパート等を所有する大家さんとLPガス供給会社で無償貸与契約を結んだあと、②LPガス供給会社が所有する容器（ボンベ・バルク）を集合住宅（需要場所）に設置します。③入居者はLPガス供給会社と小売契約を結び、LPガス供給会社から定期的にガス供給を受けます。（入居者はガス使用量に応じた料金を支払う）</p><img src="/images/20220713a/ガス供給までの流れ.png" alt="ガス供給までの流れ.png" width="535" height="380" loading="lazy"><h1 id="バルク配送入門"><a href="#バルク配送入門" class="headerlink" title="バルク配送入門"></a>バルク配送入門</h1><h3 id="配送業務の流れ"><a href="#配送業務の流れ" class="headerlink" title="配送業務の流れ"></a>配送業務の流れ</h3><p>バルクを需要場所に設置した後、日々の配送業務はどのように行われるのでしょうか。<br>LPガス供給会社は、抱えている供給先の需要を予測しながら、以下のような業務を行っています。</p><img src="/images/20220713a/image.png" alt="image.png" width="1096" height="407" loading="lazy"><p><strong>①ガス仕入</strong></p><p>年間計画に基づき、一定期間分（年間・月間など）の大枠の仕入量を卸会社と契約します。日々の配送により、ある程度精緻な仕入量が分かった段階で基地にガスの払い出し量を通知します。（例えば3日ごとなど）</p><p><strong>②配送計画</strong><br>日々の配送で充填したガス量と各消費者の需要を予測し、一定基準の残量に減るタイミングで配送を予定します。</p><p><strong>③ガス充填</strong><br>配送計画に基づいて、配送員はバルクローリーを運転して、需要場所に移動しLPガスを充填します。</p><p><strong>④保安点検</strong><br>配送員は充填と合わせて、法律で定められた保安点検を行います。<br>火気と適切な距離がとられているか、ガス漏れしていないか、設備に腐食がないか、などの点検を行います。充填における点検は設備によって３つの法律（液石法・簡易ガス法・高圧法）で管理されており、それぞれ法定点検の内容が変わります。</p><h3 id="バルク配送の特徴"><a href="#バルク配送の特徴" class="headerlink" title="バルク配送の特徴"></a>バルク配送の特徴</h3><p><strong>１．運送業としての特徴</strong><br>LPガスを配送する業務は、運送業に分類されます。<br>バルクの配送はボンベと比べ、供給先が少ない一方で供給先が離れており配送距離が長いという特徴があります。また、貯蔵量と需要量が大きく、日に何度か充填工場に立ち寄り、車両にガスを継ぎ足しながら配送を行います。</p><p><strong>２．基地・充填工場の特徴</strong><br>車両のガスを継ぎ足す際に立ち寄る基地・充填工場には、様々な制約があります。<br>利用できる時間が夕方までと早かったり、回数制限や車両の大きさに制限があったりします。配送計画はこういった複雑な条件を加味しながら立てることになり、属人化につながりやすくなります。</p><p><strong>３．配送員の特徴</strong><br>バルクの配送員は、民生用バルクローリ（充てん設備）で、LPガスのバルク供給設備への充てん等の作業を行うため、「充てん作業者」という国家資格の取得が必要になるエッセンシャルワーカーです。<br>バルクの配送員は基地・充填工場の利用時間制限に合わせて配送するため、始業が早くなる場合が多いという特徴もあります。</p><p><strong>４．バルク供給設備の特徴</strong><br>バルク供給設備には定期検査を行う必要がありますが、初回の検査までの期間が20年とかなり長いという特徴があります。初回検査後は、5年ごとに再検査が必要になります。</p><p><strong>５．供給先の特徴</strong><br>バルクは民生&#x2F;産業用と広く利用されますが、使用量が比較的多い場合に利用されることが多く、その使い方も常に使用量が多い場合や突発的に使用する場合など様々です。<br>ある日突然使用量が急増するような場合、需要を予測することが難しくなるため、そういった顧客については、残量警報器を設置しているというのもバルクの特徴になります。<br>残量警報器は、一定の残量率を下回ると電話回線を通じてFax等で配送を行う会社に通知してくれる仕組みです。</p><p><strong>６．配送料金の仕組み</strong><br>バルク配送における配送料は、主に２つの考え方があります。<br>一つ目は、充填した量に応じて請求を行うもの。二つ目は、消費したガス量に応じて請求を行うものです。</p><h1 id="バルクのかかえる課題"><a href="#バルクのかかえる課題" class="headerlink" title="バルクのかかえる課題"></a>バルクのかかえる課題</h1><p>前述の「運送業としての特徴」で触れた配送距離が長いという特徴が、バルク配送の課題になっています。配送距離が長いということは、拘束時間が長くなり、長時間労働へ直結することになります。<br>バルク配送に限らず、ヤマト運輸や佐川急便といった荷運びの運送業でも同様で、政府としてもこの問題に対応すべく、2024年から働き方改革が施行されます。（下表、自動車運転の業務の猶予期間が終わる）</p><p><strong>2024年問題の概要</strong></p><p>2024年問題とは時間外労働の上限規制によるトラック等ドライバーの労働環境改善です。<br>配送員には年間960hの労働時間キャップが設けられます。</p><img src="/images/20220713a/image_2.png" alt="image.png" width="966" height="691" loading="lazy"><p>施行前にくらべ、配送できる量が制限されることになり、運送会社（LPガス供給会社）の観点では、配送料の値上げをして売上・利益を維持するか、売上利益を減らして顧客を維持するか、迫られることが懸念されます。</p><p>また、ドライバー（配送員）の観点では、走行距離が減少、結果運行手当が減るため収入減少につながり、離職が増えるという問題への発展が懸念されます。</p><img src="/images/20220713a/image_3.png" alt="image.png" width="1200" height="547" loading="lazy"><p>この問題を解決するためには、昨今叫ばれている配送シェアリングといった仕組みを業界として取り入れていくなど、早急な対応がLPガス供給会社として生き残るための課題になると考えます。</p><p>次回はこの課題について背景や今後の展望に触れていきたいと思います。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="vertical-align: top; padding-right: 10px;">1.</span><span style="vertical-align: top;">LPガスを入れる器を容器と呼ぶ</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Business/">Business</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9/">ビジネス</category>
      
      <category domain="https://future-architect.github.io/tags/%E6%A5%AD%E7%95%8C%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3/">業界ドメイン</category>
      
      <category domain="https://future-architect.github.io/tags/LP%E3%82%AC%E3%82%B9%E6%A5%AD%E7%95%8C/">LPガス業界</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A8%E3%83%8D%E3%83%AB%E3%82%AE%E3%83%BC%E6%A5%AD%E7%95%8C/">エネルギー業界</category>
      
      
      <comments>https://future-architect.github.io/articles/20220713a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>FutureCon2022 を開催します（7/18海の日）</title>
      <link>https://future-architect.github.io/articles/20220712a/</link>
      <guid>https://future-architect.github.io/articles/20220712a/</guid>
      <pubDate>Mon, 11 Jul 2022 15:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;img src=&quot;/images/20220712a/top.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;435&quot; loading=&quot;lazy&quot;&gt;


&lt;h1 id=&quot;はじめに&quot;&gt;&lt;a href=&quot;#はじめに&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<img src="/images/20220712a/top.png" alt="" width="1200" height="435" loading="lazy"><h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>フューチャーでは<a href="/tags/TechNight/">Future Tech Night</a>という名称で勉強会を開催していました。これを進化させて初めてとなる <strong>FutureCon</strong> というテックカンファレンスを有志で開催します。</p><p>様々なテーマ（フロントエンド、バックエンド、インフラストラクチャ、マネジメント、開発手法、OSS）でフューチャーの各領域のスペシャリストが登壇しますので、楽しんでいただけたらと思います。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul><li>全29セッション（29名）で開催します</li><li>各セッション25分程度</li><li>3トラック用意します！</li><li>時期<ul><li>7&#x2F;18（月）海の日 10~18時</li><li>詳しくはタイムテーブルを御覧ください！</li></ul></li></ul><h2 id="申込み方法"><a href="#申込み方法" class="headerlink" title="申込み方法"></a>申込み方法</h2><ul><li><a href="https://future.connpass.com/event/254304/">https://future.connpass.com/event/254304/</a> から参加申し込みください</li><li>登録いただけると、YouTube URLを当日（前日）に共有いたします。</li></ul><h2 id="タイムテーブル"><a href="#タイムテーブル" class="headerlink" title="タイムテーブル"></a>タイムテーブル</h2><ul><li><font color="#34a853">Beginner 初心者向け</font></li><li>Intermediate 中級レベル</li><li><font color="#ff6d01">Advance 上級レベル</font></li></ul><div class="scroll"><table><thead><tr><th></th><th>Track A</th><th>Track B</th><th>Track C</th></tr></thead><tbody><tr><td>10:00</td><td>開場</td><td></td><td></td></tr><tr><td>10:30</td><td>キーノート by 柴田健一  （<a href="https://youtu.be/5CavMJTxSqw">動画</a>）</td><td></td><td></td></tr><tr><td>11:00</td><td>工場IoTにおけるエッジレス制御基盤の設計と実装 by 辻大志郎 （<a href="https://youtu.be/q1pq09CgkMI">動画</a>）</td><td><font color="#ff6d01">Vue 最新構文 &lt;script setup&gt; の紹介 by 太田洋介 （<a href="https://youtu.be/hg0yvFpqP8M">動画</a>）</font></td><td><font color="#34a853">ベストプラクティス・ドリフト ～技術選定におけるベストプラクティスの老朽化にどう抗うか～ by 原木翔 （<a href="https://youtu.be/4E0zHLc2DwQ">動画</a>）</font></td></tr><tr><td>11:30</td><td>Datalakeにおける認証・認可 検討ポイント紹介 by 山田勇一 （<a href="https://youtu.be/KIGNI_gFoco">動画</a>）</td><td><font color="#34a853">&lt;p&gt; に &lt;div&gt; をいれてはいけない by 枇榔晃裕（<a href="https://youtu.be/13OI8vf6rfk">動画</a>）</font></td><td>How to become a Software Architecture  アーキテクティング入門 by 真野隼記 （<a href="https://youtu.be/aBkDy79l9Zo">動画</a>）</td></tr><tr><td>12:00</td><td>lunch🍝</td><td>🍜</td><td>🍙</td></tr><tr><td>12:30</td><td>lunch🍝</td><td>🍜</td><td>🍙</td></tr><tr><td>13:00</td><td>組織と成長するIaC by 伊藤太斉 （動画準備中）</td><td><font color="#34a853">エンタープライズにおける画面設計・開発のコツ by 柏木祥子 （<a href="https://youtu.be/nbnG9ztt-B0">動画</a>）</font></td><td>Tomcat Clustering on the Cloud(AWS) by 藤野圭一 （<a href="https://youtu.be/9jCr9YrsUM4">動画</a>）</td></tr><tr><td>13:30</td><td>手戻りさせないAWS設計 by 村瀬善則  （<a href="https://youtu.be/QEuynVXXqEg">動画</a>）</td><td>FlutterアプリのPerformance測定 by 藤田春佳 （<a href="https://youtu.be/NCBPZQHW8wY">動画</a>）</td><td><font color="#34a853">DBのデータ移行って何するの？エンタープライズ系システムをクラウドリフトするときに考えること by 山崎悠希 （<a href="https://youtu.be/nGXKJTalhHw">動画</a>）</font></td></tr><tr><td>14:00</td><td>LakeFormationによるアクセスコントロール by 八巻達紀 （<a href="https://youtu.be/HeCiY9x4s_A">動画</a>）</td><td>Flutter Golden Testのすすめ by 武田大輝 （<a href="https://youtu.be/qC-jts8pZJ4">動画</a>）</td><td><font color="#34a853">2022 年の Airflow の概況 by 多賀聡一朗 （<a href="https://youtu.be/MRJsa-zPTRc">動画</a>）</font></td></tr><tr><td>14:30</td><td>休憩☕</td><td>🥤</td><td>🍵</td></tr><tr><td>15:00</td><td>脆弱性とどう向き合うか by 井上圭 （<a href="https://youtu.be/pM-rH3ReF7Y">動画</a>）</td><td><font color="#34a853">社用PC環境における最強のメモアプリ？Obsidianを使った情報管理のススメ by 越島亮介 （<a href="https://youtu.be/tI25qliXp0E">動画</a>）</font></td><td><font color="#ff6d01">27周年のデザインパターンとどう付き合う？ by 澁川喜規 （<a href="https://youtu.be/G9hVXmlc5NQ">動画</a>）</font></td></tr><tr><td>15:30</td><td>深層学習を用いた自然言語処理の基本 by 玉木竜二 （<a href="https://youtu.be/jBqcdpZ6d7E">動画</a>）</td><td>ー</td><td><font color="#34a853">チームで機能設計するためのPlantUML標準化 by ヴー ホアンミン （<a href="https://youtu.be/AQsc8VC55j8">動画</a>） </font></td></tr><tr><td>16:00</td><td><font color="#ff6d01">SSO導入事例から見た認証設計の傾向と分析 by 李光焄 （<a href="https://youtu.be/oEYKo2Vfw-Q">動画</a>）</font></td><td><font color="#34a853">PostgreSQLとNewSQL（YugaByteDB）を比較してみた by 大塚雄太 （<a href="https://youtu.be/g5FJ0wHqKpQ">動画</a>）</font></td><td>AWS Amplifyで小さく始めるWeb開発 by 筒井悠平  （<a href="https://youtu.be/o3tbZYbmX4M">動画</a>）</td></tr><tr><td>16:30</td><td>休憩☕</td><td>🥤</td><td>🍵</td></tr><tr><td>16:45</td><td>XR技術紹介 by 阿保渚 （<a href="https://youtu.be/igdJHdTWK14">動画</a>）</td><td>N:Nツリー構造データにおけるグラフDB活用 by 村田靖拓 （<a href="https://youtu.be/7N7CAQ3N5JI">動画</a> ）</td><td>RustのWebフレームワーク周りの概観 by 本田紘規   （<a href="https://youtu.be/APeoMD5TJ_o">動画</a>）</td></tr><tr><td>17:15</td><td>エッジデバイスにおける動画像AI推論 by 岸下優介 （<a href="https://youtu.be/M1YOrK7Ll7w">動画</a>）</td><td><font color="#ff6d01">クラウドネイティブ時代のDWH by 杉江伸祐</font> （<a href="https://youtu.be/UQZBw021R9g">動画</a>）</td><td>ー</td></tr><tr><td>17:45</td><td>閉幕</td><td></td><td></td></tr></tbody></table></div><h2 id="各セッションについて"><a href="#各セッションについて" class="headerlink" title="各セッションについて"></a>各セッションについて</h2><p>各セッションの詳細について説明します。</p><h3 id="キーノート"><a href="#キーノート" class="headerlink" title="キーノート"></a>キーノート</h3><p>以下について、お話します。</p><ol><li>カンファレンスの開始宣言</li><li>技術組織のビジョンやミッション、組織・会社の変わらない考え方や覚悟など、技術組織が大切にしていること・考えていることについてのお話</li><li>世の中と照らし合わせた際の、エンタープライズ領域のアーキテクチャが未来にどうなっていくのか？そこに対して技術の目利きなどのヒントのお話</li></ol><h3 id="Track-A"><a href="#Track-A" class="headerlink" title="Track A"></a>Track A</h3><div class="scroll"><table><thead><tr><th>No</th><th>Title</th><th>Abstract</th></tr></thead><tbody><tr><td>1</td><td>工場IoTにおけるエッジレス制御基盤の設計と実装<br>by 辻大志郎</td><td>従来は工場の拠点に物理サーバを置くことが一般的であるが、可用性を担保するための機器を含めたサーバの調達・保守コストが大きくなる点や物理サーバの管理煩雑性が課題でした。 エッジコンピューティングに求める数ミリ秒のような低レイテンシが不要な場合などは、エッジにサーバをおかず、クラウドから直接工場の機器を制御するようなアーキテクチャをとることができます。 本セッションではFactoryIoTにおけるエッジレスアーキテクチャの設計と実装、運用した所感を全部乗せでお伝えします。</td></tr><tr><td>2</td><td>DataLakeにおける認証・認可 検討ポイント紹介<br>by 山田勇一</td><td>データレイク（データ収集、蓄積基盤）におけるID統合、設計ポイント、認証・認可の考え方の知見を発表します。</td></tr><tr><td>3</td><td>組織と成長するIaC<br>by 伊藤太斉</td><td>クラウドインフラはサービスに応じて容易にスケールさせることがメリットでありますが、それらを管理するソースコードも同様にスケーラビリティがなければいけません。 このセッションでは、スケーラビリティのあるソースコードとは、継続的に改善するための糸口とは、をお話できればと思います。</td></tr><tr><td>4</td><td>手戻りさせないAWS設計<br>by 村瀬善則</td><td>クラウドはオンプレミスと比較して容易にインフラ構築ができるからと言って最初に設計しておかないと後になって容易に修正できない事態に陥ります。 では最初に設計すべきことは何でしょうか？私が気を付けているポイントを紹介します。</td></tr><tr><td>5</td><td>LakeFormationによるアクセスコントロール<br>by 八巻達紀</td><td>「安全なデータレイクを数日で簡単にセットアップできるサービス」とうたわれているLakeFormationの特徴と、その一つである、緻密で一元的なアクセスコントロールについて、チュートリアルを通して、説明します。</td></tr><tr><td>6</td><td>脆弱性とどう向き合うか<br>by 井上圭</td><td>日々発見される脆弱性に、我々はどう向き合うのが良いのだろうか。その謎を解明するため、我々調査隊はアマゾンの奥地へと向かった――。<br>脆弱性はどのように見たらよいのか、どのように対応したほうが良いのか、対応する為にはどのような準備が必要なのか、をお伝えします。</td></tr><tr><td>7</td><td><font color="#ff6d01">SSO導入事例から見た認証設計の傾向と分析<br>by 李光焄</font></td><td>今まで携わってきたSSO導入事例を上げながら、認証設計の傾向とパターンごとの運用・メンテナンス・導入コスト面でのトレードオフについて語ります。</td></tr><tr><td>8</td><td>深層学習を用いた自然言語処理の基本<br>by 玉木竜二</td><td>Futureでは深層学習を用いたワクチン開発の効率化の研究・開発を行っていました。このワクチン開発では、人間が扱う言語をコンピュータで扱う自然言語処理の分野の技術を用いています。本発表では初心者向けの深層学習を用いた自然言語処理について説明します。</td></tr><tr><td>9</td><td>XR技術紹介<br>by 阿保渚</td><td>XRを用いたプロダクト開発で培った技術について紹介します。</td></tr><tr><td>10</td><td>エッジデバイスにおける動画像AI推論<br>by 岸下優介</td><td>エッジデバイスのような計算リソースの限られた環境上でDeepLearningモデルを可能な限り高速で動作させる工夫についてお話します。 主なトピックとしては、TFLiteによるモデルの量子化手法と推論、Intel Neural Compute Stick2を用いた推論の2本立てになり、動作検証にはRaspberry Piを用います。</td></tr></tbody></table></div><h3 id="Track-B"><a href="#Track-B" class="headerlink" title="Track B"></a>Track B</h3><div class="scroll"><table><thead><tr><th>No</th><th>Title</th><th>Abstract</th></tr></thead><tbody><tr><td>1</td><td><font color="#ff6d01">Vue 最新構文 &lt;script setup&gt;の紹介<br>by 太田洋介</font></td><td>Vue 3.2で導入された<code>&lt;script setup&gt;</code>について紹介します。 Reactivity Transformについても少しだけ紹介します。</td></tr><tr><td>2</td><td><font color="#34a853">&lt;p&gt; に &lt;div&gt; をいれてはいけない<br>by 枇榔晃裕</font></td><td>しっかりとしたHTMLを書けてますか？<br> Webアプリの開発を手伝うことになったときに初めて触れて、先人が書いたHTMLを参考に見よう見まねで書いてる、という人も多いのではないでしょうか。 <code>&lt;p&gt;</code>タグの内側に <code>&lt;div&gt;</code> タグを入れたり、<code>&lt;button&gt;</code> タグの中に <code>&lt;h1&gt;</code> タグを入れたり、といった誤ったHTMLを書いてもブラウザがある程度はうまく解釈して許容してくれます。<br> しかしながら、解釈しきれず表示されないこともありますし、解釈の仕方もブラウザごとにそれぞれ異なります。 上記の例がなぜダメなのかの解説と、コピペから脱却してより正確なマークアップを目指すためにはどうすればいいかを考えていきます。</td></tr><tr><td>3</td><td><font color="#34a853">エンタープライズにおける画面設計・開発のコツ<br>by 柏木祥子</font></td><td>基幹システムの刷新、特定業務領域のシステムの新規構築と、毛色の異なるプロジェクトで画面の設計、開発を経験してきて、感じたことや、私なりに苦労したポイントをお伝えします。<br>・基幹システムとそうでないシステムの画面開発における違い、共通点<br>・画面設計・開発において考慮が漏れがちなポイントとその対策<br>・Reactでの開発について（Reactを使うメリット、ハマりどころと教訓）</td></tr><tr><td>4</td><td>FlutterアプリのPerformance測定<br>by 藤田春佳</td><td>VisualStudioCodeやAndroidStudioを用いたアプリの性能測定について、具体的アプリケーションの例でお話する予定です。可能であれば、サーバサイドも含めたFirebase performanceの利用についても紹介したいです。</td></tr><tr><td>5</td><td>Flutter Golden Testのすすめ<br>by 武田大輝</td><td>アプリのUIを目視でテストする時代は終わりました。<br>FlutterではWidget Testの一部であるGolden Testにより、自動でスクリーンショットを取得し、Visual Regression Testを実現することができます。<br>本セッションではGolden Testとは何か？というところから始まり、状態管理ライブラリのRiverpodとの連携まで、工夫点やハマりどころなど実践的な内容をお話できればと思います。</td></tr><tr><td>6</td><td><font color="#34a853">社用PC環境における最強のメモアプリ？Obsidianを使った情報管理のススメ<br>by 越島亮介</font></td><td>昨今はNotionを筆頭に新しい仕事効率化アプリが次々と登場しています。しかし、クラウド同期機能がある故にセキュリティ上の理由で社用PCでは使えない、ということが多いのではないでしょうか。そんな悩みを抱えている人たちに向けて、完全オフライン対応の最強メモアプリ「Obsidian」を紹介します。</td></tr><tr><td>7</td><td>N:Nツリー構造データにおけるグラフDB活用<br>by 村田靖拓</td><td>N:Nで紐づくツリー構造データにおけるグラフDB活用についてご紹介します。マネージドなNeo4j環境であるAuraDBを使い、Cypherクエリで欲しいデータを取得する方法を語ります。</td></tr><tr><td>8</td><td><font color="#34a853">PostgreSQLとNewSQL（YugaByteDB）を比較してみた<br>by 大塚雄太</font></td><td>PostgreSQLを案件として企業に導入することをやっていますが、PostgreSQLないしはRDBMSでは解決できない課題や悩みが多々あります。 徐々に企業への導入もされており、DB界隈では注目を集めているNewSQLをテーマとしてPostgreSQL互換もあるYugaByteDBで性能や可用性、その他課題や制約を整理して比較した内容を展開できればと思います。</td></tr><tr><td>9</td><td><font color="#ff6d01">クラウドネイティブ時代のDWH<br>by 杉江伸祐</font></td><td>次のような話をします。 <br>・クラウドインフラストラクチャを利用したDWHがここ数年で大きく進化してきました <br>・その進化によりどのような変化があり、技術がどこに向かっているのかご存知でしょうか <br>・パフォーマンスとスケーラビリティだけでなく、開発手法やデータ管理そのものを大きく見直すことにつながります</td></tr></tbody></table></div><h3 id="Track-C"><a href="#Track-C" class="headerlink" title="Track C"></a>Track C</h3><div class="scroll"><table><thead><tr><th>No</th><th>Title</th><th>Abstract</th></tr></thead><tbody><tr><td>1</td><td><font color="#34a853">ベストプラクティス・ドリフト ～技術選定におけるベストプラクティスの老朽化にどう抗うか～<br>by 原木翔</font></td><td>ソフトウェアアーキテクチャの技術選定にあたり、選択肢の多さで困ったことはありませんか？多い選択肢を絞り込む有効なツールとして、ベストプラクティスは存在します。ソフトウェア開発が日進月歩で行われる昨今、ベストプラクティスの老朽化が問題となってきました。 <br>「このベストプラクティス、古臭いよね…」<br> 作った後、運用保守を怠った結果、残念な結果になってしまった事例は少なくありません。 ベストプラクティスには、時代のニーズを先取りした定期的な更新は欠かせません。ベストプラクティスがずっとベストプラクティス足りえるために大事にしていることをお話しします。</td></tr><tr><td>2</td><td>How to become a Software Architecture  アーキテクティング入門<br>by 真野隼記</td><td>アーキテクトを目指したいけど中々業務でアーキテクチャ設計にチャレンジする機会がないという方も多いのではないでしょうか？ 私はイチからアーキテクチャを決めること以外にもアーキテクチャを磨く機会は日常にあると考えています。アーキテクチャとはなにか、アーキティングとはどういった流れで行うのかというところから、サンプルケースをもとに検討の流れを紹介します。</td></tr><tr><td>3</td><td>Tomcat Clustering on the Cloud(AWS)<br>by 藤野圭一</td><td>デフォルト設定であるMulticastMembershipを利用したTomcat ClusteringをCloud（AWS）上で構築しようとするとマルチキャストを通したり、いろいろ面倒な設定が必要になります。<br> 本セッションでは、Tomcat Clustering構築でマルチキャストを利用しない別のアプローチとして、StaticMembershipを利用したECS上でのクラスタリングとCloudMembershipを利用したEKS上でのクラスタリングを中心に、その構築方法、設計ポイントを詳細に解説します。</td></tr><tr><td>4</td><td><font color="#34a853">DBのデータ移行って何するの？エンタープライズ系システムをクラウドリフトするときに考えること<br>by 山崎悠希</font></td><td>クラウドインフラストラクチャの普及から、エンタープライズ系システムをクラウドリフトする機会はますます増えています。<br>その中で「これまで積み上げてきたDBのデータをどう移行するか。」は必ず乗り越えないといけない壁になります。<br>いざ、「じゃあ、DBのデータ移行よろしく！」と言われたときに、何を考えるのか。実際に直近のPJで経験したことを元にお伝えできればと思います。</td></tr><tr><td>5</td><td><font color="#34a853">2022 年の Airflow の概況<br>by 多賀聡一朗</font></td><td>2022 年の現在の Airflow の状況と、機能面について整理した内容をお伝えいたします。 <br>筆者が 2019 年に主に業務で利用していたところから、2022 年にかけてバージョン 2.0 がリリースされたりと多く変化が起きてます。当セッションで 2022 年時点の Airflow について知ることができますので、過去使用されていた方やまだ利用されたことがない方のインプットとなりましたら幸いです。</td></tr><tr><td>6</td><td><font color="#ff6d01">27周年のデザインパターンとどう付き合う？<br>by 澁川喜規</font></td><td>デザインパターンが書籍として出版されたのは1995年。当時とはプログラミング言語もフレームワークも、さまざまな状況が変わっています。デザインパターンを学ぶと、それに引きずられてしまうという声も聞かれます。<br>プログラミング言語の進化はデザインパターンにどのように影響を与えるのか？言語に関係なく使える知識というのは本当なのか？デザインパターン本を読んでデザインパターンで実装しなければならないという憑き物をどうやって払うのかを考えていきたいと思います。</td></tr><tr><td>7</td><td><font color="#34a853">チームで機能設計するためのPlantUML標準化<br>by ヴー ホアンミン</font></td><td>Futureの実務で使っているPlantUMLの標準化事例を紹介します。標準化する際に心がけていること、メンバー間の議論やおすすめのカラーテーマの話も交えて語ります。</td></tr><tr><td>8</td><td><font color="#34a853">AWS Amplifyで小さく始めるWeb開発<br>by 筒井悠平</font></td><td>新規にWebアプリを立ち上げるにあたって、どんな技術スタックを採用するかは悩ましい問題です。数ある選択肢の中からAWS Amplifyがおすすめできるシーンと、これを使うときのコツについてお話しします。</td></tr><tr><td>9</td><td>RustのWebフレームワーク周りの概観<br>by 本田紘規</td><td>RustでWeb開発を行えば、高速で安定したシステムが生産性高く構築できることが期待できます。本発表ではRustのWebフレームワーク周り(axum, tokio, tower, mio, hyper)を概観します。</td></tr></tbody></table></div><h2 id="開催にいたるまでの思い"><a href="#開催にいたるまでの思い" class="headerlink" title="開催にいたるまでの思い"></a>開催にいたるまでの思い</h2><p>フューチャー社内でOSS推進しようという活動を2020年にはじめていますが、<a href="https://future-architect.github.io/articles/20201107/#%E6%9D%A5%E5%B9%B4%E3%81%AB%E5%90%91%E3%81%91%E3%81%A6%E7%9B%AE%E6%A8%99">フューチャーOSS推進タスクフォース始めます </a> の目標に書いていた通り、今まで行っていなかった自社開催のカンファレンスを開催することで、外部発信の意識が高まり、コミュニティ活動への貢献が活発さに繋がれば良いなと考えています。</p><p>名称は途中までテックカンファレンスって読んでいましたが、運営を手動してくれていたApache Tomcatコミッターで有名な藤野さんが、いつのまにかフューチャーコンって呼ぶことにより定着しました。<a href="https://www.apachecon.com/">ApacheCon</a> のようでカッコいいですね。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>テックカンファレンスを通して少しでも皆さまに有意義な情報をお届けできれば幸いです。ぜひconnpassから登録をお待ちしております！</p>]]></content:encoded>
      
      
      <category domain="https://future-architect.github.io/categories/Culture/">Culture</category>
      
      
      <category domain="https://future-architect.github.io/tags/%E3%82%AB%E3%83%B3%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9/">カンファレンス</category>
      
      <category domain="https://future-architect.github.io/tags/%E5%8B%89%E5%BC%B7%E4%BC%9A/">勉強会</category>
      
      <category domain="https://future-architect.github.io/tags/%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9/">インデックス</category>
      
      <category domain="https://future-architect.github.io/tags/FutureCon/">FutureCon</category>
      
      
      <comments>https://future-architect.github.io/articles/20220712a/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
