<!DOCTYPE html>
<!--[if IE 8]> <html lang="ja" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="ja" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="ja">
<!--<![endif]-->
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>JavaプログラマーのためのGo言語入門 | フューチャー技術ブログ</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  
  <meta name="description" content="JavaプログラマーのためのGo言語入門こちらはJava to Go in-depth tutorialの日本語訳です原文の著者に許諾を得て翻訳・公開いたします。 このチュートリアルは、JavaプログラマーがすばやくGo言語にキャッチアップできるようにすることを目的としています。 目次 Hello stack 主な違い シンタックス（文法） 定数 構造体 ポインタ スライス 値の作成 メソッドとイ">
<meta name="keywords" content="Java,Go,翻訳">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaプログラマーのためのGo言語入門">
<meta property="og:url" content="https://future-architect.github.io/articles/20200311/index.html">
<meta property="og:site_name" content="フューチャー技術ブログ">
<meta property="og:description" content="JavaプログラマーのためのGo言語入門こちらはJava to Go in-depth tutorialの日本語訳です原文の著者に許諾を得て翻訳・公開いたします。 このチュートリアルは、JavaプログラマーがすばやくGo言語にキャッチアップできるようにすることを目的としています。 目次 Hello stack 主な違い シンタックス（文法） 定数 構造体 ポインタ スライス 値の作成 メソッドとイ">
<meta property="og:locale" content="ja">
<meta property="og:updated_time" content="2020-03-12T01:44:02.223Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaプログラマーのためのGo言語入門">
<meta name="twitter:description" content="JavaプログラマーのためのGo言語入門こちらはJava to Go in-depth tutorialの日本語訳です原文の著者に許諾を得て翻訳・公開いたします。 このチュートリアルは、JavaプログラマーがすばやくGo言語にキャッチアップできるようにすることを目的としています。 目次 Hello stack 主な違い シンタックス（文法） 定数 構造体 ポインタ スライス 値の作成 メソッドとイ">
  
    <link rel="alternative" href="/atom.xml" title="フューチャー技術ブログ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  

  <meta content="JavaプログラマーのためのGo言語入門 | フューチャー技術ブログ" name="description">
  <meta content="JavaプログラマーのためのGo言語入門,フューチャー技術ブログ,フューチャーアーキテクト,Future Architect,フューチャー,Future,Tech Blog,技術ブログ,技術,ブログ" name="keywords">
  <meta content="Future Architect Consultant" name="author">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Audiowide|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/custom.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body class="corporate">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- BEGIN HEADER -->
<div class="header">
	<div class="header-overlay">
		<!--<a class="site-logo" href="/" id="logo">フューチャー技術ブログ</a>-->
		<div class="header-menu">
			<a class="site-logo" href="/">
				<img src="/metronic/assets/corporate/img/site_logo.png" alt="logo" class="logo-img" width="180px">
			</a>
			<a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>
			<!-- BEGIN NAVIGATION -->
			<div class="header-navigation pull-right font-transform-inherit">
				<ul>
					
					<li class="">
						<a href="/"><i class="fa fa-home"></i>Home</a>
					</li>
					
					<li class="">
						<a href="/articles/"><i class="fa fa-newspaper-o"></i>Blog</a>
					</li>
					
					<li class="">
						<a href="https://github.com/future-architect"><i class="fa fa-github"></i>GitHub</a>
					</li>
					
					<!-- BEGIN TOP SEARCH -->
					<!-- END TOP SEARCH -->
				</ul>
			</div>
		</div>
		<!-- END NAVIGATION -->
		<div class="header-title">Future Tech Blog</div>
        <div class="header-title-sub">フューチャー開発者ブログ</div>
	</div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/articles/">Blog</a></li>
    <li class="active">Post</li>
  </ul>
  <section id="main">
    
    <h2 itemprop="name">
      <a class="article-title" href="/articles/20200311/">JavaプログラマーのためのGo言語入門</a>
    </h2>


    <div class="row">
<div class="col-md-9 col-sm-9 blog-posts">
<article id="post-20200311-go-in-depth-tutorial" class="article article-type-post blog-item" itemscope itemprop="blogPost">
  <div class="article-meta">
  </div>
  <div class="article-inner">
    
    <header class="article-header">
    <ul class="blog-info">
    <li><i class="fa fa-user"></i> 柏木祥子,佐藤尚至</li>
    <li><i class="fa fa-calendar"></i>
	  <time datetime="2020-03-11T00:39:47.000Z" itemprop="datePublished">2020/03/11</time>

    </li>

    <li><i class="fa fa-tags"></i>
    
  
    <a href="/tags/Java/" title="Java">Java</a>,
  
    <a href="/tags/Go/" title="Go">Go</a>,
  
    <a href="/tags/翻訳/" title="翻訳">翻訳</a>
  


    </li>
    </ul>
    
  <div class="article-category">
    
    Category: 
    
    <a class="article-category-link" href="/categories/Programming/">Programming</a>
  </div>
  <br>


    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaプログラマーのためのGo言語入門"><a href="#JavaプログラマーのためのGo言語入門" class="headerlink" title="JavaプログラマーのためのGo言語入門"></a>JavaプログラマーのためのGo言語入門</h2><p>こちらは<a href="https://yourbasic.org/golang/go-java-tutorial/" target="_blank" rel="noopener">Java to Go in-depth tutorial</a>の日本語訳です<br>原文の著者に許諾を得て翻訳・公開いたします。</p>
<p>このチュートリアルは、JavaプログラマーがすばやくGo言語にキャッチアップできるようにすることを目的としています。</p>
<h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><ul>
<li><a href="./#Hello-stack1">Hello stack</a></li>
<li><a href="./#主な違い">主な違い</a></li>
<li><a href="./#シンタックス（文法">シンタックス（文法）</a></li>
<li><a href="./#定数">定数</a></li>
<li><a href="./#構造体">構造体</a></li>
<li><a href="./#ポインタ">ポインタ</a></li>
<li><a href="./#スライス">スライス</a></li>
<li><a href="./#値の作成">値の作成</a></li>
<li><a href="./#メソッドとインターフェース">メソッドとインターフェース</a></li>
<li><a href="./#エラー">エラー</a></li>
<li><a href="./#PanicとRecover">PanicとRecover</a></li>
<li><a href="./#ゴルーチンとチャネル">ゴルーチンとチャネル</a></li>
<li><a href="./#Hello-server">Hello server</a></li>
</ul>
<h2 id="Hello-stack1"><a href="#Hello-stack1" class="headerlink" title="Hello stack1"></a>Hello stack<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><p>まずはじめに簡単な例を見ていきましょう。この例ではシンプルな抽象データ型をGoで実装しています。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collectionパッケージはstring型を格納できるスタックを実装している</span></span><br><span class="line"><span class="keyword">package</span> collection</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stackのゼロ値はすぐに使用できる空のスタック</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pushメソッドはスタックの一番上にxを追加する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Popメソッドは最後に追加された要素をスタックから削除しつつ、その要素を返す</span></span><br><span class="line"><span class="comment">// 空のスタックでPopメソッドを呼ぶとランタイムエラーが発生する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.data) - <span class="number">1</span></span><br><span class="line">    res := s.data[n]</span><br><span class="line">    s.data[n] = <span class="string">""</span> <span class="comment">// メモリリークを避けるための処理</span></span><br><span class="line">    s.data = s.data[:n]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sizeメソッドはスタックの要素数を返す</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最上位の宣言文の前に直接書かれているコメントはドキュメントコメントになります。ドキュメントコメントはプレーンテキストで書かれます。</li>
<li>変数を宣言するときは、変数名の後ろに型を書きます。</li>
<li>構造体( <code>struct</code> )はJavaでいうところのクラスに該当します。Goの構造体はメソッドをメンバに含めることはできません。変数のみを構造体のメンバに含めることができます。</li>
<li>コード上の <code>(s *Stach)</code> という部分でメソッドのレシーバーを宣言しています。これはJavaでいうところの <code>this</code> に該当します。</li>
<li><code>:=</code> という演算子は変数の宣言と初期化を同時に行ってくれます。変数の型は初期化式から自動で導かれます。</li>
</ul>
<p>以下のコードは、抽象データ型 <code>collection.Stack</code> を用いたHello worldプログラムです。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"go-for-java-programmers/collection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleStack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s collection.Stack</span><br><span class="line">    s.Push(<span class="string">"world!"</span>)</span><br><span class="line">    s.Push(<span class="string">"Hello, "</span>)</span><br><span class="line">    <span class="keyword">for</span> s.Size() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Print(s.Pop())</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// Output: Hello, world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>この <code>collection_test</code> というテストパッケージは <code>collection</code> パッケージと同じディレクトリに配置します。</li>
<li>1つめの<code>import</code> 文の <code>fmt</code> はGoの標準パッケージです。 2つめ <code>import</code> 文は“go-for-java-programmers/collection”ディレクトリのパッケージを使うことを示しています。</li>
<li>ソースコード上では <code>fmt</code> や <code>collection</code> という短い名前でこれらのパッケージにアクセスできます。</li>
</ul>
<p>NOTE: Goでスタックを実装する慣用的な方法は、スライスを直接使用することです。詳しくは<a href="https://yourbasic.org/golang/implement-stack/" target="_blank" rel="noopener">Implement a stack (LIFO)</a>を参照してください。</p>
<h2 id="主な違い"><a href="#主な違い" class="headerlink" title="主な違い"></a>主な違い</h2><h3 id="オブジェクト指向プログラミング"><a href="#オブジェクト指向プログラミング" class="headerlink" title="オブジェクト指向プログラミング"></a>オブジェクト指向プログラミング</h3><ul>
<li>Goにはコンストラクタを伴うクラスという概念がありません。インスタンスメソッド、クラスの継承構造、メソッドの動的ルックアップで実現したいことを、Goでは<a href="https://yourbasic.org/golang/structs-explained/" target="_blank" rel="noopener">struct</a>と<a href="https://yourbasic.org/golang/interfaces-explained/" target="_blank" rel="noopener">interface</a>を用いて実現します。</li>
<li>Goでは、どんな型に対しても<a href="https://yourbasic.org/golang/methods-explained/" target="_blank" rel="noopener">メソッド</a>を作成することができます。レシーバーをボックス化する必要もありません。レシーバーはJavaでいうところの <code>this</code> に対応します。レシーバーには値そのものかポインタが入ります。</li>
<li>Javaの <code>public</code>や <code>package-private</code> に似た２つのアクセスレベルがGoには存在します。トップレベルで宣言された<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>変数や関数の名前が大文字で始まる場合は <code>public</code> 、小文字で始まる場合は <code>package-private</code> のアクセスレベルになります。</li>
</ul>
<h3 id="関数型プログラミング"><a href="#関数型プログラミング" class="headerlink" title="関数型プログラミング"></a>関数型プログラミング</h3><ul>
<li>Goの関数は第一級オブジェクトです。<a href="https://yourbasic.org/golang/function-pointer-type-declaration/" target="_blank" rel="noopener">関数値</a>は他の値と同じように使用したり、関数の引数として渡すことができます。<a href="https://yourbasic.org/golang/anonymous-function-literal-lambda-closure/" target="_blank" rel="noopener">関数リテラル</a>は外側の関数で定義された変数を参照できます。</li>
</ul>
<h3 id="ポインタと参照"><a href="#ポインタと参照" class="headerlink" title="ポインタと参照"></a>ポインタと参照</h3><ul>
<li>Goは、オブジェクトや配列だけでなく、すべての型で<a href="https://yourbasic.org/golang/pointers-explained/" target="_blank" rel="noopener">ポインタ</a>を使用することができます。任意の型 <code>T</code> には対応するポインタ型 <code>*T</code> が存在します。これは型 <code>T</code> の値へのポインタを示しています。</li>
<li>Goでは無効なポインタに <code>nil</code> を使用しますが、Javaでは <code>null</code> を使用します。</li>
<li>Goの配列は値型です。配列が関数の引数として使用される場合、その関数は配列へのポインターではなく配列のコピーを受け取ります。実際には、配列ではなくスライスを関数の引数に渡すことがほとんどです。スライスは参照型です。</li>
<li>特定の型(マップ, スライス, チャネル)は値型ではなく、参照型です。つまり、マップを関数に渡してもマップはコピーされません。渡されたマップを関数内で変更した場合、変更は呼び出し元にも反映されます。Javaの用語を使うと、これはマップへの参照が行われているからだと説明できます。</li>
</ul>
<h3 id="組み込み型"><a href="#組み込み型" class="headerlink" title="組み込み型"></a>組み込み型</h3><ul>
<li>文字列型はGoの言語仕様として組み込まれています。<a href="https://yourbasic.org/golang/string-functions-reference-cheat-sheet/" target="_blank" rel="noopener">string</a> はbyte型のスライスのように振る舞いますが、イミュータブルです。</li>
<li>ハッシュテーブルはGoの言語自体に組み込まれています。Goでは<a href="https://yourbasic.org/golang/maps-explained/" target="_blank" rel="noopener">map</a>と呼びます。</li>
</ul>
<h3 id="エラーハンドリング"><a href="#エラーハンドリング" class="headerlink" title="エラーハンドリング"></a>エラーハンドリング</h3><ul>
<li>Goでは例外処理(exceptions)の代わりに、<a href="https://yourbasic.org/golang/errors-explained/" target="_blank" rel="noopener">error</a>を使用します。EOFなどのイベント、配列の範囲外の領域にアクセスしようとしたしたときのランタイム<a href="https://yourbasic.org/golang/recover-from-panic/" target="_blank" rel="noopener">パニック</a>はerrorで表現されます。</li>
</ul>
<h3 id="並行処理"><a href="#並行処理" class="headerlink" title="並行処理"></a>並行処理</h3><ul>
<li>Goでは個別に動く実行スレッドを<a href="https://yourbasic.org/golang/goroutines-explained/" target="_blank" rel="noopener">ゴルーチン</a>と呼びます。またゴルーチン間の通信は<a href="https://yourbasic.org/golang/channels-explained/" target="_blank" rel="noopener">チャネル</a>を使用します。これらは言語が提供しています。</li>
</ul>
<h3 id="用意されていない機能"><a href="#用意されていない機能" class="headerlink" title="用意されていない機能"></a>用意されていない機能</h3><ul>
<li>Goは暗黙的な型変換をサポートしていません。異なる型を混在させるような操作では、明示的な型変換が必要です。一方、数値型の定数を宣言するときには、型を指定せずに定数を宣言できます。この場合、宣言時の段階では、数値の上限は未確定になります。詳しくは<a href="https://yourbasic.org/golang/untyped-constants/" target="_blank" rel="noopener">Untyped numeric constants with no limits</a>を参照してください。</li>
<li>Goでは関数のオーバロードをサポートしていません。同じスコープ内の関数及びメソッドにはユニークな名前を付ける必要があります。代替手段としては<a href="https://yourbasic.org/golang/overload-overwrite-optional-parameter/" target="_blank" rel="noopener">Optional parameters and method overloading</a>を参照してください。</li>
<li>Goには組み込みのスライスやマップといったジェネリクス及び、<code>append</code> や <code>copy</code> といったジェネリクス用関数があります。しかし、ジェネリクス用関数を独自実装できる機構はありません。代替手段としては、<a href="https://yourbasic.org/golang/generics/" target="_blank" rel="noopener">Generics (alternatives and workarounds)</a>を参照してください。</li>
</ul>
<h2 id="シンタックス（文法）"><a href="#シンタックス（文法）" class="headerlink" title="シンタックス（文法）"></a>シンタックス（文法）</h2><h3 id="宣言"><a href="#宣言" class="headerlink" title="宣言"></a>宣言</h3><p>変数の宣言の仕方は、Javaと比べると逆になっています。Goでは変数名の後ろに型名を記述します。これによってGoのコンパイラが「変数××の型は○○である」と解釈しやすくなります。</p>
<table>
<thead>
<tr>
<th align="left">Goの書き方</th>
<th align="left">Javaでざっくりイコールな書き方</th>
</tr>
</thead>
<tbody><tr>
<td align="left">var v1 int</td>
<td align="left">int v1 = 0;</td>
</tr>
<tr>
<td align="left">var v2 *int</td>
<td align="left">Integer v2 = null;</td>
</tr>
<tr>
<td align="left">var v3 string</td>
<td align="left">String v3 = “”;</td>
</tr>
<tr>
<td align="left">var v4 [10]int</td>
<td align="left">int[] v4 = new int[10];  <br> (Arrays are values in Go.)</td>
</tr>
<tr>
<td align="left">var v5 []int</td>
<td align="left">int[] v5 = null;</td>
</tr>
<tr>
<td align="left">var v6 *struct{ a int }</td>
<td align="left">class C { int a; } <br> C v6 = null;</td>
</tr>
<tr>
<td align="left">var v7 map[string]int</td>
<td align="left">HashMap&lt;String, Integer&gt; v7; <br> v7 = null;</td>
</tr>
<tr>
<td align="left">var v8 func(a int) int</td>
<td align="left">interface F { <br> &nbsp;&nbsp;&nbsp;&nbsp;int f(int a); <br> } <br> F v8 = null;</td>
</tr>
</tbody></table>
<p>一般的に、宣言ではキーワードの後ろにオブジェクト<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>の名称が続きます。キーワードとは<code>const</code>、<code>type</code>、<code>var</code>や<code>func</code>などです。キーワードの後ろに括弧でまとめて宣言を書くこともできます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    n <span class="keyword">int</span></span><br><span class="line">    x <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>関数を定義する時、引数の名前の付け方は統一する必要があります。それぞれの引数に名前をつけるか、または全く名前をつけないかです。いずれかに名前をつけ、いずれかは省略するということはできません。複数の引数が同じ型の場合、グループ化することは可能です。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>変数は宣言の時に初期化することもできます。初期化も行う場合、変数の型を特定することもできますが、必須ではありません。型が特定されていない場合は、初期化式の右辺の値の型が設定されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v9 = *v2</span><br></pre></td></tr></table></figure>

<p>もしも変数が明示的に初期化されていない場合でも、型は指定する必要があります。この場合、初期値は暗黙的に<a href="https://yourbasic.org/golang/default-zero-value/" target="_blank" rel="noopener">ゼロ値</a>（0、<code>nil</code>、””など）が与えられます。Goの世界では初期化されていない変数は存在しません。</p>
<h3 id="宣言の省略形"><a href="#宣言の省略形" class="headerlink" title="宣言の省略形"></a>宣言の省略形</h3><p>関数の中では、<code>:=</code>で宣言を簡略化することもできます。例えばこの文は</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v10 := v1</span><br></pre></td></tr></table></figure>

<p>下の文と同様の意味を持ちます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v10 = v1</span><br></pre></td></tr></table></figure>

<h3 id="関数型"><a href="#関数型" class="headerlink" title="関数型"></a>関数型</h3><p>Goでは、関数は第一級オブジェクトに属しています。Goの世界では、引数と戻り値の型が同一の関数は全て同じ<a href="https://yourbasic.org/golang/function-pointer-type-declaration/" target="_blank" rel="noopener">関数型</a>をしているとみなされます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> binOp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">op</span> <span class="title">binOp</span></span></span><br><span class="line"><span class="function"><span class="title">add</span> := <span class="title">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i + j &#125;</span><br><span class="line"></span><br><span class="line">op = add</span><br><span class="line">n = op(<span class="number">100</span>, <span class="number">200</span>)  <span class="comment">// n = 100 + 200</span></span><br></pre></td></tr></table></figure>

<h3 id="複数割り当て"><a href="#複数割り当て" class="headerlink" title="複数割り当て"></a>複数割り当て</h3><p>Goでは代入で複数の値を割り当てることができます。右側の式は左側の被演算子に割り当てられる前に評価されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j = j, i  <span class="comment">// iとjを置き換える</span></span><br></pre></td></tr></table></figure>

<p>関数が複数の値を戻り値として返すこともできます。その場合括弧()の中に列挙して示します。戻り値を一度に複数の変数に保存することもできます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>, pj *<span class="keyword">int</span>)</span></span> &#123; ... &#125;</span><br><span class="line">v1, v2 = f()</span><br></pre></td></tr></table></figure>

<h3 id="ブランク識別子"><a href="#ブランク識別子" class="headerlink" title="ブランク識別子"></a>ブランク識別子</h3><p><a href="https://yourbasic.org/golang/underscore/" target="_blank" rel="noopener">ブランク識別子</a>は<code>_</code>(アンダースコア）で表され、複数の戻り値が返ってくる式で値を無視したい場合に用いられます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1, _ = f()  <span class="comment">// f()の関数から返ってきた2つ目の値を無視する</span></span><br></pre></td></tr></table></figure>

<h3 id="セミコロンとフォーマット"><a href="#セミコロンとフォーマット" class="headerlink" title="セミコロンとフォーマット"></a>セミコロンとフォーマット</h3><p>セミコロンやフォーマットで悩む必要はありません。「gofmt」を使えば、唯一のスタンダードであるGoのスタイルに整形することができます。このスタイルは最初は違和感を感じるかもしれませんが、他のスタイルと同じように良く、また慣れてしまえば快適なものとなるでしょう。</p>
<p>実際、セミコロンを使う機会はGoではめったにありません。理論上、Goの全ての宣言はセミコロンで終わります。しかしGoは、行が明らかに処理途中のものでない限り、空白でない行の終わりに暗黙的にセミコロンを挿入します。これによって、場合によっては改行が許されないケースもでてくるのです。例えば、下のような書き方は許されません。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;            <span class="comment">// 不正: "&#123;" は前の行に存在すべきである</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>この場合、<code>g()</code> のすぐあとにセミコロンが挿入されてしまいます。その結果、関数を定義しているのではなく関数を宣言しているとみなされてしまいます。同様に、下のような書き方もできません。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;       <span class="comment">// 不正: "else &#123;" は前の行に存在すべきである</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>この場合、<code>else</code>の前の<code>}</code>の直後にセミコロンが挿入されてしまい、結果として文法エラーになります。</p>
<h3 id="if文（条件文）"><a href="#if文（条件文）" class="headerlink" title="if文（条件文）"></a>if文（条件文）</h3><p>Goではif文、for文の条件式、switch文の値を括弧()で囲みません。一方、if文やfor文のボディは中括弧{}で囲む必要があります。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; b &#123; f() &#125;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123; f() &#125;          <span class="comment">// 括弧は不要</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) f()              <span class="comment">// 不正</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;&#125; <span class="comment">// 不正</span></span><br></pre></td></tr></table></figure>

<p>さらに、if文やswitch文ではオプショナルな初期化式を記述することもできます。多くの場合これはローカル変数を設定するときに用いられます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="For文"><a href="#For文" class="headerlink" title="For文"></a>For文</h3><p>Goにはwhile文もdo-while文もありません。for文を単一の条件と一緒に用いることができ、これがwhile文と同様の動きになります。条件を完全に省略すると無限ループ文となります。</p>
<p><a href="https://yourbasic.org/golang/for-loop/" target="_blank" rel="noopener">for文</a>は文字列（<code>string</code>）、配列（<code>array</code>）、スライス（<code>slice</code>）、マップ（<code>map</code>）やチャネル（<code>channel</code>）を <code>range</code> 句に指定できます。通常であれば下のように書きますが、</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>a</code>の各要素に対して繰り返して処理をしたい場合、下のように書くことができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>上の書き方では、<code>i</code>にインデックスが割り当てられ、<code>v</code>に配列やスライス、文字列などの要素の連続する値が割り当てられます。</p>
<ul>
<li>文字列の場合は、<code>i</code>はバイトごとのインデックスとなり、<code>v</code>は<code>rune</code>型のUnicodeのコードポイント<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>となります（<code>rune</code>は<code>int32</code>のエイリアスです）。</li>
<li>mapでの繰り返しはキー・バリューのペアの反復値を生成しますが、チャネルは反復値を１つだけ生成します。</li>
</ul>
<h3 id="BreakとContinue"><a href="#BreakとContinue" class="headerlink" title="BreakとContinue"></a>BreakとContinue</h3><p>Javaと同じように、Goでも<code>break</code>と<code>continue</code>でラベルを指定することができますが、for文、switch文、select文の中でラベルを参照する必要があります。</p>
<h3 id="Switch文"><a href="#Switch文" class="headerlink" title="Switch文"></a>Switch文</h3><p>Goの<a href="https://yourbasic.org/golang/switch-statement/" target="_blank" rel="noopener">switch文</a>では、<code>break</code>を書かなくても、<code>switch</code> から抜け出ることができます。コードブロックの最後に<code>fallthrough</code>文を置くことで、次の <code>case</code>に処理を回すことができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// caseの中身は空である</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    f() <span class="comment">// n == 0のときf()は呼ばれない</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>しかし、<code>case</code>は複数の値を持つことができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">    f() <span class="comment">// n == 0 または n == 1のときf()が呼ばれる</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>case</code>の中の値は、例えば文字列やポインタなど、等価比較演算子で扱うことのできるどんな型でも使えます。switch式がない場合、その式は<code>true</code>とみなされます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n &lt; <span class="number">0</span>:</span><br><span class="line">    f1()</span><br><span class="line"><span class="keyword">case</span> n == <span class="number">0</span>:</span><br><span class="line">    f2()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="インクリメントとデクリメント"><a href="#インクリメントとデクリメント" class="headerlink" title="インクリメントとデクリメント"></a>インクリメントとデクリメント</h3><p><code>++</code>と<code>--</code>は後置演算子として文の中でのみ使うことができます。式の中で扱うことはできません。例えば、<code>n = i++</code>と書くことはできません。</p>
<h3 id="Defer文"><a href="#Defer文" class="headerlink" title="Defer文"></a>Defer文</h3><p><a href="https://yourbasic.org/golang/defer/" target="_blank" rel="noopener">defer文</a>を使うことで、呼び出し元の関数がreturnされたタイミングで実行されるべき処理を記述することができます。</p>
<ul>
<li>defer宣言された関数は、呼び出し元の関数がどのようにretrunされたかに関わらず実行されます。<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></li>
</ul>
<ul>
<li>defer宣言された関数の引数は、defer宣言されたタイミングで計算され、実行時に使用されるまで保存されます。<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"filename"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close() <span class="comment">// fはこの関数がreturnされたときに終了する</span></span><br></pre></td></tr></table></figure>

<h2 id="定数"><a href="#定数" class="headerlink" title="定数"></a>定数</h2><p>Goの定数は<a href="https://yourbasic.org/golang/untyped-constants/" target="_blank" rel="noopener">untypedな状態</a>にすることもできます<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>。このルールは下記に適用されます。</p>
<ul>
<li>数値リテラル、</li>
<li>型なしの定数のみを用いている式、</li>
<li>型が与えられていない、もしくは初期化式が型なしであるconst式</li>
</ul>
<p>型なしの定数の値は、型のある値が必要になったタイミングで型定義されます。これにより、Goでは明示的な型変換が行われないにも関わらず、定数を比較的自由に扱うことができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">uint</span></span><br><span class="line">f(a + <span class="number">1</span>)   <span class="comment">// 型の定義されていない数値1はuintとして型定義される</span></span><br><span class="line">f(a + <span class="number">1e3</span>) <span class="comment">// 1e3もuintとして定義される</span></span><br></pre></td></tr></table></figure>

<p>Go言語では型定義のない数値の定数に上限値は明確にされません。型が必要になったときにのみ上限は適用されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> huge = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span> = huge &gt;&gt; <span class="number">98</span></span><br></pre></td></tr></table></figure>

<p>もしも変数宣言において型が定義されておらず、対応する式が型のない数値の定数だった場合、その数値は、値が文字列なのかintegerなのか浮動小数点なのか複素定数なのかによって<code>rune</code>、<code>int</code>、<code>float64</code>か<code>complex128</code>の型にそれぞれ変換されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="string">'å'</span>    <span class="comment">// rune (int32のエイリアス)</span></span><br><span class="line">n := <span class="number">1</span> + <span class="number">2</span>  <span class="comment">// int</span></span><br><span class="line">x := <span class="number">2.7</span>    <span class="comment">// float64</span></span><br><span class="line">z := <span class="number">1</span> + <span class="number">2i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure>

<p>Goでは列挙型を扱いません。その代わりに、連続して増え続ける値を唯一const宣言することができる<code>iota</code>という特別な名称をつけることができます。constの初期化式が省略された時は、先に定義された式が再利用されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    red = <span class="literal">iota</span> <span class="comment">// red == 0</span></span><br><span class="line">    blue       <span class="comment">// blue == 1</span></span><br><span class="line">    green      <span class="comment">// green == 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="構造体"><a href="#構造体" class="headerlink" title="構造体"></a>構造体</h2><p><a href="https://yourbasic.org/golang/structs-explained/" target="_blank" rel="noopener">構造体</a>はJavaでいうクラスのようなものですが、構造体のメンバにはメソッドを含めることはできません。構造体は変数のみで構成されます。構造体のポインタは、Javaでいう参照変数のようなものです。Javaのクラスとは対照的に、Goの構造体は直接の値として定義することもできます。どちらの場合でも、構造体のメンバにアクセスするには<code>.</code>を用います。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">    n <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x MyStruct     <span class="comment">// x は MyStruct&#123;"", 0&#125; に初期化される</span></span><br><span class="line"><span class="keyword">var</span> px *MyStruct   <span class="comment">// px は nil に初期化される</span></span><br><span class="line">px = <span class="built_in">new</span>(MyStruct) <span class="comment">// px は新たに作られる MyStruct&#123;"", 0&#125; のポインタとなる</span></span><br><span class="line"></span><br><span class="line">x.s = <span class="string">"Foo"</span></span><br><span class="line">px.s = <span class="string">"Bar"</span></span><br></pre></td></tr></table></figure>

<p>Goでは、ユーザー定義型に対してメソッドを追加することができます。これは構造体をベースにしたユーザー定義型に限った話ではありません。詳しくは<a href="https://yourbasic.org/golang/go-java-tutorial/#methods-and-interfaces" target="_blank" rel="noopener">メソッドとインターフェース</a>をご参照ください。</p>
<h2 id="ポインタ"><a href="#ポインタ" class="headerlink" title="ポインタ"></a>ポインタ</h2><p>int, struct, arrayの代入操作は、オブジェクト実体をコピーすることを意味します。Javaでいう参照変数をGoで実現するためには<a href="https://yourbasic.org/golang/pointers-explained/" target="_blank" rel="noopener">ポインタ</a>を使用します。</p>
<p>任意の型Tには、対応するポインタ型 <code>*T</code> があり、型Tの値へのポインタを示します。</p>
<p>ポインタ変数が参照するメモリ領域を割り当てるには、組み込み関数 <code>new</code> を使用します。これは、型を引数として受け取り、割り当てられたストレージへのポインタを返す関数です。割り当てられたストレージ領域は、その型に対応するゼロ値で初期化されます。例えば、<code>new(int)</code> はint用にストレージの割り当てを新規で行い、その領域を値0で初期化し、そして <code>*int</code> 型を持つそのアドレスを返します。</p>
<p><code>T p = new T()</code> というJavaコードをGoコードに置き換えてみましょう。<code>T</code> は２つの <code>int</code> 型インスタンスを持つクラスだとします。これに対応するGoコードは次のとおりです。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; a, b <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> p *T = <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure>

<p>より慣用的には次のように書きます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure>

<p> <code>var v T</code> は型Tの値を保持するための変数を宣言していますが、こういった宣言方法はJavaには存在しません。<br>複合リテラルを使用して値を初期化することもできます。例えば：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := T&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>これは以下と同じです。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v T</span><br><span class="line">v.a = <span class="number">1</span></span><br><span class="line">v.b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>型Tの変数xの場合、アドレス演算子 <code>＆x</code> はxのアドレス(<code>*T</code> 型の値)を提供します。例えば：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;T&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// pは型 *Tを持つ</span></span><br></pre></td></tr></table></figure>

<p>変数xがポインタ型変数の場合、ポインタの間接参照 <code>*x</code>は、xが指す値を示します。ポインタの間接指定はほとんど使用されません。GoはJavaと同様に、変数のアドレスを自動的に取得できます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(T)</span><br><span class="line">p.a = <span class="number">1</span> <span class="comment">// (*p).a = 1 に等しい</span></span><br></pre></td></tr></table></figure>

<h2 id="スライス"><a href="#スライス" class="headerlink" title="スライス"></a>スライス</h2><p><a href="https://yourbasic.org/golang/slices-explained/" target="_blank" rel="noopener">スライス</a>は概念的には下記の3つのフィールドをもつ構造体です。</p>
<ul>
<li>配列に対するポインタ</li>
<li>長さ</li>
<li>容量</li>
</ul>
<p>スライスでは<code>[]</code>演算子を使ってスライス内部の配列の要素にアクセスします。</p>
<ul>
<li>組み込み関数である<code>len</code>関数はスライスの長さ(<code>length</code>)を返します。</li>
<li>組み込み関数である<code>cap</code>関数はスライスの容量(<code>capacity</code>)を返します。</li>
</ul>
<p>ある配列やスライス(例えば<code>a</code>)から新規のスライスを生成する場合、<code>a[i:j]</code>の形で生成することができます。この<code>a[i:j]</code>は</p>
<ul>
<li>インデックス<code>i</code>からインデックス<code>j</code>の手前までの<code>a</code>を参照したスライスになります。</li>
<li><code>j-i</code>の長さを持っています。</li>
<li><code>i</code>が省略されていた場合、スライスは0を起点とします。</li>
<li><code>j</code>が省略された場合、スライスはaの長さ（len(a)）までの長さとなります。</li>
</ul>
<p>新しくできたスライスは<code>a</code>が参照しているものと同一の配列を参照します。つまり、新しいスライスで要素が変更された場合、<code>a</code>の要素も同じように変更されます<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>。</p>
<p>新しいスライスの容量は、純粋に<code>a</code>から<code>i</code>を引いた差分となります。配列の容量と配列の長さはイコールです。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">s = a[:] <span class="comment">// s = a[0:len(a)]の短縮形</span></span><br></pre></td></tr></table></figure>

<p>もし、<code>[100]byte</code>型の値（<code>byte</code>100個分の配列、例えばバッファ）を作り、関数に参照渡しをしたいのであれば、<code>[]byte</code>型の引数を持つ関数を宣言し、配列をスライスに変えて、その引数に渡してあげるのが良いでしょう<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>。スライスは、<a href="https://yourbasic.org/golang/go-java-tutorial/#making-values" target="_blank" rel="noopener">下記</a>に書いてあるような<code>make</code>関数でも作り出すことができます。</p>
<p>スライスには組み込み関数<code>append</code>が備え付けられており、Javaの<code>ArrayList</code>とほぼ同様の機能を持っています。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s0 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s1 := <span class="built_in">append</span>(s0, <span class="number">3</span>)     <span class="comment">// 要素を1つ追加する</span></span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 要素を複数追加する</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, s0...) <span class="comment">// スライスを1つ追加する</span></span><br></pre></td></tr></table></figure>

<p>スライス構文は文字列と一緒に使うこともできます。文字列のスライスは、オリジナルの文字列の部分文字列を返します。</p>
<h2 id="値の作成"><a href="#値の作成" class="headerlink" title="値の作成"></a>値の作成</h2><p>Mapやチャネルの値は、組み込み関数である<code>make</code>関数によって割り当てられていなければなりません。例えば、</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>をコールすると、新しく<code>map[string]int</code>型で割り当てられた値が返ってきます。</p>
<p><code>new</code>とは対照的に、<code>make</code>はアドレスではなくオブジェクトそのものが返ってきます。これはMapやチャネルが参照型であるという事実に一致しています。</p>
<p>Mapの場合、<code>make</code>では第2オプション引数に容量ヒントを渡すことができます。</p>
<p>チャネルの場合は、第2オプション引数はチャネルのバッファの容量となります。デフォルトは<code>0</code>です。（バッファがない状態）</p>
<p><code>make</code>関数はスライスを割り当てる場合にも使用されます。この場合<code>make</code>関数は、スライスのもとになる配列にメモリを割り当て、それを参照するスライスを返します。必須の引数として、スライスの要素数を渡さなければなりません。第2オプション引数でスライスの容量を指定できます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment">// new([20]int)[:10]と同意</span></span><br></pre></td></tr></table></figure>

<h2 id="メソッドとインターフェース"><a href="#メソッドとインターフェース" class="headerlink" title="メソッドとインターフェース"></a>メソッドとインターフェース</h2><p>メソッドは、レシーバーを持っていることを除いて、通常の関数定義のような見た目をしています。レシーバーは、Javaインスタンスメソッドのthis参照に似ています。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">struct</span> &#123; i <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MyType)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pm = <span class="built_in">new</span>(MyType)</span><br><span class="line"><span class="keyword">var</span> n = pm.Get()</span><br></pre></td></tr></table></figure>

<p>上記の例では、 <code>MyType</code> に関連付けられた <code>Get</code> メソッドを宣言しています。このメソッドの中で、レシーバーはpという名前を付けられています。</p>
<p>メソッドは定義済みの型に対して宣言されます。レシーバーを別の型に変換すると、変換後の新しい変数は変換前の型のメソッドではなく、変換後の型のメソッドを持つようになります。</p>
<p>組み込み型から派生した新しい型を宣言することにより、組み込み型にメソッドを定義できます。その新しい型は、もとの組み込み型とは全く別のものとなります。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p MyInt)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(p) <span class="comment">// intへの変換は必須</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> v MyInt</span><br><span class="line"></span><br><span class="line">v = v * v <span class="comment">// 派生元の演算子は引き続き使用できる</span></span><br><span class="line">f(<span class="keyword">int</span>(v)) <span class="comment">// int(v) には宣言されたメソッドがない</span></span><br><span class="line">f(v)      <span class="comment">// INVALID</span></span><br></pre></td></tr></table></figure>

<h3 id="インターフェース"><a href="#インターフェース" class="headerlink" title="インターフェース"></a>インターフェース</h3><p>Go<a href="https://yourbasic.org/golang/interfaces-explained/" target="_blank" rel="noopener">インターフェース</a>はJavaインターフェースに似ていますが、Goインターフェースの場合、インターフェースが要求するメソッド群を提供している型はみな、そのインターフェースの実装として扱われます。明示的な宣言は必要ありません。</p>
<p>以下のインターフェースが定義されているとします。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get() <span class="keyword">int</span></span><br><span class="line">    Set(i <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MyType</code> はすでに <code>Get</code> メソッドを持っているので、 <code>Set</code> メソッドを追加することにより、 <code>MyType</code> が <code>MyInterface</code> を満たすようになります。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MyType)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p.i = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MyInterface</code> を引数にもつ関数は皆、 <code>*MyType</code> 型の変数を受け容れます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAndSet</span><span class="params">(x MyInterface)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p MyType</span><br><span class="line">    GetAndSet(&amp;p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Javaの用語を使うとすると、 <code>*MyType</code> の <code>Set</code> および <code>Get</code> を定義すると、 <code>*MyType</code> が自動的に <code>MyInterface</code> を <code>implement</code> します。<br>型は複数のインターフェースを満たすことができます。これはダックタイピングの一種です。</p>
<blockquote>
<p>アヒルのように歩き、アヒルのように泳ぎ、アヒルのように鳴く鳥を見るとき、私はその鳥をアヒルと呼ぶ。<br>– James Whitcomb Riley</p>
</blockquote>
<h3 id="埋め込み（委譲）"><a href="#埋め込み（委譲）" class="headerlink" title="埋め込み（委譲）"></a>埋め込み（委譲）</h3><p>型を匿名フィールドとして埋め込むことで、派生型を実装することができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySubType <span class="keyword">struct</span> &#123;</span><br><span class="line">    MyType</span><br><span class="line">    j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MySubType)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    p.j++</span><br><span class="line">    <span class="keyword">return</span> p.MyType.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事実上、MySubTypeがMyTypeの派生型として実装されます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p MySubType</span><br><span class="line">    GetAndSet(&amp;p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Set</code> メソッドは <code>MyType</code> 型から継承されます。これは匿名フィールドのメソッドが、派生型のメソッドへと昇格されるためです。</p>
<p>この場合、 <code>MySubType</code> には <code>MyType</code> 型の匿名フィールドがあるため、 <code>MyType</code> のメソッドは <code>MySubType</code> のメソッドになります。<code>Get</code> メソッドはオーバーライドされ、 <code>Set</code> メソッドは継承されています。</p>
<p>これはJavaのクラス継承と同じではなく、委譲という方式をとっています。匿名フィールドのメソッドが呼び出されたとき、そのメソッドのレシーバは、派生型(<code>MySubType</code>)の方ではなく、内包する匿名フィールド(<code>MyType</code>)になります。つまり、匿名フィールドのメソッドは動的に派生型のメソッドとしてディスパッチされません。Javaの動的メソッドルックアップに相当するものが必要な場合、<code>interface</code> を使用してください。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v MyInterface</span><br><span class="line"></span><br><span class="line">    v = <span class="built_in">new</span>(MyType)</span><br><span class="line">    v.Get() <span class="comment">// *MyTypeのGetメソッドをコールしている</span></span><br><span class="line"></span><br><span class="line">    v = <span class="built_in">new</span>(MySubType)</span><br><span class="line">    v.Get() <span class="comment">// *MySubTypeのGetメソッドをコールしている</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="型アサーション"><a href="#型アサーション" class="headerlink" title="型アサーション"></a>型アサーション</h3><p>あるインターフェース型が実装されている変数は、<a href="https://yourbasic.org/golang/type-assertion-switch/" target="_blank" rel="noopener">型アサーション</a>を使用して、異なるインターフェース型を持つように変換できます。これは実行時に動的に変換されます。Javaとは異なり、2つのインターフェース間の関係を宣言する必要はありません。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">(x MyInterface)</span></span> &#123;</span><br><span class="line">    x.(Printer).Print() <span class="comment">// Printerへの型アサーション</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Printer</code> への変換は動的に行われます。xが <code>Print</code> メソッドを定義している限り機能します。</p>
<h2 id="エラー"><a href="#エラー" class="headerlink" title="エラー"></a>エラー</h2><p>Javaでは通常例外を使用するケースでも、Goでは2つの異なるメカニズムがあります。</p>
<ul>
<li>大抵の関数ではエラーを返します。</li>
<li>本当にリカバーできない状況のとき、例えば範囲外のインデックスだった場合などにのみ、実行時の例外を生み出します。</li>
</ul>
<p>Goでは複数の値を返すことができますが、それによって通常の戻り値に加え、詳細なエラーメッセージを返すことが簡単にできます。慣例的に、そのようなメッセージには、シンプルな組み込みインターフェースであるerror型が存在します。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例えば<code>os.Open</code>関数は、ファイルを開くことができなかった場合、<code>nil</code>でないエラー値を返します。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>下記のコードではファイルを開くために<code>os.Open</code>関数を用いています。エラーが生じた場合は、エラーメッセージをログに出力して処理を中断する<code>log.Fatal</code>関数を呼び出します。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"filename.ext"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// オープンされた*File型のfを使った何らかの処理を行う</span></span><br></pre></td></tr></table></figure>

<p>エラーのインターフェースは<code>Error</code>のメソッドのみ必要としますが、特定のエラーとなるとしばしばその他のメソッドも持っています。それによって、呼び出し側がエラーの詳細を検知することができます。</p>
<h2 id="PanicとRecover"><a href="#PanicとRecover" class="headerlink" title="PanicとRecover"></a>PanicとRecover</h2><p><a href="https://yourbasic.org/golang/recover-from-panic/" target="_blank" rel="noopener">panic</a>は、ゴルーチンのスタックを巻き戻し、途中でdefer宣言された関数を実行してからプログラムを停止するランタイムエラーです。</p>
<p>panicはJavaの例外処理(exceptions)に似ていますが、ランタイムエラーのみを対象としています。例えば、<code>nil</code> ポインタを参照しようとしたときや、配列の範囲外領域にインデックスしようとしたときにpanicが発生します。EOFなどエラーイベントを表現するために、Goプログラムは<a href="https://qiita.com/wagi0716/private/37c8fa3398717a4d6b3b#%E3%82%A8%E3%83%A9%E3%83%BC" target="_blank" rel="noopener">上記</a>の <code>error</code> という組み込み型を使用します。</p>
<p>組み込み関数<a href="https://yourbasic.org/golang/recover-from-panic/" target="_blank" rel="noopener">recover</a>を使用して、panic状態のゴルーチンの制御を取り戻し、通常の実行を再開できます。</p>
<ul>
<li><code>recover</code> を呼び出すとスタックの巻き戻しが停止します。<code>recover</code> は <code>panic</code> に渡した引数を返します。</li>
</ul>
<p>巻き戻し中に実行されるコードはdefer宣言された関数内のコードのみであるため、<code>recover</code> はdefer宣言された関数内でのみ有用です。ゴルーチンがパニックになっていない場合、<code>recover</code> は <code>nil</code> を返します。</p>
<h2 id="ゴルーチンとチャネル"><a href="#ゴルーチンとチャネル" class="headerlink" title="ゴルーチンとチャネル"></a>ゴルーチンとチャネル</h2><h3 id="ゴルーチン"><a href="#ゴルーチン" class="headerlink" title="ゴルーチン"></a>ゴルーチン</h3><p>Goでは、<code>go</code> 文を使用して、新たなスレッド(ゴルーチン)を立ち上げることができます。<code>go</code> 文に続く関数は新しく作成された<a href="https://yourbasic.org/golang/goroutines-explained/" target="_blank" rel="noopener">ゴルーチン</a>上で実行されます。 1つのプログラム内のすべてのゴルーチンは、同じアドレス空間を共有します。</p>
<p>ゴルーチンは軽量であり、スタック領域割り当て程度のコストしかかかりません。はじめはスタックの割り当てを小さく抑え、必要に応じてヒープストレージへの割り当てと解放を行いながら大きくしていきます。内部的にゴルーチンは、複数のオペレーティングシステムスレッド間で多重化されるコルーチンのように機能します。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort() <span class="comment">// list.Sort()はパラレルに実行される</span></span><br></pre></td></tr></table></figure>

<p>Goには関数リテラルがあります。関数リテラルは<a href="https://yourbasic.org/golang/anonymous-function-literal-lambda-closure/" target="_blank" rel="noopener">クロージャー</a>として機能し、 <code>go</code> 文と組み合わせると強力になります。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delayで指定した時間が立つと、Publish関数は標準出力にtextを書き出す</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(text)</span><br><span class="line">    &#125;() <span class="comment">// 括弧をつけてください。go句直後の関数はコールする必要がある</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>変数 <code>text</code> および <code>delay</code> は、<code>Publish</code> 関数とその内部の関数リテラルの間で共有されます。</p>
<h3 id="チャネル"><a href="#チャネル" class="headerlink" title="チャネル"></a>チャネル</h3><p><a href="https://yourbasic.org/golang/channels-explained/" target="_blank" rel="noopener">チャネル</a>は、2つのゴルーチンの処理を同期させたり、通信させたりするメカニズムを提供します。 <code>&lt;-</code> 演算子は、チャネルの方向(送信または受信)を指定します。方向が指定されていない場合、そのチャネルは送受信可能です。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> Sushi     <span class="comment">// Sushi型の値を送受信するために使用できる</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span> <span class="comment">// float64型を送信するためにのみ使用できる</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>     <span class="comment">// int型を受信するためにのみ使用できる</span></span><br></pre></td></tr></table></figure>

<p>チャネルは参照型であり、<code>make</code> で作成することができます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)       <span class="comment">// バッファを持たないint型のチャネル</span></span><br><span class="line">wc := <span class="built_in">make</span>(<span class="keyword">chan</span> *Work, <span class="number">10</span>) <span class="comment">// バッファを持つ*Work型のチャネル</span></span><br></pre></td></tr></table></figure>

<p>チャネルに値を送信するには、<code>&lt;-</code> を二項演算子のように使用します。チャネルから値を受信するには、<code>&lt;-</code> を単項演算子のように使用します。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic &lt;- <span class="number">3</span>      <span class="comment">// チャネルに3を送信する</span></span><br><span class="line">work := &lt;-wc <span class="comment">// チャネルから*Workを受信する</span></span><br></pre></td></tr></table></figure>

<ul>
<li>チャネルがバッファを持たない場合、受信チャネルから値を取り出すまでの間、送信チャネルは処理をブロックします。</li>
<li>チャネルがバッファを持つ場合、送信チャネルから渡される値がバッファに書き込まれる余地があるときは処理がブロックされません。逆に、バッファがいっぱいになっているときは、受信チャネルから値を取り出すまで、送信チャネルは処理をブロックします。</li>
<li>受信チャネルは取り出せる値が存在するまでの間、処理をブロックします。</li>
</ul>
<p><code>close</code> 関数はこれ以上チャネルに値を送信できないようにすることができます。</p>
<ul>
<li><code>close</code> 関数が呼び出されたとします。<code>close</code> 関数が呼び出されるまでの間にすでにチャネルに送信された値は問題なく受信チャネルから取り出すことができます。その後の受信処理ではブロックは発生されず、ゼロ値を返します。</li>
<li>受信チャネルからは値の他に、チャネルが閉じているかどうかの指標を取り出すことができます。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Hello!"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// "Hello!"が表示される</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// ここではブロックされず、string型のゼロ値である""が表示される</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// もう一度""が表示される</span></span><br><span class="line">v, ok := &lt;-ch     <span class="comment">// vは"", okはfalseの値をとる</span></span><br></pre></td></tr></table></figure>

<p>次の例では <code>Publish</code> 関数がチャネルを返すようにします。 <code>text</code> が発行されたときにメッセージをブロードキャストするためにこのチャネルが使われます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delayで指定した時間が経過したのち、Publish関数はtextを標準出力に書き出す</span></span><br><span class="line"><span class="comment">// textが表示されたタイミングでwaitチャネルをクローズする</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span> <span class="params">(wait &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(text)</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Publish関数はこのように使えます。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait := Publish(<span class="string">"important news"</span>, <span class="number">2</span> * time.Minute)</span><br><span class="line"><span class="comment">// ここに何らかの処理が入る</span></span><br><span class="line">&lt;-wait <span class="comment">// textが表示されるまで、ここで処理がブロックされる</span></span><br></pre></td></tr></table></figure>

<h3 id="select文"><a href="#select文" class="headerlink" title="select文"></a>select文</h3><p>select文はGoの重要な並行処理ツールキットの一つです。<code>select</code> は通信時に続行する処理を選択します。</p>
<ul>
<li>どの通信も成功し得るとき、そのうちの一つがランダム選択され、対応する処理が実行されます。</li>
<li>defaultのケースが存在しない場合、いずれかの通信が成功するまでselect文は処理をブロックします。</li>
</ul>
<p>以下のコードは、select文を使用した乱数ジェネレーターの実装例です。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rand := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// ランダムで0か1のどちらかをを続けざまに送信している</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rand &lt;- <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> rand &lt;- <span class="number">1</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>もう少し現実的な実装例を見てみましょう。次のコードはselect文をつかって、受信操作にタイムリミットを設けている例です。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> news := &lt;-AFP:</span><br><span class="line">    fmt.Println(news)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Minute):</span><br><span class="line">    fmt.Println(<span class="string">"Time out: no news in one minute."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.After</code> は標準ライブラリの関数です。一定時間たった後に、現在時刻を送信するチャネルを返す関数です。</p>
<h2 id="Hello-server"><a href="#Hello-server" class="headerlink" title="Hello server"></a>Hello server</h2><p>これまでのピースがどのようにはまっていくのかを、ちょっとした例でお見せして終わることにしましょう。<code>server</code>パッケージはチャネルを経由して<code>Work</code>リクエストを受け入れるサーバーを実装しています。</p>
<ul>
<li>リクエストごとに別々の<code>goroutine</code>で処理が行われます。</li>
<li><code>Work</code>の構造体それ自身は、結果を返すために用いられるチャンネルを含んでいます。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Newでreqチャネルを経由してWorkのリクエストを受け入れるサーバーを生成する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(req <span class="keyword">chan</span>&lt;- *Work)</span></span> &#123;</span><br><span class="line">    wc := <span class="built_in">make</span>(<span class="keyword">chan</span> *Work)</span><br><span class="line">    <span class="keyword">go</span> serve(wc)</span><br><span class="line">    <span class="keyword">return</span> wc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">A</span>, <span class="title">B</span>  <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">Reply</span> <span class="title">chan</span> <span class="title">int</span> // <span class="title">Server</span>はこのチャネルに結果を返す</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">serve</span><span class="params">(wc &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> w := <span class="keyword">range</span> wc &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(w *Work)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 実行中の他のgoroutineをkillしないように、パニック状態になっているgoroutineの制御を取り戻す</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(w *Work)</span></span> &#123;</span><br><span class="line">    w.Reply &lt;- w.Op(w.A, w.B)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>こんな風に使えるでしょう。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"server"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := server.New()</span><br><span class="line"></span><br><span class="line">    divideByZero := &amp;server.Work&#123;</span><br><span class="line">        Op:    <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a / b &#125;,</span><br><span class="line">        A:     <span class="number">100</span>,</span><br><span class="line">        B:     <span class="number">0</span>,</span><br><span class="line">        Reply: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    s &lt;- divideByZero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-divideByZero.Reply:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">        fmt.Println(<span class="string">"No result in one second."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出力結果: No result in one second.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="さらに学びたい場合"><a href="#さらに学びたい場合" class="headerlink" title="さらに学びたい場合"></a>さらに学びたい場合</h3><p><a href="https://yourbasic.org/golang/tutorials/" target="_blank" rel="noopener">Tutorials</a>は初心者にも上級者にもためになるサイトです。ベストプラクティスや、本番環境に匹敵するコード例が揃っています。</p>
<h2 id="関連リンク"><a href="#関連リンク" class="headerlink" title="関連リンク"></a>関連リンク</h2><p>Goに関連した連載企画があります。</p>
<ul>
<li><a href="https://future-architect.github.io/articles/20190713/">Goを学ぶときにつまずきやすいポイントFAQ</a></li>
<li><a href="https://future-architect.github.io/tags/GoCDK/">Go Cloud 連載</a></li>
<li><a href="https://future-architect.github.io/tags/DynamoDB%C3%97Go/">DynamoDB×Go連載</a></li>
<li><a href="https://future-architect.github.io/tags/GCP%E9%80%A3%E8%BC%89/">GCP 連載</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">後入れ先出し（LIFO: Last In First Out; FILO: First In Last Out）の構造</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><code>{}</code> の中で宣言されていない変数・関数をトップレベルで宣言された変数・関数と読んでいる。import文はトップレベルで宣言されている。main packageのmain関数はトップレベルで宣言されている。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Javaの世界で呼ばれる「オブジェクト」と同義です。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">Unicodeの<a href="https://ja.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E7%82%B9" target="_blank" rel="noopener">コードポイント</a>とは、全ての文字を4桁の16進数で一意に表現したコード体系の値です。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">panicが発生して、呼び出し元の関数が強制的にreturnされても、defer宣言された関数は実行されます。</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">サンプルコード ( <a href="https://play.golang.org/p/XDaWkZqEZ9K" target="_blank" rel="noopener">https://play.golang.org/p/XDaWkZqEZ9K</a> )</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">untypedな状態の時は型が決まっておらず、式や代入の中でその定数が用いられる時、型が決定されます。</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">サンプルコード ( <a href="https://play.golang.org/p/J3JBKvSmYJW" target="_blank" rel="noopener">https://play.golang.org/p/J3JBKvSmYJW</a> )</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">サンプルコード ( <a href="https://play.golang.org/p/jTKvVIBqwMa" target="_blank" rel="noopener">https://play.golang.org/p/jTKvVIBqwMa</a> )</span><a href="#fnref:9" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>
    <div class="social-area">
    <!-- シェアボタン START -->
  <ul class="social-button">
    
    
    
      
      
    
    <!-- twitter -->
    <li class="sc-tw social-button-twitter" style="position: static; width:75px; height:20px">
      <a href="https://twitter.com/share" class="twitter-share-button" data-via="future_techblog" data-lang="ja" data-text="JavaプログラマーのためのGo言語入門" data-url="https://future-architect.github.io/articles/20200311/">ツイート</a>
    </li>
    <!-- Facebookいいね -->
    <li class="social-button-fb" style="width:120px; height:20px">
     <div class="fb-like" data-href="https://future-architect.github.io/articles/20200311/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="true"></div>
    </li>
    <!-- はてなブックマーク -->
    <li class="social-button-hatebu" style="width:115px; height:20px">
       <a href="http://b.hatena.ne.jp/entry/https://future-architect.github.io/articles/20200311/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="ja" title="はてなブックマークに追加">はてブする</a>
    </li>
    <!-- pocket -->
    <li class="social-button-pocket">
      <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en" data-save-url="https://future-architect.github.io/articles/20200311/"></a>
    </li>
  </ul>
<!-- シェアボタン END -->

    </div>
  </div>
</div>
<div class="col-md-3 col-sm-3 blog-sidebar">
  <!-- BEGIN FEATURED POSTS -->
<h2>Featured Posts</h2>
<div class="recent-news margin-bottom-10">
  
  
    
      
        <a href="https://future-architect.github.io/articles/20200525/">
          <div class="row margin-bottom-10">
            <div class="col-md-10">
              <li>
                Go Tips 連載7:【golngci-lint】lint issueを新たに作り出さないためのTips
              </li>
            </div>
          </div>
        </a>
      
	
  
    
      
        <a href="https://future-architect.github.io/articles/20200523/">
          <div class="row margin-bottom-10">
            <div class="col-md-10">
              <li>
                Go Tips連載6: Error wrappingされた各クラウドSDKの独自型エラーを扱う
              </li>
            </div>
          </div>
        </a>
      
	
  
    
      
        <a href="https://future-architect.github.io/articles/20200522/">
          <div class="row margin-bottom-10">
            <div class="col-md-10">
              <li>
                Go Tips 連載5: エラーコードベースの例外ハンドリングの実装＋morikuni/failureサンプル
              </li>
            </div>
          </div>
        </a>
      
	
  
    
      
        <a href="https://future-architect.github.io/articles/20200520/">
          <div class="row margin-bottom-10">
            <div class="col-md-10">
              <li>
                Go Tips連載3: ファイルを扱うちょっとしたスクリプトをGoで書くときのTips5選
              </li>
            </div>
          </div>
        </a>
      
	
  
    
      
        <a href="https://future-architect.github.io/articles/20200521/">
          <div class="row margin-bottom-10">
            <div class="col-md-10">
              <li>
                Go Tips連載4: GoDocの読み方
              </li>
            </div>
          </div>
        </a>
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
      
	
  
    
  
    
  
    
      
	
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
  
    
  
    
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
      
	
  
    
  
    
      
	
  
    
      
	
  
    
      
	
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</div>
<!-- END FEATURED POSTS -->

<!-- CATEGORIES START -->
<h2 class="margin-top-30">Categories</h2>

<div class="widget-wrap">
  <div class="widget">
    <ul class="nav sidebar-categories margin-bottom-40">
      
	<li>
	  <a href="/categories/Culture/">Culture (24)</a>
	</li>
      
	<li>
	  <a href="/categories/IoT/">IoT (11)</a>
	</li>
      
	<li>
	  <a href="/categories/VR/">VR (8)</a>
	</li>
      
	<li>
	  <a href="/categories/Security/">Security (1)</a>
	</li>
      
	<li>
	  <a href="/categories/Design/">Design (6)</a>
	</li>
      
	<li>
	  <a href="/categories/Programming/">Programming (60)</a>
	</li>
      
	<li>
	  <a href="/categories/Management/">Management (7)</a>
	</li>
      
	<li>
	  <a href="/categories/Infrastructure/">Infrastructure (53)</a>
	</li>
      
	<li>
	  <a href="/categories/DB/">DB (8)</a>
	</li>
      
	<li>
	  <a href="/categories/DataScience/">DataScience (19)</a>
	</li>
      
	<li>
	  <a href="/categories/CI-CD/">CI/CD (1)</a>
	</li>
      
	<li>
	  <a href="/categories/認証認可/">認証認可 (3)</a>
	</li>
      
	<li>
	  <a href="/categories/マネジメント/">マネジメント (1)</a>
	</li>
      
	<li>
	  <a href="/categories/インタビュー/">インタビュー (1)</a>
	</li>
      
    </ul>
  </div>
</div>


<!-- CATEGORIES END -->

<!-- START ADVENT CALENDAR -->
<div class="margin-bottom-20">
  <h2>Advent Calendar</h2>
  <div class="widget-wrap">
  <div class="widget">
    <ul class="nav">
      <li>
        <a href="http://qiita.com/advent-calendar/2018/future" target="_blank">2018年</a>
      </li>
      <li>
        <a href="http://qiita.com/advent-calendar/2017/future" target="_blank">2017年</a>
      </li>
      <li>
        <a href="http://qiita.com/advent-calendar/2016/future" target="_blank">2016年</a>
      </li>
      <li>
        <a href="http://qiita.com/advent-calendar/2015/future" target="_blank">2015年</a>
      </li>
    </ul>
  </div>
</div>

</div>
<!-- END ADVENT CALENDAR -->


</div>
</div>

  </section>
</div>

    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p>経営とITをデザインする、フューチャーの技術ブログです。IoTやAI(MachineLearning)・Security・VR・Cloud・BigDataといった内容の記事を中心に、業務で利用する幅広い技術について紹介します。また、OSSへの貢献やカンファレンスなどへの登壇など、フューチャーへのエンジニア文化についてもドシドシ紹介していきますのでぜひウォッチ下さい！<br /><br /><a href="http://www.future.co.jp/">http://www.future.co.jp/</a></p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              東京都品川区大崎1-2-2<br>
              アートヴィレッジ大崎セントラルタワー<br><br>
              Email: <a href="mailto:techblog@future.co.jp">techblog@future.co.jp</a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

  <!-- FacebookのShareボタン用. ページに1度初期化できればよいのでフッターに配備 -->
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.0";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>

  <!-- Pocket Shareボタン. ページ毎に1度初期化できれば良いのでフッターに配備 -->
  <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
  <!-- Twitter Shareボタン. ページ毎に1度初期化できれば良いのでフッターに配備 -->
  <script>window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };
    return t;
  }(document, "script", "twitter-wjs"));</script>
  <!-- はてぶ Shareボタン. ページ毎に1度初期化できれば良いのでフッターに配備 -->
  <script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>

	
    <!-- BEGIN TWITTER BLOCK -->
    <div class="col-md-4 col-sm-6 pre-footer-col">
      <!-- Twitterフォローボタン -->
      <a href="https://twitter.com/future_techblog" class="twitter-follow-button" data-show-count="false" data-lang="ja">/future_techblogさんをフォロー</a>
      <!-- 組み込みTwitterウィジェット -->
      <a data-tweet-limit="1" class="twitter-timeline" href="https://twitter.com/future_techblog" data-widget-id="732749663766372354">Tweets by @future_techblog</a>
    </div>
    <!-- END TWITTER BLOCK -->
	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2020 フューチャー技術ブログ<br>
 <!-- <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a> -->
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
      
      <li><a href="https://github.com/future-architect"><i class="fa fa-github"></i></a></li>
      
  
      
      <li><a href="https://twitter.com/future_techblog"><i class="fa fa-twitter"></i></a></li>
      
  
      
      <li><a href="https://www.facebook.com/future.saiyo"><i class="fa fa-facebook"></i></a></li>
      
  
      
      <li>
        <a href="http://qiita.com/organizations/future">
            <i class="fa fa-pencil-square-o"></i>
        </a>
      </li>
      
  
      
      <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li>
      
  
  </ul>
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]-->
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/script.js"></script>

<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling();
    });
</script>
<!-- END CORE PLUGINS -->
<!-- START INTEGRATIONS -->

<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-74047147-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<!-- END INTEGRATIONS --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
