<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <!--
    ███████╗██╗░░░██╗████████╗██╗░░░██╗██████╗░███████╗
    ██╔════╝██║░░░██║╚══██╔══╝██║░░░██║██╔══██╗██╔════╝
    █████╗░░██║░░░██║░░░██║░░░██║░░░██║██████╔╝█████╗░░
    ██╔══╝░░██║░░░██║░░░██║░░░██║░░░██║██╔══██╗██╔══╝░░
    ██║░░░░░╚██████╔╝░░░██║░░░╚██████╔╝██║░░██║███████╗
    ╚═╝░░░░░░╚═════╝░░░░╚═╝░░░░╚═════╝░╚═╝░░╚═╝╚══════╝
    ████████╗███████╗░█████╗░██╗░░██╗
    ╚══██╔══╝██╔════╝██╔══██╗██║░░██║
    ░░░██║░░░█████╗░░██║░░╚═╝███████║
    ░░░██║░░░██╔══╝░░██║░░██╗██╔══██║
    ░░░██║░░░███████╗╚█████╔╝██║░░██║
    ░░░╚═╝░░░╚══════╝░╚════╝░╚═╝░░╚═╝
    ██████╗░██╗░░░░░░█████╗░░██████╗░
    ██╔══██╗██║░░░░░██╔══██╗██╔════╝░
    ██████╦╝██║░░░░░██║░░██║██║░░██╗░
    ██╔══██╗██║░░░░░██║░░██║██║░░╚██╗
    ██████╦╝███████╗╚█████╔╝╚██████╔╝
    ╚═════╝░╚══════╝░╚════╝░░╚═════╝░
    Welcome engineer.
    https://www.future.co.jp/recruit/
  -->
  
  <title>GORM v1 と v2 のソースコードリーディングしてみた | フューチャー技術ブログ</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  
  <meta name="description" content="[GORM v2 doc](https:&#x2F;&#x2F;gorm.io&#x2F;) より  概要TIG DXユニット 多賀です。GoのORマッパー連載の4日目の記事です。 GORM の v1 と v2 の実装を比較して、何が変わっているのかを調査してみました。v1 -&gt; v2 への移行や、詳細な変更点については別の記事を見ていただいたほうが良いかと思います。  GORM 2.0 Release Note |">
<meta property="og:type" content="article">
<meta property="og:title" content="GORM v1 と v2 のソースコードリーディングしてみた | フューチャー技術ブログ">
<meta property="og:url" content="https://future-architect.github.io/articles/20210729a/index.html">
<meta property="og:site_name" content="フューチャー技術ブログ">
<meta property="og:description" content="[GORM v2 doc](https:&#x2F;&#x2F;gorm.io&#x2F;) より  概要TIG DXユニット 多賀です。GoのORマッパー連載の4日目の記事です。 GORM の v1 と v2 の実装を比較して、何が変わっているのかを調査してみました。v1 -&gt; v2 への移行や、詳細な変更点については別の記事を見ていただいたほうが良いかと思います。  GORM 2.0 Release Note |">
<meta property="og:locale" content="ja_JP">
<meta property="og:image" content="https://future-architect.github.io/images/20210729a/image.png">
<meta property="article:published_time" content="2021-07-28T15:00:00.000Z">
<meta property="article:modified_time" content="2022-07-04T14:47:53.482Z">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="ORM">
<meta property="article:tag" content="GORM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://future-architect.github.io/images/20210729a/image.png">
  
  <link rel="alternate" href="/atom.xml" title="フューチャー技術ブログ" type="application/atom+xml">
  
  <link rel="icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes='180x180' href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes='57x57' href="/apple-touch-icon-57x57.png">
  <link rel="canonical" href="https://future-architect.github.io/articles/20210729a/">
  <meta content="Go,ORM,GORM" name="keywords">
  <meta content="多賀聡一朗" name="author">
  <link rel="preload" as="image" href="/banner.jpg" />
  <link rel='manifest' href='/manifest.webmanifest'/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
  <link rel="stylesheet" href="/metronic/assets/style.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="corporate">
  <div class="wrap" itemscope itemtype="https://schema.org/TechArticle">
  <!-- BEGIN HEADER -->
<header class="header">
	<div class="header-overlay">
		<div class="header-menu"></div>
		<div class="header-title"><a href="/">Future Tech Blog</a></div>
		<div class="header-title-sub">フューチャー技術ブログ</div>
	</div>
</header>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/articles/">Blog</a></li>
    <li class="active">Post</li>
  </ul>
  <section id="main" class="margin-top-30">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programmingカテゴリ</a>
  </div>


    <h2 itemprop="name" class="article-title">GORM v1 と v2 のソースコードリーディングしてみた
  
  <a target="_blank" rel="noopener" href="https://github.com/future-architect/tech-blog/edit/master/source/_posts/20210729a_GORM_v1_と_v2_のソースコードリーディングしてみた.md" title="Suggest Edits" class="github-edit"><i class="github-edit-icon"></i></a>
  
</h2>

    <div class="row">
  <main class="col-md-9 blog-posts">
    <article id="post-20210729a_GORM_v1_と_v2_のソースコードリーディングしてみた" class="article article-type-post blog-item" itemscope itemprop="blogPost">
      <div class="article-inner">
        
        <header class="article-header">
          <ul class="blog-info">
            <li class="blog-info-item"><a href="/articles/2021/" class="publish-date"><time datetime="2021-07-28T15:00:00.000Z" itemprop="datePublished">2021.07.29</time></a>
</li>
            <li class="blog-info-item"><li><a href="/authors/%E5%A4%9A%E8%B3%80%E8%81%A1%E4%B8%80%E6%9C%97" title="多賀聡一朗さんの記事一覧へ" class="post-author">多賀聡一朗</a></li></li>
            <li class="blog-info-item">
  
    
    <a href="/tags/Go/" title="Goタグの記事へ" class="tag-list-link">Go言語</a>
  
    
    <a href="/tags/ORM/" title="ORMタグの記事へ" class="tag-list-link">ORM</a>
  
    
    <a href="/tags/GORM/" title="GORMタグの記事へ" class="tag-list-link">GORM</a>
  

</li>
          </ul>
          </header>
        
        <div class="article-entry" itemprop="articleBody">
          
            <img src="/images/20210729a/image.png" alt="gormトップページ">
[GORM v2 doc](https://gorm.io/) より

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>TIG DXユニット 多賀です。<a href="/articles/20210726a/">GoのORマッパー連載</a>の4日目の記事です。</p>
<p>GORM の v1 と v2 の実装を比較して、何が変わっているのかを調査してみました。<br>v1 -&gt; v2 への移行や、詳細な変更点については別の記事を見ていただいたほうが良いかと思います。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gorm.io/docs/v2_release_note.html">GORM 2.0 Release Note | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.techtouch.jp/entry/gorm-v2">GORM v2 触ってみた Major Features 編 - Techtouch Developers Blog</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.techtouch.jp/entry/gorm-v2-breaking-changes">GORM v2 触ってみた Breaking Changes 編 - Techtouch Developers Blog</a></li>
</ul>
<p>当記事では、ソースコードの差分を眺めてみてなにか学びがないかを調べてみた記事になっています。<br>完全にスクラッチで書き直しているとのことで、エッセンスが吸収できると良いなと思っています。</p>
<p>調査バージョン</p>
<div class="scroll"><table>
<thead>
<tr>
<th>バージョン</th>
<th>リポジトリ</th>
<th>タグ</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td><a target="_blank" rel="noopener" href="https://github.com/jinzhu/gorm/tree/v1.9.16">jinzhu&#x2F;gorm</a></td>
<td>v1.9.16</td>
</tr>
<tr>
<td>v2</td>
<td><a target="_blank" rel="noopener" href="https://github.com/go-gorm/gorm/tree/v1.21.11">go-gorm&#x2F;gorm</a></td>
<td>v1.21.11</td>
</tr>
</tbody></table></div>
<h3 id="ディレクトリ構造"><a href="#ディレクトリ構造" class="headerlink" title="ディレクトリ構造"></a>ディレクトリ構造</h3><p>まずはディレクトリ構造の差分を比較してみます。</p>
<figure class="highlight sh"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 --dirsfirst</span><br><span class="line">.</span><br><span class="line">├── dialects</span><br><span class="line">├── License</span><br><span class="line">├── README.md</span><br><span class="line">├── association.go</span><br><span class="line">├── association_test.go</span><br><span class="line">├── callback.go</span><br><span class="line">├── callback_create.go</span><br><span class="line">├── callback_delete.go</span><br><span class="line">├── callback_query.go</span><br><span class="line">├── callback_query_preload.go</span><br><span class="line">├── callback_row_query.go</span><br><span class="line">├── callback_save.go</span><br><span class="line">├── callback_system_test.go</span><br><span class="line">├── callback_update.go</span><br><span class="line">├── callbacks_test.go</span><br><span class="line">├── create_test.go</span><br><span class="line">├── customize_column_test.go</span><br><span class="line">├── delete_test.go</span><br><span class="line">├── dialect.go</span><br><span class="line">├── dialect_common.go</span><br><span class="line">├── dialect_mysql.go</span><br><span class="line">├── dialect_postgres.go</span><br><span class="line">├── dialect_sqlite3.go</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── embedded_struct_test.go</span><br><span class="line">├── errors.go</span><br><span class="line">├── errors_test.go</span><br><span class="line">├── field.go</span><br><span class="line">├── field_test.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── interface.go</span><br><span class="line">├── join_table_handler.go</span><br><span class="line">├── join_table_test.go</span><br><span class="line">├── logger.go</span><br><span class="line">├── main.go</span><br><span class="line">├── main_test.go</span><br><span class="line">├── migration_test.go</span><br><span class="line">├── model.go</span><br><span class="line">├── model_struct.go</span><br><span class="line">├── model_struct_test.go</span><br><span class="line">├── multi_primary_keys_test.go</span><br><span class="line">├── naming.go</span><br><span class="line">├── naming_test.go</span><br><span class="line">├── pointer_test.go</span><br><span class="line">├── polymorphic_test.go</span><br><span class="line">├── preload_test.go</span><br><span class="line">├── query_test.go</span><br><span class="line">├── scaner_test.go</span><br><span class="line">├── scope.go</span><br><span class="line">├── scope_test.go</span><br><span class="line">├── search.go</span><br><span class="line">├── search_test.go</span><br><span class="line">├── test_all.sh</span><br><span class="line">├── update_test.go</span><br><span class="line">├── utils.go</span><br><span class="line">└── wercker.yml</span><br><span class="line"></span><br><span class="line">1 directory, 56 files</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 --dirsfirst</span><br><span class="line">.</span><br><span class="line">├── callbacks</span><br><span class="line">├── clause</span><br><span class="line">├── logger</span><br><span class="line">├── migrator</span><br><span class="line">├── schema</span><br><span class="line">├── tests</span><br><span class="line">├── utils</span><br><span class="line">├── License</span><br><span class="line">├── README.md</span><br><span class="line">├── association.go</span><br><span class="line">├── callbacks.go</span><br><span class="line">├── chainable_api.go</span><br><span class="line">├── errors.go</span><br><span class="line">├── finisher_api.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── gorm.go</span><br><span class="line">├── interfaces.go</span><br><span class="line">├── migrator.go</span><br><span class="line">├── model.go</span><br><span class="line">├── prepare_stmt.go</span><br><span class="line">├── scan.go</span><br><span class="line">├── soft_delete.go</span><br><span class="line">├── statement.go</span><br><span class="line">└── statement_test.go</span><br><span class="line"></span><br><span class="line">7 directories, 18 files</span><br></pre></td></tr></table></figure>

<p>v1 ではパッケージが切られていない設計に対して、v2 ではパッケージを分けた設計に変更されています。<br><code>callbacks_xxx.go</code> が <code>callbacks</code> パッケージにまとめられていそうですが、その他の実装がどのように変更されたかはディレクトリ構造を見るだけではわからないですね。</p>
<h3 id="gorm-Open"><a href="#gorm-Open" class="headerlink" title="gorm.Open"></a>gorm.Open</h3><p>GORM 利用時は、 <code>gorm.Open</code> 関数を利用して <code>database/sql</code> パッケージの <code>sql.DB</code> をラップした GORM 向けの <code>gorm.DB</code> オブジェクトを取得します。取得のインターフェイス含めて何が変わっているのでしょうか？</p>
<p>API を見てみると、インターフェイス自体がまず変わっていて、第一引数の dialect を文字列ではなく <code>gorm.Dialector</code> で受けるようになっています。なので、 <code>&quot;postgres&quot;</code> や <code>&quot;mysql&quot;</code> の文字列指定ができなくなっていますね。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (db *DB, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span></span> (db *DB, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><code>gorm.Dialector</code> を見てみると、 interface が定義されています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://pkg.go.dev/gorm.io/gorm#Dialector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dialector GORM database dialector</span></span><br><span class="line"><span class="keyword">type</span> Dialector <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	Initialize(*DB) <span class="type">error</span></span><br><span class="line">	Migrator(db *DB) Migrator</span><br><span class="line">	DataTypeOf(*schema.Field) <span class="type">string</span></span><br><span class="line">	DefaultValueOf(*schema.Field) clause.Expression</span><br><span class="line">	BindVarTo(writer clause.Writer, stmt *Statement, v <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	QuoteTo(clause.Writer, <span class="type">string</span>)</span><br><span class="line">	Explain(sql <span class="type">string</span>, vars ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dialector interface の実装ですが、<a target="_blank" rel="noopener" href="https://gorm.io/docs/v2_release_note.html#How-To-Upgrade">ドキュメント</a>を見てみると別リポジトリでされていることがわかりました。各 DB driver 毎に <code>dialector</code> が実装されています。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/postgres">https://github.com/go-gorm/postgres</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/mysql">https://github.com/go-gorm/mysql</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/sqlite">https://github.com/go-gorm/sqlite</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/sqlserver">https://github.com/go-gorm/sqlserver</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/clickhouse">https://github.com/go-gorm/clickhouse</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/bigquery">https://github.com/go-gorm/bigquery</a></li>
</ul>
<p>(BigQuery 向けの <code>dialector</code> が実装されているのが意外でした。)<br>使い方としては、 各パッケージにて <code>Open</code> 関数が定義されているようでそちらを呼び出して、各 DB ごとの <code>dialector</code> を取得します。 (※ module 名がリポジトリ URL と異なるので注意が必要です。)</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">&quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dialector := sqlite.Open(<span class="string">&quot;gorm.db&quot;</span>)</span><br><span class="line">db, err := gorm.Open(dialector, &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>v1 と異なり、利用者側で driver を blank import しなくて良くなりました。 GORM が提供する dialector の実装内で既に定義されているためです。それぞれの dialector の実装を見たところ、 Postgres の driver が <a target="_blank" rel="noopener" href="https://github.com/jackc/pgx">jackc&#x2F;pgx</a> になっていた点が意外でした ( <a target="_blank" rel="noopener" href="https://github.com/lib/pq">lib&#x2F;pq</a> をよく使っていました )。<br>driver を変更したい場合は、 <code>gorm.Dialector</code> interface を実装する必要があり、少し選択の自由度が下がってますね。</p>
<hr>
<p><code>余談</code><br><a target="_blank" rel="noopener" href="https://github.com/jackc/pgx">jackc&#x2F;pgx</a> は <code>database/sql</code> と 独自のインターフェイスのどちらも対応している点が <a target="_blank" rel="noopener" href="https://github.com/lib/pq">lib&#x2F;pq</a> と異なり、独自のインターフェイスではより Postgres の特徴を利用できる模様です。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jackc/pgx#comparison-with-alternatives">GitHub - jackc&#x2F;pgx: PostgreSQL driver and toolkit for Go</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jackc/pgx/issues/73">[QUESTION] Comparison with lib&#x2F;pq · Issue #73 · jackc&#x2F;pgx · GitHub</a></li>
</ul>
<hr>
<p>第2引数以降の指定も変更されています。 Functional options パターンが使われるようになっていますね。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (db *DB, err <span class="type">error</span>)</span><br><span class="line">                          ↑ この部分</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span></span> (db *DB, err <span class="type">error</span>)</span><br><span class="line">                               ↑ この部分</span><br></pre></td></tr></table></figure>

<p><code>Option</code> は interface になっています。 <code>Apply(*Config) error</code> が適用される option です。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">	Apply(*Config) <span class="type">error</span></span><br><span class="line">	AfterInitialize(*DB) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gorm.Open</code> のAPI 変更は、全体的に型付けを厳格化して Open の実装ミスをコンパイル時にある程度検知できるように、設計変更されていると感じました。</p>
<p>ソースコードの面でも、インターフェイスの変更に伴い、更新が入っています。</p>
<details><summary>[v1 gorm.Open](https://github.com/jinzhu/gorm/blob/v1.9.16/main.go#L58)</summary><div>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (db *DB, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;invalid database source&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> source <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> dbSQL SQLCommon</span><br><span class="line">	<span class="keyword">var</span> ownDbSQL <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> value := args[<span class="number">0</span>].(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">var</span> driver = dialect</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span> &#123;</span><br><span class="line">			source = value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">			driver = value</span><br><span class="line">			source = args[<span class="number">1</span>].(<span class="type">string</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		dbSQL, err = sql.Open(driver, source)</span><br><span class="line">		ownDbSQL = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> SQLCommon:</span><br><span class="line">		dbSQL = value</span><br><span class="line">		ownDbSQL = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid database source: %v is not a valid type&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db = &amp;DB&#123;</span><br><span class="line">		db:        dbSQL,</span><br><span class="line">		logger:    defaultLogger,</span><br><span class="line">		callbacks: DefaultCallback,</span><br><span class="line">		dialect:   newDialect(dialect, dbSQL),</span><br><span class="line">	&#125;</span><br><span class="line">	db.parent = db</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Send a ping to make sure the database connection is alive.</span></span><br><span class="line">	<span class="keyword">if</span> d, ok := dbSQL.(*sql.DB); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err = d.Ping(); err != <span class="literal">nil</span> &amp;&amp; ownDbSQL &#123;</span><br><span class="line">			d.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<details><summary>[v2 gorm.Open](https://github.com/go-gorm/gorm/blob/v1.21.11/gorm.go#L112)</summary><div>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span></span> (db *DB, err <span class="type">error</span>) &#123;</span><br><span class="line">	config := &amp;Config&#123;&#125;</span><br><span class="line"></span><br><span class="line">	sort.Slice(opts, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		_, isConfig := opts[i].(*Config)</span><br><span class="line">		_, isConfig2 := opts[j].(*Config)</span><br><span class="line">		<span class="keyword">return</span> isConfig &amp;&amp; !isConfig2</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		<span class="keyword">if</span> opt != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := opt.Apply(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> errr := opt.AfterInitialize(db); errr != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = errr</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(opt)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> d, ok := dialector.(<span class="keyword">interface</span>&#123; Apply(*Config) <span class="type">error</span> &#125;); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err = d.Apply(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.NamingStrategy == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.NamingStrategy = schema.NamingStrategy&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.Logger == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.Logger = logger.Default</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.NowFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.NowFunc = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time &#123; <span class="keyword">return</span> time.Now().Local() &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dialector != <span class="literal">nil</span> &#123;</span><br><span class="line">		config.Dialector = dialector</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.Plugins == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.Plugins = <span class="keyword">map</span>[<span class="type">string</span>]Plugin&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.cacheStore == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.cacheStore = &amp;sync.Map&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db = &amp;DB&#123;Config: config, clone: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	db.callbacks = initializeCallbacks(db)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.ClauseBuilders == <span class="literal">nil</span> &#123;</span><br><span class="line">		config.ClauseBuilders = <span class="keyword">map</span>[<span class="type">string</span>]clause.ClauseBuilder&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.Dialector != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = config.Dialector.Initialize(db)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preparedStmt := &amp;PreparedStmtDB&#123;</span><br><span class="line">		ConnPool:    db.ConnPool,</span><br><span class="line">		Stmts:       <span class="keyword">map</span>[<span class="type">string</span>]Stmt&#123;&#125;,</span><br><span class="line">		Mux:         &amp;sync.RWMutex&#123;&#125;,</span><br><span class="line">		PreparedSQL: <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	db.cacheStore.Store(preparedStmtDBKey, preparedStmt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.PrepareStmt &#123;</span><br><span class="line">		db.ConnPool = preparedStmt</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db.Statement = &amp;Statement&#123;</span><br><span class="line">		DB:       db,</span><br><span class="line">		ConnPool: db.ConnPool,</span><br><span class="line">		Context:  context.Background(),</span><br><span class="line">		Clauses:  <span class="keyword">map</span>[<span class="type">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !config.DisableAutomaticPing &#123;</span><br><span class="line">		<span class="keyword">if</span> pinger, ok := db.ConnPool.(<span class="keyword">interface</span>&#123; Ping() <span class="type">error</span> &#125;); ok &#123;</span><br><span class="line">			err = pinger.Ping()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		config.Logger.Error(context.Background(), <span class="string">&quot;failed to initialize database, got error %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>


<p>第一に、Open の返却値である DB struct のフィールド構成が大きく変更されています。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	Value        <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Error        <span class="type">error</span></span><br><span class="line">	RowsAffected <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// single db</span></span><br><span class="line">	db                SQLCommon</span><br><span class="line">	blockGlobalUpdate <span class="type">bool</span></span><br><span class="line">	logMode           logModeValue</span><br><span class="line">	logger            logger</span><br><span class="line">	search            *search</span><br><span class="line">	values            sync.Map</span><br><span class="line"></span><br><span class="line">	<span class="comment">// global db</span></span><br><span class="line">	parent        *DB</span><br><span class="line">	callbacks     *Callback</span><br><span class="line">	dialect       Dialect</span><br><span class="line">	singularTable <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// function to be used to override the creating of a new timestamp</span></span><br><span class="line">	nowFuncOverride <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Config</span><br><span class="line">	Error        <span class="type">error</span></span><br><span class="line">	RowsAffected <span class="type">int64</span></span><br><span class="line">	Statement    *Statement</span><br><span class="line">	clone        <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v2 では 設定値が <code>Config</code> struct の埋め込みで表現されていて、設定値のフィールド項目がわかりやすくなっています。また先程の、 <code>Option</code> interface を <code>Config</code> struct が満たしているため、設定値をまとめて渡すことができるようになっています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(dialector, &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>v1, v2 とも <code>sql.DB</code> をラップしているのですが、 struct をぱっと見ただけではどこに持っているのかわからないです。実態はこちらです。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">	db SQLCommon <span class="comment">// *sql.DB</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConnPool ConnPool <span class="comment">// *sql.DB</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>どちらも、 <code>sql.DB</code> を満たす interface が定義されているのですが、interface 定義も少し改良が加えられています。 v2 では Context 対応のメソッドを利用するように変更されていて、 Context に正式に対応していることがわかります。 <code>database/sql</code> のインターフェイスは以下の 4メソッドだけしか利用されていないのも少々驚きました。(正確には、Transaction 系のメソッドも利用されています。 別で <code>TxBeginner</code> <code>TxCommitter</code> interface が GORM 内で定義されており、型変換により <code>dabase/sql</code> の各 Transaction 系のメソッドを呼び出していました。)</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SQLCommon <span class="keyword">interface</span> &#123;</span><br><span class="line">	Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, <span class="type">error</span>)</span><br><span class="line">	Prepare(query <span class="type">string</span>) (*sql.Stmt, <span class="type">error</span>)</span><br><span class="line">	Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, <span class="type">error</span>)</span><br><span class="line">	QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnPool <span class="keyword">interface</span> &#123;</span><br><span class="line">	PrepareContext(ctx context.Context, query <span class="type">string</span>) (*sql.Stmt, <span class="type">error</span>)</span><br><span class="line">	ExecContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, <span class="type">error</span>)</span><br><span class="line">	QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, <span class="type">error</span>)</span><br><span class="line">	QueryRowContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ちなみに、sql.DB の生成については、 v1 は直接 <code>sql.Open</code> を呼び出しているのですが、 v2 では <code>gorm.Dialector.Initialize()</code> を経由して、 GORM が提供している driver 内で sql.Open を呼び出しています。</p>
<p>参考: <a target="_blank" rel="noopener" href="https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L47">https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L47</a></p>
<p><code>エッセンス</code></p>
<ul>
<li>interface を利用して型付けを厳格にして実行時エラーを防御</li>
<li>任意の項目は Functional options パターンで設定できるようにすると良い</li>
<li>config 値は、struct として定義して埋め込みで定義することで、設定値と struct で利用するフィールドを分離</li>
<li>標準API から必要なメソッドのみを、抜き出して interface 定義することで、利用するメソッドを絞り込む</li>
</ul>
<h4 id="おまけ-Prepared-Statement"><a href="#おまけ-Prepared-Statement" class="headerlink" title="(おまけ) Prepared Statement"></a>(おまけ) Prepared Statement</h4><p>v2 では Prepared Statement モードに対応しています。 <code>gorm.Open</code> 内で実装箇所がありましたので、併せて調べてみます。<br>ちなみに、 v1 の <code>SQLCommon</code> 上は <code>Prepare()</code> の呼び出しに対応していますが、検索したところ実装上は呼ばれていなかったので Prepared Statement は使えなかった状態と考えられます。<br>v2 では、 <code>gorm.Open()</code> の呼び出し時の <code>opts</code> に <code>gorm.Config&#123;PrepareStmt: true&#125;</code> と指定することで利用できます。</p>
<p>実装としては、 <code>gorm.PreparedStmtDB</code> structをキャッシュで持ち、 <code>ConnPool</code> (&#x3D; <code>sql.DB</code>) と差し替えを実施しています。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span></span> (db *DB, err <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	preparedStmt := &amp;PreparedStmtDB&#123;</span><br><span class="line">		ConnPool:    db.ConnPool,</span><br><span class="line">		Stmts:       <span class="keyword">map</span>[<span class="type">string</span>]Stmt&#123;&#125;,</span><br><span class="line">		Mux:         &amp;sync.RWMutex&#123;&#125;,</span><br><span class="line">		PreparedSQL: <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	db.cacheStore.Store(preparedStmtDBKey, preparedStmt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.PrepareStmt &#123;</span><br><span class="line">		<span class="comment">// db.ConnPool を prepared statement 対応版へ差し替え</span></span><br><span class="line">		db.ConnPool = preparedStmt</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db.Statement = &amp;Statement&#123;</span><br><span class="line">		DB:       db,</span><br><span class="line">		ConnPool: db.ConnPool,</span><br><span class="line">		Context:  context.Background(),</span><br><span class="line">		Clauses:  <span class="keyword">map</span>[<span class="type">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>PreparedStmtDB</code> struct にて prepare された Stmt を管理して、クエリ実行時に prepare されているかキャッシュ ( <code>Stmts</code> フィールド) を検索して利用しています。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/go-gorm/gorm/blob/v1.21.11/prepare_stmt.go#L14">gorm&#x2F;prepare_stmt.go at v1.21.11 · go-gorm&#x2F;gorm</a></p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PreparedStmtDB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Stmts       <span class="keyword">map</span>[<span class="type">string</span>]Stmt <span class="comment">// Stmt キャッシュ</span></span><br><span class="line">	PreparedSQL []<span class="type">string</span></span><br><span class="line">	Mux         *sync.RWMutex</span><br><span class="line">	ConnPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">	*sql.Stmt <span class="comment">// database/sql 標準を利用</span></span><br><span class="line">	Transaction <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query の場合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *PreparedStmtDB)</span></span> QueryContext(ctx context.Context, query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (rows *sql.Rows, err <span class="type">error</span>) &#123;</span><br><span class="line">	stmt, err := db.prepare(ctx, db.ConnPool, <span class="literal">false</span>, query) <span class="comment">// ここで Stmt キャッシュを検索</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		rows, err = stmt.QueryContext(ctx, args...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.Mux.Lock()</span><br><span class="line">			stmt.Close()</span><br><span class="line">			<span class="built_in">delete</span>(db.Stmts, query)</span><br><span class="line">			db.Mux.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rows, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="クエリ発行"><a href="#クエリ発行" class="headerlink" title="クエリ発行"></a>クエリ発行</h3><p>クエリ発行の比較として、先頭一行を SELECT する <code>First()</code> 関数の実装を読んでみます。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/jinzhu/gorm/blob/v1.9.16/main.go#L329">v1: gorm&#x2F;main.go#First</a></p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span></span> First(out <span class="keyword">interface</span>&#123;&#125;, where ...<span class="keyword">interface</span>&#123;&#125;) *DB &#123;</span><br><span class="line">	newScope := s.NewScope(out)</span><br><span class="line">	newScope.Search.Limit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newScope.Set(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>, <span class="string">&quot;ASC&quot;</span>).</span><br><span class="line">		inlineCondition(where...).callCallbacks(s.parent.callbacks.queries).db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/go-gorm/gorm/blob/v1.21.11/finisher_api.go#L114">v2: gorm&#x2F;finisher_api.go#First</a></p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> First(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;) (tx *DB) &#123;</span><br><span class="line">	tx = db.Limit(<span class="number">1</span>).Order(clause.OrderByColumn&#123;</span><br><span class="line">		Column: clause.Column&#123;Table: clause.CurrentTable, Name: clause.PrimaryKey&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tx.Statement.RaiseErrorOnNotFound = <span class="literal">true</span></span><br><span class="line">	tx.Statement.Dest = dest</span><br><span class="line">	<span class="keyword">return</span> tx.callbacks.Query().Execute(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API のインターフェイスは変わっていないですが、引数の命名が変更されています。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql の結果の出力先は destination と名付けられている模様です</span></span><br><span class="line">out -&gt; dest</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition へ命名を統一している模様です</span></span><br><span class="line"><span class="comment">// v1 から inlineCondition 等で condition を使っているため</span></span><br><span class="line">where -&gt; conds</span><br></pre></td></tr></table></figure>

<p>実装を読むと、v1 は <code>Scope</code> struct を利用して SQL を実行していたのに対して、v2 では特に <code>Scope</code> struct は利用せず <code>gorm.DB</code> を tx 変数へ格納の上で、そのまま利用しています。<br>そもそも v1 の <code>Scope</code> はどういった利用用途であったかを調べてみると、 <code>Scope</code> のコメントにあるように実行する特定のクエリ操作の状態のみを含むオブジェクト、を指している模様です。 <code>First()</code> で呼び出している <code>db.NewScope()</code> メソッドを見ると、 <code>gorm.DB</code> を clone して <code>Scope</code> へ渡しておりクエリ発行毎に <code>Scope</code> を生成していることがわかります。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope contain current operation&#x27;s information when you perform any operation on the database</span></span><br><span class="line"><span class="keyword">type</span> Scope <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewScope create a scope for current operation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span></span> NewScope(value <span class="keyword">interface</span>&#123;&#125;) *Scope &#123;</span><br><span class="line">	dbClone := s.clone()</span><br><span class="line">	dbClone.Value = value</span><br><span class="line">	scope := &amp;Scope&#123;db: dbClone, Value: value&#125;</span><br><span class="line">	<span class="keyword">if</span> s.search != <span class="literal">nil</span> &#123;</span><br><span class="line">		scope.Search = s.search.clone()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		scope.Search = &amp;search&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v2 では、 <code>First()</code> 内で直接呼び出してはないですが、 <code>First()</code> で呼び出している <code>Limit()</code> や <code>Order()</code> 内の <code>gorm.DB.getInstance()</code> メソッドで同様の処理をしています。<br>v2 では <code>gorm.DB</code> をそのままコピーして利用しつつ、<code>Statement</code> をクエリ発行毎に 発行 or clone しています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Limit(limit <span class="type">int</span>) (tx *DB) &#123;</span><br><span class="line">	tx = db.getInstance() <span class="comment">// この部分</span></span><br><span class="line">	tx.Statement.AddClause(clause.Limit&#123;Limit: limit&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> getInstance() *DB &#123;</span><br><span class="line">	<span class="keyword">if</span> db.clone &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tx := &amp;DB&#123;Config: db.Config, Error: db.Error&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> db.clone == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="comment">// clone with new statement</span></span><br><span class="line">			tx.Statement = &amp;Statement&#123;</span><br><span class="line">				DB:       tx,</span><br><span class="line">				ConnPool: db.Statement.ConnPool,</span><br><span class="line">				Context:  db.Statement.Context,</span><br><span class="line">				Clauses:  <span class="keyword">map</span>[<span class="type">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">				Vars:     <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">8</span>),</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// with clone statement</span></span><br><span class="line">			tx.Statement = db.Statement.clone()</span><br><span class="line">			tx.Statement.DB = tx</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tx</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Statement</code> の定義は以下です。 <code>scopes</code> はフィールドで持つ構造になっています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Statement <span class="keyword">struct</span> &#123;</span><br><span class="line">	*DB</span><br><span class="line">	TableExpr            *clause.Expr</span><br><span class="line">	Table                <span class="type">string</span></span><br><span class="line">	Model                <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Unscoped             <span class="type">bool</span></span><br><span class="line">	Dest                 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ReflectValue         reflect.Value</span><br><span class="line">	Clauses              <span class="keyword">map</span>[<span class="type">string</span>]clause.Clause</span><br><span class="line">	BuildClauses         []<span class="type">string</span></span><br><span class="line">	Distinct             <span class="type">bool</span></span><br><span class="line">	Selects              []<span class="type">string</span> <span class="comment">// selected columns</span></span><br><span class="line">	Omits                []<span class="type">string</span> <span class="comment">// omit columns</span></span><br><span class="line">	Joins                []join</span><br><span class="line">	Preloads             <span class="keyword">map</span>[<span class="type">string</span>][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Settings             sync.Map</span><br><span class="line">	ConnPool             ConnPool</span><br><span class="line">	Schema               *schema.Schema</span><br><span class="line">	Context              context.Context</span><br><span class="line">	RaiseErrorOnNotFound <span class="type">bool</span></span><br><span class="line">	SkipHooks            <span class="type">bool</span></span><br><span class="line">	SQL                  strings.Builder</span><br><span class="line">	Vars                 []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	CurDestIndex         <span class="type">int</span></span><br><span class="line">	attrs                []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	assigns              []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	scopes               []<span class="function"><span class="keyword">func</span><span class="params">(*DB)</span></span> *DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scope を生成しているところから、Statement へ変更されていますが、実態としては大きな変更は入っていない印象でした。<br>(データモデルやインターフェイスは変わっていますが、やっていることはあまり変わっていないため。)</p>
<p>続いて実際のクエリ発行と、model への適用はどこでやっているのでしょうか。<br>v1, v2 ともにレコード取得は以下のメソッド呼び出しで完結しています。</p>
<figure class="highlight go"><figcaption><span>v1&v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 と v2 どちらも同様</span></span><br><span class="line">db.First(&amp;product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>v1 から見てみると、<code>First</code> メソッド内のどこかしらでクエリ発行が行われているはずですが、実装を見ても正直良くわからないです。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1 First()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span></span> First(out <span class="keyword">interface</span>&#123;&#125;, where ...<span class="keyword">interface</span>&#123;&#125;) *DB &#123;</span><br><span class="line">	newScope := s.NewScope(out)</span><br><span class="line">	newScope.Search.Limit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newScope.Set(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>, <span class="string">&quot;ASC&quot;</span>).</span><br><span class="line">		inlineCondition(where...).callCallbacks(s.parent.callbacks.queries).db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>おそらく、 <code>callCallbacks</code> にて実行されていると推測しましたが、実装をみると引数で渡された関数を呼び出しているのみでした。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(scope *Scope)</span></span> callCallbacks(funcs []*<span class="function"><span class="keyword">func</span><span class="params">(s *Scope)</span></span>) *Scope &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> db, ok := scope.db.db.(sqlTx); ok &#123;</span><br><span class="line">				db.Rollback()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">		(*f)(scope)</span><br><span class="line">		<span class="keyword">if</span> scope.skipLeft &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callCallbacks</code> の引数である、<code>s.parent.callbacks.queries</code> にクエリを実行する関数が渡っていそうなので、どこで定義しているか調べてみると、 <code>gorm.Open</code> にて <code>DefaultCallback</code> を渡していました。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialect <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (db *DB, err <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	db = &amp;DB&#123;</span><br><span class="line">		db:        dbSQL,</span><br><span class="line">		logger:    defaultLogger,</span><br><span class="line">		callbacks: DefaultCallback,</span><br><span class="line">		dialect:   newDialect(dialect, dbSQL),</span><br><span class="line">	&#125;</span><br><span class="line">	db.parent = db</span><br></pre></td></tr></table></figure>

<p>さらに、 <code>DefaultCallback</code> をみると、 <code>Callback</code> struct が格納されているだけで、 <code>queries</code> フィールドが初期化されていません。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultCallback = &amp;Callback&#123;logger: nopLogger&#123;&#125;&#125; <span class="comment">// 初期化されていない..?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>どこかで初期化しているところはないか、調べてみると <code>init()</code> が利用されてました。 <code>init()</code> が利用されていると、ソースコードが追いづらくて、読みづらかったです。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback_query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:query&quot;</span>, queryCallback)</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:preload&quot;</span>, preloadCallback)</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:after_query&quot;</span>, afterQueryCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>クエリ発行の実態は、 <code>Register()</code> で渡されている <code>queryCallback</code> 関数でした。</p>
<details><summary>[v1 gorm.queryCallback](https://github.com/jinzhu/gorm/blob/v1.9.16/callback_query.go#L17)</summary><div>

<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryCallback</span><span class="params">(scope *Scope)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, skip := scope.InstanceGet(<span class="string">&quot;gorm:skip_query_callback&quot;</span>); skip &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//we are only preloading relations, dont touch base model</span></span><br><span class="line">	<span class="keyword">if</span> _, skip := scope.InstanceGet(<span class="string">&quot;gorm:only_preload&quot;</span>); skip &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> scope.trace(NowFunc())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		isSlice, isPtr <span class="type">bool</span></span><br><span class="line">		resultType     reflect.Type</span><br><span class="line">		results        = scope.IndirectValue()</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> orderBy, ok := scope.Get(<span class="string">&quot;gorm:order_by_primary_key&quot;</span>); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> primaryField := scope.PrimaryField(); primaryField != <span class="literal">nil</span> &#123;</span><br><span class="line">			scope.Search.Order(fmt.Sprintf(<span class="string">&quot;%v.%v %v&quot;</span>, scope.QuotedTableName(), scope.Quote(primaryField.DBName), orderBy))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> value, ok := scope.Get(<span class="string">&quot;gorm:query_destination&quot;</span>); ok &#123;</span><br><span class="line">		results = indirect(reflect.ValueOf(value))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kind := results.Kind(); kind == reflect.Slice &#123;</span><br><span class="line">		isSlice = <span class="literal">true</span></span><br><span class="line">		resultType = results.Type().Elem()</span><br><span class="line">		results.Set(reflect.MakeSlice(results.Type(), <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> resultType.Kind() == reflect.Ptr &#123;</span><br><span class="line">			isPtr = <span class="literal">true</span></span><br><span class="line">			resultType = resultType.Elem()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> kind != reflect.Struct &#123;</span><br><span class="line">		scope.Err(errors.New(<span class="string">&quot;unsupported destination, should be slice or struct&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scope.prepareQuerySQL()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !scope.HasError() &#123;</span><br><span class="line">		scope.db.RowsAffected = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> str, ok := scope.Get(<span class="string">&quot;gorm:query_hint&quot;</span>); ok &#123;</span><br><span class="line">			scope.SQL = fmt.Sprint(str) + scope.SQL</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> str, ok := scope.Get(<span class="string">&quot;gorm:query_option&quot;</span>); ok &#123;</span><br><span class="line">			scope.SQL += addExtraSpaceIfExist(fmt.Sprint(str))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rows, err := scope.SQLDB().Query(scope.SQL, scope.SQLVars...); scope.Err(err) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">			columns, _ := rows.Columns()</span><br><span class="line">			<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">				scope.db.RowsAffected++</span><br><span class="line"></span><br><span class="line">				elem := results</span><br><span class="line">				<span class="keyword">if</span> isSlice &#123;</span><br><span class="line">					elem = reflect.New(resultType).Elem()</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				scope.scan(rows, columns, scope.New(elem.Addr().Interface()).Fields())</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> isSlice &#123;</span><br><span class="line">					<span class="keyword">if</span> isPtr &#123;</span><br><span class="line">						results.Set(reflect.Append(results, elem.Addr()))</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						results.Set(reflect.Append(results, elem))</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				scope.Err(err)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> scope.db.RowsAffected == <span class="number">0</span> &amp;&amp; !isSlice &#123;</span><br><span class="line">				scope.Err(ErrRecordNotFound)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></details>

<p>scope を利用して、いくつか処理を挟んでいますが、クエリの実行と model への代入は以下の部分です。<br><a target="_blank" rel="noopener" href="https://github.com/jinzhu/gorm/blob/v1.9.16/scope.go#L476">scope.scan()</a> の実装を読むと、 <code>interface&#123;&#125;</code> で model を渡していることもあり、 reflection が多用されていました。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryCallback</span><span class="params">(scope *Scope)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">		<span class="comment">// SQLDB() で gorm.SQLCommon を取得</span></span><br><span class="line">		<span class="comment">// gorm.SQLCommon = *sql.DB であり、標準の Query を呼び出している</span></span><br><span class="line">		<span class="keyword">if</span> rows, err := scope.SQLDB().Query(scope.SQL, scope.SQLVars...); scope.Err(err) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">			columns, _ := rows.Columns()</span><br><span class="line">			<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">				scope.db.RowsAffected++</span><br><span class="line"></span><br><span class="line">				elem := results</span><br><span class="line">				<span class="keyword">if</span> isSlice &#123;</span><br><span class="line">					elem = reflect.New(resultType).Elem()</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 第3 引数 の []*Fields を更新してレコードの値を代入</span></span><br><span class="line">				scope.scan(rows, columns, scope.New(elem.Addr().Interface()).Fields())</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>v1 での実装はここまでにして、 v2 の <code>First()</code> はどうなっているかを紐解いていきます。<br>実装を読む限り、 <code>tx.callbacks.Query().Execute(tx)</code> でクエリが実行されていそうなことがわかり、読みやすくなっています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2 First()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> First(dest <span class="keyword">interface</span>&#123;&#125;, conds ...<span class="keyword">interface</span>&#123;&#125;) (tx *DB) &#123;</span><br><span class="line">	tx = db.Limit(<span class="number">1</span>).Order(clause.OrderByColumn&#123;</span><br><span class="line">		Column: clause.Column&#123;Table: clause.CurrentTable, Name: clause.PrimaryKey&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(conds) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> exprs := tx.Statement.BuildCondition(conds[<span class="number">0</span>], conds[<span class="number">1</span>:]...); <span class="built_in">len</span>(exprs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tx.Statement.AddClause(clause.Where&#123;Exprs: exprs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tx.Statement.RaiseErrorOnNotFound = <span class="literal">true</span></span><br><span class="line">	tx.Statement.Dest = dest</span><br><span class="line">	<span class="keyword">return</span> tx.callbacks.Query().Execute(tx) <span class="comment">// おそらくここ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>まず、 <code>tx.callbacks.Query()</code> の実装を見ると、 mapに格納された query 向けの processor を取得しています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *callbacks)</span></span> Query() *processor &#123;</span><br><span class="line">	<span class="keyword">return</span> cs.processors[<span class="string">&quot;query&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v1 と同様に、processors が初期化されている実装を探してみると、 <code>initializeCallbacks()</code> が定義されており、 <code>gorm.Open</code> から呼ばれていました。 <code>init()</code> ではないので、ソースコードが追いやすく明示的に初期化できるようになっており、とても良い設計変更だと思いました。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeCallbacks</span><span class="params">(db *DB)</span></span> *callbacks &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;callbacks&#123;</span><br><span class="line">		processors: <span class="keyword">map</span>[<span class="type">string</span>]*processor&#123;</span><br><span class="line">			<span class="string">&quot;create&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;query&quot;</span>:  &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;update&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;delete&quot;</span>: &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;row&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">			<span class="string">&quot;raw&quot;</span>:    &#123;db: db&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gorm.Open で呼び出されている</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span></span> (db *DB, err <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	db.callbacks = initializeCallbacks(db)</span><br></pre></td></tr></table></figure>

<p><code>initializeCallbacks()</code> の実装をよくみると、各 processor に <code>gorm.DB</code> を渡しているのみであることがわかります。要するに、 <code>create</code> と <code>query</code> に渡している processor に違いがない状態です。違いがない状態で、どのように発行するクエリを切り替えているのでしょうか。<br>(v1 では、processor ごとに異なる関数を渡すことで実装を切り替えてました。)</p>
<p><code>First()</code> に戻ると、 <code>tx.callbacks.Query().Execute(tx)</code> が実行されているので、processor の <code>Execute()</code> メソッドが呼ばれていることがわかります。</p>
<details><summary>[v2 processor.Execute()](https://github.com/go-gorm/gorm/blob/v1.21.11/callbacks.go#L75)</summary><div>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span></span> Execute(db *DB) *DB &#123;</span><br><span class="line">	<span class="comment">// call scopes</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(db.Statement.scopes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		scopes := db.Statement.scopes</span><br><span class="line">		db.Statement.scopes = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">for</span> _, scope := <span class="keyword">range</span> scopes &#123;</span><br><span class="line">			db = scope(db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		curTime           = time.Now()</span><br><span class="line">		stmt              = db.Statement</span><br><span class="line">		resetBuildClauses <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(stmt.BuildClauses) == <span class="number">0</span> &#123;</span><br><span class="line">		stmt.BuildClauses = p.Clauses</span><br><span class="line">		resetBuildClauses = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assign model values</span></span><br><span class="line">	<span class="keyword">if</span> stmt.Model == <span class="literal">nil</span> &#123;</span><br><span class="line">		stmt.Model = stmt.Dest</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> stmt.Dest == <span class="literal">nil</span> &#123;</span><br><span class="line">		stmt.Dest = stmt.Model</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parse model values</span></span><br><span class="line">	<span class="keyword">if</span> stmt.Model != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := stmt.Parse(stmt.Model); err != <span class="literal">nil</span> &amp;&amp; (!errors.Is(err, schema.ErrUnsupportedDataType) || (stmt.Table == <span class="string">&quot;&quot;</span> &amp;&amp; stmt.SQL.Len() == <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> errors.Is(err, schema.ErrUnsupportedDataType) &amp;&amp; stmt.Table == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				db.AddError(fmt.Errorf(<span class="string">&quot;%w: Table not set, please set it like: db.Model(&amp;user) or db.Table(\&quot;users\&quot;)&quot;</span>, err))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				db.AddError(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assign stmt.ReflectValue</span></span><br><span class="line">	<span class="keyword">if</span> stmt.Dest != <span class="literal">nil</span> &#123;</span><br><span class="line">		stmt.ReflectValue = reflect.ValueOf(stmt.Dest)</span><br><span class="line">		<span class="keyword">for</span> stmt.ReflectValue.Kind() == reflect.Ptr &#123;</span><br><span class="line">			<span class="keyword">if</span> stmt.ReflectValue.IsNil() &amp;&amp; stmt.ReflectValue.CanAddr() &#123;</span><br><span class="line">				stmt.ReflectValue.Set(reflect.New(stmt.ReflectValue.Type().Elem()))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			stmt.ReflectValue = stmt.ReflectValue.Elem()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !stmt.ReflectValue.IsValid() &#123;</span><br><span class="line">			db.AddError(ErrInvalidValue)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">		f(db)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db.Logger.Trace(stmt.Context, curTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">int64</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> db.Dialector.Explain(stmt.SQL.String(), stmt.Vars...), db.RowsAffected</span><br><span class="line">	&#125;, db.Error)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !stmt.DB.DryRun &#123;</span><br><span class="line">		stmt.SQL.Reset()</span><br><span class="line">		stmt.Vars = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resetBuildClauses &#123;</span><br><span class="line">		stmt.BuildClauses = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></details>

<p>(<code>Execute()</code> を読んでみても、どこで SQL が実行されているかよくわからないですね..。)<br>よくわからなかったので、v2 の <code>First()</code> を呼ぶ簡易な実装をして、デバッグ実行してみたところ、 <code>processor.fns</code> にクエリを実行する関数がセットされていることがわかりました。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processor)</span></span> Execute(db *DB) *DB &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// クエリ発行はこの部分</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> p.fns &#123;</span><br><span class="line">		f(db)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// セットされていた関数</span></span><br><span class="line"><span class="comment">// ./callbacks/query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">		BuildQuerySQL(db)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !db.DryRun &amp;&amp; db.Error == <span class="literal">nil</span> &#123;</span><br><span class="line">			rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				db.AddError(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">			gorm.Scan(rows, db, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gorm.Open</code> で呼び出している <code>initializeCallbacks()</code> の実装を読む限りは、特に <code>processor.fns</code> がセットされていません。どこでセットしているか調べてみたところ、<code>dialector</code> の実装にて定義されていました。(つまり別パッケージで定義されていました。。)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/go-gorm/sqlite/blob/master/sqlite.go#L40">go-gorm&#x2F;sqlite&#x2F;blob&#x2F;master&#x2F;sqlite.go#L40</a></p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dialector Dialector)</span></span> Initialize(db *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> dialector.DriverName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		dialector.DriverName = DriverName</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ↓ こちら</span></span><br><span class="line">	callbacks.RegisterDefaultCallbacks(db, &amp;callbacks.Config&#123;</span><br><span class="line">		LastInsertIDReversed: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>GORM にて定義されている、<code>callbacks.RegisterDefaultCallbacks</code> 関数内にて、 <code>Query</code> 関数を <code>Register</code> 関数を通して、 <code>processor.fns</code> へセットしています。</p>
<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	queryCallback := db.Callback().Query()</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query) <span class="comment">// Query 関数をセット</span></span><br></pre></td></tr></table></figure>

<p>この実装を読み解くのに、一番苦労しました。 <code>callback</code> の登録である、 <code>RegisterDefaultCallbacks</code> 関数の呼び出しは、 <code>dialector</code> 側に委ねずに、 <code>gorm.Open</code> の <code>gorm.DB</code> 生成時に実行すればよいのではと思いました。 <code>dialector</code> を新たに実装する際に抜け漏れる可能性もありますし、そもそもデフォルト値の設定なので別パッケージ側での呼び出しを期待するのは少々違和感があるなと感じました。(何よりも読みづらかったです。)</p>
<p>GORM のクエリ発行は、v1 と v2 どちらも <code>callback</code> を中心に設計されていました。 特定のクエリ操作(<code>Create</code>, <code>Query</code>, …) に対して複数の <code>callback</code>  が定義され、<code>callback</code> 関数を順序を意識してセットしています。実際のクエリ呼び出しでは、セットされた <code>callback</code> 関数を呼び出すことだけをしています。これにより、 <code>callback</code> 関数を追加・削除することで柔軟にクエリ発行をアレンジすることができるようになっています。ここは v1 と v2 で変わっていない部分だと読み取れました。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback_query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:query&quot;</span>, queryCallback)</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:preload&quot;</span>, preloadCallback)</span><br><span class="line">	DefaultCallback.Query().Register(<span class="string">&quot;gorm:after_query&quot;</span>, afterQueryCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callbacks/query.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDefaultCallbacks</span><span class="params">(db *gorm.DB, config *Config)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	queryCallback := db.Callback().Query()</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:query&quot;</span>, Query)</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:preload&quot;</span>, Preload)</span><br><span class="line">	queryCallback.Register(<span class="string">&quot;gorm:after_query&quot;</span>, AfterQuery)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>エッセンス</code></p>
<ul>
<li>クエリ発行のような外部リソース呼び出しを行う関数は、呼び出しを実行していることがわかるような名前付けをすると良い</li>
<li>init() 関数はコードを追いかける範囲外での定義のためコードが読みづらい。代わりに initialize 関数を定義して明示的に呼び出すと良い</li>
<li>デフォルト値設定の呼び出しをパッケージ外にて期待するような実装はコードが読みづらい</li>
</ul>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>v2 からは返却値の <code>gorm.DB</code> に対して、副作用なく debug モードが定義できるようになりました。v2 では元の <code>gorm.DB</code> を更新する実装でしたが、 v2 からは元の <code>gorm.DB</code> は更新せず新たに debug モードの <code>gorm.DB</code> が生成されていました。一部の処理だけ debug モードにしたいといった用途に対応できるようになっています。</p>
<figure class="highlight go"><figcaption><span>v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.LogMode(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><figcaption><span>v2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;v2_test.db&quot;</span>), &amp;gorm.Config&#123;</span><br><span class="line">	Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// やっていることは上の実装のラッパー</span></span><br><span class="line">db = db.Debug()</span><br></pre></td></tr></table></figure>

<p><code>エッセンス</code></p>
<ul>
<li>副作用のない実装をすることで、影響範囲を狭めることができる</li>
</ul>
<h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><p>GORM v1 と v2 のソースコード比較をしてみました。元々は、 v1 と v2 の機能比較も考えていたのですが、すでに記事もいくつかあり新たにまとめなくてもよいかと思い、ちょっと別の切り口にしてみました。インターフェイスを大きく崩すことなく、スクラッチで再実装したいケースの参考と慣れば良いなと思います。<br>v2 は読みづらい部分もありましたが、全体的にはきれいに再設計されていて、v1 と比較してより良くなっていると感じました。 データモデルの部分が若干わかっていないところがありまとめきれていないですが、モデル設計から再設計されている印象を受けました(DB, Statement, Scope 等)。<br>最後に、記載したエッセンスの一覧を載せておきます。</p>
<h3 id="エッセンスまとめ"><a href="#エッセンスまとめ" class="headerlink" title="エッセンスまとめ"></a>エッセンスまとめ</h3><ul>
<li>interface を利用して型付けを厳格にして実行時エラーを防御</li>
<li>任意の項目は Functional options パターンで設定できるようにすると良い</li>
<li>config 値は、struct として定義して埋め込みで定義することで、設定値と struct で利用するフィールドを分離</li>
<li>標準API から必要なメソッドのみを、抜き出して interface 定義することで、利用するメソッドを絞り込む</li>
<li>クエリ発行のような外部リソース呼び出しを行う関数は、呼び出しを実行していることがわかるような名前付けをする</li>
<li>init() 関数はコードを追いかける範囲外での定義のためコードが読みづらい。代わりに initialize 関数を定義して明示的に呼び出すと良い</li>
<li>デフォルト値設定の呼び出しをパッケージ外にて期待するような実装はコードが読みづらい</li>
<li>副作用のない実装をすることで、影響範囲を狭めることができる</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://v1.gorm.io/docs/index.html">GORM Guides (v1) | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jinzhu/gorm/tree/v1.9.16">jinzhu&#x2F;gorm at v1.9.16</a></li>
<li><a target="_blank" rel="noopener" href="https://gorm.io/docs/index.html">GORM Guides (v2) | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/gorm/tree/v1.21.11">go-gorm&#x2F;gorm at v1.21.11</a></li>
<li><a href="https://future-architect.github.io/articles/20201117/">Goのデバッグ環境 on VSCode | フューチャー技術ブログ</a></li>
</ul>
<p>次は筒井さんの<a href="/articles/20210730a/">SQLBoiler（とoapi-codegen）でつくるREST APIサーバ</a>です。</p>

          
        </div>
        <footer>
          <section class="social-area">
          <!-- シェアボタン START -->
  <ul class="social-button">
    
    <!-- Twitter -->
    <li>
      <a class="social-btn twitter-btn" target="_blank" href="https://twitter.com/share?url=https://future-architect.github.io/articles/20210729a/&related=twitterapi%2Ctwitter&text=GORM%20v1%20%E3%81%A8%20v2%20%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%20%7C%20%E3%83%95%E3%83%A5%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E6%8A%80%E8%A1%93%E3%83%96%E3%83%AD%E3%82%B0" rel="nofollow noopener">
        <i></i><span class="social-btn-label">19</span>
      </a>
    </li>
    <!-- Facebook -->
    <li>
      <a class="social-btn fb-btn" target="_blank" href="http://www.facebook.com/share.php?u=https://future-architect.github.io/articles/20210729a/&t=GORM%20v1%20%E3%81%A8%20v2%20%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F" rel="nofollow noopener">
        <i></i><span class="social-btn-label">シェア</span>
      </a>
    </li>
    <!-- hatebu -->
    <li>
      <a class="social-btn hatebu-btn" target="_blank" href="https://b.hatena.ne.jp/entry/s/future-architect.github.io/articles/20210729a/" rel="nofollow noopener">
        <i></i><span class="social-btn-label">3</span>
      </a>
    </li>
    <!-- pocket -->
    <li>
      <a class="social-btn pocket-btn" target="_blank" href="https://getpocket.com/save?url=https://future-architect.github.io/articles/20210729a/" rel="nofollow noopener">
        <i></i><span class="social-btn-label">9</span>
      </a>
    </li>
    
  </ul>
<!-- シェアボタン END -->

          </section>
          <aside>
            <section class="related-post margin-bottom-40 nav">
              <h2 id="related"><a href="#related" class="headerlink" title="関連記事"></a>関連記事</h2>
              
  <div class="widget">
    <ul class="nav related-post-link"><li class="related-posts-item"><span>2022.05.31</span><span class="snscount">&#9825;5</span><a href=/articles/20220531a/ title="TIG 多賀です。 2022/5/19 に開催された golang.tokyo #32 に登壇しましたので報告させていただきます。「自作ライブラリ、ソフトウェアGo自慢大会」ということで、OSS 活動の一環で作成したfuture-architect/go-twowaysqlについて紹介してきました。">golang.tokyo #32 で go-twowaysql について紹介しました</a></li><li class="related-posts-item"><span>2021.06.09</span><span class="snscount">&#9825;44</span><a href=/articles/20210609a/ title="はじめまして、中岡と申します。現在はフューチャー発OSSのVuls開発をメインに、CSIGでアルバイトをしています。- ORMを触るときは発行されるクエリが意図したものか確認する">Vuls開発中に出会ったGORMあれこれ</a></li><li class="related-posts-item"><span>2020.03.11</span><span class="snscount">&#9825;563</span><a href=/articles/20200311/ title="Java to Go in-depth tutorialの日本語訳です。原文の著者に許諾を得て翻訳・公開いたします。このチュートリアルは、JavaプログラマーがすばやくGo言語にキャッチアップできるようにすることを目的としています。">JavaプログラマーのためのGo言語入門</a></li><li class="related-posts-item"><span>2019.09.26</span><span class="snscount">&#9825;30</span><a href=/articles/20190926/ title="GoのDBレイヤーライブラリとして有名な、GORM,SQLBoiler,XORMの三つについて違いと評価をまとめてみました。">Go言語のDBレイヤーライブラリの評価</a></li><li class="related-posts-item"><span>2022.11.28</span><span class="snscount">&#9825;365</span><a href=/articles/20221128a/ title="私たちのチームでは、バッチ処理が中心的な業務システム開発において Go の ORM に sqlc を採用しました。素の SQL を書いていくチームの開発方針[^1]とマッチし、開発体験は非常に良かったです。">業務システム開発でsqlcを導入して良かった点とハマった点</a></li><li class="related-posts-item"><span>2022.06.15</span><span class="snscount">&#9825;28</span><a href=/articles/20220615a/ title="!表題の通り、Go で map 型の YAML 出力の際、key を指定した順序にする方法を調査・実装してみました。指定した順序で出力したいので、map を struct へ変換して出力しました">Go で map 型の YAML 出力を指定の順序へ変更したい</a></li></ul>
  </div>
            </section>
            <section class="reference-post margin-bottom-40 nav">
              
  <div class="card">
    <div id="reference" class="reference-lede"><a href="#reference" class="headerlink" title="参照されている記事"></a>この記事を参照している記事</div>
    <ul class="reference-post-link"><li class="reference-posts-item"><a href=/articles/20210916a/ title="GoのORマッパー連載、おまけ記事です。特に示し合わせた訳では無いのですが、RDBは全員がPostgreSQLを使っていましたね。さて、今回の連載記事のいくつかでも言及されていた、jackc/pgx について簡単に紹介します。">lib/pq から jackc/pgx への移行</a></li><li class="reference-posts-item"><a href=/articles/20210728a/ title="golang ORM連載の2記事目となります。はじめまして、TIGの宮崎将太です。突然ですがみなさん、ORMは何を使用していますか？">100%型安全なgolangORM「ent」を使ってみた</a></li><li class="reference-posts-item"><a href=/articles/20210726a/ title="7/26（月）～8/3（水）の平日にかけて、GoでRDBに対してアクセスライブラリ（ORMとクエリビルダー）をテーマにした連載を始めます。">GoのORマッパー連載を始めます</a></li></ul>
  </div>
            </section>
          </aside>
        </footer>
      </div>
    </article>
  </main>
  <aside class="col-md-3 blog-sidebar">
    <!-- START SIDEBAR  -->


<section class="toc-section">
  <h2 class="margin-top-30">目次</h2>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-text">概要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E6%A7%8B%E9%80%A0"><span class="toc-text">ディレクトリ構造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gorm-Open"><span class="toc-text">gorm.Open</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%81%8A%E3%81%BE%E3%81%91-Prepared-Statement"><span class="toc-text">(おまけ) Prepared Statement</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%82%AF%E3%82%A8%E3%83%AA%E7%99%BA%E8%A1%8C"><span class="toc-text">クエリ発行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug"><span class="toc-text">Debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%84%9F"><span class="toc-text">所感</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%82%A8%E3%83%83%E3%82%BB%E3%83%B3%E3%82%B9%E3%81%BE%E3%81%A8%E3%82%81"><span class="toc-text">エッセンスまとめ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol>
</section>

<section class="category">
<h2 class="margin-top-30">カテゴリー</h2>
<div class="widget">
  <ul class="nav sidebar-categories margin-bottom-40">
  
  <li class=""><a href="/categories/Programming/">Programming (367)</a></li>
<li class=""><a href="/categories/Infrastructure/">Infrastructure (214)</a></li>
<li class=""><a href="/categories/Culture/">Culture (85)</a></li>
<li class=""><a href="/categories/DataScience/">DataScience (46)</a></li>
<li class=""><a href="/categories/IoT/">IoT (31)</a></li>
<li class=""><a href="/categories/DB/">DB (22)</a></li>
<li class=""><a href="/categories/Business/">Business (21)</a></li>
<li class=""><a href="/categories/%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF/">認証認可 (20)</a></li>
<li class=""><a href="/categories/Management/">Management (14)</a></li>
<li class=""><a href="/categories/DevOps/">DevOps (14)</a></li>
<li class=""><a href="/categories/VR/">VR (12)</a></li>
<li class=""><a href="/categories/Design/">Design (11)</a></li>
<li class=""><a href="/categories/Security/">Security (8)</a></li>

  </ul>
</div>

</section>
<section class="podcast-link">
<h2 class="margin-top-30">Tech Cast</h2>

  <div class="class="widget-wrap">
  <div class="widget">
    <ul class="nav techcast">
      <li><a href="https://anchor.fm/futuretechcast/episodes/35-MLOps-e1qe4st" title="フューチャーがお届けするポッドキャストです。#35 MLOpsエンジニアって何やるの？（後編）" target="_blank" rel="noopener"> #35 MLOpsエンジニアって何やるの？（後編）</a></li>
<li><a href="https://anchor.fm/futuretechcast/episodes/34-MLOps-e1polbj" title="フューチャーがお届けするポッドキャストです。#34 MLOpsエンジニアって何やるの？（前編）" target="_blank" rel="noopener"> #34 MLOpsエンジニアって何やるの？（前編）</a></li>
<li><a href="https://anchor.fm/futuretechcast/episodes/33-IT-e1pcaon" title="フューチャーがお届けするポッドキャストです。#33 ヘルスケアグループリーダーの中元さんと語る「医療業界におけるITコンサルとビジネスイノベーション」（後編）" target="_blank" rel="noopener"> #33 ヘルスケアグループリーダーの中元さんと語る「医療業界におけるITコンサルとビジネスイノベーション」（後編）</a></li>
    </ul>
  </div>
  </div>
  
</section>
<section class="advent-calendar">
<h2 class="margin-top-30">アドベントカレンダー</h2>
<div class="widget">
  <ul class="nav-flex">
    <li><a href="http://qiita.com/advent-calendar/2022/future" title="フューチャー Advent Calendar 2022 #Qiita" target="_blank" rel="noopener">2022年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2021/future" title="フューチャー Advent Calendar 2021 #Qiita" target="_blank" rel="noopener">2021年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2020/future" title="フューチャー Advent Calendar 2020 #Qiita" target="_blank" rel="noopener">2020年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2019/future" title="フューチャー Advent Calendar 2019 #Qiita" target="_blank" rel="noopener">2019年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2018/future" title="フューチャー Advent Calendar 2018 #Qiita" target="_blank" rel="noopener">2018年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2017/future" title="フューチャー Advent Calendar 2017 #Qiita" target="_blank" rel="noopener">2017年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2016/future" title="フューチャー Advent Calendar 2016 #Qiita" target="_blank" rel="noopener">2016年</a></li>
    <li><a href="http://qiita.com/advent-calendar/2015/future" title="フューチャー Advent Calendar 2015 #Qiita" target="_blank" rel="noopener">2015年</a></li>
  </ul>
</div>

</section>
<!-- END SIDEBAR -->

  </aside>
</div>

  </section>
</div>

      <!-- BEGIN PRE-FOOTER -->
    <footer>
      <div class="pre-footer">
        <div class="container">
          <div class="row">
            <div class="col-lg-4 col-md-4 col-sm-6 col-6 pre-footer-col">
              <h2>About Us</h2>
              <p>経営とITをデザインする、フューチャーの技術ブログです。業務で利用している幅広い技術について紹介します。<br /><br /><a target="_blank" rel="noopener" href="http://www.future.co.jp/">http://www.future.co.jp/</a></p>
              <div class="social-btn twitter-btn twitter-follow-btn">
                <a href="https://twitter.com/intent/follow?screen_name=future_techblog " target="_blank" rel="nofollow noopener">
                  <i></i><span class="tw-btn-label">フューチャー技術ブログをフォロー</span>
                </a>
              </div>
            </div>
            <div class="col-lg-2 col-md-4 col-sm-4 col-4 pre-footer-col">
              <h2>Contact</h2>
              <address class="margin-bottom-40">
                <a href="https://www.future.co.jp/recruit/recruit/rec-fresh/" title="新卒採用" target="_blank" rel="noopener">新卒採用</a><br>
                <a href="https://www.future.co.jp/recruit/recruit/rec-career/" title="キャリア採用" target="_blank" rel="noopener">キャリア採用</a><br>
                <a href="https://www.future.co.jp/contact_us/" title="お問い合わせページ" target="_blank" rel="noopener">お問い合わせ</a><br>
                <a href="https://www.future.co.jp/architect/socialmediapolicy/" title="ソーシャルメディアポリシー" target="_blank" rel="noopener">メディアポリシー</a><br><br>
                <a href="mailto:techblog@future.co.jp">techblog@future.co.jp</a>
              </address>
            </div>
            <div class="col-lg-2 col-md-4 col-sm-6 col-6 pre-footer-col">
              <h2>Contents</h2>
              <a href="https://future-architect.github.io/coding-standards/" title="Future Enterprise Coding Standards" target="_blank" rel="noopener">コーディング規約</a><br>
              <a href="https://future-architect.github.io/typescript-guide/" title="仕事ですぐに使えるTypeScript" target="_blank" rel="noopener">仕事ですぐに使えるTypeScript</a><br>
            </div>
            <div class="col-lg-2 col-md-4 col-sm-3 col-3 pre-footer-col">
              <h2>Event</h2>
              <a href="https://future.connpass.com/" title="経営とITをデザインするフューチャーの勉強会です" target="_blank" rel="noopener">connpass</a><br>
              <a href="https://www.future.co.jp/futureinsightseminar/" title="フューチャーインサイトセミナー" target="_blank" rel="noopener">Webセミナー</a><br>
            </div>
            <div class="col-lg-2 col-md-4 col-sm-3 col-3 pre-footer-col">
              <h2>SNS</h2>
              <a href="https://github.com/future-architect" title="Future's official open source repositories" target="_blank" rel="noopener">GitHub</a><br>
              <a href="https://qiita.com/organizations/future" title="フューチャーのQiita Organizationです" target="_blank" rel="noopener">Qiita</a><br>
              <a href="https://note.future.co.jp/" title="フューチャーの公式note" target="_blank" rel="noopener">未来報</a><br>
              <a href="https://www.youtube.com/channel/UCJUSwYYd0CkGgmEKAW7QVpw" title="フューチャーYoutubeチャネル" target="_blank" rel="noopener">Youtube</a>
            </div>
          </div>
        </div>
      </div>
      <div class="footer">
        <div class="container">
          <div class="row">
            <div class="col-md-6 col-sm-6 padding-top-10">
              &copy; 2023 フューチャー技術ブログ<br>
            </div>
          </div>
        </div>
      </div>
    </footer>

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X1C28R8H0M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-X1C28R8H0M');
  gtag('config', 'UA-74047147-1'); // 過渡期対応
</script>

  </div>
</body>
</html>
